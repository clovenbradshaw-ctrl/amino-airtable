<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DB Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ===== Noema Design System - CSS Variables ===== */
        :root {
            /* Color Palette */
            --primary-50: #eff6ff;
            --primary-100: #dbeafe;
            --primary-200: #bfdbfe;
            --primary-300: #93c5fd;
            --primary-400: #60a5fa;
            --primary-500: #3b82f6;
            --primary-600: #2563eb;
            --primary-700: #1d4ed8;
            --primary-800: #1e40af;

            --gray-50: #f8fafc;
            --gray-100: #f1f5f9;
            --gray-200: #e2e8f0;
            --gray-300: #cbd5e1;
            --gray-400: #94a3b8;
            --gray-500: #64748b;
            --gray-600: #475569;
            --gray-700: #334155;
            --gray-800: #1e293b;
            --gray-900: #0f172a;
            --gray-950: #020617;

            --success-500: #22c55e;
            --success-600: #16a34a;
            --warning-500: #f59e0b;
            --warning-600: #d97706;
            --danger-500: #ef4444;
            --danger-600: #dc2626;

            /* Semantic Colors - Dark Theme Default */
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --bg-elevated: #1e293b;
            --bg-hover: rgba(255, 255, 255, 0.06);
            --bg-active: rgba(255, 255, 255, 0.1);

            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --text-disabled: #475569;

            --border-primary: #334155;
            --border-secondary: #475569;

            /* Sizing */
            --sidebar-width: 288px;
            --header-height: 52px;
            --tab-bar-height: 38px;
            --status-bar-height: 28px;

            /* Typography */
            --font-sans: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Consolas', monospace;

            /* Transitions */
            --transition-fast: 0.1s ease;
            --transition-normal: 0.2s ease;
            --transition-slow: 0.3s ease;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            --shadow-xl: 0 20px 60px rgba(0, 0, 0, 0.6);

            /* Radii */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --radius-xl: 12px;
        }

        /* Light Theme Override */
        html.light-theme {
            --bg-primary: #ffffff;
            --bg-secondary: #f1f5f9;
            --bg-tertiary: #e2e8f0;
            --bg-elevated: #ffffff;
            --bg-hover: rgba(0, 0, 0, 0.06);
            --bg-active: rgba(0, 0, 0, 0.10);

            --text-primary: #0f172a;
            --text-secondary: #1e293b;
            --text-muted: #475569;
            --text-disabled: #94a3b8;

            --border-primary: #cbd5e1;
            --border-secondary: #94a3b8;

            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.12);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.18);
            --shadow-xl: 0 20px 60px rgba(0, 0, 0, 0.22);
        }

        /* Light theme: fix hardcoded bright colors for readability on light backgrounds */
        html.light-theme .cell-bool.true { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .cell-bool.false { background: rgba(220, 38, 38, 0.12); color: #dc2626; }

        html.light-theme .cell-array .tag { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .cell-link { color: #2563eb; }

        /* History change type badges */
        html.light-theme .history-change-type.created { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .history-change-type.updated { background: rgba(37, 99, 235, 0.12); color: #2563eb; }
        html.light-theme .history-change-type.deleted { background: rgba(220, 38, 38, 0.12); color: #dc2626; }
        html.light-theme .history-actor { background: rgba(217, 119, 6, 0.12); color: #b45309; }
        html.light-theme .history-source { background: rgba(100, 116, 139, 0.12); color: #64748b; }

        /* Sync status badges */
        html.light-theme .sync-status-badge.synced { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .sync-status-badge.syncing { background: rgba(217, 119, 6, 0.12); color: #b45309; }
        html.light-theme .sync-status-badge.error { background: rgba(220, 38, 38, 0.12); color: #dc2626; }
        html.light-theme .sync-status-badge.queued { background: rgba(234, 88, 12, 0.12); color: #c2410c; }
        html.light-theme .sync-result-badge.queued { background: rgba(234, 88, 12, 0.10); color: #c2410c; }
        html.light-theme .queue-count-badge { background: rgba(234, 88, 12, 0.15); color: #c2410c; }
        html.light-theme .sync-status-card.queue-highlight { border-color: rgba(234, 88, 12, 0.3); background: rgba(234, 88, 12, 0.04); }
        html.light-theme .sync-status-card.queue-highlight .card-value { color: #c2410c; }
        html.light-theme .sync-status-card.queue-highlight .card-label { color: #c2410c; }

        /* Sync type badges */
        html.light-theme .sync-history-table .sync-type-badge.incremental { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .sync-history-table .sync-type-badge.full { background: rgba(124, 58, 237, 0.10); color: #7c3aed; }
        html.light-theme .sync-history-table .sync-type-badge.snapshot { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .sync-history-table .sync-type-badge.error { background: rgba(220, 38, 38, 0.10); color: #dc2626; }
        html.light-theme .sync-history-table .sync-type-badge.edit { background: rgba(14, 165, 233, 0.10); color: #0284c7; }
        html.light-theme .sync-result-badge.success { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .sync-result-badge.error { background: rgba(220, 38, 38, 0.10); color: #dc2626; }

        /* Events table badges */
        html.light-theme .events-table .event-set { color: #2563eb; background: rgba(37, 99, 235, 0.10); }
        html.light-theme .events-table .event-record-id { color: #15803d; background: rgba(22, 163, 74, 0.10); }
        html.light-theme .events-table .event-type-badge.data { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .events-table .event-type-badge.INS { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .events-table .event-type-badge.ALT { background: rgba(217, 119, 6, 0.10); color: #b45309; }
        html.light-theme .events-table .event-type-badge.NUL { background: rgba(220, 38, 38, 0.10); color: #dc2626; }
        html.light-theme .events-table .event-type-badge.SYN { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .events-table .event-type-badge.table { background: rgba(217, 119, 6, 0.10); color: #b45309; }
        html.light-theme .events-table .event-type-badge.field { background: rgba(124, 58, 237, 0.10); color: #7c3aed; }
        html.light-theme .events-table .event-type-badge.view { background: rgba(219, 39, 119, 0.10); color: #be185d; }
        html.light-theme .events-table .event-type-badge.viewconfig { background: rgba(124, 58, 237, 0.10); color: #7c3aed; }
        html.light-theme .events-table .event-type-badge.current { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .events-table .field-op-badge.INS { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .events-table .field-op-badge.ALT { background: rgba(217, 119, 6, 0.10); color: #b45309; }
        html.light-theme .events-table .field-op-badge.NUL { background: rgba(220, 38, 38, 0.10); color: #dc2626; }
        html.light-theme .events-table .field-op-badge.SYN { background: rgba(37, 99, 235, 0.10); color: #2563eb; }

        /* JSON syntax highlighting */
        html.light-theme .json-key { color: #7c3aed; }
        html.light-theme .json-string { color: #15803d; }
        html.light-theme .json-number { color: #2563eb; }
        html.light-theme .json-boolean { color: #dc2626; }

        /* Payload field colors */
        html.light-theme .payload-field-name { color: #7c3aed; }
        html.light-theme .payload-field-value.string { color: #15803d; }
        html.light-theme .payload-field-value.number { color: #2563eb; }
        html.light-theme .payload-field-value.boolean { color: #dc2626; }
        html.light-theme .payload-field-value.array { color: #7c3aed; }
        html.light-theme .payload-field-value.object { color: #0e7490; }
        html.light-theme .payload-op-label.INS { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .payload-op-label.ALT { background: rgba(217, 119, 6, 0.12); color: #b45309; }
        html.light-theme .payload-op-label.NUL { background: rgba(220, 38, 38, 0.12); color: #dc2626; }

        /* Sync feed line colors */
        html.light-theme .sync-feed-line.info { color: #2563eb; }
        html.light-theme .sync-feed-line.success { color: #15803d; }
        html.light-theme .sync-feed-line.error { color: #dc2626; }
        html.light-theme .sync-feed-line.warn { color: #b45309; }

        /* Sync activity log */
        html.light-theme .sync-activity-log .log-line.info .message { color: #2563eb; }
        html.light-theme .sync-activity-log .log-line.success .message { color: #15803d; }
        html.light-theme .sync-activity-log .log-line.error .message { color: #dc2626; }
        html.light-theme .sync-activity-log .log-line.warn .message { color: #b45309; }

        /* Error/success/warning text */
        html.light-theme .auth-error { color: #dc2626; background: rgba(220, 38, 38, 0.08); border-color: rgba(220, 38, 38, 0.25); }
        html.light-theme .synapse-login-box .synapse-error { color: #dc2626; background: rgba(220, 38, 38, 0.08); border-color: rgba(220, 38, 38, 0.25); }
        html.light-theme .unlock-error { color: #dc2626; background: rgba(220, 38, 38, 0.08); border-color: rgba(220, 38, 38, 0.25); }
        html.light-theme .wizard-error { color: #dc2626; background: rgba(220, 38, 38, 0.08); border-color: rgba(220, 38, 38, 0.25); }
        html.light-theme .wizard-success { color: #15803d; background: rgba(22, 163, 74, 0.08); border-color: rgba(22, 163, 74, 0.25); }

        /* View tags */
        html.light-theme .view-tag { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .view-tag.workspace { background: rgba(217, 119, 6, 0.10); color: #b45309; }

        /* View type badges */
        html.light-theme .view-type-badge.schema { background: rgba(124, 58, 237, 0.12); color: #7c3aed; }
        html.light-theme .view-type-badge.grid { background: rgba(37, 99, 235, 0.12); color: #2563eb; }

        /* Historical notice */
        html.light-theme .historical-notice { background: rgba(217, 119, 6, 0.08); border-color: rgba(217, 119, 6, 0.3); color: #92400e; }
        html.light-theme .pit-modal-header .pit-event-badge { background: rgba(217, 119, 6, 0.12); color: #b45309; }

        /* Profile sync history */
        html.light-theme .profile-sync-history-type.created { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .profile-sync-history-type.updated { background: rgba(37, 99, 235, 0.12); color: #2563eb; }
        html.light-theme .profile-sync-history-type.deleted { background: rgba(220, 38, 38, 0.12); color: #dc2626; }
        html.light-theme .profile-sync-history-actor { background: rgba(217, 119, 6, 0.12); color: #b45309; }
        html.light-theme .profile-sync-history-source { background: rgba(100, 116, 139, 0.12); color: #64748b; }
        html.light-theme .profile-sync-history-value.old { background: rgba(220, 38, 38, 0.06); color: #991b1b; }
        html.light-theme .profile-sync-history-value.new { background: rgba(22, 163, 74, 0.06); color: #166534; }

        /* Context menu danger */
        html.light-theme .view-context-menu-item.danger { color: #dc2626; }
        html.light-theme .view-context-menu-item.danger:hover { background: rgba(220, 38, 38, 0.08); }
        html.light-theme .filter-remove-btn:hover { background: rgba(220, 38, 38, 0.08); color: #dc2626; }
        html.light-theme .sort-remove-btn:hover { background: rgba(220, 38, 38, 0.08); color: #dc2626; }

        /* Active view items and primary accent adjustments */
        html.light-theme .view-control-btn.active { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .table-view-item.active { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .browser-tab.active .tab-icon { color: #2563eb; }
        html.light-theme .profile-tab.active { color: #2563eb; }
        html.light-theme .row-height-option.selected { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .row-height-option.selected svg { color: #2563eb; }
        html.light-theme .view-selector-option.active { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .fields-btn .fields-count { background: rgba(37, 99, 235, 0.10); color: #2563eb; }

        /* Loading progress container */
        html.light-theme .loading-progress-container { background: rgba(0, 0, 0, 0.03); }
        html.light-theme .loading-note { background: rgba(0, 0, 0, 0.03); }

        /* ===== Base Reset & Layout ===== */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ===== Custom Scrollbars ===== */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border-secondary); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        * { scrollbar-width: thin; scrollbar-color: var(--border-secondary) transparent; }

        /* ===== Sidebar ===== */
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-track { background: transparent; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border-primary); border-radius: 3px; }
        .sidebar::-webkit-scrollbar-thumb:hover { background: var(--border-secondary); }

        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            overflow-y: auto;
            flex-shrink: 0;
            font-family: var(--font-sans);
            display: flex;
            flex-direction: column;
            contain: layout style;
            will-change: contents;
        }
        .sidebar-header { padding: 16px; border-bottom: 1px solid var(--border-primary); }
        .sidebar-header-top { display: flex; align-items: center; gap: 10px; margin-bottom: 14px; }
        .sidebar-logo {
            width: 28px; height: 28px; border-radius: 8px;
            background: linear-gradient(135deg, var(--primary-500) 0%, #8b5cf6 100%);
            display: flex; align-items: center; justify-content: center;
        }
        .sidebar-logo svg { width: 14px; height: 14px; color: #fff; }
        .sidebar-header h2 { color: var(--text-primary); font-size: 15px; font-weight: 600; letter-spacing: -0.01em; }

        /* Sidebar Search */
        .sidebar-search { position: relative; }
        .sidebar-search-icon { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: var(--text-muted); pointer-events: none; }
        .sidebar-search-icon svg { width: 14px; height: 14px; }
        .sidebar-search input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: 9px 44px 9px 36px;
            font-size: 13px;
            color: var(--text-primary);
            transition: all var(--transition-fast);
        }
        .sidebar-search input::placeholder { color: var(--text-muted); }
        .sidebar-search input:focus {
            outline: none;
            border-color: var(--primary-500);
            background: var(--bg-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
        }
        .sidebar-search-shortcut {
            position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
            font-size: 10px; color: var(--text-muted);
            background: var(--bg-tertiary); padding: 3px 6px;
            border-radius: var(--radius-sm); border: 1px solid var(--border-primary);
            font-family: system-ui, sans-serif;
        }

        /* Section Headers */
        .sidebar-section-header {
            display: flex; align-items: center; gap: 8px;
            padding: 10px 16px; font-size: 11px; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.05em;
            color: var(--text-muted); cursor: pointer;
            transition: color var(--transition-fast); user-select: none;
        }
        .sidebar-section-header:hover { color: var(--text-secondary); }
        .sidebar-section-header:active { color: var(--text-primary); background: var(--bg-hover); transition: background-color 0.05s, color 0.05s; border-radius: var(--radius-sm); }
        .sidebar-section-header svg { width: 12px; height: 12px; transition: transform 0.2s; }
        .sidebar-section-header.collapsed svg { transform: rotate(-90deg); }
        .sidebar-section-header .section-icon { opacity: 0.8; }
        .sidebar-section-header .section-count { margin-left: auto; font-weight: 400; color: var(--text-muted); }

        .sidebar-divider { height: 1px; background: var(--border-primary); margin: 8px 16px; }

        /* Fast sidebar search: hide structural elements via CSS class on container */
        #table-list.sidebar-searching > .sidebar-section-header,
        #table-list.sidebar-searching > .sidebar-divider { display: none; }
        #table-list .sidebar-search-hidden { display: none !important; }

        /* Table Items */
        .table-wrapper { contain: layout style; }
        .sidebar div.table-item {
            padding: 9px 12px; margin: 2px 8px; border-radius: var(--radius-lg);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
            display: flex; align-items: center; gap: 10px;
            transition: background-color var(--transition-fast), color var(--transition-fast); position: relative;
        }
        .sidebar div.table-item:hover { background: var(--bg-hover); color: var(--text-primary); }
        .sidebar div.table-item:active { background: var(--bg-active); color: var(--text-primary); transition: background-color 0.05s, color 0.05s; }
        .sidebar div.table-item.active {
            background: var(--bg-tertiary); color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }
        .sidebar div.table-item.active::before {
            content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%);
            width: 3px; height: 20px; border-radius: 0 2px 2px 0;
            background: var(--type-color, var(--primary-500));
        }
        .sidebar div.table-item .table-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .sidebar div.table-item .count { font-size: 11px; color: var(--text-muted); font-variant-numeric: tabular-nums; }
        .sidebar div.table-item.active .count { color: var(--text-secondary); }
        .sidebar div.table-item:hover .count { color: var(--text-secondary); }

        /* Table Type Icons */
        .table-icon {
            width: 20px; height: 20px; border-radius: 5px; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
        }
        .table-icon svg { width: 12px; height: 12px; }
        .table-icon.type-events { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .table-icon.type-operational { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
        .table-icon.type-collection { background: rgba(139, 92, 246, 0.2); color: #8b5cf6; }
        .table-icon.type-reference { background: rgba(16, 185, 129, 0.2); color: #10b981; }
        .table-icon.type-dev { background: rgba(107, 114, 128, 0.2); color: #9ca3af; }
        .table-icon.type-room { background: rgba(99, 102, 241, 0.2); color: #6366f1; }

        /* Room meta (room ID shown under name) */
        .room-meta { font-size: 10px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 140px; opacity: 0.7; }

        /* Count Bar */
        .count-bar-wrapper { display: flex; align-items: center; gap: 6px; min-width: 54px; justify-content: flex-end; }
        .count-bar { height: 4px; border-radius: 2px; transition: all var(--transition-fast); opacity: 0.6; }
        .count-value { font-size: 11px; font-variant-numeric: tabular-nums; min-width: 28px; text-align: right; }

        /* Pin Button */
        .pin-btn {
            padding: 4px; border-radius: var(--radius-sm); background: transparent;
            border: none; cursor: pointer; opacity: 0;
            transition: all var(--transition-fast);
            display: flex; align-items: center; justify-content: center;
        }
        .pin-btn svg { width: 12px; height: 12px; color: var(--text-muted); }
        .pin-btn:hover svg { color: #f59e0b; }
        .pin-btn.pinned { opacity: 1; }
        .pin-btn.pinned svg { color: #f59e0b; fill: #f59e0b; }
        .sidebar div.table-item:hover .pin-btn { opacity: 1; }

        /* Expand Arrow */
        .sidebar div.table-item .expand-arrow {
            font-size: 10px; color: var(--text-muted);
            transition: transform 0.2s; padding: 4px;
        }
        .sidebar div.table-item.expanded .expand-arrow { transform: rotate(90deg); }
        .sidebar div.table-item:hover .expand-arrow { color: var(--text-secondary); }

        /* Table Views List */
        .table-views-list {
            display: none;
            background: var(--bg-primary);
            margin: 0 8px; border-radius: 0 0 var(--radius-lg) var(--radius-lg);
            contain: content;
        }
        .table-views-list.expanded { display: block; }
        .table-view-item {
            padding: 7px 12px 7px 40px; cursor: pointer;
            font-size: 12px; color: var(--text-muted);
            display: flex; align-items: center; gap: 8px;
            transition: background-color var(--transition-fast), color var(--transition-fast);
            margin: 1px 4px; border-radius: var(--radius-md);
        }
        .table-view-item:hover { background: var(--bg-hover); color: var(--text-primary); }
        .table-view-item:active { background: var(--bg-active); color: var(--text-primary); transition: background-color 0.05s, color 0.05s; }
        .table-view-item.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .table-view-item.active:active { background: rgba(59, 130, 246, 0.25); }
        .table-view-item .view-icon { font-size: 12px; width: 16px; text-align: center; color: var(--text-muted); }
        .table-view-item:hover .view-icon, .table-view-item.active .view-icon { color: inherit; }
        .table-view-item .view-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .table-view-item .view-name-input {
            flex: 1; background: var(--bg-primary); border: 1px solid var(--primary-500);
            border-radius: var(--radius-sm); color: var(--text-primary);
            font-size: 12px; padding: 3px 8px; outline: none; min-width: 0;
        }
        .table-view-item .view-name-input:focus { border-color: var(--primary-400); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }
        .table-view-default { color: var(--text-muted); font-style: italic; }

        /* Sidebar Footer - Theme Toggle */
        .sidebar-footer {
            margin-top: auto; padding: 12px 16px;
            border-top: 1px solid var(--border-primary);
            display: flex; flex-wrap: wrap; align-items: center; gap: 8px;
        }
        .theme-toggle-btn {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 10px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            color: var(--text-secondary); font-size: 12px; cursor: pointer;
            transition: all var(--transition-fast); flex: 1;
        }
        .theme-toggle-btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--border-secondary); }

        /* Matrix connection status */
        .theme-toggle-btn.matrix-connected { border-color: var(--success-500); color: var(--success-500); }
        .theme-toggle-btn.matrix-connected:hover { background: rgba(34,197,94,0.1); }

        /* ===== Room Publishing Modal ===== */
        .room-publish-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; display: flex; align-items: center; justify-content: center; }
        .room-publish-modal.hidden { display: none !important; }
        .room-publish-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 24px; width: 480px; max-height: 80vh; overflow-y: auto; box-shadow: var(--shadow-xl); }
        .room-publish-box h2 { font-size: 18px; margin-bottom: 4px; color: var(--text-primary); }
        .room-publish-box .pub-subtitle { font-size: 13px; color: var(--text-muted); margin-bottom: 20px; }
        .room-publish-section { margin-bottom: 16px; }
        .room-publish-section h3 { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .room-table-item { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); margin-bottom: 6px; cursor: pointer; transition: all var(--transition-fast); }
        .room-table-item:hover { border-color: var(--primary-500); background: var(--bg-hover); }
        .room-table-item input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--primary-500); flex-shrink: 0; }
        .room-table-item .table-info { flex: 1; }
        .room-table-item .table-info .table-name { font-size: 13px; font-weight: 500; color: var(--text-primary); }
        .room-table-item .table-info .table-meta { font-size: 11px; color: var(--text-muted); }
        .room-table-item .pub-status { font-size: 11px; padding: 2px 8px; border-radius: 10px; font-weight: 500; }
        .room-table-item .pub-status.local { background: var(--bg-tertiary); color: var(--text-muted); border: 1px solid var(--border-primary); }
        .room-table-item .pub-status.published { background: rgba(34,197,94,0.15); color: var(--success-500); }
        .pub-actions { display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end; }
        .pub-actions button { padding: 8px 16px; border-radius: var(--radius-md); font-size: 13px; font-weight: 500; cursor: pointer; transition: all var(--transition-fast); }
        .pub-btn-cancel { background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-secondary); }
        .pub-btn-cancel:hover { background: var(--bg-hover); }
        .pub-btn-publish { background: var(--primary-500); border: none; color: #fff; }
        .pub-btn-publish:hover { background: var(--primary-600); }
        .pub-btn-publish:disabled { background: var(--gray-600); cursor: not-allowed; }
        .pub-progress { margin-top: 12px; }
        .pub-progress-bar { height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; }
        .pub-progress-fill { height: 100%; background: var(--primary-500); transition: width 0.3s ease; }
        .pub-progress-text { font-size: 12px; color: var(--text-muted); margin-top: 6px; }
        /* ===== Main Content Area ===== */
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: var(--bg-primary); }

        /* ===== Browser Tab Bar ===== */
        .tab-bar {
            display: flex; align-items: stretch;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-primary);
            height: var(--tab-bar-height); padding: 0 4px;
            gap: 2px; position: relative; user-select: none;
            flex-shrink: 0;
        }
        .tab-bar::before {
            content: ''; position: absolute; bottom: 0; left: 0; right: 0;
            height: 1px; background: var(--border-primary);
        }
        .tab-bar-tabs {
            display: flex; align-items: flex-end; flex: 1;
            overflow-x: auto; overflow-y: hidden;
            scrollbar-width: none; gap: 1px; padding-top: 6px;
        }
        .tab-bar-tabs::-webkit-scrollbar { display: none; }

        .browser-tab {
            display: flex; align-items: center; gap: 8px;
            min-width: 120px; max-width: 240px; height: 32px;
            padding: 0 12px; background: var(--bg-secondary);
            border: 1px solid var(--border-primary); border-bottom: none;
            border-radius: var(--radius-md) var(--radius-md) 0 0;
            color: var(--text-secondary); font-size: 13px;
            cursor: pointer; position: relative;
            transition: var(--transition-fast); flex-shrink: 0;
        }
        .browser-tab:hover { background: var(--bg-elevated); color: var(--text-primary); }
        .browser-tab:hover .tab-close { opacity: 1; }
        .browser-tab.active {
            background: var(--bg-primary); color: var(--text-primary);
            border-color: var(--primary-500); border-top-width: 2px;
            z-index: 1; font-weight: 600;
            box-shadow: inset 0 2px 0 0 var(--primary-500);
        }
        .browser-tab.active::after {
            content: ''; position: absolute; bottom: -1px; left: 0; right: 0;
            height: 2px; background: var(--bg-primary);
        }

        .tab-icon {
            display: flex; align-items: center; justify-content: center;
            width: 16px; height: 16px; font-size: 14px;
            flex-shrink: 0; color: var(--text-muted);
        }
        .browser-tab.active .tab-icon { color: var(--primary-400); }

        .tab-title {
            flex: 1; white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis; font-weight: 500;
        }

        .tab-close {
            display: flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; border-radius: var(--radius-sm);
            color: var(--text-muted); opacity: 0;
            transition: var(--transition-fast); flex-shrink: 0; cursor: pointer;
            background: none; border: none; font-size: 14px;
        }
        .tab-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .tab-close:active { background: var(--danger-500); color: white; }
        .browser-tab.active .tab-close { opacity: 0.7; }
        .browser-tab.active .tab-close:hover { opacity: 1; color: var(--text-primary); }

        .tab-count {
            font-size: 11px; color: var(--text-muted);
            background: var(--bg-tertiary); padding: 1px 6px;
            border-radius: var(--radius-sm); margin-left: 4px; flex-shrink: 0;
        }
        .browser-tab.active .tab-count { background: var(--bg-secondary); color: var(--text-secondary); }

        .tab-bar-new-tab {
            display: flex; align-items: center; justify-content: center;
            width: 28px; height: 28px; margin: auto 4px;
            background: transparent; border: none;
            border-radius: var(--radius-md); color: var(--text-muted);
            cursor: pointer; transition: var(--transition-fast); flex-shrink: 0;
            font-size: 18px;
        }
        .tab-bar-new-tab:hover { background: var(--bg-hover); color: var(--text-primary); }
        .tab-bar-new-tab:active { background: var(--bg-active); }

        /* ===== Toolbar ===== */
        .toolbar {
            padding: 12px 20px; border-bottom: 1px solid var(--border-primary);
            display: flex; align-items: center; gap: 12px;
            background: var(--bg-secondary);
        }
        .toolbar h1 { font-size: 18px; font-weight: 600; color: var(--text-primary); flex: 1; }
        .btn {
            padding: 6px 12px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            color: var(--text-secondary); font-size: 12px; cursor: pointer;
            display: flex; align-items: center; gap: 4px;
            transition: all var(--transition-fast);
        }
        .btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--border-secondary); }
        .btn-primary { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .btn-primary:hover { background: var(--primary-600); }

        /* ===== Status Bar ===== */
        .status-bar {
            padding: 8px 20px; background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            font-size: 12px; color: var(--text-muted);
            display: flex; align-items: center; gap: 12px;
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.synced { background: var(--success-500); }
        .status-dot.loading { background: var(--warning-500); }

        /* Sync Toggle */
        .sync-toggle-wrapper { display: flex; align-items: center; gap: 6px; margin-left: 8px; padding-left: 12px; border-left: 1px solid var(--border-primary); }

        /* Sync Feed */
        .sync-feed-btn { background: none; border: none; padding: 2px 6px; cursor: pointer; font-size: 11px; color: var(--text-muted); border-radius: 3px; margin-left: 4px; }
        .sync-feed-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .sync-feed-btn.has-activity { color: var(--primary-500); }
        .sync-feed-panel {
            position: fixed; bottom: 60px; right: 20px; width: 420px; max-height: 300px;
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg); box-shadow: var(--shadow-lg);
            z-index: 1000; display: none; flex-direction: column;
            font-family: var(--font-mono);
        }
        .sync-feed-panel.visible { display: flex; }
        .sync-feed-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid var(--border-primary); color: var(--text-primary); font-size: 12px; font-weight: 500; }
        .sync-feed-header-left { display: flex; align-items: center; gap: 8px; }
        .sync-feed-status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-muted); }
        .sync-feed-status-dot.active { background: var(--success-500); animation: pulse 2s infinite; }
        .sync-feed-status-dot.error { background: var(--danger-500); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .sync-feed-close { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 16px; padding: 0 4px; }
        .sync-feed-close:hover { color: var(--text-primary); }
        .sync-feed-body { flex: 1; overflow-y: auto; padding: 8px 0; max-height: 240px; }
        .sync-feed-line { padding: 2px 12px; font-size: 11px; line-height: 1.6; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .sync-feed-line.info { color: #7ec8e3; }
        .sync-feed-line.success { color: var(--success-500); }
        .sync-feed-line.error { color: var(--danger-500); }
        .sync-feed-line.warn { color: var(--warning-500); }
        .sync-feed-line .timestamp { color: var(--text-disabled); margin-right: 8px; }
        .sync-feed-line .prefix { color: var(--text-muted); }
        .sync-feed-empty { padding: 20px; text-align: center; color: var(--text-disabled); font-size: 11px; }
        .sync-feed-footer { padding: 8px 12px; border-top: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; font-size: 10px; color: var(--text-disabled); }
        .sync-feed-footer button { background: var(--bg-tertiary); border: none; color: var(--text-muted); font-size: 10px; padding: 4px 8px; border-radius: 3px; cursor: pointer; }
        .sync-feed-footer button:hover { background: var(--bg-hover); color: var(--text-primary); }

        /* ===== Table Container ===== */
        .table-container { flex: 1; overflow: auto; }

        /* ===== Table ===== */
        table { min-width: 100%; border-collapse: collapse; font-size: 13px; }
        th {
            background: var(--bg-secondary); border-bottom: 2px solid var(--border-primary);
            padding: 8px 12px; text-align: left; font-weight: 500;
            color: var(--text-secondary); position: sticky; top: 0; z-index: 10; white-space: nowrap;
        }
        th:first-child { width: 120px; color: var(--text-muted); }
        td {
            border-bottom: 1px solid var(--border-primary);
            padding: 8px 12px; max-width: 300px; overflow: hidden;
            text-overflow: ellipsis; white-space: nowrap; vertical-align: top;
            color: var(--text-secondary);
        }
        tr:hover td { background: var(--bg-hover); }
        tr.selected td { background: rgba(59, 130, 246, 0.15); }

        /* Cell Styling */
        .cell-empty { color: var(--text-disabled); }
        .cell-array { color: var(--text-secondary); }
        .cell-array .tag { display: inline-block; background: rgba(59, 130, 246, 0.15); color: var(--primary-400); padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; font-size: 12px; }
        .cell-link { color: var(--primary-400); text-decoration: none; }
        .cell-link:hover { text-decoration: underline; }
        .cell-number { font-family: var(--font-mono); }
        .cell-bool { padding: 2px 8px; border-radius: var(--radius-sm); font-size: 11px; font-weight: 500; }
        .cell-bool.true { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .cell-bool.false { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Inline Cell Editing */
        td.inline-editable { cursor: text; position: relative; }
        td.inline-editable:hover:not(.inline-editing) {
            background: rgba(59, 130, 246, 0.06);
            outline: 1px solid rgba(59, 130, 246, 0.25); outline-offset: -1px;
        }
        td.inline-editable:hover:not(.inline-editing)::after {
            content: '';
            position: absolute; right: 6px; top: 50%; transform: translateY(-50%);
            width: 14px; height: 14px; opacity: 0.35; pointer-events: none;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7'/%3E%3Cpath d='M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z'/%3E%3C/svg%3E") no-repeat center/contain;
        }
        td.inline-editing { padding: 0; overflow: visible; white-space: normal; }
        td.inline-editing::after { display: none; }
        td.inline-editing .inline-edit-input,
        td.inline-editing select.inline-edit-input {
            width: 100%; background: var(--bg-primary); color: var(--text-primary);
            border: 2px solid var(--primary-500); border-radius: 0;
            padding: 6px 11px; font-size: 13px; font-family: inherit;
            outline: none; box-sizing: border-box; resize: vertical;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            min-height: 34px;
        }
        td.inline-editing select.inline-edit-input { cursor: pointer; padding-right: 24px; appearance: auto; }
        td.inline-editing input[type="date"].inline-edit-input,
        td.inline-editing input[type="datetime-local"].inline-edit-input {
            cursor: text; color-scheme: dark;
        }
        html.light-theme td.inline-editing input[type="date"].inline-edit-input,
        html.light-theme td.inline-editing input[type="datetime-local"].inline-edit-input { color-scheme: light; }
        td.inline-editing .inline-edit-checkbox { margin: 8px 12px; width: 16px; height: 16px; cursor: pointer; accent-color: var(--primary-500); }
        td.inline-editable.cell-focused:not(.inline-editing) {
            outline: 2px solid var(--primary-500); outline-offset: -2px;
            background: rgba(59, 130, 246, 0.06);
        }

        /* Formula / computed field cells (read-only) */
        td.cell-formula { cursor: default; color: var(--text-secondary); }
        td.cell-formula:hover { background: rgba(124, 58, 237, 0.06); outline: none; }
        td.cell-formula:hover::after { display: none; }
        td.cell-formula.cell-focused {
            outline: 2px solid rgba(124, 58, 237, 0.5); outline-offset: -2px;
            background: rgba(124, 58, 237, 0.06);
        }

        /* Read-only (non-computed) field cells */
        td.cell-readonly { cursor: default; color: var(--text-secondary); }
        td.cell-readonly:hover { background: rgba(148, 163, 184, 0.06); outline: none; }
        td.cell-readonly:hover::after { display: none; }
        td.cell-readonly.cell-focused {
            outline: 2px solid rgba(148, 163, 184, 0.4); outline-offset: -2px;
            background: rgba(148, 163, 184, 0.06);
        }

        /* Formula icon in column headers */
        th .formula-icon {
            display: inline-flex; align-items: center; margin-left: 4px;
            color: var(--text-muted); vertical-align: middle;
        }
        th .formula-icon svg { width: 12px; height: 12px; }

        /* Read-only icon in column headers (lock icon) */
        th .readonly-icon {
            display: inline-flex; align-items: center; margin-left: 4px;
            color: var(--text-muted); vertical-align: middle;
        }
        th .readonly-icon svg { width: 11px; height: 11px; }

        /* Display name icon in column headers */
        th .display-name-icon {
            display: inline-flex; align-items: center; margin-left: 4px;
            color: #3b82f6; vertical-align: middle;
        }
        th .display-name-icon svg { width: 12px; height: 12px; }
        html.light-theme th .display-name-icon { color: #2563eb; }

        /* Formula badge on profile field cards */
        .profile-field-name .formula-badge {
            font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px;
            color: #a78bfa; background: rgba(124, 58, 237, 0.2);
            padding: 1px 5px; border-radius: 3px; margin-left: auto; cursor: pointer;
        }
        .profile-field-name .formula-badge:hover { background: rgba(124, 58, 237, 0.35); }
        html.light-theme .profile-field-name .formula-badge { color: #7c3aed; background: rgba(124, 58, 237, 0.12); }
        html.light-theme .profile-field-name .formula-badge:hover { background: rgba(124, 58, 237, 0.22); }

        /* Read-only badge on profile field cards */
        .profile-field-name .readonly-badge {
            font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px;
            color: var(--text-muted); background: rgba(148, 163, 184, 0.2);
            padding: 1px 5px; border-radius: 3px; margin-left: auto;
        }
        html.light-theme .profile-field-name .readonly-badge { color: #64748b; background: rgba(100, 116, 139, 0.12); }

        /* Formula field value in profile (read-only look) */
        .profile-field-value.formula-readonly { cursor: default; }
        .profile-field-value.formula-readonly:hover { background: none; }

        /* Read-only field value in profile */
        .profile-field-value.field-readonly { cursor: default; }
        .profile-field-value.field-readonly:hover { background: none; }

        /* Formula info popover */
        .formula-info-popover {
            position: fixed; z-index: 10000;
            background: var(--bg-elevated); border: 1px solid var(--border-secondary);
            border-radius: var(--radius-lg); padding: 14px 16px;
            box-shadow: var(--shadow-lg); min-width: 240px; max-width: 400px;
        }
        .formula-info-popover .formula-info-header {
            font-size: 11px; font-weight: 600; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.4px; margin-bottom: 8px;
            display: flex; align-items: center; gap: 6px;
        }
        .formula-info-popover .formula-info-header svg { width: 14px; height: 14px; color: #a78bfa; }
        .formula-info-popover .formula-info-type {
            font-size: 12px; color: #a78bfa; background: rgba(124, 58, 237, 0.15);
            padding: 2px 8px; border-radius: var(--radius-sm); display: inline-block; margin-bottom: 8px;
        }
        .formula-info-popover .formula-info-expression {
            font-family: var(--font-mono); font-size: 12px; color: var(--text-primary);
            background: var(--bg-primary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); padding: 8px 10px; white-space: pre-wrap;
            word-break: break-word; max-height: 200px; overflow-y: auto;
        }
        .formula-info-popover .formula-info-note {
            font-size: 11px; color: var(--text-muted); margin-top: 8px;
        }
        html.light-theme .formula-info-popover .formula-info-header svg { color: #7c3aed; }
        html.light-theme .formula-info-popover .formula-info-type { color: #7c3aed; background: rgba(124, 58, 237, 0.1); }

        /* Pagination */
        .pagination {
            padding: 12px 20px; border-top: 1px solid var(--border-primary);
            background: var(--bg-secondary); display: flex; align-items: center;
            gap: 12px; font-size: 13px;
        }
        .pagination button {
            padding: 6px 12px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            cursor: pointer; color: var(--text-secondary);
            transition: all var(--transition-fast);
        }
        .pagination button:hover:not(:disabled) { background: var(--bg-hover); color: var(--text-primary); }
        .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
        .pagination .page-info { color: var(--text-muted); }
        /* ===== Auth Screen ===== */
        #auth-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 100; }
        #auth-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .auth-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 360px; box-shadow: var(--shadow-xl); }
        .auth-box h2 { font-size: 20px; margin-bottom: 8px; color: var(--text-primary); }
        .auth-box p { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .auth-box input { width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .auth-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .auth-box button { width: 100%; padding: 10px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; transition: background var(--transition-fast); }
        .auth-box button:hover { background: var(--primary-600); }
        .auth-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .auth-box button.secondary { background: var(--bg-tertiary); color: var(--text-secondary); }
        .auth-box button.secondary:hover { background: var(--bg-hover); }
        .auth-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-sm); display: none; }
        .auth-info { color: var(--text-muted); font-size: 12px; margin-top: 16px; text-align: center; }

        /* Synapse Login Screen */
        #synapse-login-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 105; }
        #synapse-login-screen.hidden { display: none !important; }
        #synapse-login-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .synapse-login-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 360px; box-shadow: var(--shadow-xl); }
        .synapse-login-box h2 { font-size: 20px; margin-bottom: 8px; color: var(--text-primary); }
        .synapse-login-box p { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .synapse-login-box input { width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .synapse-login-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .synapse-login-box button { width: 100%; padding: 10px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; font-weight: 500; transition: background var(--transition-fast); }
        .synapse-login-box button:hover { background: var(--primary-600); }
        .synapse-login-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .synapse-login-box .synapse-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-sm); display: none; }
        .synapse-login-box label { display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 4px; font-weight: 500; }

        /* ===== Home Screen ===== */
        #home-app {
            display: none;
            flex-direction: column;
            flex: 1;
            overflow-y: auto;
            background: var(--bg-primary);
        }
        #home-app.visible { display: flex; }

        .home-topbar {
            position: sticky;
            top: 0;
            height: 52px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 32px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            z-index: 10;
            flex-shrink: 0;
        }

        .home-topbar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .home-logo-mark {
            width: 28px;
            height: 28px;
            border-radius: var(--radius-md);
            background: var(--primary-500);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }

        .home-logo-text {
            font-size: 17px;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: 0.01em;
        }

        .home-topbar-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .home-status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--success-500);
            background: rgba(34, 197, 94, 0.1);
            padding: 4px 10px;
            border-radius: 20px;
            font-weight: 500;
        }

        .home-status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success-500);
            animation: home-pulse 2s ease-in-out infinite;
        }

        @keyframes home-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .home-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-400);
            cursor: pointer;
            transition: border-color var(--transition-normal);
        }

        .home-avatar:hover {
            border-color: var(--primary-400);
        }

        .home-content {
            max-width: 860px;
            margin: 0 auto;
            padding: 60px 32px 80px;
            width: 100%;
        }

        .home-greeting {
            margin-bottom: 44px;
        }

        .home-greeting h1 {
            font-size: 32px;
            font-weight: 600;
            letter-spacing: -0.02em;
            margin-bottom: 6px;
            color: var(--text-primary);
        }

        .home-greeting h1 span {
            color: var(--primary-400);
        }

        .home-greeting p {
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        /* Home cards grid */
        .home-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 48px;
        }

        .home-card {
            position: relative;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl);
            padding: 28px 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow: hidden;
            text-decoration: none;
            color: inherit;
            display: flex;
            flex-direction: column;
            min-height: 220px;
        }

        .home-card::before {
            content: '';
            position: absolute;
            inset: 0;
            opacity: 0;
            transition: opacity 0.3s;
            border-radius: var(--radius-xl);
        }

        .home-card:nth-child(1)::before {
            background: radial-gradient(ellipse at 30% 20%, rgba(59, 130, 246, 0.06) 0%, transparent 70%);
        }

        .home-card:nth-child(2)::before {
            background: radial-gradient(ellipse at 30% 20%, rgba(34, 197, 94, 0.05) 0%, transparent 70%);
        }

        .home-card:nth-child(3)::before {
            background: radial-gradient(ellipse at 30% 20%, rgba(148, 163, 184, 0.05) 0%, transparent 70%);
        }

        .home-card:hover {
            border-color: var(--border-secondary);
            transform: translateY(-3px);
            background: var(--bg-tertiary);
        }

        .home-card:hover::before { opacity: 1; }

        .home-card-icon {
            width: 42px;
            height: 42px;
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }

        .home-card:nth-child(1) .home-card-icon {
            background: rgba(59, 130, 246, 0.12);
            color: var(--primary-400);
        }

        .home-card:nth-child(2) .home-card-icon {
            background: rgba(34, 197, 94, 0.1);
            color: var(--success-500);
        }

        .home-card:nth-child(3) .home-card-icon {
            background: rgba(148, 163, 184, 0.1);
            color: var(--gray-400);
        }

        .home-card-icon svg {
            width: 20px;
            height: 20px;
        }

        .home-card-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 6px;
            position: relative;
            z-index: 1;
            color: var(--text-primary);
        }

        .home-card-desc {
            font-size: 13px;
            line-height: 1.55;
            color: var(--text-muted);
            position: relative;
            z-index: 1;
            flex-grow: 1;
        }

        .home-card-arrow {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 16px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-muted);
            position: relative;
            z-index: 1;
            transition: color 0.25s, gap 0.25s;
        }

        .home-card:hover .home-card-arrow { gap: 10px; }
        .home-card:nth-child(1):hover .home-card-arrow { color: var(--primary-400); }
        .home-card:nth-child(2):hover .home-card-arrow { color: var(--success-500); }
        .home-card:nth-child(3):hover .home-card-arrow { color: var(--gray-300); }

        .home-card-arrow svg {
            width: 14px;
            height: 14px;
            transition: transform 0.25s;
        }

        .home-card:hover .home-card-arrow svg { transform: translateX(2px); }

        /* Home stats row */
        .home-stats {
            display: flex;
            gap: 1px;
            background: var(--border-primary);
            border-radius: var(--radius-lg);
            overflow: hidden;
            margin-bottom: 36px;
        }

        .home-stat {
            flex: 1;
            background: var(--bg-secondary);
            padding: 18px 20px;
            text-align: center;
        }

        .home-stat:first-child { border-radius: var(--radius-lg) 0 0 var(--radius-lg); }
        .home-stat:last-child { border-radius: 0 var(--radius-lg) var(--radius-lg) 0; }

        .home-stat-value {
            font-size: 26px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .home-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 500;
        }

        /* Home activity */
        .home-section-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 12px;
            padding-left: 2px;
            font-weight: 500;
        }

        .home-activity-list {
            display: flex;
            flex-direction: column;
            gap: 1px;
            background: var(--border-primary);
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        .home-activity-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 18px;
            background: var(--bg-secondary);
            font-size: 13px;
            transition: background var(--transition-normal);
        }

        .home-activity-item:hover { background: var(--bg-tertiary); }

        .home-activity-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .home-activity-dot.blue { background: var(--primary-400); }
        .home-activity-dot.green { background: var(--success-500); }
        .home-activity-dot.muted { background: var(--text-muted); }

        .home-activity-text {
            flex-grow: 1;
            color: var(--text-secondary);
        }

        .home-activity-text strong { font-weight: 600; color: var(--text-primary); }

        .home-activity-time {
            font-size: 12px;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        /* Home animations */
        .home-greeting, .home-cards, .home-stats, .home-section-label, .home-activity-list {
            opacity: 0;
            transform: translateY(12px);
            animation: home-fadeUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .home-greeting { animation-delay: 0.1s; }
        .home-cards { animation-delay: 0.2s; }
        .home-stats { animation-delay: 0.3s; }
        .home-section-label { animation-delay: 0.38s; }
        .home-activity-list { animation-delay: 0.42s; }

        @keyframes home-fadeUp {
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 720px) {
            .home-cards { grid-template-columns: 1fr; }
            .home-card { min-height: auto; }
            .home-greeting h1 { font-size: 24px; }
            .home-stats { flex-direction: column; }
            .home-content { padding: 40px 20px 60px; }
        }

        /* ===== File Header Bar ===== */
        .file-header {
            display: none;
            width: 100%;
            height: 36px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            flex-shrink: 0;
            z-index: 51;
        }
        .file-header.visible { display: flex; }
        .file-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-muted);
        }
        .file-header-role {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        .file-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-header-theme-btn {
            padding: 3px 10px;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            background: transparent;
            color: var(--text-muted);
            font-size: 11px;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: background var(--transition-fast), color var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .file-header-theme-btn:hover { background: var(--bg-hover); color: var(--text-primary); }

        /* ===== App Navigation Bar ===== */
        .app-nav {
            display: none;
            width: 100%;
            height: 44px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            align-items: center;
            padding: 0 16px;
            gap: 2px;
            flex-shrink: 0;
            z-index: 50;
        }
        .app-nav.visible { display: flex; }
        .app-nav-btn {
            padding: 6px 16px;
            border: none;
            border-radius: var(--radius-md);
            background: transparent;
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 500;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: background var(--transition-fast), color var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }
        .app-nav-btn:hover { background: var(--bg-hover); color: var(--text-secondary); }
        .app-nav-btn.active { background: var(--bg-active); color: var(--text-primary); }
        .app-nav-btn svg { width: 16px; height: 16px; }
        .app-nav-spacer { flex: 1; }
        .app-nav-user {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .app-nav-user-role {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .app-nav-user-role.admin { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .app-nav-user-role.staff { background: rgba(34, 197, 94, 0.15); color: var(--success-500); }
        .app-nav-logout {
            padding: 4px 10px;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            background: transparent;
            color: var(--text-muted);
            font-size: 12px;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: background var(--transition-fast), color var(--transition-fast);
        }
        .app-nav-logout:hover { background: rgba(239, 68, 68, 0.1); color: var(--danger-500); border-color: var(--danger-500); }

        /* App content wrapper - holds sidebar + main or settings */
        .app-content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ===== Settings Sub-App ===== */
        #settings-app {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 32px 48px;
            background: var(--bg-primary);
        }
        #settings-app.visible { display: block; }
        .settings-header {
            margin-bottom: 32px;
        }
        .settings-header h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .settings-header p {
            font-size: 14px;
            color: var(--text-muted);
        }
        .settings-tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--border-primary);
            margin-bottom: 24px;
        }
        .settings-tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 500;
            font-family: var(--font-sans);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: color var(--transition-fast), border-color var(--transition-fast);
        }
        .settings-tab:hover { color: var(--text-secondary); }
        .settings-tab.active { color: var(--primary-400); border-bottom-color: var(--primary-400); }
        .settings-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin-bottom: 24px;
        }
        .settings-section h2 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .settings-section-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 20px;
        }

        /* Settings: Users & Roles Table */
        .settings-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .settings-table th {
            text-align: left;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-muted);
            font-weight: 500;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .settings-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-primary);
            vertical-align: middle;
        }
        .settings-table tr:last-child td { border-bottom: none; }
        .settings-table tr:hover td { background: var(--bg-hover); }
        .settings-table .user-id {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-secondary);
        }
        .settings-table .role-badge {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .settings-table .role-badge.admin { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .settings-table .role-badge.staff { background: rgba(34, 197, 94, 0.15); color: var(--success-500); }
        .settings-table .role-badge.client { background: rgba(245, 158, 11, 0.15); color: var(--warning-500); }
        .settings-table .role-badge.default { background: var(--bg-tertiary); color: var(--text-muted); }
        .settings-role-select {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 12px;
            font-family: var(--font-sans);
            cursor: pointer;
        }
        .settings-role-select:focus { outline: none; border-color: var(--primary-500); }

        /* Settings: Room Access Table */
        .settings-room-access {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .settings-room-access th {
            text-align: left;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-muted);
            font-weight: 500;
            font-size: 12px;
        }
        .settings-room-access td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-primary);
            vertical-align: middle;
        }
        .settings-room-access tr:last-child td { border-bottom: none; }
        .settings-room-access .room-name {
            font-weight: 500;
        }
        .settings-room-access .room-id {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            display: block;
            margin-top: 2px;
        }
        .settings-access-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--primary-500);
        }
        .settings-action-btn {
            padding: 6px 14px;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 12px;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        .settings-action-btn:hover { background: var(--bg-hover); }
        .settings-action-btn.primary {
            background: var(--primary-500);
            border-color: var(--primary-500);
            color: #fff;
        }
        .settings-action-btn.primary:hover { background: var(--primary-600); }
        .settings-action-btn.danger {
            color: var(--danger-500);
            border-color: var(--danger-500);
        }
        .settings-action-btn.danger:hover { background: rgba(239, 68, 68, 0.1); }
        .settings-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Preference toggle rows */
        .settings-pref-row {
            padding: 12px 0;
            border-bottom: 1px solid var(--border-primary);
        }
        .settings-pref-row:last-child { border-bottom: none; }
        .settings-toggle-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            gap: 16px;
        }
        .settings-toggle-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .settings-toggle-text strong {
            font-size: 13px;
            color: var(--text-primary);
            font-weight: 500;
        }
        .settings-toggle-desc {
            font-size: 12px;
            color: var(--text-muted);
        }
        .settings-toggle-checkbox {
            display: none;
        }
        .settings-toggle-switch {
            position: relative;
            width: 36px;
            min-width: 36px;
            height: 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            transition: background 0.2s, border-color 0.2s;
        }
        .settings-toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: var(--text-muted);
            border-radius: 50%;
            transition: transform 0.2s, background 0.2s;
        }
        .settings-toggle-checkbox:checked + .settings-toggle-switch {
            background: var(--primary-500);
            border-color: var(--primary-500);
        }
        .settings-toggle-checkbox:checked + .settings-toggle-switch::after {
            transform: translateX(16px);
            background: #fff;
        }
        .settings-toast {
            padding: 10px 16px;
            border-radius: var(--radius-md);
            font-size: 13px;
            margin-bottom: 16px;
            display: none;
        }
        .settings-toast.success {
            display: block;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: var(--success-500);
        }
        .settings-toast.error {
            display: block;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--danger-500);
        }
        .settings-toast.info {
            display: block;
            background: rgba(59, 130, 246, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: var(--primary-400);
        }
        .settings-loading {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            font-size: 13px;
            padding: 16px 0;
        }
        .settings-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-primary);
            border-top-color: var(--primary-500);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Settings: Invite User Form */
        .settings-invite-form {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-primary);
        }
        .settings-invite-form h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .settings-invite-form p {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 16px;
        }
        .settings-invite-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        .settings-invite-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 140px;
        }
        .settings-invite-field label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        .settings-invite-field input,
        .settings-invite-field select {
            padding: 7px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            font-family: var(--font-sans);
        }
        .settings-invite-field input:focus,
        .settings-invite-field select:focus {
            outline: none;
            border-color: var(--primary-500);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        .settings-invite-btn {
            padding: 7px 18px;
            background: var(--primary-500);
            border: none;
            border-radius: var(--radius-sm);
            color: #fff;
            font-size: 13px;
            font-family: var(--font-sans);
            font-weight: 500;
            cursor: pointer;
            transition: background var(--transition-fast);
            white-space: nowrap;
        }
        .settings-invite-btn:hover { background: var(--primary-600); }
        .settings-invite-btn:disabled { background: var(--gray-600); cursor: not-allowed; }

        /* Login: Password Reset */
        .synapse-login-box .synapse-forgot-link {
            display: block;
            margin-top: 12px;
            text-align: center;
            font-size: 13px;
            color: var(--primary-400);
            cursor: pointer;
            text-decoration: none;
        }
        .synapse-login-box .synapse-forgot-link:hover { text-decoration: underline; }
        #synapse-reset-form {
            display: none;
        }
        #synapse-reset-form .synapse-reset-step {
            display: none;
        }
        #synapse-reset-form .synapse-reset-step.active {
            display: block;
        }
        .synapse-login-box .synapse-back-link {
            display: block;
            margin-top: 12px;
            text-align: center;
            font-size: 13px;
            color: var(--text-muted);
            cursor: pointer;
        }
        .synapse-login-box .synapse-back-link:hover { color: var(--text-secondary); }
        .synapse-login-box .synapse-info {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 16px;
            line-height: 1.5;
        }
        .synapse-login-box .synapse-success {
            color: var(--success-500);
            font-size: 13px;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: var(--radius-sm);
            display: none;
        }

        /* Interface placeholder */
        #interface-app {
            display: none;
            flex: 1;
            overflow-y: auto;
            background: var(--bg-primary);
        }
        #interface-app.visible { display: flex; align-items: center; justify-content: center; }
        .interface-placeholder {
            text-align: center;
            color: var(--text-muted);
        }
        .interface-placeholder svg { width: 64px; height: 64px; margin-bottom: 16px; opacity: 0.3; }
        .interface-placeholder h2 { font-size: 20px; color: var(--text-secondary); margin-bottom: 8px; }
        .interface-placeholder p { font-size: 14px; }

        .hidden { display: none !important; }

        /* Unlock Screen */
        #unlock-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 110; }
        #unlock-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .unlock-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); padding: 32px; width: 400px; box-shadow: var(--shadow-xl); }
        .unlock-box h2 { font-size: 22px; margin-bottom: 8px; color: var(--text-primary); display: flex; align-items: center; gap: 10px; }
        .unlock-box h2 .lock-icon { font-size: 24px; }
        .unlock-box .subtitle { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .unlock-box input { width: 100%; padding: 12px 14px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .unlock-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
        .unlock-box button { width: 100%; padding: 12px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; transition: background var(--transition-fast); }
        .unlock-box button:hover { background: var(--primary-600); }
        .unlock-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .unlock-box button.secondary { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-primary); }
        .unlock-box button.secondary:hover { background: var(--bg-hover); }
        .unlock-box button.passkey-btn { background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; gap: 8px; }
        .unlock-box button.passkey-btn:hover { background: var(--bg-hover); }
        .unlock-box button.passkey-btn .passkey-icon { font-size: 18px; }
        .unlock-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 10px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-md); display: none; }
        .unlock-divider { display: flex; align-items: center; gap: 12px; margin: 16px 0; color: var(--text-muted); font-size: 12px; }
        .unlock-divider::before, .unlock-divider::after { content: ''; flex: 1; height: 1px; background: var(--border-primary); }
        .unlock-info { color: var(--text-muted); font-size: 12px; margin-top: 16px; text-align: center; line-height: 1.5; }
        .unlock-info a { color: var(--primary-400); text-decoration: none; }
        .unlock-info a:hover { text-decoration: underline; }
        .setup-section { margin-bottom: 20px; }
        .setup-section label { display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500; }
        .password-strength { height: 4px; background: var(--bg-tertiary); border-radius: 2px; margin-top: -8px; margin-bottom: 12px; overflow: hidden; }
        .password-strength-fill { height: 100%; transition: width 0.2s, background 0.2s; width: 0%; }
        .password-strength-fill.weak { background: var(--danger-500); width: 33%; }
        .password-strength-fill.medium { background: var(--warning-500); width: 66%; }
        .password-strength-fill.strong { background: var(--success-500); width: 100%; }
        .security-note { background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 12px; margin-bottom: 16px; font-size: 12px; color: var(--text-secondary); line-height: 1.5; }
        .security-note strong { color: var(--text-primary); }

        /* Empty & Loading States */
        .empty-state { padding: 60px 20px; text-align: center; color: var(--text-muted); }
        .empty-state h3 { font-size: 16px; margin-bottom: 8px; color: var(--text-primary); }
        .loading-state { padding: 60px 20px; text-align: center; color: var(--text-muted); animation: fadeIn 0.15s ease-out; }
        .loading-state h3 { font-size: 16px; margin-bottom: 8px; color: var(--text-primary); }
        .loading-spinner { display: inline-block; width: 24px; height: 24px; border: 3px solid var(--border-primary); border-top-color: var(--primary-500); border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Skeleton Loading */
        .skeleton-row td { background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .skeleton-cell { height: 16px; background: var(--border-primary); border-radius: var(--radius-sm); }

        /* Progress Bar */
        .progress-bar { height: 3px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; margin-top: 4px; }
        .progress-fill { height: 100%; background: var(--primary-500); transition: width 0.3s ease; }
        .table-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .table-container { position: relative; }

        /* ===== View Controls Bar ===== */
        .view-controls-bar { display: flex; align-items: center; gap: 4px; padding: 8px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); }
        .view-control-wrapper { position: relative; }
        .view-control-btn {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 10px; background: transparent; border: none;
            border-radius: var(--radius-sm); cursor: pointer; font-size: 13px;
            color: var(--text-secondary); transition: all var(--transition-fast);
        }
        .view-control-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .view-control-btn.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-control-btn svg { flex-shrink: 0; }
        .control-count { background: var(--primary-500); color: #fff; font-size: 10px; font-weight: 600; padding: 1px 5px; border-radius: 8px; min-width: 16px; text-align: center; }
        .view-controls-spacer { flex: 1; }

        /* View Search */
        .view-search-wrapper { position: relative; display: flex; align-items: center; }
        .view-search-wrapper .search-icon { position: absolute; left: 10px; color: var(--text-muted); pointer-events: none; }
        .view-search-input {
            padding: 6px 10px 6px 32px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); font-size: 13px; width: 180px;
            background: var(--bg-tertiary); color: var(--text-primary);
            transition: all var(--transition-fast);
        }
        .view-search-input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15); width: 220px; }
        .view-search-input::placeholder { color: var(--text-muted); }

        /* View Control Dropdowns */
        .view-control-dropdown {
            position: absolute; top: 100%; left: 0; margin-top: 4px;
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg); box-shadow: var(--shadow-lg);
            z-index: 100; min-width: 280px; display: none;
        }
        .view-control-dropdown.open { display: block; }
        .dropdown-section { padding: 0; }
        .dropdown-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid var(--border-primary); background: var(--bg-tertiary); border-radius: var(--radius-lg) var(--radius-lg) 0 0; }
        .dropdown-header span { font-size: 13px; font-weight: 600; color: var(--text-primary); }
        .dropdown-action-btn { background: transparent; border: none; color: var(--primary-400); font-size: 12px; cursor: pointer; padding: 4px 8px; border-radius: var(--radius-sm); }
        .dropdown-action-btn:hover { background: rgba(59, 130, 246, 0.15); }

        /* Filter Dropdown */
        .filter-list { padding: 12px 16px; max-height: 300px; overflow-y: auto; }
        .empty-filters, .empty-sorts { color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px 0; }
        .filter-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .filter-row:last-child { border-bottom: none; }
        .filter-row select, .filter-row input { padding: 6px 8px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; background: var(--bg-tertiary); color: var(--text-primary); }
        .filter-row select { min-width: 100px; }
        .filter-row input { flex: 1; min-width: 80px; }
        .filter-remove-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 4px; border-radius: var(--radius-sm); }
        .filter-remove-btn:hover { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Sort Dropdown */
        .sort-list { padding: 12px 16px; max-height: 300px; overflow-y: auto; }
        .sort-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .sort-row:last-child { border-bottom: none; }
        .sort-row select { padding: 6px 8px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; flex: 1; background: var(--bg-tertiary); color: var(--text-primary); }
        .sort-direction-btns { display: flex; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); overflow: hidden; }
        .sort-direction-btn { padding: 6px 10px; background: var(--bg-tertiary); border: none; cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .sort-direction-btn.active { background: var(--primary-500); color: #fff; }
        .sort-direction-btn:first-child { border-right: 1px solid var(--border-primary); }
        .sort-remove-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 4px; border-radius: var(--radius-sm); }
        .sort-remove-btn:hover { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Group & Color Dropdown */
        .group-options, .color-options { padding: 8px 0; max-height: 400px; overflow-y: auto; }
        .group-option, .color-option { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; font-size: 13px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .group-option:hover, .color-option:hover { background: var(--bg-hover); }
        .group-option .check-mark, .color-option .check-mark { color: var(--primary-400); font-size: 14px; width: 16px; visibility: hidden; }
        .group-option.selected .check-mark, .color-option.selected .check-mark, .group-option.none-selected .check-mark, .color-option.none-selected .check-mark { visibility: visible; }

        /* Dropdown Search */
        .dropdown-search-wrapper { padding: 8px 12px; border-bottom: 1px solid var(--border-primary); }
        .dropdown-search-input { width: 100%; padding: 8px 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 13px; box-sizing: border-box; background: var(--bg-tertiary); color: var(--text-primary); }
        .dropdown-search-input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15); }
        .dropdown-search-input::placeholder { color: var(--text-muted); }

        /* Grouped Table */
        .group-header-row td { background: var(--bg-secondary); font-weight: 600; padding: 10px 12px !important; border-top: 1px solid var(--border-primary); cursor: pointer; user-select: none; }
        .group-header-row:hover td { background: var(--bg-hover); }
        .group-header-row .group-toggle { display: inline-flex; align-items: center; gap: 8px; color: var(--text-primary); }
        .group-header-row .group-toggle svg { width: 16px; height: 16px; transition: transform 0.2s; color: var(--text-muted); }
        .group-header-row.collapsed .group-toggle svg { transform: rotate(-90deg); }
        .group-header-row .group-name { font-size: 13px; }
        .group-header-row .group-count { font-size: 12px; color: var(--text-muted); font-weight: 400; margin-left: 8px; }
        .group-row.hidden { display: none; }

        /* Color By Row Styling */
        tr[data-color-idx] td { transition: background 0.15s; }
        tr[data-color-idx="0"] td { background: rgba(59, 130, 246, 0.12); }
        tr[data-color-idx="1"] td { background: rgba(16, 185, 129, 0.12); }
        tr[data-color-idx="2"] td { background: rgba(245, 158, 11, 0.12); }
        tr[data-color-idx="3"] td { background: rgba(239, 68, 68, 0.12); }
        tr[data-color-idx="4"] td { background: rgba(139, 92, 246, 0.12); }
        tr[data-color-idx="5"] td { background: rgba(236, 72, 153, 0.12); }
        tr[data-color-idx="6"] td { background: rgba(6, 182, 212, 0.12); }
        tr[data-color-idx="7"] td { background: rgba(249, 115, 22, 0.12); }
        tr[data-color-idx="8"] td { background: rgba(34, 197, 94, 0.12); }
        tr[data-color-idx="9"] td { background: rgba(168, 85, 247, 0.12); }
        tr[data-color-idx="10"] td { background: rgba(14, 165, 233, 0.12); }
        tr[data-color-idx="11"] td { background: rgba(251, 146, 60, 0.12); }
        tr[data-color-idx="12"] td { background: rgba(52, 211, 153, 0.12); }
        tr[data-color-idx="13"] td { background: rgba(244, 63, 94, 0.12); }
        tr[data-color-idx="14"] td { background: rgba(99, 102, 241, 0.12); }
        tr[data-color-idx="15"] td { background: rgba(217, 70, 239, 0.12); }
        tr[data-color-idx="16"] td { background: rgba(20, 184, 166, 0.12); }
        tr[data-color-idx="17"] td { background: rgba(234, 179, 8, 0.12); }
        tr[data-color-idx="18"] td { background: rgba(248, 113, 113, 0.12); }
        tr[data-color-idx="19"] td { background: rgba(96, 165, 250, 0.12); }
        /* Color swatch dots in dropdown */
        .color-option .color-swatch { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }

        /* Record count badge next to Filter */
        .record-count-badge { font-size: 11px; color: var(--text-muted); margin-left: 4px; font-weight: 400; }
        .record-count-badge.filtered { color: var(--primary-400); }

        /* Row Height */
        .row-height-option { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; font-size: 13px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .row-height-option:hover { background: var(--bg-hover); }
        .row-height-option.selected { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .row-height-option svg { color: var(--text-muted); }
        .row-height-option.selected svg { color: var(--primary-400); }
        table.row-height-short td { padding: 4px 12px; }
        table.row-height-medium td { padding: 8px 12px; }
        table.row-height-tall td { padding: 14px 12px; }
        table.row-height-extra-tall td { padding: 20px 12px; white-space: normal; }
        /* ===== Modals ===== */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .modal-overlay.open { opacity: 1; visibility: visible; }
        .modal { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 90%; max-width: 700px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: var(--shadow-xl); transform: translateY(20px); transition: transform 0.2s; }
        .modal-overlay.open .modal { transform: translateY(0); }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .modal-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); flex: 1; margin: 0; }
        .modal-header .record-id { font-size: 12px; color: var(--text-muted); font-family: var(--font-mono); }
        .modal-close { width: 32px; height: 32px; border: none; background: var(--bg-tertiary); border-radius: var(--radius-md); cursor: pointer; font-size: 18px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .modal-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .modal-body { flex: 1; overflow-y: auto; padding: 0; }
        .modal-empty { padding: 60px 20px; text-align: center; color: var(--text-muted); }
        .modal-empty h3 { font-size: 16px; color: var(--text-primary); margin-bottom: 8px; }

        /* History Timeline */
        .history-timeline { padding: 16px 0; }
        .history-item { padding: 16px 24px; border-bottom: 1px solid var(--border-primary); transition: background var(--transition-fast); }
        .history-item:hover { background: var(--bg-hover); }
        .history-item:last-child { border-bottom: none; }
        .history-item-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
        .history-field-name { font-weight: 600; color: var(--text-primary); font-size: 14px; }
        .history-change-type { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: var(--radius-sm); text-transform: uppercase; letter-spacing: 0.3px; }
        .history-change-type.created { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .history-change-type.updated { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .history-change-type.deleted { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .history-actor { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: var(--radius-sm); background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .history-source { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: var(--radius-sm); background: rgba(100, 116, 139, 0.15); color: #94a3b8; text-transform: capitalize; }
        .history-timestamp { font-size: 12px; color: var(--text-muted); margin-left: auto; }
        .history-event-id { font-size: 11px; color: var(--text-disabled); font-family: var(--font-mono); }
        .history-values { display: flex; gap: 12px; align-items: flex-start; flex-wrap: wrap; }
        .history-value-box { flex: 1; min-width: 200px; padding: 10px 12px; border-radius: var(--radius-md); font-size: 13px; }
        .history-value-box.old { background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); }
        .history-value-box.new { background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); }
        .history-value-box.null { background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-muted); font-style: italic; }
        .history-value-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin-bottom: 4px; }
        .history-value-content { word-break: break-word; color: var(--text-secondary); }
        .history-arrow { color: var(--text-muted); font-size: 16px; flex-shrink: 0; align-self: center; }
        .history-btn { padding: 4px 8px; background: transparent; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: inline-flex; align-items: center; gap: 4px; transition: all var(--transition-fast); }
        .history-btn:hover { background: var(--bg-hover); border-color: var(--primary-500); color: var(--primary-400); }
        .history-btn svg { width: 12px; height: 12px; }
        .history-item-actions { display: flex; gap: 8px; margin-top: 10px; }
        .history-revert-btn { padding: 5px 12px; background: transparent; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 12px; color: var(--text-muted); font-weight: 500; transition: all var(--transition-fast); display: inline-flex; align-items: center; gap: 6px; }
        .history-revert-btn:hover { background: var(--primary-500); border-color: var(--primary-500); color: white; }
        .history-revert-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .history-revert-btn svg { width: 14px; height: 14px; }

        /* Modal Toolbar */
        .modal-toolbar { padding: 12px 24px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .modal-toolbar select { padding: 6px 10px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 13px; background: var(--bg-secondary); color: var(--text-primary); }
        .modal-toolbar .history-count { font-size: 12px; color: var(--text-muted); margin-left: auto; }

        /* View Selector */
        .view-selector { position: relative; display: flex; align-items: center; gap: 8px; }
        .view-selector-btn { padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 8px; min-width: 140px; transition: border-color var(--transition-fast); color: var(--text-secondary); }
        .view-selector-btn:hover { border-color: var(--primary-500); }
        .view-selector-btn .view-icon { font-size: 14px; }
        .view-selector-btn .view-name { flex: 1; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .view-selector-btn .dropdown-arrow { font-size: 10px; color: var(--text-muted); }
        .view-selector-dropdown { position: absolute; top: 100%; left: 0; margin-top: 4px; min-width: 200px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 100; max-height: 300px; overflow-y: auto; display: none; }
        .view-selector-dropdown.open { display: block; }
        .view-selector-dropdown-header { padding: 10px 12px; font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border-primary); background: var(--bg-tertiary); }
        .view-selector-option { padding: 10px 12px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 10px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .view-selector-option:hover { background: var(--bg-hover); }
        .view-selector-option.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-selector-option .view-type-icon { width: 20px; text-align: center; }
        .view-selector-option .view-option-name { flex: 1; }
        .view-selector-option .view-check { color: var(--primary-400); font-size: 14px; }

        /* Fields Button & Dropdown */
        .fields-btn { padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 6px; transition: all var(--transition-fast); color: var(--text-secondary); }
        .fields-btn:hover { border-color: var(--primary-500); color: var(--text-primary); }
        .fields-btn .fields-icon { font-size: 14px; }
        .fields-btn .fields-count { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); padding: 2px 6px; border-radius: 10px; font-size: 11px; font-weight: 600; }
        .fields-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; width: 340px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 100; display: none; }
        .fields-dropdown.open { display: block; }
        .fields-dropdown-header { padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; }
        .fields-dropdown-header h3 { font-size: 14px; font-weight: 600; color: var(--text-primary); margin: 0; }
        .fields-dropdown-actions { display: flex; gap: 8px; }
        .fields-dropdown-actions button { padding: 4px 8px; font-size: 11px; background: transparent; border: none; color: var(--primary-400); cursor: pointer; border-radius: var(--radius-sm); }
        .fields-dropdown-actions button:hover { background: rgba(59, 130, 246, 0.15); }
        .fields-search-container { padding: 8px 12px; border-bottom: 1px solid var(--border-primary); }
        .fields-search-input { width: 100%; padding: 6px 10px; font-size: 13px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); outline: none; box-sizing: border-box; }
        .fields-search-input::placeholder { color: var(--text-muted); }
        .fields-search-input:focus { border-color: var(--primary-500); }
        .fields-dropdown-list { max-height: 450px; overflow-y: auto; padding: 8px 0; }
        .fields-dropdown-item.drag-over-above { box-shadow: inset 0 2px 0 0 var(--primary-500); }
        .fields-dropdown-item.drag-over-below { box-shadow: inset 0 -2px 0 0 var(--primary-500); }
        .fields-dropdown-item { padding: 8px 16px; display: flex; align-items: center; gap: 10px; cursor: pointer; transition: background var(--transition-fast); user-select: none; }
        .fields-dropdown-item:hover { background: var(--bg-hover); }
        .fields-dropdown-item.dragging { background: rgba(59, 130, 246, 0.15); opacity: 0.8; }
        .fields-dropdown-item .field-drag-handle { cursor: grab; color: var(--text-disabled); font-size: 12px; padding: 2px; }
        .fields-dropdown-item .field-drag-handle:hover { color: var(--text-muted); }
        .fields-dropdown-item .field-checkbox { width: 18px; height: 18px; border: 2px solid var(--border-secondary); border-radius: var(--radius-sm); display: flex; align-items: center; justify-content: center; transition: all var(--transition-fast); flex-shrink: 0; }
        .fields-dropdown-item .field-checkbox.checked { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .fields-dropdown-item .field-checkbox .check-icon { font-size: 12px; display: none; }
        .fields-dropdown-item .field-checkbox.checked .check-icon { display: block; }
        .fields-dropdown-item .field-info { flex: 1; min-width: 0; }
        .fields-dropdown-item .field-name { font-size: 13px; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .fields-dropdown-item .field-type { font-size: 11px; color: var(--text-muted); }
        .fields-dropdown-item .field-move-btns { display: flex; flex-direction: column; gap: 2px; opacity: 0; transition: opacity var(--transition-fast); }
        .fields-dropdown-item:hover .field-move-btns { opacity: 1; }
        .fields-dropdown-item .field-move-btn { width: 18px; height: 14px; border: none; background: var(--bg-tertiary); border-radius: 3px; cursor: pointer; font-size: 10px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .fields-dropdown-item .field-move-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .fields-dropdown-footer { padding: 10px 16px; border-top: 1px solid var(--border-primary); background: var(--bg-tertiary); font-size: 11px; color: var(--text-muted); }
        .toolbar-views { display: flex; align-items: center; gap: 8px; position: relative; }
        /* ===== Loading Overlay ===== */
        #loading-overlay {
            position: fixed; inset: 0;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            display: flex; align-items: center; justify-content: center; z-index: 200;
        }
        #loading-overlay.fading-out { opacity: 0; transition: opacity 0.4s ease; pointer-events: none; }
        .loading-content { text-align: center; max-width: 400px; padding: 40px; }
        .loading-logo { width: 80px; height: 80px; margin: 0 auto 24px; position: relative; }
        .loading-logo-inner {
            width: 100%; height: 100%; border-radius: 20px;
            background: linear-gradient(135deg, var(--primary-500) 0%, #7c3aed 100%);
            animation: pulse-glow 2s ease-in-out infinite;
            display: flex; align-items: center; justify-content: center;
            font-size: 36px; color: white;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.4); transform: scale(1); }
            50% { box-shadow: 0 0 40px rgba(124, 58, 237, 0.6); transform: scale(1.05); }
        }
        .loading-title { font-size: 24px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; }
        .loading-subtitle { font-size: 14px; color: var(--text-muted); margin-bottom: 32px; line-height: 1.5; }
        .loading-progress-container { background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 20px; margin-bottom: 24px; }
        .loading-progress-bar { height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden; margin-bottom: 16px; position: relative; }
        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-500), #7c3aed, var(--primary-500));
            background-size: 200% 100%; border-radius: 3px;
            transition: width 0.3s ease; animation: shimmer-progress 1.5s linear infinite;
        }
        @keyframes shimmer-progress { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .loading-status { font-size: 13px; color: var(--text-secondary); margin-bottom: 4px; }
        .loading-detail { font-size: 12px; color: var(--text-muted); font-family: var(--font-mono); }
        .loading-time-estimate { font-size: 11px; color: var(--text-muted); margin-top: 8px; min-height: 16px; }
        .loading-table-progress { font-size: 12px; color: var(--text-muted); font-family: var(--font-mono); margin-top: 4px; min-height: 16px; }
        .loading-speed { font-size: 11px; color: var(--primary-500); margin-top: 8px; min-height: 16px; font-family: var(--font-mono); }
        .loading-progress-activity { position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; border-radius: 3px; }
        .loading-progress-activity::after {
            content: ''; position: absolute; top: 0; left: -100%; height: 100%; width: 50%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: activity-sweep 1.2s ease-in-out infinite;
        }
        @keyframes activity-sweep { 0% { left: -50%; } 100% { left: 100%; } }
        .loading-facts { display: flex; justify-content: center; gap: 24px; margin-bottom: 24px; }
        .loading-fact { text-align: center; }
        .loading-fact-value { font-size: 28px; font-weight: 700; color: var(--text-primary); line-height: 1; }
        .loading-fact-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }
        .loading-note { font-size: 12px; color: var(--text-muted); background: rgba(255, 255, 255, 0.03); border: 1px solid var(--border-primary); padding: 12px 16px; border-radius: var(--radius-lg); border-left: 3px solid var(--primary-500); }
        .loading-note strong { color: var(--text-secondary); }
        .loading-skip-section { margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border-primary); }
        .loading-skip-text { font-size: 12px; color: var(--text-muted); margin-bottom: 12px; }
        .loading-skip-btn { background: transparent; border: 1px solid var(--border-secondary); color: var(--text-secondary); padding: 10px 20px; border-radius: var(--radius-md); font-size: 13px; cursor: pointer; transition: all 0.2s; }
        .loading-skip-btn:hover { background: var(--bg-hover); border-color: var(--text-muted); color: var(--text-primary); }
        .loading-skip-btn:active { transform: scale(0.98); }
        .loading-particles { position: absolute; inset: 0; overflow: hidden; pointer-events: none; }
        .particle { position: absolute; width: 4px; height: 4px; background: rgba(59, 130, 246, 0.3); border-radius: 50%; animation: float-up 8s ease-in-out infinite; }
        .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
        .particle:nth-child(2) { left: 20%; animation-delay: 1s; }
        .particle:nth-child(3) { left: 30%; animation-delay: 2s; }
        .particle:nth-child(4) { left: 40%; animation-delay: 3s; }
        .particle:nth-child(5) { left: 50%; animation-delay: 4s; }
        .particle:nth-child(6) { left: 60%; animation-delay: 5s; }
        .particle:nth-child(7) { left: 70%; animation-delay: 6s; }
        .particle:nth-child(8) { left: 80%; animation-delay: 7s; }
        .particle:nth-child(9) { left: 90%; animation-delay: 0.5s; }
        .particle:nth-child(10) { left: 15%; animation-delay: 2.5s; }
        @keyframes float-up {
            0%, 100% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(90vh) scale(1); }
            90% { opacity: 1; transform: translateY(10vh) scale(1); }
            100% { transform: translateY(0) scale(0); opacity: 0; }
        }

        /* Refresh & Save Indicators */
        .refresh-indicator { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text-muted); padding: 2px 8px; border-radius: var(--radius-sm); transition: all 0.3s; }
        .refresh-indicator.syncing { color: var(--primary-400); background: rgba(59, 130, 246, 0.1); }
        .refresh-indicator .refresh-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); transition: all 0.3s; }
        .refresh-indicator.syncing .refresh-dot { background: var(--primary-500); animation: pulse-dot 1s ease-in-out infinite; }
        @keyframes pulse-dot { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.5); opacity: 0.5; } }

        /* Airtable sync button states */
        #airtable-sync-btn.syncing { color: var(--primary-400); border-color: var(--primary-500); }
        #airtable-sync-btn.syncing #sync-icon { animation: spin-sync 1s linear infinite; }
        #airtable-sync-btn.cooldown { opacity: 0.6; cursor: default; }
        #airtable-sync-btn.cooldown:hover { background: var(--bg-tertiary); color: var(--text-secondary); border-color: var(--border-primary); }
        @keyframes spin-sync { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .view-save-indicator { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text-muted); padding: 4px 10px; border-radius: var(--radius-sm); transition: all 0.3s; margin-left: 8px; }
        .view-save-indicator.dirty { color: var(--warning-500); background: rgba(245, 158, 11, 0.1); }
        .view-save-indicator.saving { color: var(--primary-400); background: rgba(59, 130, 246, 0.1); }
        .view-save-indicator.saved { color: var(--success-500); background: rgba(34, 197, 94, 0.1); }
        .view-save-indicator .save-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }
        .view-save-indicator.saving .save-dot { animation: pulse-dot 1s ease-in-out infinite; }
        .view-save-btn { padding: 4px 10px; background: var(--primary-500); color: #fff; border: none; border-radius: var(--radius-sm); font-size: 11px; cursor: pointer; margin-left: 4px; transition: all var(--transition-fast); }
        .view-save-btn:hover { background: var(--primary-600); }
        .view-save-btn:disabled { background: var(--gray-600); cursor: not-allowed; }

        /* View Folders */
        .table-view-folder { padding: 6px 16px 6px 36px; cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 8px; transition: all var(--transition-fast); user-select: none; }
        .table-view-folder:hover { background: var(--bg-hover); color: var(--text-primary); }
        .table-view-folder .folder-icon { font-size: 12px; transition: transform 0.2s; }
        .table-view-folder.expanded .folder-icon { transform: rotate(90deg); }
        .table-view-folder .folder-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .table-view-folder .folder-actions { display: none; gap: 4px; }
        .table-view-folder:hover .folder-actions { display: flex; }
        .table-view-folder .folder-action-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 2px 4px; font-size: 10px; border-radius: 3px; }
        .table-view-folder .folder-action-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .folder-views-list { max-height: 0; overflow: hidden; transition: max-height 0.25s ease-out; }
        .folder-views-list.expanded { max-height: 500px; }
        .folder-views-list .table-view-item { padding-left: 52px; }
        .table-view-add-btn { padding: 6px 16px 6px 44px; cursor: pointer; font-size: 12px; color: var(--text-disabled); display: flex; align-items: center; gap: 8px; transition: all var(--transition-fast); }
        .table-view-add-btn:hover { background: var(--bg-hover); color: var(--primary-400); }
        .table-view-add-btn .add-icon { font-size: 14px; color: var(--primary-400); }
        .folder-name-input { background: var(--bg-tertiary); border: 1px solid var(--primary-500); color: var(--text-primary); padding: 4px 8px; font-size: 12px; border-radius: var(--radius-sm); width: 120px; }
        .folder-name-input:focus { outline: none; border-color: var(--primary-400); }

        /* Context Menu */
        .view-context-menu { position: fixed; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 1000; min-width: 160px; padding: 4px 0; display: none; }
        .view-context-menu.open { display: block; }
        .view-context-menu-item { padding: 8px 16px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 8px; color: var(--text-secondary); }
        .view-context-menu-item:hover { background: var(--bg-hover); }
        .view-context-menu-item.danger { color: #f87171; }
        .view-context-menu-item.danger:hover { background: rgba(239, 68, 68, 0.15); }
        .view-context-menu-separator { height: 1px; background: var(--border-primary); margin: 4px 0; }

        /* Column Drag */
        th.dragging { opacity: 0.5; background: rgba(59, 130, 246, 0.15) !important; }
        th.drag-over { border-left: 3px solid var(--primary-500); }
        th { cursor: grab; }
        th:active { cursor: grabbing; }
        th:first-child { cursor: default; }

        /* Schema View */
        .schema-view-container { padding: 20px; display: flex; flex-wrap: wrap; gap: 16px; overflow-y: auto; }
        .schema-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 320px; max-height: 500px; overflow: hidden; box-shadow: var(--shadow-sm); transition: box-shadow 0.2s, transform 0.2s; display: flex; flex-direction: column; }
        .schema-card:hover { box-shadow: var(--shadow-md); transform: translateY(-2px); }
        .schema-card-header { padding: 16px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; }
        .schema-card-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); background: var(--bg-primary); padding: 4px 8px; border-radius: var(--radius-sm); }
        .schema-card-actions { display: flex; gap: 8px; }
        .schema-card-body { padding: 0; overflow-y: auto; flex: 1; }
        .schema-field-row { padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; flex-direction: column; gap: 4px; }
        .schema-field-row:last-child { border-bottom: none; }
        .schema-field-name { font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.3px; }
        .schema-field-value { font-size: 13px; color: var(--text-primary); word-break: break-word; }
        .schema-field-value.empty { color: var(--text-disabled); font-style: italic; }
        /* ===== Create View Modal ===== */
        .create-view-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1001; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .create-view-modal.open { opacity: 1; visibility: visible; }
        .create-view-modal-content { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 400px; max-width: 90%; box-shadow: var(--shadow-xl); transform: translateY(20px); transition: transform 0.2s; }
        .create-view-modal.open .create-view-modal-content { transform: translateY(0); }
        .create-view-modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border-primary); }
        .create-view-modal-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); margin: 0 0 4px 0; }
        .create-view-modal-header p { font-size: 13px; color: var(--text-muted); margin: 0; }
        .create-view-modal-body { padding: 24px; }
        .create-view-field { margin-bottom: 16px; }
        .create-view-field label { display: block; font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 6px; }
        .create-view-field input, .create-view-field select { width: 100%; padding: 10px 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); font-size: 14px; background: var(--bg-tertiary); color: var(--text-primary); }
        .create-view-field input:focus, .create-view-field select:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .create-view-modal-footer { padding: 16px 24px; border-top: 1px solid var(--border-primary); display: flex; justify-content: flex-end; gap: 12px; background: var(--bg-tertiary); border-radius: 0 0 var(--radius-xl) var(--radius-xl); }
        .create-view-modal-footer button { padding: 10px 20px; border-radius: var(--radius-md); font-size: 14px; font-weight: 500; cursor: pointer; transition: all var(--transition-fast); }
        .create-view-modal-footer .btn-cancel { background: var(--bg-secondary); border: 1px solid var(--border-primary); color: var(--text-muted); }
        .create-view-modal-footer .btn-cancel:hover { background: var(--bg-hover); }
        .create-view-modal-footer .btn-create { background: var(--primary-500); border: 1px solid var(--primary-500); color: #fff; }
        .create-view-modal-footer .btn-create:hover { background: var(--primary-600); }

        /* Share View Modal */
        .share-options { display: flex; flex-direction: column; gap: 8px; }
        .share-option { display: flex; align-items: flex-start; gap: 12px; padding: 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); cursor: pointer; transition: all var(--transition-fast); }
        .share-option:hover { background: var(--bg-hover); }
        .share-option input[type="radio"] { margin-top: 4px; accent-color: var(--primary-500); }
        .share-option-icon { font-size: 20px; line-height: 1; flex-shrink: 0; }
        .share-option-text { display: flex; flex-direction: column; gap: 2px; }
        .share-option-text strong { font-size: 14px; color: var(--text-primary); font-weight: 500; }
        .share-option-text span { font-size: 12px; color: var(--text-muted); }
        .share-option:has(input:checked) { border-color: var(--primary-500); background: rgba(59, 130, 246, 0.05); }
        .share-users-list { max-height: 200px; overflow-y: auto; border: 1px solid var(--border-primary); border-radius: var(--radius-md); }
        .share-users-loading { padding: 12px; text-align: center; font-size: 13px; color: var(--text-muted); }
        .share-user-item { display: flex; align-items: center; gap: 10px; padding: 8px 12px; cursor: pointer; transition: background var(--transition-fast); }
        .share-user-item:hover { background: var(--bg-hover); }
        .share-user-item input[type="checkbox"] { accent-color: var(--primary-500); }
        .share-user-item .user-name { font-size: 13px; color: var(--text-primary); }
        .share-user-item .user-id { font-size: 11px; color: var(--text-muted); }
        .share-view-owner { font-size: 12px; color: var(--text-muted); margin-bottom: 12px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: var(--radius-md); }

        /* View Sharing Badge in Sidebar */
        .view-sharing-badge { font-size: 11px; margin-left: auto; flex-shrink: 0; opacity: 0.6; }
        .view-sharing-badge.shared { opacity: 0.8; color: var(--primary-400); }

        /* View Tags */
        .view-tags { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; }
        .view-tag { font-size: 10px; padding: 2px 6px; border-radius: 10px; background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-tag.workspace { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .table-view-item .view-tags { padding-left: 24px; }

        /* Workspace Tabs */
        .workspace-tabs { display: flex; gap: 4px; padding: 8px 16px; background: var(--bg-primary); border-bottom: 1px solid var(--border-primary); }
        .workspace-tab { padding: 6px 12px; font-size: 12px; color: var(--text-muted); border-radius: var(--radius-sm); cursor: pointer; transition: all var(--transition-fast); }
        .workspace-tab:hover { background: var(--bg-hover); color: var(--text-primary); }
        .workspace-tab.active { background: var(--primary-500); color: #fff; }
        .workspace-tab .workspace-count { margin-left: 6px; font-size: 10px; background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 8px; }
        .workspace-add-btn { padding: 6px 8px; font-size: 12px; color: var(--text-muted); cursor: pointer; }
        .workspace-add-btn:hover { color: var(--primary-400); }

        /* Nested Views */
        .table-view-item.nested-level-1 { padding-left: 60px; }
        .table-view-item.nested-level-2 { padding-left: 76px; }
        .table-view-item.nested-level-3 { padding-left: 92px; }
        .view-nest-indicator { font-size: 10px; color: var(--text-muted); margin-right: 4px; }
        .view-type-badge { font-size: 9px; padding: 2px 5px; border-radius: 3px; background: var(--bg-tertiary); color: var(--text-muted); margin-left: auto; }
        .view-type-badge.schema { background: rgba(124, 58, 237, 0.3); color: #a78bfa; }
        .view-type-badge.grid { background: rgba(59, 130, 246, 0.3); color: #60a5fa; }

        /* Events Sidebar Items */
        .events-section-header { padding: 12px 16px 8px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); border-bottom: 1px solid var(--border-primary); }
        .sidebar div.table-item.events-item { margin: 2px 8px; border-radius: var(--radius-lg); background: transparent; border: none; }
        .sidebar div.table-item.events-item .table-icon { background: rgba(245, 158, 11, 0.15); border-radius: 5px; }
        .sidebar div.table-item.events-item .table-icon svg { color: #d97706; }
        .sidebar div.table-item.events-item:hover { background: var(--bg-hover); }
        .sidebar div.table-item.events-item:active { background: rgba(139, 92, 246, 0.15); transition: background-color 0.05s; }
        .sidebar div.table-item.events-item.active { background: rgba(139, 92, 246, 0.15); }
        .sidebar div.table-item.events-item.active::before { background: #8b5cf6; }

        .sidebar div.table-item.sync-status-item { margin: 2px 8px; border-radius: var(--radius-lg); background: transparent; border: none; }
        .sidebar div.table-item.sync-status-item .table-icon { background: rgba(16, 185, 129, 0.15); border-radius: 5px; }
        .sidebar div.table-item.sync-status-item .table-icon svg { color: #10b981; }
        .sidebar div.table-item.sync-status-item:hover { background: var(--bg-hover); }
        .sidebar div.table-item.sync-status-item:active { background: rgba(16, 185, 129, 0.15); transition: background-color 0.05s; }
        .sidebar div.table-item.sync-status-item.active { background: rgba(16, 185, 129, 0.15); }
        .sidebar div.table-item.sync-status-item.active::before { background: #10b981; }

        /* ===== Sync Status View ===== */
        .sync-status-view { padding: 24px; max-width: 1200px; }
        .sync-status-header { display: flex; align-items: center; gap: 12px; margin-bottom: 24px; }
        .sync-status-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); }
        .sync-status-header .sync-status-badge { font-size: 11px; font-weight: 600; padding: 3px 10px; border-radius: 12px; }
        .sync-status-badge.synced { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-status-badge.syncing { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .sync-status-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-status-badge.queued { background: rgba(251, 146, 60, 0.15); color: #fb923c; }
        .sync-status-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; margin-bottom: 24px; }
        .sync-status-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 18px; }
        .sync-status-card .card-label { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 6px; }
        .sync-status-card .card-value { font-size: 22px; font-weight: 600; color: var(--text-primary); }
        .sync-status-card .card-sub { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
        .sync-status-section { margin-bottom: 24px; }
        .sync-status-section h3 { font-size: 14px; font-weight: 600; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .sync-status-section h3 .section-dot { width: 8px; height: 8px; border-radius: 50%; }
        .sync-status-section h3 .section-dot.green { background: #10b981; }
        .sync-status-section h3 .section-dot.amber { background: #f59e0b; }
        .sync-status-section h3 .section-dot.red { background: #ef4444; }

        .sync-history-table { width: 100%; border-collapse: collapse; font-size: 13px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); overflow: hidden; }
        .sync-history-table th { background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); padding: 10px 14px; text-align: left; font-weight: 600; color: var(--text-secondary); font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; }
        .sync-history-table td { border-bottom: 1px solid var(--border-primary); padding: 10px 14px; color: var(--text-secondary); }
        .sync-history-table tr:last-child td { border-bottom: none; }
        .sync-history-table tr:hover td { background: var(--bg-hover); }
        .sync-history-table .sync-type-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: var(--radius-sm); text-transform: uppercase; }
        .sync-history-table .sync-type-badge.incremental { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .sync-history-table .sync-type-badge.full { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .sync-history-table .sync-type-badge.snapshot { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-history-table .sync-type-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-history-table .sync-type-badge.edit { background: rgba(14, 165, 233, 0.15); color: #38bdf8; }
        .sync-result-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: var(--radius-sm); }
        .sync-result-badge.success { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-result-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-result-badge.no-change { background: var(--bg-tertiary); color: var(--text-muted); }
        .sync-result-badge.queued { background: rgba(251, 146, 60, 0.15); color: #fb923c; }
        .sync-result-badge.syncing { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .queue-count-badge { display: inline-flex; align-items: center; justify-content: center; min-width: 20px; height: 20px; padding: 0 6px; border-radius: 10px; background: rgba(251, 146, 60, 0.2); color: #fb923c; font-size: 11px; font-weight: 700; margin-left: 6px; }
        .sync-status-card.queue-highlight { border-color: rgba(251, 146, 60, 0.4); background: rgba(251, 146, 60, 0.05); }
        .sync-status-card.queue-highlight .card-value { color: #fb923c; }
        .sync-status-card.queue-highlight .card-label { color: #fb923c; }
        .sync-poll-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .sync-poll-controls .btn-poll { display: inline-flex; align-items: center; gap: 6px; padding: 8px 16px; border-radius: var(--radius-lg); border: 1px solid var(--border-primary); background: var(--bg-secondary); font-size: 13px; font-weight: 500; color: var(--text-secondary); cursor: pointer; transition: all var(--transition-fast); }
        .sync-poll-controls .btn-poll:hover { background: var(--bg-hover); border-color: var(--border-secondary); }
        .sync-poll-controls .btn-poll.primary { background: var(--success-500); color: #fff; border-color: var(--success-500); }
        .sync-poll-controls .btn-poll.primary:hover { background: var(--success-600); }
        .sync-poll-controls .btn-poll:disabled { opacity: 0.5; cursor: not-allowed; }
        .snapshot-export-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }
        .sync-activity-log { background: var(--bg-primary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 16px; max-height: 300px; overflow-y: auto; font-family: var(--font-mono); font-size: 12px; line-height: 1.6; }
        .sync-activity-log .log-line { color: var(--text-muted); }
        .sync-activity-log .log-line .timestamp { color: var(--text-disabled); margin-right: 8px; }
        .sync-activity-log .log-line.info .message { color: #60a5fa; }
        .sync-activity-log .log-line.success .message { color: #34d399; }
        .sync-activity-log .log-line.error .message { color: #f87171; }
        .sync-activity-log .log-line.warn .message { color: #fbbf24; }
        .sync-activity-log .log-empty { color: var(--text-disabled); text-align: center; padding: 20px; }
        /* ===== Matrix Rooms View ===== */
        .matrix-rooms-view { padding: 24px; max-width: 1200px; }
        .matrix-rooms-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(340px, 1fr)); gap: 12px; }
        .matrix-room-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 16px; transition: border-color var(--transition-fast), background var(--transition-fast); cursor: default; }
        .matrix-room-card:hover { border-color: var(--border-secondary); background: var(--bg-hover); }
        .matrix-room-card.space { border-left: 3px solid #8b5cf6; }
        .matrix-room-card.room { border-left: 3px solid #6366f1; }
        .matrix-room-card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .matrix-room-card-icon { width: 32px; height: 32px; border-radius: var(--radius-md); display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
        .matrix-room-card-icon.space-icon { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .matrix-room-card-icon.room-icon { background: rgba(99, 102, 241, 0.15); color: #818cf8; }
        .matrix-room-card-name { font-size: 13px; font-weight: 600; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; min-width: 0; }
        .matrix-room-card-type { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: var(--radius-sm); text-transform: uppercase; flex-shrink: 0; }
        .matrix-room-card-type.space { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .matrix-room-card-type.room { background: rgba(99, 102, 241, 0.15); color: #818cf8; }
        .matrix-room-card-type.dm { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
        .matrix-room-card-topic { font-size: 12px; color: var(--text-muted); margin-bottom: 8px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .matrix-room-card-meta { display: flex; gap: 12px; font-size: 11px; color: var(--text-disabled); flex-wrap: wrap; }
        .matrix-room-card-meta span { display: flex; align-items: center; gap: 4px; }
        .matrix-room-card-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-disabled); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-top: 6px; }
        .matrix-rooms-section { margin-bottom: 20px; }
        .matrix-rooms-section h3 { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .matrix-rooms-section h3 .section-count { font-weight: 400; color: var(--text-muted); }
        .matrix-rooms-filter { display: flex; gap: 8px; margin-bottom: 20px; align-items: center; }
        .matrix-rooms-filter input { flex: 1; max-width: 360px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 8px 12px; font-size: 13px; color: var(--text-primary); font-family: inherit; }
        .matrix-rooms-filter input:focus { outline: none; border-color: var(--primary-400); }
        .matrix-rooms-filter .filter-btn { padding: 6px 14px; border-radius: var(--radius-md); border: 1px solid var(--border-primary); background: var(--bg-secondary); font-size: 12px; font-weight: 500; color: var(--text-muted); cursor: pointer; transition: all var(--transition-fast); }
        .matrix-rooms-filter .filter-btn:hover { border-color: var(--border-secondary); color: var(--text-secondary); }
        .matrix-rooms-filter .filter-btn.active { background: rgba(99, 102, 241, 0.15); color: #818cf8; border-color: rgba(99, 102, 241, 0.3); }
        /* ===== Events Table ===== */
        .events-table { min-width: 100%; border-collapse: collapse; font-size: 13px; }
        .events-table th { background: var(--bg-secondary); border-bottom: 2px solid var(--border-primary); padding: 10px 12px; text-align: left; font-weight: 500; color: var(--text-secondary); position: sticky; top: 0; z-index: 10; white-space: nowrap; }
        .events-table td { border-bottom: 1px solid var(--border-primary); padding: 10px 12px; vertical-align: top; }
        .events-table tr:hover td { background: var(--bg-hover); }
        .events-table .event-id { font-family: var(--font-mono); font-size: 12px; color: var(--text-muted); }
        .events-table .event-timestamp { font-size: 12px; color: var(--text-muted); white-space: nowrap; }
        .events-table .event-set { font-family: var(--font-mono); font-size: 11px; color: var(--primary-400); background: rgba(59, 130, 246, 0.15); padding: 2px 6px; border-radius: var(--radius-sm); display: inline-block; max-width: 150px; overflow: hidden; text-overflow: ellipsis; }
        .events-table .event-record-id { font-family: var(--font-mono); font-size: 11px; color: #4ade80; background: rgba(34, 197, 94, 0.15); padding: 2px 6px; border-radius: var(--radius-sm); display: inline-block; }
        .events-table .event-type-badge { font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); }
        .events-table .event-type-badge.data { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .event-type-badge.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .event-type-badge.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .event-type-badge.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .events-table .event-type-badge.SYN { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .event-type-badge.table { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .event-type-badge.field { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .events-table .event-type-badge.view { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
        .events-table .event-type-badge.viewconfig { background: rgba(124, 58, 237, 0.15); color: #a78bfa; }
        .events-table .event-type-badge.current { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .field-op-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); margin-right: 4px; }
        .events-table .field-op-badge.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .field-op-badge.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .field-op-badge.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .events-table .field-op-badge.SYN { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .field-op-badge .field-count { font-weight: 400; opacity: 0.8; }
        .events-table .event-details { white-space: nowrap; }
        .events-table .current-state-row { background: rgba(34, 197, 94, 0.05); }
        .events-table .event-id.current-state { color: var(--text-disabled); }

        /* New Event Indicators */
        .events-table tr.new-event td { background: rgba(34, 197, 94, 0.05); }
        .events-table tr.new-event:hover td { background: rgba(34, 197, 94, 0.1); }
        .new-event-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: var(--radius-sm); background: var(--success-500); color: #fff; text-transform: uppercase; letter-spacing: 0.5px; margin-left: 6px; animation: pulse-new 2s ease-in-out infinite; }
        @keyframes pulse-new { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .new-events-divider { position: relative; padding: 8px 0; }
        .new-events-divider td { background: rgba(34, 197, 94, 0.1) !important; border-bottom: 2px solid var(--success-500); text-align: center; padding: 8px 12px; }
        .new-events-divider-text { display: inline-flex; align-items: center; gap: 8px; color: var(--success-500); font-size: 11px; font-weight: 600; }
        .new-events-divider-text::before, .new-events-divider-text::after { content: ''; display: inline-block; width: 40px; height: 1px; background: var(--success-500); }

        /* Payload Preview */
        .payload-preview-container { max-width: 400px; }
        .payload-preview { font-family: var(--font-mono); font-size: 11px; color: var(--text-secondary); background: var(--bg-tertiary); padding: 6px 10px; border-radius: var(--radius-sm); max-height: 60px; overflow: hidden; cursor: pointer; position: relative; transition: all 0.2s; border: 1px solid var(--border-primary); }
        .payload-preview:hover { background: var(--bg-hover); border-color: var(--border-secondary); }
        .payload-preview.expanded { max-height: none; white-space: pre-wrap; word-break: break-all; }
        .payload-expand-btn { position: absolute; bottom: 4px; right: 4px; font-size: 10px; color: var(--primary-400); background: var(--bg-secondary); padding: 2px 6px; border-radius: 3px; border: 1px solid var(--border-primary); cursor: pointer; }
        .payload-preview.expanded .payload-expand-btn { position: static; display: block; margin-top: 8px; }

        /* JSON Syntax Highlighting */
        .json-key { color: #a78bfa; }
        .json-string { color: #4ade80; }
        .json-number { color: #60a5fa; }
        .json-boolean { color: #f87171; }
        .json-null { color: var(--text-muted); font-style: italic; }

        /* Payload Fields */
        .payload-fields { }
        .payload-op-group { margin-bottom: 6px; }
        .payload-op-group:last-child { margin-bottom: 0; }
        .payload-op-label { display: inline-block; font-size: 9px; font-weight: 600; padding: 1px 5px; border-radius: 3px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        .payload-op-label.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .payload-op-label.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .payload-op-label.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .payload-field-row { display: flex; gap: 8px; padding: 2px 0; border-bottom: 1px solid var(--border-primary); }
        .payload-field-row:last-child { border-bottom: none; }
        .payload-field-name { color: #a78bfa; font-weight: 500; min-width: 80px; flex-shrink: 0; }
        .payload-field-value { color: var(--text-secondary); word-break: break-word; }
        .payload-field-value.string { color: #4ade80; }
        .payload-field-value.number { color: #60a5fa; }
        .payload-field-value.boolean { color: #f87171; }
        .payload-field-value.null { color: var(--text-muted); font-style: italic; }
        .payload-field-value.array { color: #a78bfa; }
        .payload-field-value.object { color: #22d3ee; }
        .payload-raw-toggle { font-size: 10px; color: var(--text-muted); cursor: pointer; margin-top: 6px; }
        .payload-raw-toggle:hover { color: var(--primary-400); text-decoration: underline; }

        /* Event Actions */
        .event-actions { display: flex; gap: 6px; }
        .event-action-btn { padding: 4px 8px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: inline-flex; align-items: center; gap: 4px; transition: all var(--transition-fast); white-space: nowrap; }
        .event-action-btn:hover { background: var(--bg-hover); border-color: var(--primary-500); color: var(--primary-400); }
        .event-action-btn.primary { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .event-action-btn.primary:hover { background: var(--primary-600); }

        /* Infinite Scroll */
        .events-load-more { display: flex; align-items: center; justify-content: center; padding: 20px; gap: 10px; color: var(--text-muted); font-size: 13px; }
        .events-load-more .loading-spinner-small { width: 20px; height: 20px; border: 2px solid var(--border-primary); border-top-color: var(--primary-500); border-radius: 50%; animation: spin 0.8s linear infinite; }
        .events-end-message { text-align: center; padding: 20px; color: var(--text-muted); font-size: 12px; border-top: 1px solid var(--border-primary); }

        /* Events Tab Bar */
        .events-tab-bar { display: flex; gap: 0; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); padding: 0 20px; position: sticky; top: 0; z-index: 11; }
        .events-tab { padding: 10px 20px; font-size: 13px; font-weight: 500; color: var(--text-muted); cursor: pointer; border-bottom: 2px solid transparent; transition: color 0.15s, border-color 0.15s; user-select: none; }
        .events-tab:hover { color: var(--text-secondary); }
        .events-tab.active { color: var(--text-primary); border-bottom-color: var(--primary-500); }
        .room-access-layout { display: flex; flex-direction: column; gap: 14px; padding: 16px 20px; }
        .room-access-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
        .room-access-meta { font-size: 12px; color: var(--text-muted); }
        .room-access-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(330px, 1fr)); gap: 12px; }
        .room-access-card { border: 1px solid var(--border-primary); border-radius: var(--radius-md); background: var(--bg-secondary); padding: 12px; display: flex; flex-direction: column; gap: 8px; }
        .room-access-title { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
        .room-access-name { font-weight: 600; color: var(--text-primary); }
        .room-access-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); word-break: break-all; }
        .room-access-badges { display: flex; gap: 6px; flex-wrap: wrap; }
        .room-access-badge { font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); text-transform: uppercase; letter-spacing: 0.04em; }
        .room-access-badge.space { background: rgba(124, 58, 237, 0.15); color: #a78bfa; }
        .room-access-badge.table { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .room-access-badge.timeline { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .room-access-summary { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 6px; font-size: 12px; }
        .room-access-summary .label { color: var(--text-muted); }
        .room-access-summary .value { color: var(--text-secondary); font-family: var(--font-mono); }
        .room-access-preview { margin-top: 4px; border-top: 1px solid var(--border-primary); padding-top: 8px; }
        .room-access-preview h4 { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 6px; }
        .room-access-preview-item { font-size: 11px; color: var(--text-secondary); line-height: 1.4; border-left: 2px solid var(--border-secondary); padding-left: 8px; margin-bottom: 6px; word-break: break-word; }
        .room-access-preview-item:last-child { margin-bottom: 0; }

        /* Changelog styles */
        .changelog-list { padding: 0; }
        .changelog-entry { display: flex; gap: 16px; padding: 14px 20px; border-bottom: 1px solid var(--border-primary); transition: background 0.1s; }
        .changelog-entry:hover { background: var(--bg-hover); }
        .changelog-timeline { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; padding-top: 3px; }
        .changelog-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
        .changelog-dot.INS { background: #4ade80; }
        .changelog-dot.ALT { background: #fbbf24; }
        .changelog-dot.NUL { background: #f87171; }
        .changelog-dot.SYN { background: #60a5fa; }
        .changelog-line { width: 2px; flex: 1; background: var(--border-primary); margin-top: 4px; }
        .changelog-content { flex: 1; min-width: 0; }
        .changelog-header { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 6px; }
        .changelog-op { font-size: 11px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); }
        .changelog-op.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .changelog-op.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .changelog-op.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .changelog-op.SYN { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .changelog-table-badge { font-size: 11px; color: var(--primary-400); background: rgba(59, 130, 246, 0.12); padding: 2px 8px; border-radius: var(--radius-sm); }
        .changelog-record-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); }
        .changelog-time { font-size: 11px; color: var(--text-muted); margin-left: auto; white-space: nowrap; }
        .changelog-fields { display: flex; flex-direction: column; gap: 3px; }
        .changelog-field { font-size: 12px; color: var(--text-secondary); display: flex; align-items: baseline; gap: 6px; }
        .changelog-field-name { font-weight: 500; color: var(--text-primary); flex-shrink: 0; }
        .changelog-field-value { color: var(--text-secondary); word-break: break-word; overflow: hidden; text-overflow: ellipsis; max-width: 400px; }
        .changelog-field-arrow { color: var(--text-muted); flex-shrink: 0; }
        .changelog-actor { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
        .changelog-empty { text-align: center; padding: 60px 20px; color: var(--text-muted); }
        .changelog-empty h3 { font-size: 15px; margin-bottom: 6px; color: var(--text-secondary); }
        .changelog-empty p { font-size: 13px; }

        /* Light theme overrides for changelog */
        html.light-theme .changelog-dot.INS { background: #16a34a; }
        html.light-theme .changelog-dot.ALT { background: #d97706; }
        html.light-theme .changelog-dot.NUL { background: #dc2626; }
        html.light-theme .changelog-dot.SYN { background: #2563eb; }
        html.light-theme .changelog-op.INS { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .changelog-op.ALT { background: rgba(217, 119, 6, 0.10); color: #b45309; }
        html.light-theme .changelog-op.NUL { background: rgba(220, 38, 38, 0.10); color: #dc2626; }
        html.light-theme .changelog-op.SYN { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .changelog-table-badge { color: #2563eb; background: rgba(37, 99, 235, 0.10); }

        /* Point in Time Modal */
        .pit-modal { max-width: 900px; width: 95%; }
        .pit-modal-header { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .pit-modal-header .pit-info { flex: 1; }
        .pit-modal-header .pit-event-badge { font-size: 11px; background: rgba(245, 158, 11, 0.15); color: #fbbf24; padding: 4px 8px; border-radius: var(--radius-sm); font-family: var(--font-mono); }
        .pit-modal-header .pit-timestamp { font-size: 12px; color: var(--text-muted); }

        /* Historical Notice */
        .historical-notice { display: flex; align-items: center; gap: 8px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: var(--radius-md); padding: 10px 14px; margin: 0 24px 12px 24px; font-size: 12px; color: #fbbf24; }
        .historical-notice svg { flex-shrink: 0; }
        .historical-notice-text { line-height: 1.4; }
        .historical-notice-text strong { font-weight: 600; }
        .history-modal .historical-notice { margin: 12px 16px; }

        .pit-record-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); margin: 16px 24px; overflow: hidden; }
        .pit-record-header { background: var(--bg-tertiary); padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .pit-record-header .pit-table-name { font-weight: 600; color: var(--text-primary); }
        .pit-record-header .pit-record-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); }
        .pit-record-header .pit-go-to-table { margin-left: auto; }
        .pit-record-fields { padding: 16px; }
        .pit-field-row { display: flex; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .pit-field-row:last-child { border-bottom: none; }
        .pit-field-name { width: 180px; flex-shrink: 0; font-weight: 500; color: var(--text-primary); font-size: 13px; }
        .pit-field-value { flex: 1; font-size: 13px; color: var(--text-secondary); word-break: break-word; }
        .pit-empty-state { padding: 40px 20px; text-align: center; color: var(--text-muted); }
        .pit-record-actions { padding: 12px 16px; border-top: 1px solid var(--border-primary); display: flex; gap: 8px; justify-content: flex-end; }
        .pit-revert-btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 16px; border: none; border-radius: var(--radius-sm); font-size: 12px; font-weight: 600; cursor: pointer; background: rgba(245, 158, 11, 0.15); color: #fbbf24; transition: background 0.15s; }
        .pit-revert-btn:hover { background: rgba(245, 158, 11, 0.3); }
        .pit-revert-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .pit-revert-confirm { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .pit-revert-confirm:hover { background: rgba(239, 68, 68, 0.3); }

        /* Events View Controls */
        .events-controls { padding: 12px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .events-filter-group { display: flex; align-items: center; gap: 8px; }
        .events-filter-group label { font-size: 12px; color: var(--text-muted); font-weight: 500; }
        .events-filter-group select, .events-filter-group input { padding: 6px 10px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; background: var(--bg-tertiary); color: var(--text-primary); }
        .events-filter-group input { width: 150px; }
        .events-stats { margin-left: auto; font-size: 12px; color: var(--text-muted); }
        .events-actions { display: flex; gap: 8px; margin-left: 12px; }
        .events-actions .btn { padding: 5px 10px; font-size: 11px; }
        .events-actions .btn svg { width: 14px; height: 14px; }
        .import-status { position: fixed; bottom: 20px; right: 20px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 16px 20px; box-shadow: var(--shadow-lg); z-index: 1000; min-width: 280px; }
        .import-status.success { border-color: var(--success-500); }
        .import-status.error { border-color: var(--danger-500); }
        .import-status-title { font-weight: 600; font-size: 14px; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
        .import-status-title.success { color: var(--success-500); }
        .import-status-title.error { color: var(--danger-500); }
        .import-status-details { font-size: 12px; color: var(--text-muted); }
        .import-progress { margin-top: 8px; height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; }
        .import-progress-bar { height: 100%; background: var(--primary-500); transition: width 0.3s; }
        /* ===== Record Profile Panel ===== */
        .record-profile-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .record-profile-overlay.open { opacity: 1; visibility: visible; }
        .record-profile-panel { position: fixed; top: 0; right: 0; bottom: 0; width: 600px; max-width: 90vw; background: var(--bg-secondary); box-shadow: var(--shadow-xl); transform: translateX(100%); transition: transform 0.25s ease-out; display: flex; flex-direction: column; z-index: 1001; border-left: 1px solid var(--border-primary); }
        .record-profile-overlay.open .record-profile-panel { transform: translateX(0); }
        .profile-header { padding: 16px 20px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; background: var(--bg-tertiary); }
        .profile-header h2 { font-size: 16px; font-weight: 600; color: var(--text-primary); margin: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .profile-header .profile-view-name { flex: 1; font-size: 11px; color: var(--text-muted); background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); padding: 3px 8px; border-radius: var(--radius-sm); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .profile-header .profile-view-name:empty { display: none; }
        .profile-header .profile-record-id { font-size: 11px; color: var(--text-muted); font-family: var(--font-mono); }
        .profile-close { width: 32px; height: 32px; border: none; background: var(--bg-secondary); border-radius: var(--radius-md); cursor: pointer; font-size: 18px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .profile-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .profile-tabs { display: flex; border-bottom: 1px solid var(--border-primary); background: var(--bg-secondary); padding: 0 20px; }
        .profile-tab { padding: 12px 16px; font-size: 13px; font-weight: 500; color: var(--text-muted); cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -1px; transition: all var(--transition-fast); }
        .profile-tab:hover { color: var(--text-primary); }
        .profile-tab.active { color: var(--primary-400); border-bottom-color: var(--primary-500); }
        .profile-tab-content { display: none; flex: 1; overflow-y: auto; }
        .profile-tab-content.active { display: flex; flex-direction: column; }

        .profile-sync-history-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; text-align: center; color: var(--text-muted); flex: 1; }
        .profile-sync-history-empty svg { width: 48px; height: 48px; color: var(--text-disabled); margin-bottom: 16px; }
        .profile-sync-history-empty h3 { font-size: 16px; font-weight: 500; color: var(--text-primary); margin: 0 0 8px 0; }
        .profile-sync-history-empty p { font-size: 13px; color: var(--text-muted); margin: 0; }
        .profile-sync-history-list { padding: 16px 20px; }
        .profile-sync-history-item { padding: 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); margin-bottom: 8px; background: var(--bg-primary); }
        .profile-sync-history-item:last-child { margin-bottom: 0; }
        .profile-sync-history-item-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .profile-sync-history-field { font-weight: 500; color: var(--text-primary); font-size: 13px; }
        .profile-sync-history-type { font-size: 11px; padding: 2px 6px; border-radius: 3px; font-weight: 500; }
        .profile-sync-history-type.created { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .profile-sync-history-type.updated { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .profile-sync-history-type.deleted { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .profile-sync-history-type.synced { background: rgba(168, 85, 247, 0.15); color: #c084fc; }
        .profile-sync-history-sender { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: rgba(168, 85, 247, 0.15); color: #c084fc; font-weight: 500; }
        .profile-sync-history-actor { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: rgba(251, 191, 36, 0.15); color: #fbbf24; font-weight: 500; }
        .profile-sync-history-source { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: rgba(100, 116, 139, 0.15); color: #94a3b8; font-weight: 500; text-transform: capitalize; }
        .profile-sync-history-time { margin-left: auto; font-size: 11px; color: var(--text-muted); }
        .profile-sync-history-values { display: flex; gap: 12px; font-size: 12px; }
        .profile-sync-history-value { flex: 1; padding: 6px 8px; border-radius: var(--radius-sm); word-break: break-word; }
        .profile-sync-history-value.old { background: rgba(239, 68, 68, 0.1); color: #fca5a5; }
        .profile-sync-history-value.new { background: rgba(34, 197, 94, 0.1); color: #86efac; }
        .profile-sync-history-value-label { font-size: 10px; font-weight: 500; text-transform: uppercase; margin-bottom: 2px; opacity: 0.7; }

        /* Profile Toolbar */
        .profile-toolbar { padding: 10px 20px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 8px; flex-wrap: wrap; background: var(--bg-secondary); }
        .profile-toolbar-label { font-size: 12px; color: var(--text-muted); }
        .profile-layout-btn { padding: 4px 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .profile-layout-btn:hover { background: var(--bg-hover); }
        .profile-layout-btn.active { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .profile-toolbar-spacer { flex: 1; }
        .profile-add-block-btn { padding: 4px 10px; background: var(--bg-secondary); border: 1px dashed var(--border-secondary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .profile-add-block-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-configure-btn { padding: 4px 10px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; }
        .profile-configure-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }

        /* Profile Body */
        .profile-body { flex: 1; overflow-y: auto; padding: 16px 20px; }
        .profile-block { margin-bottom: 16px; border: 1px solid var(--border-primary); border-radius: var(--radius-lg); background: var(--bg-primary); }
        .profile-block-header { padding: 8px 12px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); border-radius: var(--radius-lg) var(--radius-lg) 0 0; display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text-muted); }
        .profile-block-header .block-drag-handle { cursor: grab; color: var(--text-disabled); }
        .profile-block-header .block-drag-handle:hover { color: var(--text-muted); }
        .profile-block-header .block-title { flex: 1; font-weight: 500; color: var(--text-primary); }
        .profile-block-header .block-cols-select { padding: 2px 6px; border: 1px solid var(--border-primary); border-radius: 3px; font-size: 11px; background: var(--bg-secondary); color: var(--text-secondary); }
        .profile-block-header .block-remove-btn { background: none; border: none; color: var(--text-disabled); cursor: pointer; padding: 2px; }
        .profile-block-header .block-remove-btn:hover { color: var(--danger-500); }
        .profile-block-content { padding: 12px; }
        .profile-field-grid { display: grid; gap: 12px; }
        .profile-field-grid.cols-1 { grid-template-columns: 1fr; }
        .profile-field-grid.cols-2 { grid-template-columns: 1fr 1fr; }
        .profile-field-grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }

        .profile-field-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 10px 12px; transition: all var(--transition-fast); }
        .profile-field-card:hover { border-color: var(--border-secondary); }
        .profile-field-card.dragging { opacity: 0.5; border-color: var(--primary-500); }
        .profile-field-card.drag-over { border-color: var(--primary-500); background: rgba(59, 130, 246, 0.1); }
        .profile-field-name { font-size: 11px; font-weight: 500; color: var(--text-muted); margin-bottom: 4px; display: flex; align-items: center; gap: 6px; }
        .profile-field-name .field-drag-handle { cursor: grab; color: var(--text-disabled); font-size: 10px; }
        .profile-field-name .field-drag-handle:hover { color: var(--text-muted); }
        .profile-field-value { font-size: 13px; color: var(--text-primary); word-break: break-word; cursor: pointer; padding: 2px 4px; margin: -2px -4px; border-radius: var(--radius-sm); transition: background var(--transition-fast); }
        .profile-field-value:hover:not(.editing) { background: var(--bg-hover); }
        .configure-mode .profile-field-value { cursor: default; }
        .configure-mode .profile-field-value:hover { background: none; }
        .profile-field-value.empty { color: var(--text-disabled); font-style: italic; }
        .profile-field-value.editing { padding: 0; margin: 0; background: none; }
        .profile-edit-input { width: 100%; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-secondary); border-radius: var(--radius-sm); padding: 4px 8px; font-size: 13px; font-family: inherit; outline: none; box-sizing: border-box; resize: vertical; }
        .profile-edit-input:focus { border-color: var(--primary-500, #3b82f6); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        .profile-edit-checkbox { width: 16px; height: 16px; cursor: pointer; }

        /* Profile Navigation */
        .profile-nav { padding: 12px 20px; border-top: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; background: var(--bg-tertiary); }
        .profile-nav-btn { padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; transition: all var(--transition-fast); }
        .profile-nav-btn:hover:not(:disabled) { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .profile-nav-info { flex: 1; text-align: center; font-size: 12px; color: var(--text-muted); }
        .profile-nav-history { padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; }
        .profile-nav-history:hover { border-color: var(--primary-500); color: var(--primary-400); }

        /* Profile Configure Mode */
        .profile-body.configure-mode .profile-field-card { cursor: move; border-style: dashed; }
        .profile-body.configure-mode .profile-field-card .field-drag-handle { display: inline; }
        .profile-body:not(.configure-mode) .profile-field-card .field-drag-handle { display: none; }
        .profile-body.configure-mode .profile-block-header .block-drag-handle { display: inline; }
        .profile-body:not(.configure-mode) .profile-block-header .block-drag-handle { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header .block-cols-select { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header .block-remove-btn { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header { display: none; }
        .profile-body:not(.configure-mode) .profile-block { border: none; background: transparent; }
        .profile-body:not(.configure-mode) .profile-block-content { padding: 0; }
        .profile-body:not(.configure-mode) .profile-block { margin-bottom: 0; }

        /* Add Field to Block */
        .profile-add-field-btn { width: 100%; padding: 8px; background: var(--bg-secondary); border: 1px dashed var(--border-secondary); border-radius: var(--radius-md); cursor: pointer; font-size: 12px; color: var(--text-muted); margin-top: 8px; }
        .profile-add-field-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-body:not(.configure-mode) .profile-add-field-btn { display: none; }
        .profile-field-picker { position: fixed; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 1100; width: 240px; max-height: 300px; overflow-y: auto; }
        .profile-field-picker-header { padding: 10px 12px; border-bottom: 1px solid var(--border-primary); font-size: 12px; font-weight: 600; color: var(--text-primary); }
        .profile-field-picker-item { padding: 8px 12px; cursor: pointer; font-size: 13px; color: var(--text-secondary); display: flex; align-items: center; gap: 8px; }
        .profile-field-picker-item:hover { background: var(--bg-hover); }
        .profile-field-picker-item .field-type-badge { font-size: 10px; color: var(--text-muted); background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; }

        /* ===== Matrix Setup Wizard ===== */
        #matrix-wizard {
            position: fixed; inset: 0; background: var(--bg-primary);
            display: flex; align-items: center; justify-content: center;
            z-index: 150;
        }
        #matrix-wizard.hidden { display: none; }
        .wizard-container {
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl); padding: 0; width: 540px; max-width: 95vw;
            max-height: 90vh; overflow-y: auto; box-shadow: var(--shadow-xl);
        }
        .wizard-header {
            padding: 28px 32px 0; text-align: center;
        }
        .wizard-header h2 { font-size: 22px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; }
        .wizard-header p { font-size: 13px; color: var(--text-muted); margin-bottom: 0; }
        .wizard-steps {
            display: flex; justify-content: center; gap: 8px;
            padding: 20px 32px 0; margin-bottom: 0;
        }
        .wizard-step-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--border-secondary); transition: all 0.2s;
        }
        .wizard-step-dot.active { background: var(--primary-500); transform: scale(1.2); }
        .wizard-step-dot.completed { background: var(--success-500); }
        .wizard-body { padding: 24px 32px; }
        .wizard-body .form-group { margin-bottom: 18px; }
        .wizard-body .form-group label {
            display: block; font-size: 13px; font-weight: 500;
            color: var(--text-secondary); margin-bottom: 6px;
        }
        .wizard-body .form-group label .label-hint {
            font-weight: 400; color: var(--text-muted); font-size: 12px;
        }
        .wizard-body input[type="text"],
        .wizard-body input[type="password"],
        .wizard-body select {
            width: 100%; padding: 10px 12px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            color: var(--text-primary); font-size: 14px; box-sizing: border-box;
        }
        .wizard-body input:focus, .wizard-body select:focus {
            outline: none; border-color: var(--primary-500);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        .wizard-body .checkbox-group {
            display: flex; flex-direction: column; gap: 8px;
            max-height: 200px; overflow-y: auto;
            padding: 8px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
        }
        .wizard-body .checkbox-item {
            display: flex; align-items: center; gap: 10px;
            padding: 6px 8px; border-radius: var(--radius-sm);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
        }
        .wizard-body .checkbox-item:hover { background: var(--bg-hover); }
        .wizard-body .checkbox-item input[type="checkbox"] {
            width: 16px; height: 16px; accent-color: var(--primary-500);
        }
        .wizard-body .linked-record-row {
            display: flex; align-items: center; gap: 8px;
            padding: 8px 0; border-bottom: 1px solid var(--border-primary);
        }
        .wizard-body .linked-record-row:last-child { border-bottom: none; }
        .wizard-body .linked-record-row .table-name {
            min-width: 120px; font-size: 13px; font-weight: 500; color: var(--text-primary);
        }
        .wizard-body .linked-record-row select { flex: 1; }
        .wizard-footer {
            padding: 16px 32px 28px; display: flex; justify-content: space-between; gap: 12px;
        }
        .wizard-footer button {
            padding: 10px 24px; border-radius: var(--radius-md); font-size: 14px;
            font-weight: 500; cursor: pointer; transition: all var(--transition-fast);
        }
        .wizard-footer .btn-back {
            background: var(--bg-tertiary); border: 1px solid var(--border-primary);
            color: var(--text-muted);
        }
        .wizard-footer .btn-back:hover { background: var(--bg-hover); color: var(--text-primary); }
        .wizard-footer .btn-next {
            background: var(--primary-500); border: 1px solid var(--primary-500);
            color: #fff; margin-left: auto;
        }
        .wizard-footer .btn-next:hover { background: var(--primary-600); }
        .wizard-footer .btn-next:disabled { background: var(--gray-600); border-color: var(--gray-600); cursor: not-allowed; }
        .wizard-error {
            color: #f87171; font-size: 13px; padding: 10px 12px;
            background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: var(--radius-md); margin-bottom: 16px; display: none;
        }
        .wizard-success {
            color: #4ade80; font-size: 13px; padding: 10px 12px;
            background: rgba(34, 197, 94, 0.15); border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: var(--radius-md); margin-bottom: 16px;
        }
        .wizard-progress-section { margin-top: 16px; }
        .wizard-progress-bar {
            height: 6px; background: var(--bg-tertiary); border-radius: 3px;
            overflow: hidden; margin-bottom: 10px;
        }
        .wizard-progress-fill {
            height: 100%; background: linear-gradient(90deg, var(--primary-500), #7c3aed);
            transition: width 0.3s ease; border-radius: 3px;
        }
        .wizard-progress-status { font-size: 13px; color: var(--text-secondary); }
        .wizard-progress-detail { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
        .wizard-info-box {
            background: var(--bg-tertiary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-md); padding: 12px 16px; font-size: 12px;
            color: var(--text-secondary); line-height: 1.5; margin-bottom: 16px;
        }
        .wizard-info-box strong { color: var(--text-primary); }
        #room-manager {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5);
            display: flex; align-items: center; justify-content: center;
            z-index: 160;
        }
        #room-manager.hidden { display: none; }
        #room-manager .rm-client-row {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 10px; border-radius: var(--radius-sm);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
        }
        #room-manager .rm-client-row:hover { background: var(--bg-hover); }
        #room-manager .rm-client-row .rm-room-info {
            font-size: 11px; color: var(--text-muted); margin-left: auto;
        }

        /* ===== Toast Notifications ===== */
        #toast-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 10000;
            display: flex;
            flex-direction: column-reverse;
            gap: 8px;
            pointer-events: none;
        }
        .toast {
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            border-radius: var(--radius-sm);
            font-size: 13px;
            font-family: var(--font-family);
            color: #fff;
            background: var(--gray-700);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transform: translateY(12px);
            animation: toast-in 0.25s ease forwards;
            max-width: 340px;
        }
        .toast.removing {
            animation: toast-out 0.2s ease forwards;
        }
        .toast.toast-saving {
            background: var(--gray-600);
        }
        .toast.toast-success {
            background: #166534;
        }
        .toast.toast-error {
            background: #991b1b;
        }
        .toast.toast-info {
            background: var(--gray-600);
        }
        .toast.toast-warning {
            background: #92400e;
        }
        .toast .toast-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: toast-spin 0.6s linear infinite;
        }
        .toast .toast-dismiss {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            padding: 0 0 0 8px;
            margin-left: auto;
        }
        .toast .toast-dismiss:hover {
            color: #fff;
        }
        .toast.toast-undo {
            background: var(--gray-700);
        }
        .toast .toast-undo-btn {
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.25);
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            font-family: inherit;
            line-height: 1;
            padding: 4px 10px;
            border-radius: 4px;
            margin-left: 4px;
            white-space: nowrap;
        }
        .toast .toast-undo-btn:hover {
            background: rgba(255,255,255,0.25);
        }
        @keyframes toast-in {
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes toast-out {
            to { opacity: 0; transform: translateY(12px); }
        }
        @keyframes toast-spin {
            to { transform: rotate(360deg); }
        }

        /* ===== Mobile Sidebar Toggle ===== */
        .mobile-sidebar-toggle {
            display: none;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border: none;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            cursor: pointer;
            flex-shrink: 0;
            transition: background var(--transition-fast);
        }
        .mobile-sidebar-toggle:hover { background: var(--bg-hover); color: var(--text-primary); }

        /* Sidebar Overlay Backdrop (mobile) */
        .sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 49;
            opacity: 0;
            transition: opacity 0.25s ease;
        }
        .sidebar-overlay.visible {
            display: block;
            opacity: 1;
        }

        /* ===== Responsive: Tablet (max-width: 768px) ===== */
        @media (max-width: 768px) {
            /* Show mobile sidebar toggle */
            .mobile-sidebar-toggle { display: flex; }

            /* Sidebar: slide-out drawer on mobile */
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                z-index: 50;
                transform: translateX(-100%);
                transition: transform 0.25s ease;
                width: 288px;
                max-width: 85vw;
            }
            .sidebar.mobile-open {
                transform: translateX(0);
            }

            /* Database app fills full width */
            #database-app { flex-direction: column; }

            /* Main takes full width */
            .main { width: 100%; }

            /* Tab bar: more compact */
            .browser-tab { min-width: 80px; max-width: 160px; padding: 0 8px; font-size: 12px; }
            .tab-title { font-size: 12px; }
            .tab-count { font-size: 10px; }

            /* Toolbar: wrap on mobile */
            .toolbar {
                padding: 8px 12px;
                gap: 8px;
                flex-wrap: wrap;
            }
            .toolbar h1 { font-size: 15px; flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            .toolbar-views { flex-wrap: wrap; gap: 6px; }

            /* View controls bar: scrollable */
            .view-controls-bar {
                padding: 6px 12px;
                gap: 2px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }
            .view-controls-bar::-webkit-scrollbar { display: none; }
            .view-control-btn { font-size: 12px; padding: 6px 8px; white-space: nowrap; }
            .view-search-input { width: 140px; }
            .view-search-input:focus { width: 160px; }

            /* View control dropdowns: full-width on mobile */
            .view-control-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                margin-top: 0;
                border-radius: var(--radius-xl) var(--radius-xl) 0 0;
                max-height: 70vh;
                overflow-y: auto;
                min-width: unset;
                z-index: 200;
            }

            /* Fields dropdown: full-width */
            .fields-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                border-radius: var(--radius-xl) var(--radius-xl) 0 0;
                max-height: 70vh;
                z-index: 200;
            }

            /* View selector dropdown */
            .view-selector-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                min-width: unset;
                border-radius: var(--radius-xl) var(--radius-xl) 0 0;
                max-height: 60vh;
                z-index: 200;
            }

            /* Status bar: compact */
            .status-bar { padding: 6px 12px; font-size: 11px; gap: 8px; flex-wrap: wrap; }

            /* Pagination: compact */
            .pagination { padding: 8px 12px; gap: 8px; font-size: 12px; flex-wrap: wrap; }

            /* Sync feed panel: full width at bottom */
            .sync-feed-panel {
                width: calc(100% - 16px);
                left: 8px;
                right: 8px;
                bottom: 8px;
                max-height: 60vh;
            }

            /* Record profile panel: full screen */
            .record-profile-panel {
                width: 100vw;
                max-width: 100vw;
            }
            .profile-header { padding: 12px 16px; }
            .profile-body { padding: 12px 16px; }
            .profile-field-grid.cols-2,
            .profile-field-grid.cols-3 { grid-template-columns: 1fr; }
            .profile-nav { padding: 10px 16px; }

            /* Home page */
            .home-topbar { padding: 0 16px; height: 48px; }
            .home-content { padding: 32px 16px 60px; }
            .home-greeting h1 { font-size: 24px; }
            .home-greeting { margin-bottom: 28px; }
            .home-cards { grid-template-columns: 1fr; gap: 12px; }
            .home-card { min-height: auto; padding: 20px 18px; }
            .home-stats { flex-direction: column; }
            .home-stat { text-align: left; padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; }
            .home-stat-value { font-size: 22px; }
            .home-stat-label { font-size: 10px; }

            /* Settings page */
            #settings-app { padding: 20px 16px; }
            .settings-header h1 { font-size: 20px; }
            .settings-tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
            .settings-tabs::-webkit-scrollbar { display: none; }
            .settings-tab { white-space: nowrap; padding: 10px 14px; }
            .settings-section { padding: 16px; }
            .settings-table { font-size: 12px; }
            .settings-table th, .settings-table td { padding: 8px; }

            /* Auth/Login screens */
            .auth-box, .synapse-login-box { width: 90vw; max-width: 360px; padding: 24px 20px; }
            #unlock-screen .unlock-box { width: 90vw; max-width: 400px; padding: 24px 20px; }

            /* Wizard container */
            .wizard-container { width: 95vw; max-width: 95vw; padding: 0; }
            .wizard-header { padding: 20px 20px 0; }
            .wizard-header h2 { font-size: 18px; }
            .wizard-body { padding: 16px 20px; }
            .wizard-footer { padding: 16px 20px; flex-wrap: wrap; }

            /* Room manager wizard override */
            #room-manager .wizard-container { width: 95vw; max-width: 95vw; }

            /* Modals */
            .modal { width: 95vw; max-width: 95vw; }
            .pit-modal { width: 98vw; }
            .modal-header { padding: 16px; }
            .modal-toolbar { padding: 10px 16px; flex-wrap: wrap; }
            .history-values { flex-direction: column; }
            .history-value-box { min-width: unset; }

            /* Create view modal */
            .create-view-modal-content { width: 95vw; }

            /* Room publish modal */
            .room-publish-box { width: 95vw; max-width: 480px; padding: 20px; }

            /* Schema view */
            .schema-view-container { padding: 12px; gap: 12px; }
            .schema-card { width: 100%; }

            /* Events controls */
            .events-controls { padding: 8px 12px; gap: 8px; }
            .events-filter-group { flex-wrap: wrap; }
            .events-stats { margin-left: 0; }
            .events-actions { margin-left: 0; }

            /* Matrix rooms */
            .matrix-rooms-view { padding: 16px; }
            .matrix-rooms-grid { grid-template-columns: 1fr; }
            .matrix-rooms-filter { flex-direction: column; gap: 8px; }
            .matrix-rooms-filter input { max-width: 100%; }

            /* Sync status */
            .sync-status-view { padding: 16px; }
            .sync-status-cards { grid-template-columns: 1fr 1fr; }
            .sync-poll-controls { flex-wrap: wrap; }
            .snapshot-export-controls { flex-direction: column; }

            /* Room access */
            .room-access-grid { grid-template-columns: 1fr; }

            /* Context menus */
            .view-context-menu { min-width: 140px; }

            /* Connect API modal (has inline styles, need override) */
            #connect-api-modal > div { width: 90vw !important; max-width: 360px; }

            /* View selection screen (has inline styles) */
            #view-selection-screen > div { width: 90vw !important; max-width: 400px; padding: 24px 20px !important; }

            /* Loading overlay */
            .loading-content { padding: 24px 16px; }
            .loading-title { font-size: 20px; }
            .loading-facts { gap: 16px; }
            .loading-fact-value { font-size: 22px; }

            /* Table container: smooth horizontal scroll on mobile */
            .table-container {
                -webkit-overflow-scrolling: touch;
            }

            /* Table cells: increase touch targets */
            td { padding: 10px 12px; }
            th { padding: 10px 12px; }

            /* App nav bar: always show on mobile as bottom navigation */
            .app-nav {
                display: flex !important;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 40;
                height: 56px;
                padding: 0 8px;
                border-bottom: none;
                border-top: 1px solid var(--border-primary);
                justify-content: center;
                background: var(--bg-secondary);
            }
            .app-nav-btn {
                padding: 8px 12px;
                font-size: 11px;
                flex-direction: column;
                gap: 2px;
                flex: 1;
                justify-content: center;
            }
            .app-nav-btn svg { width: 20px; height: 20px; }
            .app-nav-spacer { display: none; }
            .app-nav-user { display: none; }

            /* Body padding for bottom nav */
            .app-content-wrapper { padding-bottom: 56px; }
            #home-app { padding-bottom: 56px; }
        }

        /* ===== Responsive: Small Mobile (max-width: 480px) ===== */
        @media (max-width: 480px) {
            /* Even more compact toolbar */
            .toolbar {
                padding: 6px 10px;
                gap: 6px;
            }
            .toolbar h1 { font-size: 14px; }
            .btn { padding: 5px 8px; font-size: 11px; }

            /* Hide non-essential toolbar items */
            .view-save-indicator { display: none !important; }
            #manual-save-btn { display: none !important; }

            /* View selector: compact */
            .view-selector-btn { min-width: 100px; padding: 5px 8px; font-size: 12px; }
            .fields-btn { padding: 5px 8px; font-size: 12px; }

            /* Tab bar: ultra-compact */
            .browser-tab { min-width: 60px; max-width: 120px; gap: 4px; font-size: 11px; }
            .tab-bar-new-tab { width: 24px; height: 24px; font-size: 16px; }

            /* Home page */
            .home-greeting h1 { font-size: 20px; }
            .home-card-title { font-size: 16px; }
            .home-card-desc { font-size: 12px; }
            .home-activity-item { padding: 10px 14px; font-size: 12px; }

            /* Settings */
            #settings-app { padding: 16px 12px; }
            .settings-header h1 { font-size: 18px; }

            /* Sync status cards: single column */
            .sync-status-cards { grid-template-columns: 1fr; }

            /* Profile panel adjustments */
            .profile-tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; }
            .profile-tab { white-space: nowrap; padding: 10px 12px; font-size: 12px; }
            .profile-header h2 { font-size: 14px; }

            /* Changelog */
            .changelog-entry { padding: 10px 14px; gap: 10px; }
            .changelog-header { gap: 4px; }
            .changelog-field-value { max-width: 200px; }

            /* Events table */
            .events-table { font-size: 11px; }
            .events-table th, .events-table td { padding: 6px 8px; }

            /* Filter rows */
            .filter-row { flex-wrap: wrap; }
            .sort-row { flex-wrap: wrap; }

            /* Loading overlay */
            .loading-title { font-size: 18px; }
            .loading-subtitle { font-size: 13px; }
            .loading-fact-value { font-size: 20px; }
            .loading-note { font-size: 11px; padding: 10px 12px; }
        }

        /* ===== Touch-friendly Enhancements ===== */
        @media (hover: none) and (pointer: coarse) {
            /* Increase tap targets for touch devices */
            .view-control-btn { min-height: 40px; padding: 8px 12px; }
            .btn { min-height: 36px; }
            .sidebar div.table-item { padding: 12px; min-height: 44px; }
            .table-view-item { padding: 10px 12px 10px 40px; min-height: 40px; }
            .settings-tab { min-height: 44px; }
            .app-nav-btn { min-height: 40px; }
            .browser-tab { min-height: 36px; }
            .profile-tab { min-height: 44px; }
            .events-tab { min-height: 44px; }

            /* Always show close button on tabs (no hover on touch) */
            .tab-close { opacity: 0.5; }
            .browser-tab.active .tab-close { opacity: 0.8; }

            /* Always show pin button on touch */
            .pin-btn { opacity: 0.5; }
            .pin-btn.pinned { opacity: 1; }

            /* Disable hover card transform on touch */
            .home-card:hover { transform: none; }
        }
    </style>
</head>
<body>
    <!-- Toast Notification Container -->
    <div id="toast-container"></div>

    <!-- Encryption Unlock Screen -->
    <div id="unlock-screen" class="hidden">
        <!-- Setup Mode (first time) -->
        <div id="unlock-setup" class="unlock-box">
            <h2><span class="lock-icon">&#128274;</span> Secure Your Data</h2>
            <p class="subtitle">Set up encryption to protect your locally cached data</p>
            <div id="unlock-setup-error" class="unlock-error"></div>

            <div class="security-note">
                <strong>Why encrypt?</strong> Your API key and cached data will be encrypted before being stored in your browser. If someone gains access to your browser's storage, they won't be able to read your data without your password or passkey.
            </div>

            <div class="setup-section">
                <label for="setup-password">Create a password</label>
                <input type="password" id="setup-password" placeholder="Enter a strong password" autocomplete="new-password" oninput="updatePasswordStrength()">
                <div class="password-strength"><div class="password-strength-fill" id="password-strength-fill"></div></div>
            </div>

            <div class="setup-section">
                <label for="setup-password-confirm">Confirm password</label>
                <input type="password" id="setup-password-confirm" placeholder="Confirm your password" autocomplete="new-password">
            </div>

            <button id="setup-password-btn" onclick="setupEncryptionWithPassword()">Set Up with Password</button>

            <div class="unlock-divider">or</div>

            <button id="setup-passkey-btn" class="passkey-btn" onclick="setupEncryptionWithPasskey()">
                <span class="passkey-icon">&#128273;</span> Set Up with Passkey
            </button>

            <button id="skip-encryption-btn" class="secondary" onclick="skipEncryption()">Skip (Not Recommended)</button>

            <div class="unlock-info">
                Passkeys use your device's biometrics (Face ID, Touch ID, Windows Hello) for secure, passwordless authentication.
            </div>
        </div>

        <!-- Unlock Mode (returning user) -->
        <div id="unlock-prompt" class="unlock-box hidden">
            <h2><span class="lock-icon">&#128274;</span> Unlock Your Data</h2>
            <p class="subtitle">Enter your password or use your passkey to access your encrypted data</p>
            <div id="unlock-prompt-error" class="unlock-error"></div>

            <div id="passkey-unlock-section">
                <button id="passkey-unlock-btn" class="passkey-btn" onclick="unlockWithPasskey()">
                    <span class="passkey-icon">&#128273;</span> Unlock with Passkey
                </button>
                <div class="unlock-divider">or enter your password</div>
            </div>

            <input type="password" id="unlock-password" placeholder="Enter your password" autocomplete="current-password">
            <button id="unlock-password-btn" onclick="unlockWithPassword()">Unlock</button>

            <button id="clear-encrypted-data-btn" class="secondary" onclick="clearEncryptedData()">Clear All Data & Start Fresh</button>

            <div class="unlock-info">
                Forgot your password? You'll need to clear all local data and start fresh. Your data on the server is not affected.
            </div>
        </div>
    </div>

    <div id="synapse-login-screen">
        <div class="synapse-login-box">
            <!-- Login Form -->
            <div id="synapse-login-form">
                <h2>Amino Viewer</h2>
                <p>Sign in to your account at app.aminoimmigration.com</p>
                <div id="synapse-login-error" class="synapse-error"></div>
                <label for="synapse-username">Username</label>
                <input type="text" id="synapse-username" placeholder="Username" autocomplete="username">
                <label for="synapse-password">Password</label>
                <input type="password" id="synapse-password" placeholder="Password" autocomplete="current-password">
                <button id="synapse-login-btn">Sign In</button>
                <a class="synapse-forgot-link" onclick="showPasswordReset()">Forgot Password?</a>
            </div>
            <!-- Password Reset Form -->
            <div id="synapse-reset-form">
                <h2>Reset Password</h2>
                <div id="synapse-reset-error" class="synapse-error"></div>
                <div id="synapse-reset-success" class="synapse-success"></div>
                <!-- Step 1: Enter email -->
                <div id="synapse-reset-step1" class="synapse-reset-step active">
                    <p class="synapse-info">Enter the email address associated with your account. We'll send a verification link to confirm your identity.</p>
                    <label for="synapse-reset-email">Email Address</label>
                    <input type="email" id="synapse-reset-email" placeholder="you@example.com" autocomplete="email">
                    <button id="synapse-reset-send-btn" onclick="requestPasswordReset()">Send Reset Email</button>
                </div>
                <!-- Step 2: Enter new password after email verification -->
                <div id="synapse-reset-step2" class="synapse-reset-step">
                    <p class="synapse-info">A verification email has been sent. Click the link in the email, then enter your new password below and click "Reset Password".</p>
                    <label for="synapse-reset-new-password">New Password</label>
                    <input type="password" id="synapse-reset-new-password" placeholder="New password" autocomplete="new-password">
                    <label for="synapse-reset-confirm-password">Confirm Password</label>
                    <input type="password" id="synapse-reset-confirm-password" placeholder="Confirm new password" autocomplete="new-password">
                    <button id="synapse-reset-confirm-btn" onclick="confirmPasswordReset()">Reset Password</button>
                </div>
                <!-- Step 3: Success -->
                <div id="synapse-reset-step3" class="synapse-reset-step">
                    <div class="synapse-success" style="display: block;">Your password has been reset successfully. You can now sign in with your new password.</div>
                </div>
                <a class="synapse-back-link" onclick="hidePasswordReset()">Back to Sign In</a>
            </div>
        </div>
    </div>

    <div id="view-selection-screen" class="hidden" style="position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 104;">
        <div style="background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 400px; box-shadow: var(--shadow-xl);">
            <h2 style="font-size: 20px; margin-bottom: 8px; color: var(--text-primary);">Amino Viewer</h2>
            <p style="font-size: 13px; color: var(--text-muted); margin-bottom: 24px;">Choose how to view your data</p>
            <button id="view-as-database-btn" style="width: 100%; padding: 14px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; font-weight: 500; margin-bottom: 10px; transition: background var(--transition-fast);">View as Database</button>
            <button id="view-as-interface-btn" style="width: 100%; padding: 14px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-muted); font-size: 14px; cursor: pointer; font-weight: 500; transition: background var(--transition-fast);" disabled>View as Interface <span style="font-size: 11px; opacity: 0.6;">(coming soon)</span></button>
        </div>
    </div>
        </div>
    </div>

    <div id="auth-screen" class="hidden">
        <div class="auth-box">
            <h2>Amino Viewer</h2>
            <p>Connect to your Amino event stream</p>
            <div id="auth-error" class="auth-error"></div>
            <input type="password" id="api-key-input" placeholder="API Key" autocomplete="off">
            <input type="text" id="set-filter-input" placeholder="Filter by set (optional)" autocomplete="off">
            <button id="auth-submit">Connect</button>
            <button id="auth-clear" class="secondary hidden">Clear Local Data</button>
            <div class="auth-divider" style="display: flex; align-items: center; gap: 12px; margin: 16px 0 12px;">
                <div style="flex: 1; height: 1px; background: var(--border-primary);"></div>
                <span style="font-size: 12px; color: var(--text-muted);">or</span>
                <div style="flex: 1; height: 1px; background: var(--border-primary);"></div>
            </div>
            <button id="auth-skip-upload" class="secondary" onclick="skipAuthAndUploadCSV()">Skip - Upload CSV Only</button>
            <button id="auth-skip-upload-amo" class="secondary" onclick="skipAuthAndUploadAmo()" style="margin-top: 8px;">Skip - Upload .amo Snapshot</button>
            <div id="auth-info" class="auth-info"></div>
        </div>
    </div>

    <!-- Initial Data Loading Overlay -->
    <div id="loading-overlay" class="hidden">
        <div class="loading-particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
        </div>
        <div class="loading-content">
            <div class="loading-logo">
                <div class="loading-logo-inner">A</div>
            </div>
            <h1 class="loading-title">Setting Up Your Workspace</h1>
            <p class="loading-subtitle">We're downloading your data to this device for lightning-fast access.</p>

            <div class="loading-facts">
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-tables">0</div>
                    <div class="loading-fact-label">Tables</div>
                </div>
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-fields">0</div>
                    <div class="loading-fact-label">Fields</div>
                </div>
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-records">0</div>
                    <div class="loading-fact-label">Records</div>
                </div>
            </div>

            <div class="loading-progress-container">
                <div class="loading-progress-bar">
                    <div class="loading-progress-fill" id="loading-progress-fill" style="width: 0%"></div>
                    <div class="loading-progress-activity"></div>
                </div>
                <div class="loading-status" id="loading-status">Connecting to server...</div>
                <div class="loading-detail" id="loading-detail">Page 1</div>
                <div class="loading-table-progress" id="loading-table-progress"></div>
                <div class="loading-speed" id="loading-speed"></div>
            </div>

            <div class="loading-note">
                <strong>One-time setup:</strong> This only happens once per device. After this, your data loads instantly from local storage.
            </div>

            <!-- CSV/AMO manual import removed - hydration is automatic from cloud snapshot -->
        </div>
    </div>

    <!-- Connect API Key Modal -->
    <div id="connect-api-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; align-items: center; justify-content: center;">
        <div style="background: #fff; border-radius: 8px; padding: 24px; width: 360px; box-shadow: 0 4px 24px rgba(0,0,0,0.3);">
            <h3 style="font-size: 16px; margin-bottom: 6px; color: #333;">Connect API Key</h3>
            <p style="font-size: 13px; color: #666; margin-bottom: 16px;">Add your API key to enable syncing with the server.</p>
            <div id="connect-api-error" style="color: #dc3545; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: #f8d7da; border-radius: 4px; display: none;"></div>
            <input type="password" id="connect-api-key-input" placeholder="API Key" autocomplete="off" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <input type="text" id="connect-api-set-filter" placeholder="Filter by set (optional)" autocomplete="off" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <button id="connect-api-submit" onclick="submitConnectApi()" style="width: 100%; padding: 10px; background: #2d6cdf; border: none; border-radius: 6px; color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500;">Connect</button>
            <button onclick="hideConnectApiModal()" style="width: 100%; padding: 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 6px; color: #333; font-size: 14px; cursor: pointer; font-weight: 500;">Cancel</button>
        </div>
    </div>

    <!-- Matrix Setup Wizard -->
    <div id="matrix-wizard" class="hidden">
        <div class="wizard-container">
            <div class="wizard-header">
                <h2 id="wizard-title">Connect to Matrix</h2>
                <p id="wizard-subtitle">Set up your organization's secure data infrastructure</p>
            </div>
            <div class="wizard-steps" id="wizard-steps">
                <div class="wizard-step-dot active"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
            </div>
            <div class="wizard-body" id="wizard-body">
                <!-- Wizard content rendered dynamically per step -->
            </div>
            <div class="wizard-footer" id="wizard-footer">
                <button class="btn-back" id="wizard-back" onclick="wizardBack()">Back</button>
                <button class="btn-next" id="wizard-next" onclick="wizardNext()">Next</button>
            </div>
        </div>
    </div>

    <!-- Room Manager Panel (Admin) -->
    <div id="room-manager" class="hidden">
        <div class="wizard-container" style="width: 620px;">
            <div class="wizard-header">
                <h2 id="rm-title">Manage Rooms</h2>
                <p id="rm-subtitle">Select client rooms to delete</p>
            </div>
            <div class="wizard-body" id="rm-body">
                <div class="wizard-error" id="rm-error"></div>
                <div id="rm-list-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <label class="checkbox-item" style="padding: 0; margin: 0;">
                            <input type="checkbox" id="rm-select-all" onchange="rmToggleSelectAll(this.checked)">
                            <span style="font-weight: 500;">Select all</span>
                        </label>
                        <span id="rm-selected-count" style="font-size: 12px; color: var(--text-muted);">0 selected</span>
                    </div>
                    <div class="checkbox-group" id="rm-client-list" style="max-height: 320px;"></div>
                </div>
                <div id="rm-progress-section" style="display: none;">
                    <div class="wizard-progress-section">
                        <div class="wizard-progress-bar">
                            <div class="wizard-progress-fill" id="rm-progress" style="width: 0%"></div>
                        </div>
                        <div class="wizard-progress-status" id="rm-status">Preparing...</div>
                        <div class="wizard-progress-detail" id="rm-detail"></div>
                    </div>
                </div>
                <div id="rm-result-section" style="display: none;"></div>
            </div>
            <div class="wizard-footer" id="rm-footer">
                <button class="btn-back" onclick="hideRoomManager()">Cancel</button>
                <button class="btn-next" id="rm-delete-btn" onclick="rmConfirmDelete()" style="background: var(--error-500, #ef4444); border-color: var(--error-500, #ef4444);" disabled>Delete Selected</button>
            </div>
        </div>
    </div>

    <!-- File Header Bar (shown after login) -->
    <div class="file-header" id="file-header">
        <div class="file-header-left">
            <span class="file-header-role" id="file-header-role">admin</span>
        </div>
        <div class="file-header-right">
            <button class="file-header-theme-btn" onclick="toggleTheme()" title="Toggle light/dark theme">
                <span id="file-header-theme-icon">&#9788;</span>
                <span id="file-header-theme-label">Light Mode</span>
            </button>
        </div>
    </div>

    <!-- App Navigation Bar (shown after login) -->
    <nav class="app-nav" id="app-nav">
        <button class="app-nav-btn active" id="app-nav-home" onclick="switchApp('home')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/>
            </svg>
            Home
        </button>
        <button class="app-nav-btn" id="app-nav-database" onclick="switchApp('database')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/><path d="M3 12c0 1.66 4 3 9 3s9-1.34 9-3"/>
            </svg>
            Database
        </button>
        <button class="app-nav-btn" id="app-nav-interface" onclick="switchApp('interface')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/>
            </svg>
            Interface
        </button>
        <button class="app-nav-btn" id="app-nav-settings" onclick="switchApp('settings')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
            </svg>
            Settings
        </button>
        <div class="app-nav-spacer"></div>
        <div class="app-nav-user">
            <span id="app-nav-username"></span>
            <span class="app-nav-user-role" id="app-nav-role"></span>
            <button class="app-nav-logout" onclick="appNavLogout()">Sign Out</button>
        </div>
    </nav>

    <!-- App Content Wrapper -->
    <div class="app-content-wrapper" id="app-content-wrapper">

    <!-- Home Sub-App -->
    <div id="home-app">
        <div class="home-topbar">
            <div class="home-topbar-left">
                <div class="home-logo-mark">A</div>
                <div class="home-logo-text">Amino</div>
            </div>
            <div class="home-topbar-right">
                <div class="home-status-badge" id="home-sync-badge">
                    <div class="home-status-dot"></div>
                    Synced
                </div>
                <div class="home-avatar" id="home-avatar" onclick="switchApp('settings')"></div>
            </div>
        </div>

        <div class="home-content">
            <div class="home-greeting">
                <h1>Welcome back, <span id="home-display-name">User</span></h1>
                <p id="home-subtitle">Loading...</p>
            </div>

            <div class="home-cards">
                <!-- Database -->
                <a href="javascript:void(0)" class="home-card" onclick="switchApp('database')">
                    <div class="home-card-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <ellipse cx="12" cy="5" rx="9" ry="3"/>
                            <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/>
                            <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/>
                        </svg>
                    </div>
                    <div class="home-card-title">Database</div>
                    <div class="home-card-desc">Browse tables, run queries, and explore your Airtable data through the synchronized Matrix layer.</div>
                    <div class="home-card-arrow">
                        Open
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
                    </div>
                </a>

                <!-- Interface -->
                <a href="javascript:void(0)" class="home-card" onclick="switchApp('interface')">
                    <div class="home-card-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <path d="M3 9h18"/>
                            <path d="M9 21V9"/>
                        </svg>
                    </div>
                    <div class="home-card-title">Interface</div>
                    <div class="home-card-desc">Client views, case dashboards, and custom forms  your workspace for day-to-day operations.</div>
                    <div class="home-card-arrow">
                        Open
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
                    </div>
                </a>

                <!-- Settings -->
                <a href="javascript:void(0)" class="home-card" onclick="switchApp('settings')">
                    <div class="home-card-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"/>
                            <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06A1.65 1.65 0 004.68 15a1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 009 4.68a1.65 1.65 0 001-1.51V3a2 2 0 014 0v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 9a1.65 1.65 0 001.51 1H21a2 2 0 010 4h-.09a1.65 1.65 0 00-1.51 1z"/>
                        </svg>
                    </div>
                    <div class="home-card-title">Settings</div>
                    <div class="home-card-desc">Matrix sync configuration, user management, webhook endpoints, and system preferences.</div>
                    <div class="home-card-arrow">
                        Open
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
                    </div>
                </a>
            </div>

            <div class="home-stats">
                <div class="home-stat">
                    <div class="home-stat-value" id="home-stat-tables">--</div>
                    <div class="home-stat-label">Tables</div>
                </div>
                <div class="home-stat">
                    <div class="home-stat-value" id="home-stat-rooms">--</div>
                    <div class="home-stat-label">Rooms</div>
                </div>
                <div class="home-stat">
                    <div class="home-stat-value" id="home-stat-users">--</div>
                    <div class="home-stat-label">Users</div>
                </div>
                <div class="home-stat">
                    <div class="home-stat-value" id="home-stat-uptime">--</div>
                    <div class="home-stat-label">Uptime</div>
                </div>
            </div>

            <div class="home-section-label">Recent Activity</div>
            <div class="home-activity-list" id="home-activity-list">
                <div class="home-activity-item">
                    <div class="home-activity-dot muted"></div>
                    <div class="home-activity-text">Loading activity...</div>
                    <div class="home-activity-time"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Database Sub-App (existing sidebar + main) -->
    <div id="database-app" style="display: none; flex: 1; overflow: hidden;">
    <div class="sidebar-overlay" id="sidebar-overlay" onclick="closeMobileSidebar()"></div>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-header-top">
                <div class="sidebar-logo">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <ellipse cx="12" cy="5" rx="9" ry="3"/>
                        <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/>
                        <path d="M3 12c0 1.66 4 3 9 3s9-1.34 9-3"/>
                    </svg>
                </div>
                <h2>Amino Viewer</h2>
            </div>
            <div class="sidebar-search">
                <span class="sidebar-search-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.3-4.3"/>
                    </svg>
                </span>
                <input type="text" id="sidebar-search-input" placeholder="Search tables..." />
                <span class="sidebar-search-shortcut">&#8984;K</span>
            </div>
        </div>
        <div id="table-list"></div>
        <div class="sidebar-footer">
            <button class="theme-toggle-btn" id="matrix-connect-btn" onclick="showSynapseLoginScreen()" title="Connect to Matrix for room sync">
                <span id="matrix-status-icon">&#9675;</span>
                <span id="matrix-status-label">Connect Matrix</span>
            </button>
            <button class="theme-toggle-btn" id="manage-rooms-btn" onclick="showRoomManager()" title="Manage Matrix rooms" style="display: none;">
                <span>&#9881;</span>
                <span>Manage Rooms</span>
            </button>
            <button class="theme-toggle-btn" onclick="toggleTheme()" title="Toggle light/dark theme">
                <span id="theme-icon">&#9788;</span>
                <span id="theme-label">Light Mode</span>
            </button>
        </div>
    </div>

    <div class="main">
        <!-- Browser Tab Bar -->
        <div class="tab-bar" id="tab-bar">
            <div class="tab-bar-tabs" id="tab-bar-tabs">
                <!-- Tabs rendered dynamically -->
            </div>
            <button class="tab-bar-new-tab" id="tab-bar-new-tab" onclick="openNewTab()" title="Open in new tab">+</button>
        </div>
        <!-- Data Viewer View -->
        <div id="data-view" style="display: flex; flex-direction: column; height: 100%;">
            <div class="toolbar">
                <button class="mobile-sidebar-toggle" id="mobile-sidebar-toggle" onclick="toggleMobileSidebar()" title="Toggle sidebar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                </button>
                <h1 id="title">Select a table</h1>

                <!-- View Selector -->
                <div class="toolbar-views">
                    <div class="view-selector" id="view-selector-container">
                        <button class="view-selector-btn" id="view-selector-btn" onclick="toggleViewSelector()">
                            <span class="view-icon" id="current-view-icon">&#9638;</span>
                            <span class="view-name" id="current-view-name">All Fields</span>
                            <span class="dropdown-arrow">&#9662;</span>
                        </button>
                        <div class="view-selector-dropdown" id="view-selector-dropdown">
                            <!-- View options will be rendered here -->
                        </div>
                    </div>

                    <!-- Fields Button -->
                    <button class="fields-btn" id="fields-btn" onclick="toggleFieldsDropdown()">
                        <span class="fields-icon">&#9776;</span>
                        <span>Fields</span>
                        <span class="fields-count" id="fields-visible-count">0</span>
                    </button>
                    <div class="fields-dropdown" id="fields-dropdown">
                        <div class="fields-dropdown-header">
                            <h3>Toggle Fields</h3>
                            <div class="fields-dropdown-actions">
                                <button onclick="showAllFields()">Show All</button>
                                <button onclick="hideAllFields()">Hide All</button>
                            </div>
                        </div>
                        <div class="fields-search-container">
                            <input type="text" class="fields-search-input" id="fields-search-input" placeholder="Search fields..." oninput="filterFieldsDropdown(this.value)">
                        </div>
                        <div class="fields-dropdown-list" id="fields-dropdown-list">
                            <!-- Field items will be rendered here -->
                        </div>
                        <div class="fields-dropdown-footer">
                            Drag to reorder  Click checkbox to toggle
                        </div>
                    </div>
                </div>

                <!-- View Save Indicator -->
                <div class="view-save-indicator" id="view-save-indicator" style="display: none;">
                    <span class="save-dot"></span>
                    <span id="save-indicator-text">Saved</span>
                </div>
                <button class="view-save-btn" id="manual-save-btn" onclick="saveViewToBackendNow()" style="display: none;">Save Now</button>

                <button class="btn" id="airtable-sync-btn" onclick="manualAirtableSync()" title="Pull latest changes from Airtable">
                    <svg id="sync-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6"/><path d="M2.5 11.5a10 10 0 0118.8-4.3L21.5 8M21.5 12.5a10 10 0 01-18.8 4.3L2.5 16"/></svg>
                    <span id="sync-btn-text">Sync</span>
                </button>
                <button class="btn" id="connect-api-btn" onclick="showConnectApiModal()" style="display: none; background: #2d6cdf; color: #fff;">Connect API</button>
                <button class="btn" onclick="logout()">Logout</button>
            </div>

            <!-- Airtable-style View Controls Bar -->
            <div class="view-controls-bar" id="view-controls-bar">
                <!-- Filter Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="filter-btn" onclick="toggleFilterDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M4 8h8M6 12h4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                        <span>Filter</span>
                        <span class="control-count" id="filter-count" style="display: none;">0</span>
                        <span class="record-count-badge" id="record-count-badge"></span>
                    </button>
                    <div class="view-control-dropdown filter-dropdown" id="filter-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Filter records</span>
                                <button class="dropdown-action-btn" onclick="addFilter()">+ Add filter</button>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="filter-search-input" placeholder="Find a field" oninput="filterFilterDropdown(this.value)">
                            </div>
                            <div class="filter-list" id="filter-list">
                                <div class="empty-filters">No filters applied</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sort Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="sort-btn" onclick="toggleSortDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 5l2-2 2 2M6 3v10M12 11l-2 2-2-2M10 13V3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
                        <span>Sort</span>
                        <span class="control-count" id="sort-count" style="display: none;">0</span>
                    </button>
                    <div class="view-control-dropdown sort-dropdown" id="sort-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Sort records</span>
                                <button class="dropdown-action-btn" onclick="addSort()">+ Add sort</button>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="sort-search-input" placeholder="Find a field" oninput="filterSortDropdown(this.value)">
                            </div>
                            <div class="sort-list" id="sort-list">
                                <div class="empty-sorts">No sorts applied</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Group Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="group-btn" onclick="toggleGroupDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="2" y="3" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="3" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="2" y="9" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="9" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/></svg>
                        <span>Group</span>
                    </button>
                    <div class="view-control-dropdown group-dropdown" id="group-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Group records by</span>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="group-search-input" placeholder="Find a field" oninput="filterGroupDropdown(this.value)">
                            </div>
                            <div class="group-options" id="group-options">
                                <div class="group-option none-selected" onclick="setGroupBy(null)">
                                    <span class="check-mark">&#10003;</span>
                                    <span>None</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Color Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="color-btn" onclick="toggleColorDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="5" stroke="currentColor" stroke-width="1.5"/><path d="M8 3v10M3 8h10" stroke="currentColor" stroke-width="1.5"/></svg>
                        <span>Color</span>
                    </button>
                    <div class="view-control-dropdown color-dropdown" id="color-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Color records by</span>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="color-search-input" placeholder="Find a field" oninput="filterColorDropdown(this.value)">
                            </div>
                            <div class="color-options" id="color-options">
                                <div class="color-option none-selected" onclick="setColorBy(null)">
                                    <span class="check-mark">&#10003;</span>
                                    <span>None</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Row Height Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="row-height-btn" onclick="toggleRowHeightDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                        <span>Row height</span>
                    </button>
                    <div class="view-control-dropdown row-height-dropdown" id="row-height-dropdown">
                        <div class="dropdown-section">
                            <div class="row-height-option" onclick="setRowHeight('short')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 6h12M2 10h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Short</span>
                            </div>
                            <div class="row-height-option selected" onclick="setRowHeight('medium')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Medium</span>
                            </div>
                            <div class="row-height-option" onclick="setRowHeight('tall')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 3h12M2 7h12M2 11h12M2 15h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Tall</span>
                            </div>
                            <div class="row-height-option" onclick="setRowHeight('extra-tall')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 2h12M2 5h12M2 8h12M2 11h12M2 14h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Extra tall</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="view-controls-spacer"></div>

                <!-- Search -->
                <div class="view-search-wrapper">
                    <svg class="search-icon" width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="7" cy="7" r="4.5" stroke="currentColor" stroke-width="1.5"/><path d="M10.5 10.5L14 14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                    <input type="text" class="view-search-input" id="view-search-input" placeholder="Find in view" oninput="handleViewSearch(this.value)">
                </div>
            </div>
            <div class="status-bar">
                <span class="status-dot" id="status-dot"></span>
                <span id="status-text">Ready</span>
                <div class="progress-bar" id="progress-bar" style="display: none; flex: 1; max-width: 200px;">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <span id="status-detail" style="color: #999; font-size: 11px;"></span>
                <div class="sync-toggle-wrapper">
                    <button class="sync-feed-btn" id="sync-feed-btn" onclick="SyncStatusFeed.toggle()" title="View sync activity log">[log]</button>
                </div>
                <span style="flex: 1;"></span>
                <span class="refresh-indicator" id="refresh-indicator">
                    <span class="refresh-dot"></span>
                    <span id="last-refresh-text">Auto-refresh in 60s</span>
                </span>
            </div>
            <div class="table-container" id="table-container">
                <table id="table"></table>
            </div>
            <div class="pagination" id="pagination">
                <button id="prev-btn" onclick="prevPage()">Previous</button>
                <span class="page-info" id="page-info">Page 1</span>
                <button id="next-btn" onclick="nextPage()">Next</button>
            </div>
        </div>
    </div>

    <!-- View Context Menu -->
    <div class="view-context-menu" id="view-context-menu">
        <div class="view-context-menu-item" onclick="moveViewToFolder()">
            <span>&#128193;</span> Move to folder...
        </div>
        <div class="view-context-menu-item" onclick="renameView()">
            <span>&#9998;</span> Rename
        </div>
        <div class="view-context-menu-item" onclick="manageViewTags()">
            <span>&#127991;</span> Manage tags...
        </div>
        <div class="view-context-menu-item" onclick="addViewToWorkspaceMenu()">
            <span>&#11088;</span> Add to workspace...
        </div>
        <div class="view-context-menu-item" onclick="setViewParent()">
            <span>&#128279;</span> Set parent view...
        </div>
        <div class="view-context-menu-separator"></div>
        <div class="view-context-menu-item" onclick="openShareViewMenu()">
            <span id="ctx-share-icon">&#128274;</span> <span id="ctx-share-label">Share view...</span>
        </div>
        <div class="view-context-menu-separator"></div>
        <div class="view-context-menu-item danger" onclick="deleteView()">
            <span>&#128465;</span> Delete
        </div>
    </div>

    <!-- Table Context Menu -->
    <div class="view-context-menu" id="table-context-menu">
        <div class="view-context-menu-item" onclick="createViewFolderFromContextMenu()">
            <span>&#128193;</span> New folder
        </div>
    </div>

    <!-- Column Context Menu -->
    <div class="view-context-menu" id="column-context-menu">
        <div class="view-context-menu-item" id="ctx-set-display-name" onclick="setDisplayNameFromContextMenu()">
            <span>&#127991;</span> Set as display name
        </div>
        <div class="view-context-menu-separator"></div>
        <div class="view-context-menu-item" onclick="hideColumnFromContextMenu()">
            <span>&#128065;</span> Hide column
        </div>
    </div>

    <!-- Field History Modal -->
    <div class="modal-overlay" id="history-modal-overlay" onclick="closeHistoryModal(event)">
        <div class="modal history-modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 id="history-modal-title">Field History</h2>
                <button class="modal-close" onclick="closeHistoryModal()">&times;</button>
            </div>
            <div class="modal-toolbar">
                <label>Filter by field:</label>
                <select id="history-field-filter" onchange="filterHistoryByField()">
                    <option value="">All Fields</option>
                </select>
                <span class="history-count" id="history-count"></span>
            </div>
            <div class="historical-notice">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M8 4.5V8L10.5 9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="historical-notice-text"><strong>Historical data:</strong> Values shown are what was recorded at the time of each change, not the current state of the record.</span>
            </div>
            <div class="modal-body" id="history-modal-body">
                <!-- History items will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Create View Modal -->
    <div class="create-view-modal" id="create-view-modal" onclick="closeCreateViewModal(event)">
        <div class="create-view-modal-content" onclick="event.stopPropagation()">
            <div class="create-view-modal-header">
                <h2>Create New View</h2>
                <p id="create-view-reason">Customize this view with your own filters and field settings.</p>
            </div>
            <div class="create-view-modal-body">
                <div class="create-view-field">
                    <label for="create-view-name">View Name</label>
                    <input type="text" id="create-view-name" placeholder="Enter view name...">
                </div>
                <div class="create-view-field">
                    <label for="create-view-type">View Type</label>
                    <select id="create-view-type">
                        <option value="grid">Grid View</option>
                        <option value="schema">Schema View (Cards)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-parent">Parent View (for nesting)</label>
                    <select id="create-view-parent">
                        <option value="">(No parent - root level)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-tags">Tags (comma-separated)</label>
                    <input type="text" id="create-view-tags" placeholder="e.g., reports, daily, team-a">
                </div>
                <div class="create-view-field">
                    <label for="create-view-workspace">Add to Workspace</label>
                    <select id="create-view-workspace">
                        <option value="">(None)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-sharing">Visibility</label>
                    <select id="create-view-sharing">
                        <option value="private">Private (only you)</option>
                        <option value="everyone">Shared with everyone</option>
                    </select>
                </div>
            </div>
            <div class="create-view-modal-footer">
                <button class="btn-cancel" onclick="closeCreateViewModal()">Cancel</button>
                <button class="btn-create" id="create-view-submit" onclick="submitCreateView()">Create View</button>
            </div>
        </div>
    </div>

    <!-- Share View Modal -->
    <div class="create-view-modal" id="share-view-modal" onclick="closeShareViewModal(event)">
        <div class="create-view-modal-content" onclick="event.stopPropagation()">
            <div class="create-view-modal-header">
                <h2>Share View</h2>
                <p id="share-view-name">Configure who can see this view</p>
            </div>
            <div class="create-view-modal-body">
                <div class="share-view-owner" id="share-view-owner"></div>
                <div class="create-view-field">
                    <label>Sharing</label>
                    <div class="share-options">
                        <label class="share-option">
                            <input type="radio" name="share-level" value="private" checked onchange="onShareLevelChange()">
                            <span class="share-option-icon">&#128274;</span>
                            <div class="share-option-text">
                                <strong>Private</strong>
                                <span>Only you can see this view</span>
                            </div>
                        </label>
                        <label class="share-option">
                            <input type="radio" name="share-level" value="specific" onchange="onShareLevelChange()">
                            <span class="share-option-icon">&#128101;</span>
                            <div class="share-option-text">
                                <strong>Specific people</strong>
                                <span>Share with selected team members</span>
                            </div>
                        </label>
                        <label class="share-option">
                            <input type="radio" name="share-level" value="everyone" onchange="onShareLevelChange()">
                            <span class="share-option-icon">&#127760;</span>
                            <div class="share-option-text">
                                <strong>Everyone</strong>
                                <span>All org members can see this view</span>
                            </div>
                        </label>
                    </div>
                </div>
                <div class="create-view-field" id="share-users-section" style="display: none;">
                    <label>Share with</label>
                    <div class="share-users-list" id="share-users-list">
                        <div class="share-users-loading">Loading org members...</div>
                    </div>
                </div>
            </div>
            <div class="create-view-modal-footer">
                <button class="btn-cancel" onclick="closeShareViewModal()">Cancel</button>
                <button class="btn-create" id="share-view-submit" onclick="submitShareView()">Save Sharing</button>
            </div>
        </div>
    </div>

    <!-- Point in Time Modal -->
    <div class="modal-overlay" id="pit-modal-overlay" onclick="closePitModal(event)">
        <div class="modal pit-modal" onclick="event.stopPropagation()">
            <div class="modal-header pit-modal-header">
                <div class="pit-info">
                    <h2 id="pit-modal-title">Record at Point in Time</h2>
                    <span class="pit-timestamp" id="pit-modal-timestamp"></span>
                </div>
                <span class="pit-event-badge" id="pit-modal-event-badge"></span>
                <button class="modal-close" onclick="closePitModal()">&times;</button>
            </div>
            <div class="historical-notice">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M8 4.5V8L10.5 9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="historical-notice-text"><strong>Snapshot:</strong> This shows the record as it existed at this point in time, not its current state. Click "View Current Record" to see the latest data.</span>
            </div>
            <div class="modal-body" id="pit-modal-body">
                <!-- Record state will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Record Profile Slide-out Panel -->
    <div class="record-profile-overlay" id="record-profile-overlay" onclick="closeRecordProfile(event)">
        <div class="record-profile-panel" onclick="event.stopPropagation()">
            <div class="profile-header">
                <h2 id="profile-title">Record</h2>
                <span class="profile-view-name" id="profile-view-name"></span>
                <span class="profile-record-id" id="profile-record-id"></span>
                <button class="profile-close" onclick="closeRecordProfile()">&times;</button>
            </div>
            <div class="profile-tabs">
                <div class="profile-tab active" data-tab="details" onclick="switchProfileTab('details')">Case Details</div>
                <div class="profile-tab" data-tab="sync-history" onclick="switchProfileTab('sync-history')">Sync History</div>
            </div>
            <div class="profile-tab-content active" id="profile-tab-details">
                <div class="profile-toolbar" id="profile-toolbar">
                    <button class="profile-configure-btn" id="profile-configure-btn" onclick="toggleProfileConfigureMode()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                        Configure
                    </button>
                    <div class="profile-toolbar-spacer"></div>
                    <button class="profile-add-block-btn" id="profile-add-block-btn" onclick="addProfileBlock()" style="display: none;">+ Add Block</button>
                </div>
                <div class="profile-body" id="profile-body">
                    <!-- Profile content will be rendered here -->
                </div>
            </div>
            <div class="profile-tab-content" id="profile-tab-sync-history">
                <!-- Sync history content will be rendered here -->
            </div>
            <div class="profile-nav">
                <button class="profile-nav-btn" id="profile-prev-btn" onclick="navigateProfile(-1)">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15,18 9,12 15,6"/></svg>
                    Prev
                </button>
                <span class="profile-nav-info" id="profile-nav-info">1 of 100</span>
                <button class="profile-nav-btn" id="profile-next-btn" onclick="navigateProfile(1)">
                    Next
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9,18 15,12 9,6"/></svg>
                </button>
            </div>
        </div>
    </div>

    </div><!-- /database-app -->

    <!-- Interface Sub-App (placeholder) -->
    <div id="interface-app">
        <div class="interface-placeholder">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/>
            </svg>
            <h2>Interface Designer</h2>
            <p>Custom interfaces for your data  coming soon.</p>
        </div>
    </div>

    <!-- Settings Sub-App -->
    <div id="settings-app">
        <div class="settings-header">
            <h1>Settings</h1>
            <p>Manage users, roles, room access, and your personal preferences.</p>
        </div>

        <div id="settings-toast" class="settings-toast"></div>

        <div class="settings-tabs">
            <button class="settings-tab active" id="settings-tab-roles" onclick="switchSettingsTab('roles')">Users &amp; Roles</button>
            <button class="settings-tab" id="settings-tab-rooms" onclick="switchSettingsTab('rooms')">Room Access</button>
            <button class="settings-tab" id="settings-tab-preferences" onclick="switchSettingsTab('preferences')">Preferences</button>
        </div>

        <!-- Users & Roles Tab -->
        <div id="settings-panel-roles">
            <div class="settings-section">
                <h2>Organization Members</h2>
                <p class="settings-section-desc">Assign roles to control what each user can do. Admins can manage schema and members. Staff can create and edit records. Clients have read-only access.</p>
                <div id="settings-users-loading" class="settings-loading">
                    <div class="settings-spinner"></div>
                    Loading members...
                </div>
                <div id="settings-users-content" style="display: none;">
                    <table class="settings-table">
                        <thead>
                            <tr>
                                <th>User</th>
                                <th>Display Name</th>
                                <th>Current Role</th>
                                <th>Change Role</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="settings-users-tbody">
                        </tbody>
                    </table>
                </div>
                <div id="settings-users-empty" style="display: none; padding: 16px 0; color: var(--text-muted); font-size: 13px;">
                    No members found. Ensure you are connected to an organization space.
                </div>
                <div id="settings-invite-section" class="settings-invite-form" style="display: none;">
                    <h3>Invite New User</h3>
                    <p>Create a new account and add them to the organization. They will receive access to the org space.</p>
                    <div class="settings-invite-row">
                        <div class="settings-invite-field">
                            <label for="invite-username">Username</label>
                            <input type="text" id="invite-username" placeholder="e.g. jsmith" autocomplete="off">
                        </div>
                        <div class="settings-invite-field">
                            <label for="invite-display-name">Display Name</label>
                            <input type="text" id="invite-display-name" placeholder="e.g. John Smith" autocomplete="off">
                        </div>
                        <div class="settings-invite-field">
                            <label for="invite-email">Email</label>
                            <input type="email" id="invite-email" placeholder="e.g. jsmith@example.com" autocomplete="off">
                        </div>
                    </div>
                    <div class="settings-invite-row">
                        <div class="settings-invite-field" style="max-width: 180px;">
                            <label for="invite-role">Role</label>
                            <select id="invite-role">
                                <option value="staff">Staff (50)</option>
                                <option value="client">Client (10)</option>
                                <option value="admin">Admin (100)</option>
                            </select>
                        </div>
                        <button class="settings-invite-btn" id="invite-submit-btn" onclick="inviteNewUser()">Invite User</button>
                    </div>
                    <div id="invite-status" style="font-size: 13px; margin-top: 8px;"></div>
                </div>
            </div>
        </div>

        <!-- Room Access Tab -->
        <div id="settings-panel-rooms" style="display: none;">
            <div class="settings-section">
                <h2>Room Access Management</h2>
                <p class="settings-section-desc">Control which users have access to which data rooms. Check a box to grant a user access (join them to the room), uncheck to revoke (kick from room).</p>

                <div style="margin-bottom: 16px;">
                    <label style="font-size: 13px; color: var(--text-secondary); display: block; margin-bottom: 6px;">Select user:</label>
                    <select id="settings-room-user-select" class="settings-role-select" style="min-width: 260px;" onchange="loadRoomAccessForUser()">
                        <option value="">-- Choose a user --</option>
                    </select>
                </div>

                <div id="settings-rooms-loading" class="settings-loading" style="display: none;">
                    <div class="settings-spinner"></div>
                    Loading room access...
                </div>
                <div id="settings-rooms-content" style="display: none;">
                    <table class="settings-room-access">
                        <thead>
                            <tr>
                                <th>Room</th>
                                <th style="text-align: center; width: 80px;">Access</th>
                                <th style="width: 100px;">Status</th>
                            </tr>
                        </thead>
                        <tbody id="settings-rooms-tbody">
                        </tbody>
                    </table>
                </div>
                <div id="settings-rooms-empty" style="display: none; padding: 16px 0; color: var(--text-muted); font-size: 13px;">
                    Select a user to manage their room access.
                </div>
            </div>
        </div>

        <!-- Preferences Tab -->
        <div id="settings-panel-preferences" style="display: none;">
            <div class="settings-section">
                <h2>Notifications</h2>
                <p class="settings-section-desc">Control which notifications you receive. These preferences are synced to your account.</p>
                <div class="settings-pref-row">
                    <label class="settings-toggle-label" for="pref-offline-sync-toasts">
                        <span class="settings-toggle-text">
                            <strong>Offline sync toasts</strong>
                            <span class="settings-toggle-desc">Show a toast notification when queued offline edits finish syncing</span>
                        </span>
                        <input type="checkbox" id="pref-offline-sync-toasts" class="settings-toggle-checkbox" onchange="toggleOfflineSyncToasts(this.checked)">
                        <span class="settings-toggle-switch"></span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    </div><!-- /app-content-wrapper -->

    <!-- Room Publishing Modal -->
    <div class="room-publish-modal hidden" id="room-publish-modal" onclick="closeRoomPublishModal(event)">
        <div class="room-publish-box" onclick="event.stopPropagation()">
            <h2>Publish to Matrix Rooms</h2>
            <p class="pub-subtitle">Select tables to publish as Matrix rooms. Each table becomes a room with its schema and records stored as state events.</p>
            <div id="room-publish-not-connected" style="display: none;">
                <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                    <p style="margin-bottom: 12px;">Not connected to Matrix. Sign in first to publish rooms.</p>
                    <button class="pub-btn-publish" onclick="closeRoomPublishModal(); showSynapseLoginScreen();">Sign in to Matrix</button>
                </div>
            </div>
            <div id="room-publish-content">
                <div class="room-publish-section">
                    <h3>Organization</h3>
                    <div id="pub-org-section">
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="pub-org-name" placeholder="Organization name" style="flex:1; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;">
                            <span id="pub-org-status" style="font-size: 12px; color: var(--text-muted);"></span>
                        </div>
                    </div>
                </div>
                <div class="room-publish-section">
                    <h3>Tables to Publish</h3>
                    <div id="pub-table-list">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                <div class="room-publish-section">
                    <h3>Client Grouping (Optional)</h3>
                    <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">If you want per-client rooms, select the table and field that identifies clients.</p>
                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        <select id="pub-client-table" style="flex:1; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;" onchange="pubClientTableChanged()">
                            <option value="">No client grouping</option>
                        </select>
                        <select id="pub-client-field" style="flex:1; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;" disabled>
                            <option value="">Select identifier field</option>
                        </select>
                    </div>
                </div>
                <div id="pub-progress-section" style="display: none;">
                    <div class="pub-progress">
                        <div class="pub-progress-bar"><div class="pub-progress-fill" id="pub-progress-fill" style="width: 0%"></div></div>
                        <div class="pub-progress-text" id="pub-progress-text">Preparing...</div>
                    </div>
                </div>
            </div>
            <div class="pub-actions">
                <button class="pub-btn-cancel" onclick="closeRoomPublishModal()">Cancel</button>
                <button class="pub-btn-publish" id="pub-publish-btn" onclick="executeRoomPublish()">Publish Selected</button>
            </div>
        </div>
    </div>

    <!-- Sync Status Feed Panel -->
    <div class="sync-feed-panel" id="sync-feed-panel">
        <div class="sync-feed-header">
            <div class="sync-feed-header-left">
                <span class="sync-feed-status-dot" id="sync-feed-status-dot"></span>
                <span>Sync Activity</span>
            </div>
            <button class="sync-feed-close" onclick="SyncStatusFeed.hide()">&times;</button>
        </div>
        <div class="sync-feed-body" id="sync-feed-body">
            <div class="sync-feed-empty">No sync activity yet</div>
        </div>
        <div class="sync-feed-footer">
            <span id="sync-feed-stats">Idle</span>
            <button onclick="SyncStatusFeed.clear()">Clear</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@msgpack/msgpack@3.1.2/dist.umd/msgpack.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="matrix.js"></script>
    <script src="data-layer.js"></script>

    <script>
// ============ Theme Management ============
(function() {
    var saved = localStorage.getItem('amino_theme');
    if (saved === 'light') document.documentElement.classList.add('light-theme');
})();

// ============ Mobile Sidebar Toggle ============
function toggleMobileSidebar() {
    var sidebar = document.getElementById('sidebar');
    var overlay = document.getElementById('sidebar-overlay');
    if (sidebar && overlay) {
        var isOpen = sidebar.classList.toggle('mobile-open');
        if (isOpen) {
            overlay.classList.add('visible');
            document.body.style.overflow = 'hidden';
        } else {
            overlay.classList.remove('visible');
            document.body.style.overflow = '';
        }
    }
}
function closeMobileSidebar() {
    var sidebar = document.getElementById('sidebar');
    var overlay = document.getElementById('sidebar-overlay');
    if (sidebar) sidebar.classList.remove('mobile-open');
    if (overlay) overlay.classList.remove('visible');
    document.body.style.overflow = '';
}
// Close sidebar when a table is selected on mobile
(function() {
    var origOpen = window.openTableInTab;
    if (origOpen) return; // Will be patched after openTableInTab is defined
    // Defer the patching to after page load
    window.addEventListener('DOMContentLoaded', function() {
        // Patch sidebar item clicks to auto-close on mobile
        document.addEventListener('click', function(e) {
            if (window.innerWidth > 768) return;
            var item = e.target.closest('.table-item, .table-view-item');
            if (item && document.getElementById('sidebar').contains(item)) {
                setTimeout(closeMobileSidebar, 150);
            }
        });
    });
})();

function toggleTheme() {
    var html = document.documentElement;
    var isLight = html.classList.toggle('light-theme');
    localStorage.setItem('amino_theme', isLight ? 'light' : 'dark');
    // Sync theme to user preferences (Synapse account data)
    UserPreferences.set('theme', isLight ? 'light' : 'dark');
    var icon = document.getElementById('theme-icon');
    var label = document.getElementById('theme-label');
    if (icon) icon.textContent = isLight ? '\u263E' : '\u2606';
    if (label) label.textContent = isLight ? 'Dark Mode' : 'Light Mode';
    var fhIcon = document.getElementById('file-header-theme-icon');
    var fhLabel = document.getElementById('file-header-theme-label');
    if (fhIcon) fhIcon.textContent = isLight ? '\u263E' : '\u2606';
    if (fhLabel) fhLabel.textContent = isLight ? 'Dark Mode' : 'Light Mode';
}

// ============ Tab Bar Management ============
var openTabs = []; // { id, tableId, tableName, viewId, viewName, icon }
var activeTabId = null;

function generateTabId() {
    return 'tab_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
}

function openTableInTab(tableId, tableName, icon) {
    // Check if already open
    var existing = openTabs.find(function(t) { return t.tableId === tableId; });
    if (existing) {
        activeTabId = existing.id;
        // Update name if changed
        if (tableName) existing.tableName = tableName;
        renderTabBar();
        return;
    }
    var tab = { id: generateTabId(), tableId: tableId, tableName: tableName || tableId, icon: icon || '' };
    openTabs.push(tab);
    activeTabId = tab.id;
    renderTabBar();
}

var _tabNavInProgress = false;
function activateTab(tabId) {
    var tab = openTabs.find(function(t) { return t.id === tabId; });
    if (!tab) return;
    if (activeTabId === tabId && !_tabNavInProgress) { renderTabBar(); return; }
    activeTabId = tabId;
    renderTabBar();
    // Prevent re-entrant calls from showTable -> openTableInTab -> activateTab
    if (_tabNavInProgress) return;
    _tabNavInProgress = true;
    // Navigate to the appropriate view
    if (tab.tableId === '_events' && typeof showEventsView === 'function') {
        showEventsView().finally(function() { _tabNavInProgress = false; });
    } else if (tab.tableId === '_sync_status' && typeof showSyncStatusView === 'function') {
        showSyncStatusView().finally(function() { _tabNavInProgress = false; });
    } else if (typeof showTable === 'function') {
        showTable(tab.tableId).finally(function() { _tabNavInProgress = false; });
    } else {
        _tabNavInProgress = false;
    }
}

function closeTab(tabId, evt) {
    if (evt) { evt.stopPropagation(); evt.preventDefault(); }
    var idx = openTabs.findIndex(function(t) { return t.id === tabId; });
    if (idx === -1) return;
    openTabs.splice(idx, 1);
    if (activeTabId === tabId) {
        if (openTabs.length > 0) {
            var newIdx = Math.min(idx, openTabs.length - 1);
            activateTab(openTabs[newIdx].id);
        } else {
            activeTabId = null;
        }
    }
    renderTabBar();
}

function openNewTab() {
    // Focus the sidebar search to let user pick a table
    var searchInput = document.getElementById('sidebar-search-input');
    if (searchInput) { searchInput.focus(); searchInput.select(); }
}

function renderTabBar() {
    var container = document.getElementById('tab-bar-tabs');
    if (!container) return;

    // Build all tab elements into a DocumentFragment (single DOM write, no per-tab reflows)
    var frag = document.createDocumentFragment();
    openTabs.forEach(function(tab) {
        var el = document.createElement('div');
        el.className = 'browser-tab' + (tab.id === activeTabId ? ' active' : '');
        el.onclick = function() { activateTab(tab.id); };

        var iconEl = document.createElement('span');
        iconEl.className = 'tab-icon';
        iconEl.textContent = tab.icon || '\u25A6';
        el.appendChild(iconEl);

        var titleEl = document.createElement('span');
        titleEl.className = 'tab-title';
        titleEl.textContent = tab.tableName;
        el.appendChild(titleEl);

        if (openTabs.length > 1) {
            var closeEl = document.createElement('button');
            closeEl.className = 'tab-close';
            closeEl.textContent = '\u00D7';
            closeEl.onclick = function(e) { closeTab(tab.id, e); };
            el.appendChild(closeEl);
        }

        frag.appendChild(el);
    });
    container.innerHTML = '';
    container.appendChild(frag);

    // Update theme icon state on render
    var saved = localStorage.getItem('amino_theme');
    var icon = document.getElementById('theme-icon');
    var label = document.getElementById('theme-label');
    if (icon) icon.textContent = saved === 'light' ? '\u263E' : '\u2606';
    if (label) label.textContent = saved === 'light' ? 'Dark Mode' : 'Light Mode';
    var fhIcon = document.getElementById('file-header-theme-icon');
    var fhLabel = document.getElementById('file-header-theme-label');
    if (fhIcon) fhIcon.textContent = saved === 'light' ? '\u263E' : '\u2606';
    if (fhLabel) fhLabel.textContent = saved === 'light' ? 'Dark Mode' : 'Light Mode';
}

var DB_NAME = 'amino';
var DB_VERSION = 9;
var PAGE_SIZE = 100;
var N8N_WEBHOOK_BASE = 'https://n8n.intelechia.com/webhook';

var db = null;

// ============ Encryption Configuration ============
var ENCRYPTION_CONFIG_KEY = 'amino_encryption_config';
var ENCRYPTED_CREDENTIALS_KEY = 'amino_encrypted_credentials';
var encryptionKey = null; // CryptoKey object, only kept in memory
var encryptionEnabled = false;
var passkeyCredentialId = null; // For WebAuthn

// ============ Web Crypto API Utilities ============

// Generate a random salt for key derivation
function generateSalt() {
    return crypto.getRandomValues(new Uint8Array(16));
}

// Generate a random IV for AES-GCM encryption
function generateIV() {
    return crypto.getRandomValues(new Uint8Array(12));
}

// Derive an encryption key from a password using PBKDF2
async function deriveKeyFromPassword(password, salt) {
    var encoder = new TextEncoder();
    var passwordKey = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        'PBKDF2',
        false,
        ['deriveBits', 'deriveKey']
    );

    return crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        },
        passwordKey,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
}

// Encrypt data using AES-GCM
async function encryptData(data, key) {
    var encoder = new TextEncoder();
    var iv = generateIV();
    var encodedData = encoder.encode(JSON.stringify(data));

    var encryptedBuffer = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encodedData
    );

    // Combine IV and encrypted data
    var combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encryptedBuffer), iv.length);

    return arrayBufferToBase64(combined);
}

// Decrypt data using AES-GCM
async function decryptData(encryptedBase64, key) {
    var combined = base64ToArrayBuffer(encryptedBase64);
    var iv = combined.slice(0, 12);
    var encryptedData = combined.slice(12);

    var decryptedBuffer = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encryptedData
    );

    var decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decryptedBuffer));
}

// Helper: Convert ArrayBuffer to Base64
function arrayBufferToBase64(buffer) {
    var bytes = new Uint8Array(buffer);
    var binary = '';
    for (var i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

// Helper: Convert Base64 to ArrayBuffer
function base64ToArrayBuffer(base64) {
    var binary = atob(base64);
    var bytes = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

// ============ WebAuthn Passkey Utilities ============

// Check if WebAuthn is supported
function isPasskeySupported() {
    return !!(window.PublicKeyCredential && navigator.credentials);
}

// Create a new passkey for encryption
async function createPasskey() {
    if (!isPasskeySupported()) {
        throw new Error('Passkeys are not supported in this browser');
    }

    // Generate a random challenge
    var challenge = crypto.getRandomValues(new Uint8Array(32));
    var userId = crypto.getRandomValues(new Uint8Array(16));

    var publicKeyOptions = {
        challenge: challenge,
        rp: {
            name: 'Amino Viewer',
            id: window.location.hostname
        },
        user: {
            id: userId,
            name: 'amino-user',
            displayName: 'Amino Viewer User'
        },
        pubKeyCredParams: [
            { alg: -7, type: 'public-key' },   // ES256
            { alg: -257, type: 'public-key' }  // RS256
        ],
        authenticatorSelection: {
            authenticatorAttachment: 'platform',
            userVerification: 'required',
            residentKey: 'required'
        },
        timeout: 60000,
        attestation: 'none',
        extensions: {
            prf: {
                eval: {
                    first: new TextEncoder().encode('amino-encryption-key')
                }
            }
        }
    };

    var credential = await navigator.credentials.create({ publicKey: publicKeyOptions });

    // Check if PRF extension is supported
    var prfSupported = credential.getClientExtensionResults().prf !== undefined;

    return {
        credentialId: arrayBufferToBase64(credential.rawId),
        userId: arrayBufferToBase64(userId),
        prfSupported: prfSupported
    };
}

// Authenticate with an existing passkey
async function authenticateWithPasskey(credentialId) {
    if (!isPasskeySupported()) {
        throw new Error('Passkeys are not supported in this browser');
    }

    var challenge = crypto.getRandomValues(new Uint8Array(32));

    var publicKeyOptions = {
        challenge: challenge,
        allowCredentials: [{
            id: base64ToArrayBuffer(credentialId),
            type: 'public-key'
        }],
        userVerification: 'required',
        timeout: 60000,
        extensions: {
            prf: {
                eval: {
                    first: new TextEncoder().encode('amino-encryption-key')
                }
            }
        }
    };

    var assertion = await navigator.credentials.get({ publicKey: publicKeyOptions });

    // Check if PRF was used
    var prfResult = assertion.getClientExtensionResults().prf;

    return {
        credentialId: arrayBufferToBase64(assertion.rawId),
        prfOutput: prfResult ? arrayBufferToBase64(prfResult.results.first) : null,
        authenticatorData: arrayBufferToBase64(assertion.response.authenticatorData)
    };
}

// Derive encryption key from passkey authentication
async function deriveKeyFromPasskey(prfOutput, salt) {
    if (prfOutput) {
        // PRF is supported - use PRF output directly
        var prfBytes = base64ToArrayBuffer(prfOutput);
        var keyMaterial = await crypto.subtle.importKey(
            'raw',
            prfBytes,
            'HKDF',
            false,
            ['deriveBits', 'deriveKey']
        );

        return crypto.subtle.deriveKey(
            {
                name: 'HKDF',
                salt: salt,
                info: new TextEncoder().encode('amino-aes-key'),
                hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    } else {
        // PRF not supported - fall back to using authenticator data hash
        throw new Error('Your authenticator does not support the PRF extension needed for encryption. Please use a password instead.');
    }
}

// ============ Password Strength Checker ============

function checkPasswordStrength(password) {
    var strength = 0;
    if (password.length >= 8) strength++;
    if (password.length >= 12) strength++;
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
    if (/[0-9]/.test(password)) strength++;
    if (/[^a-zA-Z0-9]/.test(password)) strength++;

    if (strength <= 2) return 'weak';
    if (strength <= 3) return 'medium';
    return 'strong';
}

function updatePasswordStrength() {
    var password = document.getElementById('setup-password').value;
    var strengthFill = document.getElementById('password-strength-fill');
    strengthFill.className = 'password-strength-fill';

    if (password.length > 0) {
        var strength = checkPasswordStrength(password);
        strengthFill.classList.add(strength);
    }
}

// ============ Encryption Setup & Unlock Functions ============

// Check if encryption is already set up
function getEncryptionConfig() {
    var configStr = localStorage.getItem(ENCRYPTION_CONFIG_KEY);
    if (!configStr) return null;
    try {
        return JSON.parse(configStr);
    } catch (e) {
        return null;
    }
}

// Save encryption configuration
function saveEncryptionConfig(config) {
    localStorage.setItem(ENCRYPTION_CONFIG_KEY, JSON.stringify(config));
}

// Session key persistence: store encryption key in sessionStorage to survive refresh
var SESSION_KEY_STORAGE = 'amino_session_key';

async function saveSessionKey(key) {
    try {
        var raw = await crypto.subtle.exportKey('raw', key);
        sessionStorage.setItem(SESSION_KEY_STORAGE, arrayBufferToBase64(raw));
    } catch (e) {
        console.warn('Could not save session key:', e);
    }
}

async function loadSessionKey() {
    var stored = sessionStorage.getItem(SESSION_KEY_STORAGE);
    if (!stored) return null;
    try {
        var raw = base64ToArrayBuffer(stored);
        return await crypto.subtle.importKey(
            'raw',
            raw,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    } catch (e) {
        console.warn('Could not restore session key:', e);
        sessionStorage.removeItem(SESSION_KEY_STORAGE);
        return null;
    }
}

function clearSessionKey() {
    sessionStorage.removeItem(SESSION_KEY_STORAGE);
}

// Show the unlock screen (setup or prompt mode)
function showUnlockScreen(mode) {
    // Cancel any pending hide timeout to prevent race condition
    if (_hideUnlockTimeout) { clearTimeout(_hideUnlockTimeout); _hideUnlockTimeout = null; }

    var unlockScreen = document.getElementById('unlock-screen');
    var setupBox = document.getElementById('unlock-setup');
    var promptBox = document.getElementById('unlock-prompt');

    unlockScreen.classList.remove('hidden', 'fading-out');

    if (mode === 'setup') {
        setupBox.classList.remove('hidden');
        promptBox.classList.add('hidden');

        // Hide passkey button if not supported
        if (!isPasskeySupported()) {
            document.getElementById('setup-passkey-btn').style.display = 'none';
        }
    } else {
        setupBox.classList.add('hidden');
        promptBox.classList.remove('hidden');

        // Check encryption config for passkey vs password
        var config = getEncryptionConfig();
        var passkeySection = document.getElementById('passkey-unlock-section');
        var passwordInput = document.getElementById('unlock-password');
        var passwordBtn = document.getElementById('unlock-password-btn');
        if (config && config.type === 'passkey' && isPasskeySupported()) {
            passkeySection.style.display = 'block';
            passkeyCredentialId = config.credentialId;
            // Hide password fields for passkey-only users
            passwordInput.style.display = 'none';
            passwordBtn.style.display = 'none';
        } else {
            passkeySection.style.display = 'none';
            passwordInput.style.display = '';
            passwordBtn.style.display = '';
        }
    }
}

// Hide the unlock screen
var _hideUnlockTimeout = null;
function hideUnlockScreen() {
    var el = document.getElementById('unlock-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        if (_hideUnlockTimeout) { clearTimeout(_hideUnlockTimeout); _hideUnlockTimeout = null; }
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    _hideUnlockTimeout = setTimeout(function() { _hideUnlockTimeout = null; el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

// Show error on unlock screen
function showUnlockError(mode, message) {
    var errorId = mode === 'setup' ? 'unlock-setup-error' : 'unlock-prompt-error';
    var errorEl = document.getElementById(errorId);
    errorEl.textContent = message;
    errorEl.style.display = 'block';
}

// Hide error on unlock screen
function hideUnlockError(mode) {
    var errorId = mode === 'setup' ? 'unlock-setup-error' : 'unlock-prompt-error';
    document.getElementById(errorId).style.display = 'none';
}

// Set up encryption with password
async function setupEncryptionWithPassword() {
    hideUnlockError('setup');

    var password = document.getElementById('setup-password').value;
    var confirmPassword = document.getElementById('setup-password-confirm').value;

    if (!password) {
        showUnlockError('setup', 'Please enter a password');
        return;
    }

    if (password.length < 8) {
        showUnlockError('setup', 'Password must be at least 8 characters');
        return;
    }

    if (password !== confirmPassword) {
        showUnlockError('setup', 'Passwords do not match');
        return;
    }

    var btn = document.getElementById('setup-password-btn');
    btn.disabled = true;
    btn.textContent = 'Setting up...';

    try {
        var salt = generateSalt();
        encryptionKey = await deriveKeyFromPassword(password, salt);

        // Create verification token
        var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, encryptionKey);

        // Save config
        saveEncryptionConfig({
            type: 'password',
            salt: arrayBufferToBase64(salt),
            verificationToken: verificationToken
        });

        encryptionEnabled = true;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Encryption setup failed:', e);
        showUnlockError('setup', 'Failed to set up encryption: ' + e.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Set Up with Password';
    }
}

// Set up encryption with passkey
async function setupEncryptionWithPasskey() {
    hideUnlockError('setup');

    if (!isPasskeySupported()) {
        showUnlockError('setup', 'Passkeys are not supported in this browser');
        return;
    }

    var btn = document.getElementById('setup-passkey-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Setting up...';

    try {
        var passkeyResult = await createPasskey();

        if (!passkeyResult.prfSupported) {
            showUnlockError('setup', 'Your device does not support the encryption features needed for passkey-based encryption. Please use a password instead.');
            return;
        }

        // Authenticate immediately to get PRF output
        var authResult = await authenticateWithPasskey(passkeyResult.credentialId);

        if (!authResult.prfOutput) {
            showUnlockError('setup', 'Failed to get encryption key from passkey. Please use a password instead.');
            return;
        }

        var salt = generateSalt();
        encryptionKey = await deriveKeyFromPasskey(authResult.prfOutput, salt);

        // Create verification token
        var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, encryptionKey);

        // Save config
        saveEncryptionConfig({
            type: 'passkey',
            credentialId: passkeyResult.credentialId,
            salt: arrayBufferToBase64(salt),
            verificationToken: verificationToken
        });

        encryptionEnabled = true;
        passkeyCredentialId = passkeyResult.credentialId;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Passkey setup failed:', e);
        if (e.name === 'NotAllowedError') {
            showUnlockError('setup', 'Passkey setup was cancelled. Please try again.');
        } else {
            showUnlockError('setup', 'Failed to set up passkey: ' + e.message);
        }
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Set Up with Passkey';
    }
}

// Skip encryption (not recommended)
function skipEncryption() {
    if (!confirm('Are you sure? Your API key and cached data will be stored unencrypted, which means anyone with access to your browser could read them.')) {
        return;
    }

    saveEncryptionConfig({ type: 'none' });
    encryptionEnabled = false;
    encryptionKey = null;
    hideUnlockScreen();
    initAuthScreen();
}

// Unlock with password
async function unlockWithPassword() {
    hideUnlockError('prompt');

    var password = document.getElementById('unlock-password').value;
    if (!password) {
        showUnlockError('prompt', 'Please enter your password');
        return;
    }

    var btn = document.getElementById('unlock-password-btn');
    btn.disabled = true;
    btn.textContent = 'Unlocking...';

    try {
        var config = getEncryptionConfig();
        if (!config || !config.salt) {
            throw new Error('Invalid encryption configuration');
        }

        var salt = base64ToArrayBuffer(config.salt);
        encryptionKey = await deriveKeyFromPassword(password, salt);

        // Verify the key
        try {
            await decryptData(config.verificationToken, encryptionKey);
        } catch (e) {
            throw new Error('Incorrect password');
        }

        encryptionEnabled = true;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        document.getElementById('unlock-password').value = '';
        initAuthScreen();
    } catch (e) {
        console.error('Unlock failed:', e);
        showUnlockError('prompt', e.message || 'Failed to unlock');
        encryptionKey = null;
    } finally {
        btn.disabled = false;
        btn.textContent = 'Unlock';
    }
}

// Unlock with passkey
async function unlockWithPasskey() {
    hideUnlockError('prompt');

    var btn = document.getElementById('passkey-unlock-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Unlocking...';

    try {
        var config = getEncryptionConfig();
        if (!config || config.type !== 'passkey') {
            throw new Error('Passkey not configured');
        }

        var authResult = await authenticateWithPasskey(config.credentialId);

        if (!authResult.prfOutput) {
            throw new Error('Failed to get encryption key from passkey');
        }

        var salt = base64ToArrayBuffer(config.salt);
        encryptionKey = await deriveKeyFromPasskey(authResult.prfOutput, salt);

        // Verify the key
        try {
            await decryptData(config.verificationToken, encryptionKey);
        } catch (e) {
            throw new Error('Passkey authentication failed');
        }

        encryptionEnabled = true;
        passkeyCredentialId = config.credentialId;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Passkey unlock failed:', e);
        if (e.name === 'NotAllowedError') {
            showUnlockError('prompt', 'Passkey authentication was cancelled. Please try again.');
        } else {
            showUnlockError('prompt', e.message || 'Failed to unlock with passkey');
        }
        encryptionKey = null;
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Unlock with Passkey';
    }
}

// Clear all encrypted data and start fresh
async function clearEncryptedData() {
    if (!confirm('This will delete ALL local data including your cached database. Your data on the server is not affected. Continue?')) {
        return;
    }

    try {
        // Clear localStorage encryption config and credentials
        localStorage.removeItem(ENCRYPTION_CONFIG_KEY);
        localStorage.removeItem(ENCRYPTED_CREDENTIALS_KEY);
        localStorage.removeItem('amino_api_key');
        localStorage.removeItem('amino_set_filter');

        // Clear IndexedDB
        await new Promise((resolve, reject) => {
            var req = indexedDB.deleteDatabase(DB_NAME);
            req.onsuccess = resolve;
            req.onerror = () => reject(req.error);
        });

        encryptionKey = null;
        encryptionEnabled = false;
        passkeyCredentialId = null;

        // Show setup screen
        showUnlockScreen('setup');
    } catch (e) {
        console.error('Failed to clear data:', e);
        alert('Failed to clear data: ' + e.message);
    }
}

// ============ Encrypted Credentials Storage ============

// Save API credentials (encrypted if encryption is enabled)
async function saveEncryptedCredentials(apiKey, setFilter) {
    var credentials = { apiKey: apiKey, setFilter: setFilter };

    if (encryptionEnabled && encryptionKey) {
        var encrypted = await encryptData(credentials, encryptionKey);
        localStorage.setItem(ENCRYPTED_CREDENTIALS_KEY, encrypted);
        // Remove plaintext credentials
        localStorage.removeItem('amino_api_key');
        localStorage.removeItem('amino_set_filter');
    } else {
        // Store as plaintext (no encryption)
        localStorage.setItem('amino_api_key', apiKey);
        if (setFilter) {
            localStorage.setItem('amino_set_filter', setFilter);
        } else {
            localStorage.removeItem('amino_set_filter');
        }
    }
}

// Load API credentials (decrypt if necessary)
async function loadEncryptedCredentials() {
    if (encryptionEnabled && encryptionKey) {
        var encrypted = localStorage.getItem(ENCRYPTED_CREDENTIALS_KEY);
        if (encrypted) {
            try {
                return await decryptData(encrypted, encryptionKey);
            } catch (e) {
                console.error('Failed to decrypt credentials:', e);
                return null;
            }
        }
    } else {
        var apiKey = localStorage.getItem('amino_api_key');
        if (apiKey) {
            return {
                apiKey: apiKey,
                setFilter: localStorage.getItem('amino_set_filter')
            };
        }
    }
    return null;
}

// Clear saved credentials
function clearEncryptedCredentials() {
    localStorage.removeItem(ENCRYPTED_CREDENTIALS_KEY);
    localStorage.removeItem('amino_api_key');
    localStorage.removeItem('amino_set_filter');
}

// ============ Encrypted IndexedDB Wrapper ============

// Encrypt data before storing in IndexedDB
async function encryptForStorage(data) {
    if (encryptionEnabled && encryptionKey) {
        return {
            _encrypted: true,
            data: await encryptData(data, encryptionKey)
        };
    }
    return data;
}

// Decrypt data after retrieving from IndexedDB
async function decryptFromStorage(data) {
    if (data && data._encrypted && encryptionEnabled && encryptionKey) {
        return await decryptData(data.data, encryptionKey);
    }
    return data;
}

// ============ Encryption Init Flow ============

// Initialize encryption system - called before anything else
async function initEncryption() {
    var config = getEncryptionConfig();

    if (!config) {
        // First time user - show setup screen
        showUnlockScreen('setup');
        return false;
    }

    if (config.type === 'none') {
        // User chose to skip encryption
        encryptionEnabled = false;
        encryptionKey = null;
        return true;
    }

    // Check for session key (survives page refresh within same tab)
    var sessionKey = await loadSessionKey();
    if (sessionKey && config.verificationToken) {
        try {
            await decryptData(config.verificationToken, sessionKey);
            // Session key is valid
            encryptionKey = sessionKey;
            encryptionEnabled = true;
            return true;
        } catch (e) {
            // Session key is stale or invalid
            clearSessionKey();
        }
    }

    // User has encryption set up - show unlock screen
    showUnlockScreen('prompt');
    return false;
}

// Only keep lightweight metadata in memory
var META_TABLES = {};
var META_FIELDS = {};
var META_VIEWS = {};

// Human-readable names for entity/event types
var ENTITY_TYPE_NAMES = {
    'data': 'Data',
    'INS': 'INS',
    'ALT': 'ALT',
    'NUL': 'NUL',
    'SYN': 'SYN',
    'table': 'Table',
    'field': 'Field',
    'view': 'View',
    'viewConfig': 'View Config',
    'tableSettings': 'Table Settings',
    'current': 'Current State'
};

var currentTable = null;
var currentView = null; // Current view ID or null for "All Fields" default
var currentPage = 0;
var currentRecordIds = [];
var totalRecords = 0;
var lastEventTimestamp = null; // ISO timestamp of last synced event
var pollInterval = null;
var navVersion = 0; // Navigation guard to prevent race conditions when rapidly switching views

// View field configuration cache (in-memory, persisted to IndexedDB)
// Structure: VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [...], fieldOrder: [...] }
// Note: Views default to showing ALL fields; hiddenFieldIds stores fields to hide
var VIEW_FIELD_CONFIG = {};

// View folders: Structure: VIEW_FOLDERS[tableId][folderId] = { folderId, folderName, parentFolderId, sortOrder, isExpanded }
var VIEW_FOLDERS = {};

// Workspaces: Structure: WORKSPACES[workspaceId] = { workspaceId, workspaceName, viewIds: [], sortOrder }
var WORKSPACES = {};
var currentWorkspace = null; // Current active workspace filter

// Table Settings: User-specific preferences for tables and views
// Structure: TABLE_SETTINGS = {
//   tables: {
//     [tableId]: {
//       visible: boolean,      // Whether table is visible in sidebar
//       sortOrder: number      // Custom sort order
//     }
//   },
//   tableOrder: string[],      // Array of tableIds in user's preferred order
//   views: {
//     [viewId]: {
//       isPublic: boolean,     // Whether view is public (shared) or private
//       sortOrder: number      // Custom sort order within table
//     }
//   }
// }
var TABLE_SETTINGS = {
    tables: {},
    tableOrder: [],
    views: {}
};

// ============ Sidebar Configuration ============
// Table type definitions with colors and icons
var TABLE_TYPE_CONFIG = {
    primary: {
        color: '#ef4444',
        label: 'Primary',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>'
    },
    events: {
        color: '#f59e0b',
        label: 'Events',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>'
    },
    syncStatus: {
        color: '#10b981',
        label: 'Sync Status',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>'
    },
    operational: {
        color: '#3b82f6',
        label: 'Operational',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="3" x2="21" y1="9" y2="9"/><line x1="3" x2="21" y1="15" y2="15"/><line x1="9" x2="9" y1="9" y2="21"/><line x1="15" x2="15" y1="9" y2="21"/></svg>'
    },
    collection: {
        color: '#8b5cf6',
        label: 'Collections',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>'
    },
    reference: {
        color: '#10b981',
        label: 'Reference',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg>'
    },
    dev: {
        color: '#6b7280',
        label: 'Dev / Testing',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>'
    },
    room: {
        color: '#6366f1',
        label: 'Rooms',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>'
    }
};

// Sidebar state (pinned tables, recent tables, expanded sections, search)
var SIDEBAR_STATE = {
    pinnedTables: [],
    recentTables: [],
    expandedSections: {
        primary: true,
        pinned: true,
        recent: true,
        operational: true,
        collections: false,
        reference: false,
        dev: false
    },
    searchQuery: '',
    maxRecentTables: 5
};

// Cache for sidebar data to avoid redundant DB queries on search/pin/section toggle
var _sidebarCache = {
    tables: null,
    tableCounts: null,
    maxCount: 0,
    eventsCount: 0,
    timestamp: 0
};
var SIDEBAR_CACHE_TTL = 30000; // 30 seconds

function invalidateSidebarCache() {
    _sidebarCache.tables = null;
    _sidebarCache.tableCounts = null;
    _sidebarCache.timestamp = 0;
}

// Determine table type based on name patterns
function getTableType(tableName) {
    var name = (tableName || '').toLowerCase();

    // Primary tables (always at top for everyone)
    if (name === 'client info') return 'primary';
    if (name === 'case master view') return 'primary';
    if (name === 'events') return 'primary';

    // Events
    if (name.includes('event') && name.includes('stream')) return 'events';

    // Collections (date patterns)
    if (name.includes('collection')) return 'collection';
    if (/\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/.test(name)) return 'collection';
    if (/\d{1,2}(st|nd|rd|th)?\s*-\s*\d{1,2}(st|nd|rd|th)?/.test(name)) return 'collection';

    // Reference (small lookup tables)
    if (name.includes('dictionary') || name.includes('appendix') || name.includes('info')) return 'reference';
    if (name.includes('type') && !name.includes('activity')) return 'reference';

    // Dev
    if (name.includes('test') || name.includes('dev') || name.includes('data test')) return 'dev';

    // Default to operational
    return 'operational';
}

// Format record count (e.g., 73262 -> "73.3k")
function formatRecordCount(count) {
    if (count >= 1000) return (count / 1000).toFixed(1) + 'k';
    return count.toString();
}

// Get count bar width ratio (logarithmic scale)
function getCountBarWidth(count, maxCount) {
    if (count <= 0 || maxCount <= 0) return 0;
    var ratio = Math.log(count + 1) / Math.log(maxCount + 1);
    return Math.max(0.15, ratio);
}

// Add table to recent list
function addToRecentTables(tableId) {
    if (tableId === '_events') return;
    var recent = SIDEBAR_STATE.recentTables.filter(id => id !== tableId);
    recent.unshift(tableId);
    SIDEBAR_STATE.recentTables = recent.slice(0, SIDEBAR_STATE.maxRecentTables);
    saveSidebarState();
}

// Toggle table pin
function toggleTablePin(tableId, event) {
    if (event) event.stopPropagation();
    var idx = SIDEBAR_STATE.pinnedTables.indexOf(tableId);
    if (idx >= 0) {
        SIDEBAR_STATE.pinnedTables.splice(idx, 1);
    } else {
        SIDEBAR_STATE.pinnedTables.push(tableId);
    }
    saveSidebarState();
    // Fast path: update pin button icon in-place instead of full sidebar rebuild
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var pinBtn = wrapper.querySelector('.pin-btn');
        if (pinBtn) {
            var isPinned = SIDEBAR_STATE.pinnedTables.includes(tableId);
            pinBtn.className = 'pin-btn' + (isPinned ? ' pinned' : '');
            pinBtn.title = isPinned ? 'Unpin' : 'Pin';
            pinBtn.innerHTML = isPinned ? SIDEBAR_ICONS.starFilled : SIDEBAR_ICONS.star;
        }
    }
    // Debounce the full re-render for structural changes (pinned section)
    _debouncedSidebarRender();
}

// Debounced sidebar render to coalesce rapid toggling
var _sidebarRenderTimer = null;
function _debouncedSidebarRender() {
    if (_sidebarRenderTimer) cancelAnimationFrame(_sidebarRenderTimer);
    _sidebarRenderTimer = requestAnimationFrame(function() {
        _sidebarRenderTimer = null;
        renderSidebar();
    });
}

// Toggle sidebar section
function toggleSidebarSection(sectionId) {
    var wasExpanded = SIDEBAR_STATE.expandedSections[sectionId];
    SIDEBAR_STATE.expandedSections[sectionId] = !wasExpanded;
    saveSidebarState();

    // Fast path for collapsing: just toggle CSS class on the header
    // (table items under it are already in the DOM, hidden by the collapsed state)
    // For expanding, we need a full render to populate the section's table items
    if (wasExpanded) {
        // Collapsing  fast DOM toggle
        var headers = document.querySelectorAll('.sidebar-section-header');
        for (var i = 0; i < headers.length; i++) {
            var hdr = headers[i];
            // Match by section ID stored in the onclick
            if (hdr.onclick && hdr._sectionId === sectionId) {
                hdr.classList.add('collapsed');
                // Hide the table wrappers that follow until next section header or divider
                var sibling = hdr.nextElementSibling;
                while (sibling && !sibling.classList.contains('sidebar-section-header') && !sibling.classList.contains('sidebar-divider')) {
                    sibling.style.display = 'none';
                    sibling = sibling.nextElementSibling;
                }
                return;
            }
        }
        // Fallback if we couldn't find the header
        renderSidebar();
    } else {
        // Expanding  need full render to build the section content
        renderSidebar();
    }
}

// Save sidebar state to localStorage
function saveSidebarState() {
    try {
        localStorage.setItem('aminoSidebarState', JSON.stringify(SIDEBAR_STATE));
    } catch (e) { /* ignore */ }
}

// Load sidebar state from localStorage
function loadSidebarState() {
    try {
        var saved = localStorage.getItem('aminoSidebarState');
        if (saved) {
            var parsed = JSON.parse(saved);
            SIDEBAR_STATE.pinnedTables = parsed.pinnedTables || [];
            SIDEBAR_STATE.recentTables = parsed.recentTables || [];
            SIDEBAR_STATE.expandedSections = Object.assign({}, SIDEBAR_STATE.expandedSections, parsed.expandedSections || {});
        }
    } catch (e) { /* ignore */ }
}

// Initialize sidebar search functionality
function initSidebarSearch() {
    var searchInput = document.getElementById('sidebar-search-input');
    if (!searchInput) return;

    var debounceTimer = null;

    // Search input handler with debounce - uses fast CSS-class-based filtering
    searchInput.addEventListener('input', function(e) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(function() {
            var newQuery = e.target.value;
            SIDEBAR_STATE.searchQuery = newQuery;
            // Use fast DOM filter if sidebar is already rendered (no need for full rebuild)
            if (_sidebarCache.tables) {
                filterSidebarDOM(newQuery);
            } else {
                renderSidebar();
            }
        }, 80); // Reduced from 150ms since CSS class toggling is much cheaper
    });

    // Clear search on Escape
    searchInput.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            searchInput.value = '';
            SIDEBAR_STATE.searchQuery = '';
            searchInput.blur();
            // Use fast DOM filter to restore all items
            if (_sidebarCache.tables) {
                filterSidebarDOM('');
            } else {
                renderSidebar();
            }
        }
    });

    // Keyboard shortcut: Cmd+K / Ctrl+K to focus search
    document.addEventListener('keydown', function(e) {
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            searchInput.focus();
            searchInput.select();
        }
    });
}

// SVG icons for sidebar
var SIDEBAR_ICONS = {
    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>',
    star: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    starFilled: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    clock: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>'
};

// Pending view action (when user tries to modify default view)
var pendingViewAction = null; // { action: 'filter'|'sort'|'fields'|'group', data: any }


// ============ Events View State ============
var eventsPageSize = 50;
var eventsTypeFilter = ''; // 'INS', 'ALT', 'NUL', 'SYN', 'table', 'field', 'view', 'viewConfig', or '' for all
var eventsSetFilter = ''; // Filter by set (table id)
var eventsSearchQuery = '';
var expandedPayloads = new Set(); // Set of event IDs with expanded payloads
var appOpenedEventId = 0; // Highest event ID when app was opened (events with higher IDs are "new")

// Infinite scroll state
var loadedEvents = []; // Currently loaded events (capped to MAX_LOADED_EVENTS)
var MAX_LOADED_EVENTS = 2000; // Cap to prevent unbounded memory growth
var eventsOffset = 0; // Current offset for loading more
var isLoadingMoreEvents = false; // Prevent multiple simultaneous loads
var hasMoreEvents = true; // Whether there are more events to load
var eventsScrollHandler = null; // Reference to scroll handler for cleanup

// Events view tab state: 'events', 'changelog', or 'room-access'
var eventsActiveTab = 'events';

// Room access tab state
var roomAccessSnapshot = [];
var roomAccessRefreshTimer = null;
var roomAccessRefreshInFlight = false;
var ROOM_ACCESS_REFRESH_MS = 5000;

// Changelog state (drawn from Matrix room data)
var changelogEntries = [];
var changelogPaginationTokens = {};
var changelogHasMore = true;
var changelogIsLoading = false;
var changelogTableFilter = '';
var changelogScrollHandler = null;

// In-memory event cache for fast startup from file import
// Events are loaded into memory first for instant UI, then saved to IndexedDB in background
var inMemoryEvents = null; // Array of events or null if not using memory cache
var inMemoryEventsByRecord = null; // Map of recordId -> array of events for fast lookup
var isBackgroundSaveInProgress = false; // Track background IndexedDB save status

// ============ View Auto-Save System ============
var AUTO_SAVE_DELAY = 5 * 60 * 1000; // 5 minutes
var autoSaveTimer = null;

var viewDirtyState = {
    isDirty: false,
    lastEditTime: null,
    pendingChanges: {
        tableId: null,
        viewId: null,
        changes: {}
    }
};

// ============ AminoSync - Event Stream Client (Deprecated - Xano removed) ============
// Data flows one way: Airtable  n8n  Matrix. The client does NOT write events.
// This stub is kept for backward compatibility with any code that references AminoSync.
var AminoSync = {
    async postEvent(event) {
        throw new Error('Direct event posting is not supported. Data flows from Airtable  n8n  Matrix.');
    }
};

// ============ AmoFormat - Binary Event Stream Format (.amo) ============
// Compact binary representation using MessagePack + gzip with columnar compression.
// Extension: .amo | MIME: application/x-amino-snapshot

var AmoFormat = {
    MAGIC: 'AMO1',
    VERSION: 1,
    HEADER_SIZE: 8,

    // Produce a .amo binary from the full event stream
    // events: array of raw aminoStream events (id, set, recordId, operator, created_at, payload, uuid, ...)
    // meta: optional { tables: META_TABLES, fields: META_FIELDS } to preserve table/field names
    // Returns: Uint8Array
    produceEvents: function(events, meta) {
        // Collect all unique keys across all events for the columnar schema
        var colSet = {};
        for (var i = 0; i < events.length; i++) {
            var keys = Object.keys(events[i]);
            for (var k = 0; k < keys.length; k++) {
                // Skip encrypted payload marker  we store the decrypted payload
                if (keys[k] !== '_encryptedPayload') {
                    colSet[keys[k]] = true;
                }
            }
        }
        // Ensure core columns come first for readability
        var coreColumns = ['id', 'set', 'recordId', 'operator', 'created_at', 'payload', 'uuid'];
        var columns = [];
        for (var c = 0; c < coreColumns.length; c++) {
            if (colSet[coreColumns[c]]) {
                columns.push(coreColumns[c]);
                delete colSet[coreColumns[c]];
            }
        }
        var extra = Object.keys(colSet);
        for (var e = 0; e < extra.length; e++) {
            columns.push(extra[e]);
        }

        // Convert events to positional arrays
        var rows = [];
        var maxId = 0;
        for (var j = 0; j < events.length; j++) {
            var ev = events[j];
            var row = [];
            for (var col = 0; col < columns.length; col++) {
                var val = ev[columns[col]];
                row.push(val !== undefined ? val : null);
            }
            rows.push(row);
            if (ev.id > maxId) maxId = ev.id;
        }

        var schema = { '_events': columns };
        var records = { '_events': rows };

        // Encode payload with MessagePack
        var payload = { v: 1, type: 'events', ts: Math.floor(Date.now() / 1000), cursor: maxId, schema: schema, records: records };
        if (meta) payload.meta = meta;
        var encoded = MessagePack.encode(payload);

        // Compress with gzip
        var compressed = pako.gzip(encoded);

        // Prepend 8-byte header: "AMO1" + version(1) + flags(0) + reserved(0,0)
        var header = new Uint8Array([0x41, 0x4D, 0x4F, 0x31, 0x01, 0x00, 0x00, 0x00]);
        var out = new Uint8Array(8 + compressed.length);
        out.set(header);
        out.set(compressed, 8);
        return out;
    },

    // Read a .amo binary file
    // arrayBuffer: ArrayBuffer or Uint8Array of the .amo file
    // Returns: { type: 'events'|'snapshot', events?: [...], tables?: {...}, cursor, ts, meta? }
    read: function(arrayBuffer) {
        var bytes = new Uint8Array(arrayBuffer);

        // Validate header
        if (bytes.length < this.HEADER_SIZE) {
            throw new Error('File too small to be a .amo file');
        }
        var magic = String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]);
        if (magic !== this.MAGIC) {
            throw new Error('Not a .amo file (bad magic bytes)');
        }
        if (bytes[4] !== this.VERSION) {
            throw new Error('Unknown .amo version: ' + bytes[4]);
        }
        if (bytes[5] !== 0x00) {
            throw new Error('Unsupported .amo flags: 0x' + bytes[5].toString(16));
        }

        // Decompress + decode
        var compressed = bytes.slice(this.HEADER_SIZE);
        var decompressed = pako.ungzip(compressed);
        var payload = MessagePack.decode(decompressed);

        // Check if this is the new events format
        if (payload.type === 'events') {
            var columns = payload.schema['_events'];
            var rows = payload.records['_events'] || [];
            var events = [];
            for (var j = 0; j < rows.length; j++) {
                var obj = {};
                for (var k = 0; k < columns.length; k++) {
                    obj[columns[k]] = (k < rows[j].length) ? (rows[j][k] !== undefined ? rows[j][k] : null) : null;
                }
                events.push(obj);
            }
            var result = { type: 'events', events: events, cursor: payload.cursor, ts: payload.ts };
            if (payload.meta) result.meta = payload.meta;
            return result;
        }

        // Legacy snapshot format: re-hydrate positional arrays back into objects
        var tables = {};
        var schemaEntries = Object.entries(payload.schema);
        for (var i = 0; i < schemaEntries.length; i++) {
            var tableName = schemaEntries[i][0];
            var cols = schemaEntries[i][1];
            var tblRows = payload.records[tableName] || [];
            tables[tableName] = [];
            for (var j2 = 0; j2 < tblRows.length; j2++) {
                var obj2 = {};
                for (var k2 = 0; k2 < cols.length; k2++) {
                    obj2[cols[k2]] = (k2 < tblRows[j2].length) ? (tblRows[j2][k2] !== undefined ? tblRows[j2][k2] : null) : null;
                }
                tables[tableName].push(obj2);
            }
        }

        var result2 = { type: 'snapshot', tables: tables, cursor: payload.cursor, ts: payload.ts };
        if (payload.meta) result2.meta = payload.meta;
        return result2;
    },

    // Detect the format of a buffer
    // Returns: 'amo' | 'json-gz' | 'json' | 'csv'
    detectFormat: function(buffer) {
        var b = new Uint8Array(buffer.slice(0, 4));
        if (b[0] === 0x41 && b[1] === 0x4D && b[2] === 0x4F && b[3] === 0x31) return 'amo';
        if (b[0] === 0x1F && b[1] === 0x8B) return 'json-gz';
        if (b[0] === 0x7B || b[0] === 0x5B) return 'json';
        // Check for CSV: first line should be printable ASCII text with commas
        try {
            var preview = new TextDecoder().decode(new Uint8Array(buffer.slice(0, 2048)));
            var firstLine = preview.split(/\r?\n/)[0];
            if (firstLine && firstLine.indexOf(',') !== -1) {
                // Look for the required 'id' column in the CSV header
                var cols = firstLine.split(',');
                for (var ci = 0; ci < cols.length; ci++) {
                    if (cols[ci].replace(/"/g, '').trim() === 'id') return 'csv';
                }
            }
        } catch (e) {}
        throw new Error('Unknown format');
    }
};

// ============ Sync Status Feed ============
// Terminal-style log for sync activity visibility

var SyncStatusFeed = {
    maxLines: 100,
    lines: [],
    isVisible: false,
    isActive: false,

    // Log a message to the feed
    log(message, type) {
        type = type || 'info';
        var timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        this.lines.push({ timestamp: timestamp, message: message, type: type });

        // Trim to max lines
        if (this.lines.length > this.maxLines) {
            this.lines = this.lines.slice(-this.maxLines);
        }

        this.render();
        this.updateButton();
    },

    info(message) { this.log(message, 'info'); },
    success(message) { this.log(message, 'success'); },
    error(message) { this.log(message, 'error'); },
    warn(message) { this.log(message, 'warn'); },

    // Set active state (sync in progress)
    setActive(active) {
        this.isActive = active;
        var dot = document.getElementById('sync-feed-status-dot');
        if (dot) {
            dot.className = 'sync-feed-status-dot' + (active ? ' active' : '');
        }
        this.updateStats();
    },

    // Set error state
    setError() {
        var dot = document.getElementById('sync-feed-status-dot');
        if (dot) {
            dot.className = 'sync-feed-status-dot error';
        }
    },

    // Update the [log] button to indicate activity
    updateButton() {
        var btn = document.getElementById('sync-feed-btn');
        if (btn && this.lines.length > 0) {
            btn.classList.add('has-activity');
        }
    },

    // Update stats display
    updateStats() {
        var statsEl = document.getElementById('sync-feed-stats');
        if (statsEl) {
            statsEl.textContent = 'Idle';
        }
    },

    // Render the feed content
    render() {
        var body = document.getElementById('sync-feed-body');
        if (!body) return;

        if (this.lines.length === 0) {
            body.innerHTML = '<div class="sync-feed-empty">No sync activity yet</div>';
            return;
        }

        var html = '';
        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];
            html += '<div class="sync-feed-line ' + line.type + '">';
            html += '<span class="timestamp">' + line.timestamp + '</span>';
            html += '<span class="message">' + esc(line.message) + '</span>';
            html += '</div>';
        }
        body.innerHTML = html;

        // Auto-scroll to bottom
        body.scrollTop = body.scrollHeight;
    },

    // Show the panel
    show() {
        var panel = document.getElementById('sync-feed-panel');
        if (panel) {
            panel.classList.add('visible');
            this.isVisible = true;
            this.updateStats();
        }
    },

    // Hide the panel
    hide() {
        var panel = document.getElementById('sync-feed-panel');
        if (panel) {
            panel.classList.remove('visible');
            this.isVisible = false;
        }
    },

    // Toggle visibility
    toggle() {
        if (this.isVisible) {
            this.hide();
        } else {
            this.show();
        }
    },

    // Clear all lines
    clear() {
        this.lines = [];
        this.render();
        var btn = document.getElementById('sync-feed-btn');
        if (btn) btn.classList.remove('has-activity');
    }
};

// ============ Sync History Tracker ============
// Tracks all sync operations for the Sync Status view

var SyncHistory = {
    maxEntries: 200,
    entries: [],
    pollInterval: null,
    POLL_INTERVAL: 15000, // 15 seconds - base poll interval
    MAX_POLL_INTERVAL: 300000, // 5 minutes - max backoff cap
    isPolling: false,
    consecutiveFailures: 0,
    currentPollInterval: 15000, // tracks the active interval (may be backed off)
    listeners: [],

    // Calculate next poll interval with exponential backoff + jitter
    getBackoffInterval() {
        if (this.consecutiveFailures === 0) return this.POLL_INTERVAL;
        // Exponential backoff: base * 2^failures, capped at MAX_POLL_INTERVAL
        var exponential = this.POLL_INTERVAL * Math.pow(2, this.consecutiveFailures);
        var capped = Math.min(exponential, this.MAX_POLL_INTERVAL);
        // Add jitter: +/- 20% to avoid thundering herd
        var jitter = capped * 0.2 * (Math.random() * 2 - 1);
        return Math.round(capped + jitter);
    },

    // Record a sync operation
    record(entry) {
        this.entries.unshift({
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 5),
            timestamp: new Date(),
            type: entry.type || 'incremental',    // 'incremental', 'full', 'snapshot', 'poll'
            result: entry.result || 'success',      // 'success', 'error', 'no-change'
            eventsFound: entry.eventsFound || 0,
            snapshotsUpdated: entry.snapshotsUpdated || 0,
            duration: entry.duration || 0,
            detail: entry.detail || '',
            error: entry.error || null
        });
        if (this.entries.length > this.maxEntries) {
            this.entries = this.entries.slice(0, this.maxEntries);
        }
        this.notify();
    },

    // Poll for new events via n8n webhook API (incremental sync)
    async pollForUpdates() {
        var startTime = Date.now();
        try {
            var updated = await webhookIncrementalSync();
            var duration = Date.now() - startTime;

            if (updated > 0) {
                this.consecutiveFailures = 0;
                this.record({
                    type: 'poll',
                    result: 'success',
                    eventsFound: updated,
                    duration: duration,
                    detail: 'Webhook poll: ' + updated + ' records updated'
                });
                // Re-render current view
                if (currentTable) {
                    await showTable(currentTable, true);
                }
                await renderSidebar(false);
            } else {
                this.record({
                    type: 'poll',
                    result: 'no-change',
                    eventsFound: 0,
                    duration: duration,
                    detail: 'Webhook poll: no changes'
                });
            }

            if (this.isPolling) this.scheduleNextPoll();
        } catch (err) {
            var duration = Date.now() - startTime;
            this.consecutiveFailures++;
            this.currentPollInterval = this.getBackoffInterval();
            this.record({
                type: 'poll',
                result: 'error',
                eventsFound: 0,
                duration: duration,
                error: err.message,
                detail: 'Webhook poll failed: ' + err.message
            });
            if (this.isPolling) this.scheduleNextPoll();
        }
    },

    // Schedule the next poll using setTimeout (allows dynamic interval changes)
    scheduleNextPoll() {
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
        }
        var interval = this.consecutiveFailures > 0 ? this.currentPollInterval : this.POLL_INTERVAL;
        this.currentPollInterval = interval;
        this.pollInterval = setTimeout(() => this.pollForUpdates(), interval);
    },

    // Start background polling
    startPolling() {
        if (this.isPolling) return;
        this.isPolling = true;
        this.consecutiveFailures = 0;
        this.currentPollInterval = this.POLL_INTERVAL;
        this.scheduleNextPoll();
        this.record({ type: 'poll', result: 'no-change', detail: 'Webhook polling started (' + (this.POLL_INTERVAL / 1000) + 's interval)' });
    },

    // Stop background polling
    stopPolling() {
        this.isPolling = false;
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
            this.pollInterval = null;
            this.consecutiveFailures = 0;
            this.currentPollInterval = this.POLL_INTERVAL;
            this.record({ type: 'poll', result: 'no-change', detail: 'Webhook polling stopped' });
        }
    },

    // Get summary stats
    getStats() {
        var now = Date.now();
        var last5min = this.entries.filter(e => (now - e.timestamp.getTime()) < 300000);
        var lastHour = this.entries.filter(e => (now - e.timestamp.getTime()) < 3600000);
        var errors = this.entries.filter(e => e.result === 'error');
        var totalEvents = this.entries.reduce((sum, e) => sum + (e.eventsFound || 0), 0);
        var totalSnapshots = this.entries.reduce((sum, e) => sum + (e.snapshotsUpdated || 0), 0);
        var lastSync = this.entries.find(e => e.type !== 'poll' && e.result === 'success');
        var lastPoll = this.entries.find(e => e.type === 'poll');

        var edits = this.entries.filter(e => e.type === 'edit');
        var successfulEdits = edits.filter(e => e.result === 'success');
        var failedEdits = edits.filter(e => e.result === 'error');
        var totalFieldsEdited = successfulEdits.reduce((sum, e) => sum + (e.eventsFound || 0), 0);

        return {
            totalSyncs: this.entries.filter(e => e.type !== 'poll' && e.type !== 'edit').length,
            totalPolls: this.entries.filter(e => e.type === 'poll').length,
            totalEdits: edits.length,
            successfulEdits: successfulEdits.length,
            failedEdits: failedEdits.length,
            totalFieldsEdited: totalFieldsEdited,
            last5minOps: last5min.length,
            lastHourOps: lastHour.length,
            totalEventsProcessed: totalEvents,
            totalSnapshotsUpdated: totalSnapshots,
            errorCount: errors.length,
            lastSyncTime: lastSync ? lastSync.timestamp : null,
            lastPollTime: lastPoll ? lastPoll.timestamp : null,
            isPolling: this.isPolling
        };
    },

    // Subscribe to changes (for live UI updates)
    onChange(fn) {
        this.listeners.push(fn);
        return () => { this.listeners = this.listeners.filter(l => l !== fn); };
    },

    notify() {
        this.listeners.forEach(fn => { try { fn(); } catch(e) {} });
    }
};

// ============ Offline Sync Queue ============
// Persists failed edits to IndexedDB so they survive page reloads and can be
// retried when the network comes back. Exposes a count for the sync status UI.

var OfflineSyncQueue = {
    _draining: false,
    _listeners: [],
    MAX_RETRIES: 5,

    // Enqueue a failed edit into the pendingEdits store
    async enqueue(tableId, recordId, fieldChanges, errorMessage) {
        var entry = {
            tableId: tableId,
            recordId: recordId,
            fieldChanges: fieldChanges,
            status: 'pending',      // pending | retrying | failed
            retries: 0,
            error: errorMessage || 'Unknown error',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        await new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readwrite');
            tx.objectStore('pendingEdits').add(entry);
            tx.oncomplete = function() { resolve(); };
            tx.onerror = function() { reject(tx.error); };
        });
        this._notify();
        SyncStatusFeed.warn('Edit queued offline: ' + recordId + '  will retry when online');
    },

    // Get all pending entries
    async getAll() {
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readonly');
            var req = tx.objectStore('pendingEdits').getAll();
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });
    },

    // Get count of pending entries
    async getCount() {
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readonly');
            var req = tx.objectStore('pendingEdits').count();
            req.onsuccess = function() { resolve(req.result || 0); };
            req.onerror = function() { reject(req.error); };
        });
    },

    // Remove a successfully synced entry by id
    async remove(id) {
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readwrite');
            tx.objectStore('pendingEdits').delete(id);
            tx.oncomplete = function() { resolve(); };
            tx.onerror = function() { reject(tx.error); };
        });
    },

    // Update an entry (e.g. bump retries, mark failed)
    async _update(entry) {
        entry.updatedAt = new Date().toISOString();
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readwrite');
            tx.objectStore('pendingEdits').put(entry);
            tx.oncomplete = function() { resolve(); };
            tx.onerror = function() { reject(tx.error); };
        });
    },

    // Drain the queue: attempt to replay all pending edits
    async drain() {
        if (this._draining) return;
        this._draining = true;

        try {
            var entries = await this.getAll();
            var pending = entries.filter(function(e) { return e.status === 'pending'; });
            if (pending.length === 0) { this._draining = false; return; }

            SyncStatusFeed.info('Draining offline queue: ' + pending.length + ' edit' + (pending.length !== 1 ? 's' : '') + ' to retry');

            var _syncedCount = 0;
            var _failedCount = 0;

            for (var i = 0; i < pending.length; i++) {
                var entry = pending[i];
                entry.status = 'retrying';
                entry.retries++;
                await this._update(entry);
                this._notify();

                try {
                    var session = _loadSynapseSession();
                    if (!session || !session.accessToken) throw new Error('Not authenticated');

                    var writeUrl = WRITE_API_BASE;
                    var writeBody = JSON.stringify({
                        tableId: entry.tableId,
                        recordId: entry.recordId,
                        fields: entry.fieldChanges
                    });

                    var response = await fetch(
                        writeUrl + '?access_token=' + encodeURIComponent(session.accessToken),
                        { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: writeBody }
                    );

                    if (!response.ok) throw new Error('Server returned ' + response.status);

                    var result = await response.json();

                    // Update local store with canonical data
                    if (result.fields) {
                        await saveDataRecord({ tableId: entry.tableId, recordId: entry.recordId, fields: result.fields });
                        if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[entry.tableId] && window.IN_MEMORY_DATA[entry.tableId][entry.recordId]) {
                            window.IN_MEMORY_DATA[entry.tableId][entry.recordId] = result.fields;
                        }
                        window.dispatchEvent(new CustomEvent('amino:record-updated', {
                            detail: { recordId: entry.recordId, tableId: entry.tableId, fields: result.fields, optimistic: false }
                        }));
                    }

                    // Success  remove from queue
                    await this.remove(entry.id);
                    SyncHistory.record({
                        type: 'edit',
                        result: 'success',
                        eventsFound: Object.keys(entry.fieldChanges).length,
                        duration: 0,
                        detail: 'Queued edit replayed: ' + entry.recordId
                    });
                    SyncStatusFeed.success('Queued edit synced: ' + entry.recordId);
                    _syncedCount++;

                } catch (retryErr) {
                    if (entry.retries >= this.MAX_RETRIES) {
                        entry.status = 'failed';
                        entry.error = retryErr.message;
                        await this._update(entry);
                        SyncStatusFeed.error('Queued edit permanently failed after ' + entry.retries + ' retries: ' + entry.recordId);
                        _failedCount++;
                    } else {
                        entry.status = 'pending';
                        entry.error = retryErr.message;
                        await this._update(entry);
                    }
                }
                this._notify();
            }

            // Show summary toast if the user has sync toasts enabled
            if (UserPreferences.get('showOfflineSyncToasts')) {
                if (_syncedCount > 0 && _failedCount === 0) {
                    showToast('success', _syncedCount + ' offline edit' + (_syncedCount !== 1 ? 's' : '') + ' synced');
                } else if (_syncedCount > 0 && _failedCount > 0) {
                    showToast('warning', _syncedCount + ' edit' + (_syncedCount !== 1 ? 's' : '') + ' synced, ' + _failedCount + ' failed');
                } else if (_failedCount > 0) {
                    showToast('error', _failedCount + ' offline edit' + (_failedCount !== 1 ? 's' : '') + ' failed to sync');
                }
            }
        } finally {
            this._draining = false;
            this._notify();
        }
    },

    // Discard a specific queued entry (user action)
    async discard(id) {
        await this.remove(id);
        this._notify();
        SyncStatusFeed.info('Queued edit discarded');
    },

    // Discard all queued entries
    async discardAll() {
        var entries = await this.getAll();
        for (var i = 0; i < entries.length; i++) {
            await this.remove(entries[i].id);
        }
        this._notify();
        SyncStatusFeed.info('All queued edits discarded');
    },

    // Listener management
    onChange(fn) {
        this._listeners.push(fn);
        return function() { OfflineSyncQueue._listeners = OfflineSyncQueue._listeners.filter(function(l) { return l !== fn; }); };
    },

    _notify() {
        this._listeners.forEach(function(fn) { try { fn(); } catch(e) {} });
    }
};

// ============ Online/Offline Detection for Queue Drain ============

window.addEventListener('online', function() {
    SyncStatusFeed.info('Network connection restored');
    // Auto-drain offline queue when back online
    if (db) {
        OfflineSyncQueue.drain();
    }
});

window.addEventListener('offline', function() {
    SyncStatusFeed.warn('Network connection lost  edits will be queued locally');
});

// ============ Post-Hydration Auto-Poll (Deprecated) ============
// No longer needed  Matrix /sync handles incremental updates after initial hydration.
var PostHydrationSync = {
    isRunning: false,
    start() { /* no-op: Matrix /sync handles post-hydration updates */ },
    stop() { this.isRunning = false; }
};


// ============ IndexedDB ============

function openDB() {
    return new Promise((resolve, reject) => {
        var req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve(req.result);
        req.onupgradeneeded = (e) => {
            var db = e.target.result;

            // Delete old stores if they exist
            if (db.objectStoreNames.contains('records')) {
                db.deleteObjectStore('records');
            }
            if (db.objectStoreNames.contains('meta')) {
                db.deleteObjectStore('meta');
            }

            // Data records: keyed by [tableId, recordId]
            if (!db.objectStoreNames.contains('data')) {
                var dataStore = db.createObjectStore('data', { keyPath: ['tableId', 'recordId'] });
                dataStore.createIndex('by_table', 'tableId');
            }

            // Table metadata
            if (!db.objectStoreNames.contains('tables')) {
                db.createObjectStore('tables', { keyPath: 'tableId' });
            }

            // Field metadata: keyed by [tableId, fieldId]
            if (!db.objectStoreNames.contains('fields')) {
                var fieldStore = db.createObjectStore('fields', { keyPath: ['tableId', 'fieldId'] });
                fieldStore.createIndex('by_table', 'tableId');
            }

            // View metadata: keyed by [tableId, viewId]
            if (!db.objectStoreNames.contains('views')) {
                var viewStore = db.createObjectStore('views', { keyPath: ['tableId', 'viewId'] });
                viewStore.createIndex('by_table', 'tableId');
            }

            // Field history: keyed by auto-increment, indexed by record and field
            if (!db.objectStoreNames.contains('fieldHistory')) {
                var historyStore = db.createObjectStore('fieldHistory', { keyPath: 'id', autoIncrement: true });
                historyStore.createIndex('by_record', ['tableId', 'recordId']);
                historyStore.createIndex('by_field', ['tableId', 'recordId', 'fieldId']);
                historyStore.createIndex('by_event', 'eventId');
            }

            // View folders: keyed by folderId
            if (!db.objectStoreNames.contains('viewFolders')) {
                var folderStore = db.createObjectStore('viewFolders', { keyPath: 'folderId' });
                folderStore.createIndex('by_table', 'tableId');
            }

            // Workspaces: keyed by workspaceId
            if (!db.objectStoreNames.contains('workspaces')) {
                db.createObjectStore('workspaces', { keyPath: 'workspaceId' });
            }

            // Sync state
            if (!db.objectStoreNames.contains('sync')) {
                db.createObjectStore('sync', { keyPath: 'key' });
            }

            // Raw events: keyed by event id, indexed by set and recordId
            if (!db.objectStoreNames.contains('events')) {
                var eventsStore = db.createObjectStore('events', { keyPath: 'id' });
                eventsStore.createIndex('by_set', 'set');
                eventsStore.createIndex('by_record', 'recordId');
                eventsStore.createIndex('by_timestamp', 'created_at');
            }

            // Snapshot: materialized current state, keyed by record_id
            if (!db.objectStoreNames.contains('snapshot')) {
                var snapshotStore = db.createObjectStore('snapshot', { keyPath: 'record_id' });
                snapshotStore.createIndex('by_source_table', 'source_table');
                snapshotStore.createIndex('by_last_amino_event', 'last_amino_event');
            }

            // User preferences: per-user settings keyed by preference key
            if (!db.objectStoreNames.contains('userPreferences')) {
                db.createObjectStore('userPreferences', { keyPath: 'key' });
            }

            // Shared views: views shared with/by users, keyed by [tableId, viewId]
            if (!db.objectStoreNames.contains('sharedViews')) {
                var sharedViewStore = db.createObjectStore('sharedViews', { keyPath: ['tableId', 'viewId'] });
                sharedViewStore.createIndex('by_table', 'tableId');
                sharedViewStore.createIndex('by_owner', 'ownerId');
                sharedViewStore.createIndex('by_sharing', 'sharing');
            }

            // Pending edits: offline queue for edits that failed to sync to cloud
            if (!db.objectStoreNames.contains('pendingEdits')) {
                var pendingStore = db.createObjectStore('pendingEdits', { keyPath: 'id', autoIncrement: true });
                pendingStore.createIndex('by_table', 'tableId');
                pendingStore.createIndex('by_record', ['tableId', 'recordId']);
                pendingStore.createIndex('by_status', 'status');
            }
        };
    });
}

function getSyncMeta(key) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readonly');
        var req = tx.objectStore('sync').get(key);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
        req.onerror = () => reject(req.error);
    });
}

function setSyncMeta(key, value) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readwrite');
        tx.objectStore('sync').put({ key, value });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// ============ Events Store Functions ============

// Encrypt event payloads for storage
async function encryptEventForStorage(event) {
    if (!encryptionEnabled || !encryptionKey || !event.payload) {
        return event;
    }
    var encrypted = { ...event };
    encrypted._encryptedPayload = await encryptData(event.payload, encryptionKey);
    delete encrypted.payload;
    return encrypted;
}

// Decrypt event payload after retrieval
async function decryptEventFromStorage(event) {
    if (!event || !event._encryptedPayload || !encryptionEnabled || !encryptionKey) {
        return event;
    }
    var decrypted = { ...event };
    decrypted.payload = await decryptData(event._encryptedPayload, encryptionKey);
    delete decrypted._encryptedPayload;
    return decrypted;
}

// Encrypt data record fields for storage
async function encryptRecordForStorage(record) {
    if (!encryptionEnabled || !encryptionKey || !record.fields) {
        return record;
    }
    var encrypted = { ...record };
    encrypted._encryptedFields = await encryptData(record.fields, encryptionKey);
    delete encrypted.fields;
    return encrypted;
}

// Decrypt data record fields after retrieval
async function decryptRecordFromStorage(record) {
    if (!record || !record._encryptedFields || !encryptionEnabled || !encryptionKey) {
        return record;
    }
    var decrypted = { ...record };
    decrypted.fields = await decryptData(record._encryptedFields, encryptionKey);
    delete decrypted._encryptedFields;
    return decrypted;
}

async function saveRawEvents(events) {
    if (!events || events.length === 0) return;

    // Encrypt events if encryption is enabled
    var eventsToStore = events;
    if (encryptionEnabled && encryptionKey) {
        eventsToStore = await Promise.all(events.map(e => encryptEventForStorage(e)));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readwrite');
        var store = tx.objectStore('events');
        eventsToStore.forEach(e => store.put(e));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function getAllRawEvents(limit, offset) {
    var maxLimit = limit || 100;
    var startOffset = offset || 0;

    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        // Events are sorted by ID ascending, we want newest first (descending)
        // Iterate in reverse and collect only the slice we need (avoids copying entire array)
        var results = [];
        var end = inMemoryEvents.length - 1 - startOffset;
        var start = Math.max(end - maxLimit + 1, 0);
        for (var i = end; i >= start && results.length < maxLimit; i--) {
            results.push(inMemoryEvents[i]);
        }
        return results;
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;
        var collected = 0;

        // Use a cursor to iterate in reverse order (newest first)
        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor && collected < maxLimit) {
                if (skipped < startOffset) {
                    skipped++;
                    cursor.continue();
                } else {
                    results.push(cursor.value);
                    collected++;
                    cursor.continue();
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getRawEventsCount() {
    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        return Promise.resolve(inMemoryEvents.length);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var req = tx.objectStore('events').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

async function getRawEventsByRecordId(recordId, maxEventId) {
    // Check in-memory events first (from CSV import)
    if (inMemoryEventsByRecord && inMemoryEventsByRecord.has(recordId)) {
        var results = inMemoryEventsByRecord.get(recordId).slice();
        if (maxEventId) {
            results = results.filter(e => e.id <= maxEventId);
        }
        results.sort((a, b) => (a.id || 0) - (b.id || 0));
        return results;
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var index = tx.objectStore('events').index('by_record');
        var req = index.getAll(recordId);
        req.onsuccess = () => {
            var results = req.result || [];
            // Filter to events up to maxEventId and sort by id ascending
            if (maxEventId) {
                results = results.filter(e => e.id <= maxEventId);
            }
            results.sort((a, b) => (a.id || 0) - (b.id || 0));
            resolve(results);
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getRawEventsBySet(setFilter) {
    // DEPRECATED: Use getRawEventsBySetPaginated instead
    return getRawEventsBySetPaginated(setFilter, 0, 500);
}

// Memory-efficient paginated events by set retrieval
async function getRawEventsBySetPaginated(setFilter, offset, limit) {
    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        var filtered = [];
        for (var i = inMemoryEvents.length - 1; i >= 0; i--) {
            if (inMemoryEvents[i].set === setFilter) {
                filtered.push(inMemoryEvents[i]);
            }
        }
        return filtered.slice(offset, offset + limit);
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var index = tx.objectStore('events').index('by_set');

        // Get all matching, then sort and paginate
        // Note: IndexedDB index doesn't support ordering by different field, so we collect and sort
        var req = index.getAll(setFilter);
        req.onsuccess = () => {
            var all = req.result || [];
            all.sort((a, b) => (b.id || 0) - (a.id || 0)); // Newest first
            // Apply pagination
            resolve(all.slice(offset, offset + limit));
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function searchRawEvents(query, limit, offset) {
    var maxLimit = limit || 100;
    var skipCount = offset || 0;
    var lowerQuery = query.toLowerCase();

    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        var results = [];
        var skipped = 0;
        for (var i = inMemoryEvents.length - 1; i >= 0 && results.length < maxLimit; i--) {
            var event = inMemoryEvents[i];
            var matchesRecord = event.recordId && event.recordId.toLowerCase().includes(lowerQuery);
            var matchesSet = event.set && event.set.toLowerCase().includes(lowerQuery);
            var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);
            var matchesPayload = payloadStr && payloadStr.toLowerCase().includes(lowerQuery);

            if (matchesRecord || matchesSet || matchesPayload) {
                if (skipped < skipCount) {
                    skipped++;
                } else {
                    results.push(event);
                }
            }
        }
        return Promise.resolve(results);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;

        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                var event = cursor.value;
                // Search in recordId, set, and payload
                var matchesRecord = event.recordId && event.recordId.toLowerCase().includes(lowerQuery);
                var matchesSet = event.set && event.set.toLowerCase().includes(lowerQuery);
                var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);
                var matchesPayload = payloadStr && payloadStr.toLowerCase().includes(lowerQuery);

                if (matchesRecord || matchesSet || matchesPayload) {
                    if (skipped < skipCount) {
                        skipped++;
                        cursor.continue();
                    } else if (results.length < maxLimit) {
                        results.push(event);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                } else {
                    cursor.continue();
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

function getMaxEventId() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var req = store.openCursor(null, 'prev'); // Open cursor in reverse to get highest ID first
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                resolve(cursor.value.id || 0);
            } else {
                resolve(0); // No events
            }
        };
        req.onerror = () => reject(req.error);
    });
}

function getAllRawEventsNoPagination() {
    // DEPRECATED: Use getRawEventsPaginated instead to avoid memory issues
    return getRawEventsPaginated(0, 500); // Return max 500 events
}

// Memory-efficient paginated events retrieval using IndexedDB cursor
async function getRawEventsPaginated(offset, limit) {
    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;

        // Use cursor in reverse order (newest first, highest ID first)
        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                if (skipped < offset) {
                    skipped++;
                    cursor.continue();
                } else if (results.length < limit) {
                    results.push(cursor.value);
                    cursor.continue();
                } else {
                    resolve(results);
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

// Get total count of raw events
function getRawEventsTotalCount() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var req = tx.objectStore('events').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

// Get all current records from all tables as synthetic event-like objects
// DEPRECATED: Use getCurrentRecordsPaginated instead to avoid memory issues
function getAllCurrentRecords() {
    return getCurrentRecordsPaginated(0, 500); // Return max 500 records
}

// Memory-efficient paginated current records retrieval
function getCurrentRecordsPaginated(offset, limit, tableFilter, searchQuery) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var results = [];
        var skipped = 0;
        var setFilter = tableFilter || null;
        var query = searchQuery ? searchQuery.toLowerCase() : null;

        var req = store.openCursor();
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                var rec = cursor.value;
                var setVal = 'airtable:' + rec.tableId;

                // Apply table filter if set
                if (setFilter && setVal !== setFilter) {
                    cursor.continue();
                    return;
                }

                // Apply search filter if set
                if (query) {
                    var matchesSearch = (rec.recordId && rec.recordId.toLowerCase().includes(query)) ||
                                       (setVal.toLowerCase().includes(query)) ||
                                       (JSON.stringify(rec.fields || {}).toLowerCase().includes(query));
                    if (!matchesSearch) {
                        cursor.continue();
                        return;
                    }
                }

                if (skipped < offset) {
                    skipped++;
                    cursor.continue();
                } else if (results.length < limit) {
                    // Convert to synthetic event format
                    results.push({
                        id: 0,
                        recordId: rec.recordId,
                        set: setVal,
                        payload: JSON.stringify({
                            _set: 'current',
                            fields: { INS: rec.fields }
                        }),
                        created_at: null,
                        _isCurrentState: true
                    });
                    cursor.continue();
                } else {
                    resolve(results);
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

// Get count of all current records
function getCurrentRecordsCount() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var req = tx.objectStore('data').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

function getAllTables() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readonly');
        var req = tx.objectStore('tables').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getFieldsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var index = tx.objectStore('fields').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getViewsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var index = tx.objectStore('views').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllViews() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var req = tx.objectStore('views').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllFields() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var req = tx.objectStore('fields').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Query schema elements by recordId prefix
function getSchemaByPrefix(prefix) {
    // Returns tables (tbl*), fields (fld*), or views (viw*) based on prefix
    return new Promise(async (resolve) => {
        var results = [];
        if (prefix === 'tbl') {
            var tables = await getAllTables();
            results = tables.filter(t => t.tableId && t.tableId.startsWith('tbl'));
        } else if (prefix === 'fld') {
            var fields = await getAllFields();
            results = fields.filter(f => f.fieldId && f.fieldId.startsWith('fld'));
        } else if (prefix === 'viw') {
            var views = await getAllViews();
            results = views.filter(v => v.viewId && v.viewId.startsWith('viw'));
        }
        resolve(results);
    });
}

function getRecordIdsForTable(tableId) {
    // Check in-memory data first (from CSV import)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        return Promise.resolve(Object.keys(window.IN_MEMORY_DATA[tableId]));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var index = tx.objectStore('data').index('by_table');
        var req = index.getAllKeys(tableId);
        req.onsuccess = () => {
            // Keys are [tableId, recordId], extract recordIds
            var recordIds = (req.result || []).map(k => k[1]);
            resolve(recordIds);
        };
        req.onerror = () => reject(req.error);
    });
}

// Fast record count using IndexedDB count()  avoids loading all keys into memory
function getRecordCountForTable(tableId) {
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        return Promise.resolve(Object.keys(window.IN_MEMORY_DATA[tableId]).length);
    }
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var index = tx.objectStore('data').index('by_table');
        var req = index.count(tableId);
        req.onsuccess = () => resolve(req.result || 0);
        req.onerror = () => reject(req.error);
    });
}

async function getRecord(tableId, recordId) {
    // Check in-memory data first (from CSV import)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
        return {
            tableId: tableId,
            recordId: recordId,
            fields: window.IN_MEMORY_DATA[tableId][recordId]
        };
    }

    var result = await new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var req = tx.objectStore('data').get([tableId, recordId]);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
    });

    // Decrypt record if needed
    if (result && encryptionEnabled && encryptionKey) {
        return decryptRecordFromStorage(result);
    }
    return result;
}

// Short-lived record cache  keeps recently fetched records in memory so that
// re-renders (same page, filter tweaks, view toggles) avoid hitting IndexedDB.
// Evicted whenever the active table changes.
var _recordCache = {};  // key: "tableId|recordId" -> record object
var _recordCacheTable = null;
var _RECORD_CACHE_MAX = 600; // cap to avoid unbounded growth
function _rcKey(tid, rid) { return tid + '|' + rid; }
function clearRecordCache() { _recordCache = {}; _recordCacheTable = null; }

async function getRecordsByIds(tableId, recordIds) {
    if (!recordIds.length) return [];

    // Evict cache if table changed
    if (_recordCacheTable && _recordCacheTable !== tableId) clearRecordCache();
    _recordCacheTable = tableId;

    // Serve from cache where possible, only fetch missing IDs
    var cached = [];
    var missingForCache = [];
    for (var ci = 0; ci < recordIds.length; ci++) {
        var ck = _rcKey(tableId, recordIds[ci]);
        if (_recordCache[ck]) {
            cached.push(_recordCache[ck]);
        } else {
            missingForCache.push(recordIds[ci]);
        }
    }
    if (missingForCache.length === 0) return cached;

    // Check in-memory data first (from CSV import)  only for missing IDs
    var fetched = [];
    var stillMissing = missingForCache;
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        var afterMem = [];
        for (var i = 0; i < stillMissing.length; i++) {
            var rid = stillMissing[i];
            if (window.IN_MEMORY_DATA[tableId][rid]) {
                fetched.push({
                    tableId: tableId,
                    recordId: rid,
                    fields: window.IN_MEMORY_DATA[tableId][rid]
                });
            } else {
                afterMem.push(rid);
            }
        }
        stillMissing = afterMem;
    }

    // Fetch remaining from IndexedDB
    if (stillMissing.length > 0) {
        var dbResults = await getRecordsByIdsFromDB(tableId, stillMissing);
        fetched = fetched.concat(dbResults);
    }

    // Populate cache (cap size to avoid unbounded growth)
    var cacheKeys = Object.keys(_recordCache);
    if (cacheKeys.length + fetched.length > _RECORD_CACHE_MAX) {
        // Evict oldest entries (simple FIFO: clear half)
        var toRemove = cacheKeys.slice(0, Math.floor(cacheKeys.length / 2));
        for (var ri = 0; ri < toRemove.length; ri++) delete _recordCache[toRemove[ri]];
    }
    for (var fi = 0; fi < fetched.length; fi++) {
        _recordCache[_rcKey(tableId, fetched[fi].recordId)] = fetched[fi];
    }

    return cached.concat(fetched);
}

// Internal: Get records from IndexedDB only
async function getRecordsByIdsFromDB(tableId, recordIds) {
    if (!recordIds.length) return [];

    var results = await new Promise((resolve, reject) => {
        var store = db.transaction('data', 'readonly').objectStore('data');
        var results = [];
        var pending = recordIds.length;

        recordIds.forEach(rid => {
            var req = store.get([tableId, rid]);
            req.onsuccess = () => {
                if (req.result) results.push(req.result);
                if (--pending === 0) resolve(results);
            };
            req.onerror = () => {
                if (--pending === 0) resolve(results);
            };
        });
    });

    // Decrypt records if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(r => decryptRecordFromStorage(r)));
    }
    return results;
}

function saveTable(table) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readwrite');
        tx.objectStore('tables').put(table);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveField(field) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readwrite');
        tx.objectStore('fields').put(field);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveView(view) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readwrite');
        tx.objectStore('views').put(view);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function saveDataRecord(record) {
    // Encrypt record if needed
    var recordToStore = record;
    if (encryptionEnabled && encryptionKey) {
        recordToStore = await encryptRecordForStorage(record);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readwrite');
        tx.objectStore('data').put(recordToStore);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function saveBatch(tables, fields, views, dataRecords) {
    var stores = [];
    if (tables.length) stores.push('tables');
    if (fields.length) stores.push('fields');
    if (views.length) stores.push('views');
    if (dataRecords.length) stores.push('data');
    if (!stores.length) return;

    // Encrypt data records if needed
    var recordsToStore = dataRecords;
    if (encryptionEnabled && encryptionKey && dataRecords.length) {
        recordsToStore = await Promise.all(dataRecords.map(r => encryptRecordForStorage(r)));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction(stores, 'readwrite');

        tables.forEach(t => tx.objectStore('tables').put(t));
        fields.forEach(f => tx.objectStore('fields').put(f));
        views.forEach(v => tx.objectStore('views').put(v));
        recordsToStore.forEach(d => tx.objectStore('data').put(d));

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function clearAllData() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction(['data', 'tables', 'fields', 'views', 'sync', 'fieldHistory', 'events'], 'readwrite');
        tx.objectStore('data').clear();
        tx.objectStore('tables').clear();
        tx.objectStore('fields').clear();
        tx.objectStore('views').clear();
        tx.objectStore('sync').clear();
        tx.objectStore('fieldHistory').clear();
        tx.objectStore('events').clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveFieldHistory(historyEntries) {
    return new Promise((resolve, reject) => {
        if (!historyEntries.length) return resolve();
        var tx = db.transaction('fieldHistory', 'readwrite');
        var store = tx.objectStore('fieldHistory');
        historyEntries.forEach(entry => store.add(entry));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Field history limit to prevent excessive memory usage
var FIELD_HISTORY_LIMIT = 1000;

function getFieldHistoryForRecord(tableId, recordId, limit) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fieldHistory', 'readonly');
        var index = tx.objectStore('fieldHistory').index('by_record');
        var maxLimit = limit || FIELD_HISTORY_LIMIT;

        // Use cursor for memory-efficient retrieval with limit
        var results = [];
        var req = index.openCursor(IDBKeyRange.only([tableId, recordId]));

        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor && results.length < maxLimit) {
                results.push(cursor.value);
                cursor.continue();
            } else {
                // Sort by eventId descending (most recent first)
                results.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

/**
 * Normalize a Matrix event from either format into a consistent history entry.
 * Works for both law.firm.schema.object and law.firm.record.mutate events.
 */
function normalizeHistoryEvent(matrixEvent) {
    var content = matrixEvent.content || {};
    if (!content.recordId) return null; // schema-level event, skip

    var payload = content.payload || {};
    var fields = payload.fields || {};

    // Normalize timestamp: seconds (migration) vs milliseconds (n8n/client)
    var ts = content.sourceTimestamp;
    if (ts && ts < 10000000000) ts = ts * 1000;
    var timestamp = ts || matrixEvent.origin_server_ts;

    // Extract actor
    var actor = payload._a || content.actor || matrixEvent.sender;

    // Normalize field changes  both formats use the same structure
    var changes = {
        inserted: fields.INS || {},
        altered: fields.ALT || {},
        nulled: fields.NUL || []
    };

    // Handle flat format (op + content.fields without payload wrapper)
    if (!fields.ALT && !fields.INS && !fields.NUL && content.op && content.fields) {
        if (content.op === 'INS') changes.inserted = content.fields;
        else if (content.op === 'ALT') changes.altered = content.fields;
        else if (content.op === 'NUL') changes.nulled = content.fields;
    }

    var op = content.op || 'ALT';

    return {
        eventId: matrixEvent.event_id,
        eventType: matrixEvent.type,
        recordId: content.recordId,
        op: op,
        changes: changes,
        actor: actor,
        timestamp: timestamp,
        source: content.source || 'unknown',
        set: content.set || payload._set || ''
    };
}

// Fetch and process mutation history for a specific record from Matrix.
// Paginates forward (oldest-first) through the table's Matrix room,
// filters by recordId client-side, decrypts encrypted payloads, and
// builds field history entries with source/actor metadata.
async function fetchAndProcessHistoryForRecord(tableId, recordId) {
    var roomId = _getRoomForTable(tableId);
    if (!roomId || !MatrixClient.isLoggedIn()) {
        console.warn('[History] No room mapping or not logged in for table:', tableId);
        return;
    }

    try {
        var allEvents = [];
        var paginationToken = null;
        var maxPages = 50; // Allow more pages for tables with many events

        for (var page = 0; page < maxPages; page++) {
            var opts = {
                dir: 'f', // forward  oldest first (chronological order)
                limit: 100,
                filter: { types: ['law.firm.schema.object', 'law.firm.record.mutate'] }
            };
            if (paginationToken) opts.from = paginationToken;

            var response = await MatrixClient.getRoomMessages(roomId, opts);
            if (!response || !response.chunk) break;

            var chunk = response.chunk;
            for (var i = 0; i < chunk.length; i++) {
                var evt = chunk[i];
                var content = evt.content || {};
                if (!content.recordId) continue; // skip schema-level events (field definitions, etc.)

                // Filter client-side for our target record
                if (content.recordId === recordId) {
                    allEvents.push(evt);
                }
            }

            // Check if there are more pages
            if (!response.end || chunk.length < 100) break;
            paginationToken = response.end;
        }

        if (allEvents.length === 0) return;

        // Events are already in chronological order from dir=f, but ensure
        // stable sorting in case of identical timestamps
        allEvents.sort(function(a, b) {
            return (a.origin_server_ts || 0) - (b.origin_server_ts || 0);
        });

        // Build field history entries by replaying events in order
        var state = {};
        var fieldHistoryEntries = [];

        for (var e = 0; e < allEvents.length; e++) {
            var evt = allEvents[e];
            var content = evt.content;

            // Decrypt encrypted payloads
            if (AminoData.isEncryptedPayload(content)) {
                try {
                    var decryptedFields = await AminoData.decryptEventPayload(content);
                    content = {
                        recordId: content.recordId,
                        tableId: content.tableId,
                        op: content.op || 'ALT',
                        payload: content.payload,
                        set: content.set,
                        source: content.source,
                        sourceTimestamp: content.sourceTimestamp,
                        fields: decryptedFields
                    };
                } catch (decErr) {
                    console.warn('[History] Could not decrypt event:', decErr.message);
                    continue;
                }
            }

            var eventId = evt.event_id || null;
            var timestamp = evt.origin_server_ts || Date.now();
            var sender = evt.sender || null;

            // Extract metadata from payload and top-level content
            var payload = content.payload || content;
            var source = content.source || null;
            var sourceTimestamp = content.sourceTimestamp || null;
            var actor = (payload && payload._a) || null;

            // Extract field operations (structured or flat format)
            var fieldOps = payload.fields || {};
            var hasStructuredOps = !!(fieldOps.ALT || fieldOps.INS || fieldOps.NUL || fieldOps.SYN);

            // Common metadata for each history entry
            var baseMeta = {
                tableId: tableId,
                recordId: recordId,
                eventId: eventId,
                timestamp: timestamp,
                sender: sender,
                source: source,
                sourceTimestamp: sourceTimestamp,
                actor: actor
            };

            if (hasStructuredOps) {
                // Process INS (insert/create)
                if (fieldOps.INS) {
                    for (var fieldId in fieldOps.INS) {
                        fieldHistoryEntries.push(Object.assign({}, baseMeta, {
                            fieldId: fieldId,
                            changeType: 'created',
                            oldValue: null,
                            newValue: fieldOps.INS[fieldId]
                        }));
                    }
                    Object.assign(state, fieldOps.INS);
                }

                // Process ALT (alter/update)
                if (fieldOps.ALT) {
                    for (var fieldId in fieldOps.ALT) {
                        fieldHistoryEntries.push(Object.assign({}, baseMeta, {
                            fieldId: fieldId,
                            changeType: 'updated',
                            oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                            newValue: fieldOps.ALT[fieldId]
                        }));
                    }
                    Object.assign(state, fieldOps.ALT);
                }

                // Process SYN (sync/snapshot)
                if (fieldOps.SYN) {
                    for (var fieldId in fieldOps.SYN) {
                        fieldHistoryEntries.push(Object.assign({}, baseMeta, {
                            fieldId: fieldId,
                            changeType: 'synced',
                            oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                            newValue: fieldOps.SYN[fieldId]
                        }));
                    }
                    Object.assign(state, fieldOps.SYN);
                }

                // Process NUL (nullify/delete)
                if (fieldOps.NUL) {
                    var nulFields = Array.isArray(fieldOps.NUL) ? fieldOps.NUL : Object.keys(fieldOps.NUL);
                    for (var n = 0; n < nulFields.length; n++) {
                        fieldHistoryEntries.push(Object.assign({}, baseMeta, {
                            fieldId: nulFields[n],
                            changeType: 'deleted',
                            oldValue: state[nulFields[n]] !== undefined ? state[nulFields[n]] : null,
                            newValue: null
                        }));
                        delete state[nulFields[n]];
                    }
                }
            } else if (content.op && content.fields) {
                // Flat format: { recordId, op, fields: { key: val } }
                var op = content.op;
                var flatFields = content.fields;
                if (op === 'INS') {
                    for (var fieldId in flatFields) {
                        fieldHistoryEntries.push(Object.assign({}, baseMeta, {
                            fieldId: fieldId,
                            changeType: 'created', oldValue: null, newValue: flatFields[fieldId]
                        }));
                    }
                    Object.assign(state, flatFields);
                } else if (op === 'ALT') {
                    for (var fieldId in flatFields) {
                        fieldHistoryEntries.push(Object.assign({}, baseMeta, {
                            fieldId: fieldId,
                            changeType: 'updated',
                            oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                            newValue: flatFields[fieldId]
                        }));
                    }
                    Object.assign(state, flatFields);
                } else if (op === 'NUL') {
                    var removeKeys = Array.isArray(flatFields) ? flatFields : Object.keys(flatFields);
                    for (var r = 0; r < removeKeys.length; r++) {
                        fieldHistoryEntries.push(Object.assign({}, baseMeta, {
                            fieldId: removeKeys[r],
                            changeType: 'deleted',
                            oldValue: state[removeKeys[r]] !== undefined ? state[removeKeys[r]] : null,
                            newValue: null
                        }));
                        delete state[removeKeys[r]];
                    }
                }
            }
        }

        // Save to IndexedDB for caching
        if (fieldHistoryEntries.length > 0) {
            await saveFieldHistory(fieldHistoryEntries);
        }
    } catch (err) {
        console.error('[History] Error fetching room history for record:', err);
    }
}

// ============ View Folders ============

function getFoldersForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readonly');
        var index = tx.objectStore('viewFolders').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function saveFolder(folder) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readwrite');
        tx.objectStore('viewFolders').put(folder);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function deleteFolder(folderId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readwrite');
        tx.objectStore('viewFolders').delete(folderId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getAllFolders() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readonly');
        var req = tx.objectStore('viewFolders').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// ============ View Auto-Save System ============

// Mark view as dirty (edited)
function markViewDirty(changeType, data) {
    if (!currentTable || !currentView) return;

    viewDirtyState.isDirty = true;
    viewDirtyState.lastEditTime = Date.now();
    viewDirtyState.pendingChanges.tableId = currentTable;
    viewDirtyState.pendingChanges.viewId = currentView;
    viewDirtyState.pendingChanges.changes[changeType] = data;

    // Reset auto-save timer (debounce)
    clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(saveViewToBackend, AUTO_SAVE_DELAY);

    // Update UI indicator
    updateSaveIndicator('dirty');
}

// Update save indicator UI
function updateSaveIndicator(state) {
    var indicator = document.getElementById('view-save-indicator');
    var text = document.getElementById('save-indicator-text');
    var saveBtn = document.getElementById('manual-save-btn');

    if (!indicator || !text || !saveBtn) return;

    indicator.style.display = 'flex';
    indicator.className = 'view-save-indicator ' + state;

    switch(state) {
        case 'dirty':
            var remaining = Math.ceil((AUTO_SAVE_DELAY - (Date.now() - viewDirtyState.lastEditTime)) / 60000);
            text.textContent = 'Auto-save in ~' + Math.max(1, remaining) + 'm';
            saveBtn.style.display = 'inline-block';
            saveBtn.disabled = false;
            break;
        case 'saving':
            text.textContent = 'Saving...';
            saveBtn.style.display = 'inline-block';
            saveBtn.disabled = true;
            break;
        case 'saved':
            text.textContent = 'Saved';
            saveBtn.style.display = 'none';
            // Hide after 3 seconds
            setTimeout(() => {
                if (!viewDirtyState.isDirty) {
                    indicator.style.display = 'none';
                }
            }, 3000);
            break;
        default:
            indicator.style.display = 'none';
    }
}

// Save view changes to backend
// View config is now stored via Matrix state events (user preferences)
async function saveViewToBackend() {
    if (!viewDirtyState.isDirty) return;

    var { tableId, viewId, changes } = viewDirtyState.pendingChanges;
    if (!tableId || !viewId) return;

    updateSaveIndicator('saving');

    try {
        // Save view config via user preferences (Matrix account data)
        var view = META_VIEWS[tableId]?.[viewId] || {};
        var config = VIEW_FIELD_CONFIG[tableId]?.[viewId] || {};
        var viewConfigData = {
            viewId: viewId,
            viewName: view.viewName || viewId,
            hiddenFieldIds: config.hiddenFieldIds || [],
            fieldOrder: config.fieldOrder || [],
            filters: view.filters || [],
            sorts: view.sorts || [],
            folderId: view.folderId || null,
            ...changes
        };

        // Store via user preferences system (Matrix account data)
        await UserPreferences.set('viewConfig:' + tableId + ':' + viewId, viewConfigData);

        // Clear dirty state
        viewDirtyState.isDirty = false;
        viewDirtyState.pendingChanges = { tableId: null, viewId: null, changes: {} };
        clearTimeout(autoSaveTimer);

        updateSaveIndicator('saved');
        console.log('View saved via Matrix user preferences:', viewId);
    } catch (error) {
        console.error('Failed to save view:', error);
        updateSaveIndicator('dirty');
    }
}

// Manual save button handler
async function saveViewToBackendNow() {
    clearTimeout(autoSaveTimer);
    await saveViewToBackend();
}

// Auto-save before navigation (sync fast-path when nothing is dirty)
function autoSaveBeforeNavigation() {
    if (!viewDirtyState.isDirty) return; // sync return  no await overhead
    clearTimeout(autoSaveTimer);
    return saveViewToBackend();
}

// Browser beforeunload - auto-save
window.addEventListener('beforeunload', function(e) {
    if (viewDirtyState.isDirty) {
        // Attempt to save (may not complete if user leaves too quickly)
        saveViewToBackend();
    }
    if (tableSettingsDirty) {
        // Attempt to save table settings
        saveTableSettings();
    }
});

// ============ Table Settings (User-Specific Table/View Preferences) ============

// Table settings dirty state tracking
var tableSettingsDirty = false;
var tableSettingsAutoSaveTimer = null;

// Get current table settings
function getTableSettings() {
    return TABLE_SETTINGS;
}

// Update table visibility
function setTableVisible(tableId, visible) {
    if (!TABLE_SETTINGS.tables[tableId]) {
        TABLE_SETTINGS.tables[tableId] = {};
    }
    TABLE_SETTINGS.tables[tableId].visible = visible;
    markTableSettingsDirty();
}

// Update table sort order
function setTableSortOrder(tableId, sortOrder) {
    if (!TABLE_SETTINGS.tables[tableId]) {
        TABLE_SETTINGS.tables[tableId] = {};
    }
    TABLE_SETTINGS.tables[tableId].sortOrder = sortOrder;
    markTableSettingsDirty();
}

// Update the table order array (reorder tables)
function setTableOrder(tableOrder) {
    TABLE_SETTINGS.tableOrder = tableOrder;
    markTableSettingsDirty();
}

// Update view public/private setting
function setViewPublic(viewId, isPublic) {
    if (!TABLE_SETTINGS.views[viewId]) {
        TABLE_SETTINGS.views[viewId] = {};
    }
    TABLE_SETTINGS.views[viewId].isPublic = isPublic;
    markTableSettingsDirty();
}

// Update view sort order
function setViewSortOrder(viewId, sortOrder) {
    if (!TABLE_SETTINGS.views[viewId]) {
        TABLE_SETTINGS.views[viewId] = {};
    }
    TABLE_SETTINGS.views[viewId].sortOrder = sortOrder;
    markTableSettingsDirty();
}

// Check if a table is visible (defaults to true if not set)
function isTableVisible(tableId) {
    var settings = TABLE_SETTINGS.tables[tableId];
    return settings ? settings.visible !== false : true;
}

// Check if a view is public (defaults to false - private by default)
function isViewPublic(viewId) {
    var settings = TABLE_SETTINGS.views[viewId];
    return settings ? settings.isPublic === true : false;
}

// Get table sort order (returns null if not set)
function getTableSortOrder(tableId) {
    var settings = TABLE_SETTINGS.tables[tableId];
    return settings ? settings.sortOrder : null;
}

// Get view sort order (returns null if not set)
function getViewSortOrder(viewId) {
    var settings = TABLE_SETTINGS.views[viewId];
    return settings ? settings.sortOrder : null;
}

// Mark table settings as dirty and schedule auto-save
function markTableSettingsDirty() {
    tableSettingsDirty = true;

    // Clear existing timer
    if (tableSettingsAutoSaveTimer) {
        clearTimeout(tableSettingsAutoSaveTimer);
    }

    // Schedule auto-save after 2 seconds of inactivity
    tableSettingsAutoSaveTimer = setTimeout(function() {
        saveTableSettings();
    }, 2000);
}

// Save table settings to backend (via Matrix user preferences)
async function saveTableSettings() {
    if (!tableSettingsDirty) return;

    try {
        // Save via user preferences (Matrix account data)
        await UserPreferences.set('tableSettings', {
            tables: TABLE_SETTINGS.tables,
            tableOrder: TABLE_SETTINGS.tableOrder,
            views: TABLE_SETTINGS.views
        });

        tableSettingsDirty = false;
        clearTimeout(tableSettingsAutoSaveTimer);
        console.log('Table settings saved via Matrix user preferences');
    } catch (error) {
        console.error('Failed to save table settings:', error);
    }
}

// Load table settings from sync metadata
// Table settings are now persisted via events and restored during event replay
async function loadTableSettings() {
    try {
        var stored = await getSyncMeta('tableSettings');
        if (stored) {
            if (stored.tables) TABLE_SETTINGS.tables = stored.tables;
            if (stored.tableOrder) TABLE_SETTINGS.tableOrder = stored.tableOrder;
            if (stored.views) TABLE_SETTINGS.views = stored.views;
            console.log('Table settings loaded from sync metadata');
        }
    } catch (error) {
        console.error('Failed to load table settings:', error);
    }
}

// ============ User Preferences (Per-User Synapse Account Storage) ============
//
// User preferences are stored in two layers:
// 1. Local: IndexedDB 'userPreferences' store (for fast access, offline support)
// 2. Remote: Matrix account data (synced across devices, private to user)
//
// Preferences include: theme, sidebar collapsed state, default table/view,
// table visibility/order, and any other user-specific settings.
//
// When the user is logged into Synapse, preferences sync bidirectionally.
// Local storage acts as cache; Matrix account data is the source of truth.

var UserPreferences = (function() {
    'use strict';

    var ACCOUNT_DATA_TYPE = 'law.firm.user.preferences';

    // Default preferences
    var _defaults = {
        theme: 'dark',
        sidebarCollapsed: false,
        defaultTableId: null,
        defaultViewId: null,
        tableSettings: { tables: {}, tableOrder: [], views: {} },
        recentTables: [],
        pinnedViews: [],
        gridDensity: 'comfortable',  // 'compact', 'comfortable', 'spacious'
        pageSize: 100,
        dateFormat: 'relative',      // 'relative', 'absolute', 'iso'
        timezone: null,              // null = browser default
        showOfflineSyncToasts: true  // show toast when offline-queued edits sync
    };

    var _prefs = Object.assign({}, _defaults);
    var _dirty = false;
    var _saveTimer = null;
    var _userId = null;

    // ---- Local Storage (IndexedDB) ----

    async function _loadLocal() {
        try {
            if (!db) return;
            var tx = db.transaction('userPreferences', 'readonly');
            var req = tx.objectStore('userPreferences').get('prefs');
            var result = await new Promise(function(resolve, reject) {
                req.onsuccess = function() { resolve(req.result); };
                req.onerror = function() { reject(req.error); };
            });
            if (result && result.value) {
                _prefs = Object.assign({}, _defaults, result.value);
            }
        } catch (e) {
            console.warn('[UserPreferences] Failed to load local prefs:', e);
        }
    }

    async function _saveLocal() {
        try {
            if (!db) return;
            var tx = db.transaction('userPreferences', 'readwrite');
            tx.objectStore('userPreferences').put({ key: 'prefs', value: _prefs });
            await new Promise(function(resolve, reject) {
                tx.oncomplete = resolve;
                tx.onerror = function() { reject(tx.error); };
            });
        } catch (e) {
            console.warn('[UserPreferences] Failed to save local prefs:', e);
        }
    }

    // ---- Remote Storage (Matrix Account Data) ----

    async function _loadRemote() {
        if (!MatrixClient.isLoggedIn()) return false;
        try {
            var data = await MatrixClient.getAccountData(ACCOUNT_DATA_TYPE);
            if (data) {
                // Merge remote into local, remote wins for conflicts
                _prefs = Object.assign({}, _defaults, _prefs, data);
                await _saveLocal();
                return true;
            }
            // Account data doesn't exist yet on server (first login);
            // initialize with current prefs so future loads don't 404
            await _saveRemote();
        } catch (e) {
            console.warn('[UserPreferences] Failed to load remote prefs:', e);
        }
        return false;
    }

    async function _saveRemote() {
        if (!MatrixClient.isLoggedIn()) return;
        try {
            await MatrixClient.setAccountData(ACCOUNT_DATA_TYPE, _prefs);
        } catch (e) {
            console.warn('[UserPreferences] Failed to save remote prefs:', e);
        }
    }

    // ---- Public API ----

    async function load() {
        _userId = MatrixClient.getUserId();
        await _loadLocal();
        if (MatrixClient.isLoggedIn()) {
            await _loadRemote();
        }
        console.log('[UserPreferences] Loaded for', _userId || 'anonymous');
    }

    async function save() {
        await _saveLocal();
        await _saveRemote();
        _dirty = false;
    }

    function get(key) {
        return _prefs[key] !== undefined ? _prefs[key] : _defaults[key];
    }

    function set(key, value) {
        _prefs[key] = value;
        _dirty = true;
        _scheduleSave();
    }

    function getAll() {
        return Object.assign({}, _prefs);
    }

    function setMultiple(obj) {
        Object.keys(obj).forEach(function(k) {
            _prefs[k] = obj[k];
        });
        _dirty = true;
        _scheduleSave();
    }

    function _scheduleSave() {
        if (_saveTimer) clearTimeout(_saveTimer);
        _saveTimer = setTimeout(function() {
            save();
        }, 2000);
    }

    function reset() {
        _prefs = Object.assign({}, _defaults);
        _dirty = true;
        _scheduleSave();
    }

    return {
        load: load,
        save: save,
        get: get,
        set: set,
        getAll: getAll,
        setMultiple: setMultiple,
        reset: reset
    };
})();

// ============ Shared Views (Views with Ownership & Sharing) ============
//
// Views start as personal (private to the creator). They can then be shared:
//   - 'private': Only the creator can see/use this view (default)
//   - 'specific': Shared with specific users (by Matrix userId)
//   - 'everyone': Shared with everyone in the org
//
// Storage architecture:
//   - Private views: stored in IndexedDB + Matrix account data (law.firm.user.views)
//   - Shared views: stored in IndexedDB + Matrix room state events (law.firm.view.share)
//     in the org space, with the view config as the content and sharing metadata
//
// Each view has ownership metadata:
//   ownerId:     Matrix userId of the creator
//   sharing:     'private' | 'specific' | 'everyone'
//   sharedWith:  string[]  (Matrix userIds, only used when sharing === 'specific')
//   createdAt:   timestamp
//   updatedAt:   timestamp

var SharedViews = (function() {
    'use strict';

    var ACCOUNT_DATA_TYPE = 'law.firm.user.views';
    var _orgSpaceId = null;

    // ---- Local Storage ----

    async function _getLocalSharedView(tableId, viewId) {
        if (!db) return null;
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readonly');
            var req = tx.objectStore('sharedViews').get([tableId, viewId]);
            req.onsuccess = function() { resolve(req.result || null); };
            req.onerror = function() { reject(req.error); };
        });
    }

    async function _saveLocalSharedView(viewData) {
        if (!db) return;
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readwrite');
            tx.objectStore('sharedViews').put(viewData);
            tx.oncomplete = resolve;
            tx.onerror = function() { reject(tx.error); };
        });
    }

    async function _deleteLocalSharedView(tableId, viewId) {
        if (!db) return;
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readwrite');
            tx.objectStore('sharedViews').delete([tableId, viewId]);
            tx.oncomplete = resolve;
            tx.onerror = function() { reject(tx.error); };
        });
    }

    async function _getAllLocalSharedViews() {
        if (!db) return [];
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readonly');
            var req = tx.objectStore('sharedViews').getAll();
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });
    }

    async function _getLocalSharedViewsForTable(tableId) {
        if (!db) return [];
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readonly');
            var index = tx.objectStore('sharedViews').index('by_table');
            var req = index.getAll(tableId);
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });
    }

    // ---- Remote Storage ----

    // Save private view list to Matrix account data
    async function _syncPrivateViewsToRemote(privateViews) {
        if (!MatrixClient.isLoggedIn()) return;
        try {
            await MatrixClient.setAccountData(ACCOUNT_DATA_TYPE, {
                views: privateViews,
                updatedAt: Date.now()
            });
        } catch (e) {
            console.warn('[SharedViews] Failed to sync private views to remote:', e);
        }
    }

    // Load private views from Matrix account data
    async function _loadPrivateViewsFromRemote() {
        if (!MatrixClient.isLoggedIn()) return null;
        try {
            var data = await MatrixClient.getAccountData(ACCOUNT_DATA_TYPE);
            if (data) {
                return data.views ? data.views : null;
            }
            // Account data doesn't exist yet on server (first login);
            // initialize with empty views so future loads don't 404
            await _syncPrivateViewsToRemote([]);
            return null;
        } catch (e) {
            console.warn('[SharedViews] Failed to load private views from remote:', e);
            return null;
        }
    }

    // Share a view to the org space as a room state event
    async function _publishSharedView(viewData) {
        if (!MatrixClient.isLoggedIn() || !_orgSpaceId) return;
        var stateKey = viewData.tableId + '|' + viewData.viewId;
        try {
            await MatrixClient.sendStateEvent(
                _orgSpaceId,
                MatrixClient.EVENT_TYPES.VIEW_SHARE,
                stateKey,
                viewData
            );
        } catch (e) {
            console.warn('[SharedViews] Failed to publish shared view:', e);
            throw e;
        }
    }

    // Remove a shared view from the org space
    async function _unpublishSharedView(tableId, viewId) {
        if (!MatrixClient.isLoggedIn() || !_orgSpaceId) return;
        var stateKey = tableId + '|' + viewId;
        try {
            // Set empty content to effectively remove the state event
            await MatrixClient.sendStateEvent(
                _orgSpaceId,
                MatrixClient.EVENT_TYPES.VIEW_SHARE,
                stateKey,
                { deleted: true, deletedAt: Date.now() }
            );
        } catch (e) {
            console.warn('[SharedViews] Failed to unpublish shared view:', e);
        }
    }

    // Load all shared views from the org space
    async function _loadSharedViewsFromOrgSpace() {
        if (!MatrixClient.isLoggedIn() || !_orgSpaceId) return [];
        try {
            var events = MatrixClient.getStateEventsOfType(_orgSpaceId, MatrixClient.EVENT_TYPES.VIEW_SHARE);
            var views = [];
            for (var i = 0; i < events.length; i++) {
                var content = events[i].content;
                if (content && !content.deleted && content.viewId) {
                    views.push(content);
                }
            }
            return views;
        } catch (e) {
            console.warn('[SharedViews] Failed to load shared views from org space:', e);
            return [];
        }
    }

    // ---- Public API ----

    function setOrgSpaceId(orgSpaceId) {
        _orgSpaceId = orgSpaceId;
    }

    // Initialize: load from local + merge with remote
    async function load() {
        // Load all local shared view metadata
        var localViews = await _getAllLocalSharedViews();

        // Load from remote sources
        if (MatrixClient.isLoggedIn()) {
            // Load private views from account data
            var remotePrivate = await _loadPrivateViewsFromRemote();
            if (remotePrivate) {
                for (var i = 0; i < remotePrivate.length; i++) {
                    var rv = remotePrivate[i];
                    if (rv.tableId && rv.viewId) {
                        await _saveLocalSharedView(rv);
                    }
                }
            }

            // Load shared views from org space state events
            if (_orgSpaceId) {
                var remoteShared = await _loadSharedViewsFromOrgSpace();
                for (var j = 0; j < remoteShared.length; j++) {
                    var sv = remoteShared[j];
                    if (sv.tableId && sv.viewId) {
                        await _saveLocalSharedView(sv);
                    }
                }
            }
        }

        console.log('[SharedViews] Loaded views');
    }

    // Get sharing metadata for a view
    async function getViewSharing(tableId, viewId) {
        var viewData = await _getLocalSharedView(tableId, viewId);
        if (!viewData) {
            return {
                ownerId: null,
                sharing: 'private',
                sharedWith: [],
                createdAt: null,
                updatedAt: null
            };
        }
        return {
            ownerId: viewData.ownerId || null,
            sharing: viewData.sharing || 'private',
            sharedWith: viewData.sharedWith || [],
            createdAt: viewData.createdAt || null,
            updatedAt: viewData.updatedAt || null
        };
    }

    // Set ownership on a new view
    async function setViewOwnership(tableId, viewId, ownerId) {
        var existing = await _getLocalSharedView(tableId, viewId);
        var viewData = existing || {
            tableId: tableId,
            viewId: viewId,
            sharing: 'private',
            sharedWith: [],
            createdAt: Date.now()
        };
        viewData.ownerId = ownerId;
        viewData.updatedAt = Date.now();
        await _saveLocalSharedView(viewData);
    }

    // Share a view: update sharing level and persist to appropriate storage
    async function shareView(tableId, viewId, sharing, sharedWith) {
        var existing = await _getLocalSharedView(tableId, viewId);
        if (!existing) {
            console.warn('[SharedViews] Cannot share non-existent view:', viewId);
            return;
        }

        var oldSharing = existing.sharing;
        existing.sharing = sharing;
        existing.sharedWith = sharedWith || [];
        existing.updatedAt = Date.now();

        // Include the full view config from META_VIEWS for the shared copy
        var viewMeta = META_VIEWS[tableId] && META_VIEWS[tableId][viewId];
        if (viewMeta) {
            existing.viewName = viewMeta.viewName;
            existing.viewType = viewMeta.viewType;
            existing.filters = viewMeta.filters || [];
            existing.sorts = viewMeta.sorts || [];
            existing.groupBy = viewMeta.groupBy || null;
            existing.hiddenFieldIds = viewMeta.hiddenFieldIds || [];
            existing.fieldOrder = viewMeta.fieldOrder || [];
            existing.tags = viewMeta.tags || [];
            existing.folderId = viewMeta.folderId || null;
        }

        // Save locally
        await _saveLocalSharedView(existing);

        // Handle remote persistence based on sharing level
        if (sharing === 'private') {
            // Remove from org space if it was previously shared
            if (oldSharing !== 'private') {
                await _unpublishSharedView(tableId, viewId);
            }
            // Sync to private account data
            await _syncAllPrivateViews();
        } else {
            // Publish to org space (for 'specific' and 'everyone')
            await _publishSharedView(existing);
            // Also sync private view list (remove from it if needed)
            await _syncAllPrivateViews();
        }

        console.log('[SharedViews] View', viewId, 'sharing set to:', sharing);
    }

    // Unshare a view: revert to private
    async function unshareView(tableId, viewId) {
        await shareView(tableId, viewId, 'private', []);
    }

    // Delete a shared view's metadata
    async function deleteViewSharing(tableId, viewId) {
        var existing = await _getLocalSharedView(tableId, viewId);
        if (existing && existing.sharing !== 'private') {
            await _unpublishSharedView(tableId, viewId);
        }
        await _deleteLocalSharedView(tableId, viewId);
        await _syncAllPrivateViews();
    }

    // Get all shared views visible to the current user for a given table
    async function getVisibleViewsForTable(tableId) {
        var allViews = await _getLocalSharedViewsForTable(tableId);
        var currentUserId = MatrixClient.getUserId();
        var visible = [];

        for (var i = 0; i < allViews.length; i++) {
            var v = allViews[i];
            if (_isViewVisibleToUser(v, currentUserId)) {
                visible.push(v);
            }
        }

        return visible;
    }

    // Check if a view is visible to a specific user
    function _isViewVisibleToUser(viewData, userId) {
        if (!viewData) return false;
        // Owner always sees their own views
        if (viewData.ownerId === userId) return true;
        // Everyone can see 'everyone' views
        if (viewData.sharing === 'everyone') return true;
        // Check specific sharing list
        if (viewData.sharing === 'specific' && viewData.sharedWith) {
            return viewData.sharedWith.indexOf(userId) >= 0;
        }
        return false;
    }

    // Check if the current user owns a view
    function isOwnedByCurrentUser(viewData) {
        var currentUserId = MatrixClient.getUserId();
        return viewData && viewData.ownerId === currentUserId;
    }

    // Sync all private views to account data
    async function _syncAllPrivateViews() {
        var allViews = await _getAllLocalSharedViews();
        var currentUserId = MatrixClient.getUserId();
        var privateViews = allViews.filter(function(v) {
            return v.ownerId === currentUserId && v.sharing === 'private';
        });
        await _syncPrivateViewsToRemote(privateViews);
    }

    // Get org members for the sharing picker
    async function getOrgMembers() {
        if (!_orgSpaceId || !MatrixClient.isLoggedIn()) return [];
        try {
            return await MatrixClient.getRoomMembers(_orgSpaceId);
        } catch (e) {
            console.warn('[SharedViews] Failed to get org members:', e);
            return [];
        }
    }

    // Get a human-readable sharing label for display
    function getSharingLabel(viewData) {
        if (!viewData || !viewData.sharing) return 'Private';
        switch (viewData.sharing) {
            case 'private': return 'Private';
            case 'specific':
                var count = (viewData.sharedWith || []).length;
                return 'Shared with ' + count + ' user' + (count !== 1 ? 's' : '');
            case 'everyone': return 'Shared with everyone';
            default: return 'Private';
        }
    }

    // Get sharing icon for display
    function getSharingIcon(viewData) {
        if (!viewData || !viewData.sharing || viewData.sharing === 'private') {
            return '&#128274;'; // lock icon
        }
        if (viewData.sharing === 'everyone') {
            return '&#127760;'; // globe icon
        }
        return '&#128101;'; // people icon (specific sharing)
    }

    return {
        setOrgSpaceId: setOrgSpaceId,
        load: load,
        getViewSharing: getViewSharing,
        setViewOwnership: setViewOwnership,
        shareView: shareView,
        unshareView: unshareView,
        deleteViewSharing: deleteViewSharing,
        getVisibleViewsForTable: getVisibleViewsForTable,
        isOwnedByCurrentUser: isOwnedByCurrentUser,
        getOrgMembers: getOrgMembers,
        getSharingLabel: getSharingLabel,
        getSharingIcon: getSharingIcon
    };
})();

// ============ Column Definition Registry & Smart Ordering ============
//
// Inspired by the EO/Noema definition concept: every column has semantic meaning
// beyond its label. A field named "name" is an identity field that belongs leftmost.
// A field named "created_at" is temporal metadata that belongs further right.
//
// This system:
// 1. Recognizes common field names via fuzzy matching (CommonDefinitionsRegistry)
// 2. Assigns semantic roles (identifier, property, temporal, quantity, etc.)
// 3. Scores each field's "relevance" for left-to-right column priority
// 4. Produces an intelligent default column order when a view is first created

// Definition roles - the semantic purpose of a field
var FieldRole = Object.freeze({
    PRIMARY_IDENTITY: 'primary_identity',   // Name, title - the "what is this?" column
    IDENTIFIER: 'identifier',               // IDs, codes, keys, references
    DESCRIPTIVE: 'descriptive',             // Description, notes, summary
    CONTACT: 'contact',                     // Email, phone, address
    STATUS: 'status',                       // Status, state, type, category
    QUANTITY: 'quantity',                    // Amounts, prices, counts
    TEMPORAL: 'temporal',                   // Dates, timestamps
    RELATIONAL: 'relational',              // Foreign keys, linked records
    ORGANIZATIONAL: 'organizational',       // Department, role, company
    SPATIAL: 'spatial',                     // Address, coordinates
    TECHNICAL: 'technical',                 // UUIDs, hashes, internal IDs
    UNKNOWN: 'unknown'
});

// Role display priority - lower number = further left (more relevant)
var ROLE_PRIORITY = {
    primary_identity: 0,    // "Name" column is almost always the most important
    identifier: 1,          // IDs that help identify the record
    descriptive: 2,         // Descriptions give context
    status: 3,              // Status/type helps at a glance
    contact: 4,             // Contact info is often actionable
    organizational: 5,      // Org context
    quantity: 6,            // Numeric values
    spatial: 7,             // Location data
    relational: 8,          // Links to other records
    temporal: 9,            // Dates tend to be reference, not primary
    technical: 10,          // Internal IDs, hashes - least human-relevant
    unknown: 11
};

/**
 * CommonDefinitionsRegistry - Recognizes common field names and assigns semantic meaning
 *
 * Borrowed from the Noema epistemic data workbench concept: definitions are not just
 * labels but carry meaning, authority, and role. Here we use a lightweight version
 * focused on field name recognition and semantic role assignment for column ordering.
 */
var COMMON_DEFINITIONS = [
    //  Primary Identity (the "what is this record?" fields) 
    { keys: ['name', 'full name', 'fullname', 'display name', 'displayname', 'record name', 'title', 'subject', 'headline', 'label'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Primary display name', sensitivity: 'low', stability: 'stable' },
    { keys: ['first name', 'firstname', 'fname', 'given name', 'givenname', 'first'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'First/given name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['last name', 'lastname', 'lname', 'surname', 'family name', 'familyname', 'last'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Last/family name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['middle name', 'middlename', 'mname', 'middle'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Middle name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['prefix', 'salutation', 'honorific'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Name prefix', sensitivity: 'low', stability: 'stable' },
    { keys: ['suffix', 'name suffix', 'generational'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Name suffix', sensitivity: 'low', stability: 'stable' },
    { keys: ['company name', 'companyname', 'company', 'org name', 'orgname', 'organization name', 'organization', 'org', 'business name', 'firm'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Organization name', sensitivity: 'low', stability: 'stable' },
    { keys: ['product name', 'productname', 'product', 'item name', 'itemname', 'item'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Product/item name', sensitivity: 'low', stability: 'stable' },

    //  Identifiers (unique keys and codes) 
    { keys: ['id', 'identifier', 'uid', 'guid', 'key', 'pk', 'primary key', 'unique identifier', 'record id', 'recordid'], role: FieldRole.IDENTIFIER, meaning: 'Unique identifier', sensitivity: 'low', stability: 'stable' },
    { keys: ['code', 'sku', 'barcode', 'upc', 'ean', 'gtin', 'item number', 'itemnumber', 'stock keeping unit', 'part number', 'partnumber'], role: FieldRole.IDENTIFIER, meaning: 'Item code', sensitivity: 'low', stability: 'stable' },
    { keys: ['account number', 'accountnumber', 'acct', 'account no'], role: FieldRole.IDENTIFIER, meaning: 'Account number', sensitivity: 'high', stability: 'stable' },
    { keys: ['invoice number', 'invoicenumber', 'invoice', 'inv number', 'invnumber', 'invoice no'], role: FieldRole.IDENTIFIER, meaning: 'Invoice number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['order number', 'ordernumber', 'order no', 'order'], role: FieldRole.IDENTIFIER, meaning: 'Order number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['transaction id', 'transactionid', 'trans id', 'transid', 'txn id', 'txnid', 'transaction'], role: FieldRole.IDENTIFIER, meaning: 'Transaction ID', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['employee number', 'employeenumber', 'employee no', 'emp number', 'empnumber', 'emp no', 'badge', 'badge number'], role: FieldRole.IDENTIFIER, meaning: 'Employee number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['social security number', 'ssn', 'social security', 'ss number', 'sin', 'national id'], role: FieldRole.IDENTIFIER, meaning: 'Social Security Number', sensitivity: 'high', stability: 'stable' },
    { keys: ['drivers license number', 'dl', 'drivers license', 'license number', 'dl number'], role: FieldRole.IDENTIFIER, meaning: 'Drivers license', sensitivity: 'high', stability: 'stable' },
    { keys: ['passport number', 'passport', 'passport no'], role: FieldRole.IDENTIFIER, meaning: 'Passport number', sensitivity: 'high', stability: 'stable' },

    //  Descriptive (text that describes/explains) 
    { keys: ['description', 'desc', 'details', 'summary', 'about', 'overview', 'bio', 'biography'], role: FieldRole.DESCRIPTIVE, meaning: 'Description text', sensitivity: 'low', stability: 'contextual' },
    { keys: ['notes', 'note', 'comments', 'comment', 'remarks', 'remark', 'memo', 'observation', 'observations'], role: FieldRole.DESCRIPTIVE, meaning: 'Notes/comments', sensitivity: 'low', stability: 'contextual' },
    { keys: ['body', 'content', 'text', 'message', 'body text'], role: FieldRole.DESCRIPTIVE, meaning: 'Body content', sensitivity: 'low', stability: 'contextual' },

    //  Status/Categorical (classification and state) 
    { keys: ['status', 'state', 'condition', 'stage', 'phase', 'workflow status'], role: FieldRole.STATUS, meaning: 'Current status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['type', 'kind', 'classification', 'record type', 'recordtype', 'entity type'], role: FieldRole.STATUS, meaning: 'Type classification', sensitivity: 'low', stability: 'stable' },
    { keys: ['category', 'cat', 'group', 'class', 'segment', 'division'], role: FieldRole.STATUS, meaning: 'Category', sensitivity: 'low', stability: 'stable' },
    { keys: ['subcategory', 'sub category', 'subcat', 'subgroup', 'sub group'], role: FieldRole.STATUS, meaning: 'Subcategory', sensitivity: 'low', stability: 'stable' },
    { keys: ['priority', 'pri', 'importance', 'urgency', 'severity', 'level'], role: FieldRole.STATUS, meaning: 'Priority level', sensitivity: 'low', stability: 'contextual' },
    { keys: ['tags', 'tag', 'labels', 'keywords'], role: FieldRole.STATUS, meaning: 'Tags/labels', sensitivity: 'low', stability: 'contextual' },
    { keys: ['active', 'isactive', 'is active', 'enabled', 'isenabled', 'is enabled', 'live'], role: FieldRole.STATUS, meaning: 'Active flag', sensitivity: 'low', stability: 'contextual' },
    { keys: ['approved', 'isapproved', 'is approved', 'approval', 'approval status'], role: FieldRole.STATUS, meaning: 'Approval status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['verified', 'isverified', 'is verified', 'confirmed', 'isconfirmed', 'is confirmed', 'validation'], role: FieldRole.STATUS, meaning: 'Verification status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['source', 'origin', 'referral source', 'lead source', 'channel'], role: FieldRole.STATUS, meaning: 'Source/origin', sensitivity: 'low', stability: 'stable' },
    { keys: ['gender', 'sex'], role: FieldRole.STATUS, meaning: 'Gender', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['race', 'ethnicity', 'race ethnicity', 'raceethnicity', 'race/ethnicity'], role: FieldRole.STATUS, meaning: 'Race/Ethnicity', sensitivity: 'high', stability: 'stable' },

    //  Contact (communication channels) 
    { keys: ['email', 'email address', 'emailaddress', 'e-mail', 'e mail', 'mail', 'primary email'], role: FieldRole.CONTACT, meaning: 'Email address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['phone', 'telephone', 'phone number', 'phonenumber', 'tel', 'primary phone', 'contact number'], role: FieldRole.CONTACT, meaning: 'Phone number', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['mobile phone', 'mobile', 'cell', 'cellphone', 'cell phone', 'mobilephone', 'mobile number'], role: FieldRole.CONTACT, meaning: 'Mobile phone', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['work phone', 'workphone', 'office phone', 'officephone', 'business phone'], role: FieldRole.CONTACT, meaning: 'Work phone', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['fax', 'fax number', 'faxnumber'], role: FieldRole.CONTACT, meaning: 'Fax number', sensitivity: 'low', stability: 'stable' },
    { keys: ['url', 'link', 'href', 'web address', 'webaddress', 'uri', 'website', 'web', 'homepage', 'webpage'], role: FieldRole.CONTACT, meaning: 'URL/website', sensitivity: 'low', stability: 'contextual' },
    { keys: ['image url', 'imageurl', 'image', 'img', 'photo', 'picture', 'pic', 'avatar', 'thumbnail', 'icon'], role: FieldRole.CONTACT, meaning: 'Image', sensitivity: 'low', stability: 'contextual' },

    //  Organizational (workplace structure) 
    { keys: ['department', 'dept', 'division', 'team', 'unit', 'group'], role: FieldRole.ORGANIZATIONAL, meaning: 'Department', sensitivity: 'low', stability: 'contextual' },
    { keys: ['job title', 'jobtitle', 'title', 'position', 'role', 'designation'], role: FieldRole.ORGANIZATIONAL, meaning: 'Job title', sensitivity: 'low', stability: 'contextual' },
    { keys: ['manager', 'supervisor', 'reports to', 'reportsto', 'boss', 'lead'], role: FieldRole.ORGANIZATIONAL, meaning: 'Manager', sensitivity: 'low', stability: 'contextual' },

    //  Quantity (numeric/measurable values) 
    { keys: ['amount', 'amt', 'value', 'total', 'sum', 'grand total'], role: FieldRole.QUANTITY, meaning: 'Amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['price', 'cost', 'unit price', 'unitprice', 'rate', 'charge', 'fee'], role: FieldRole.QUANTITY, meaning: 'Price/cost', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['revenue', 'income', 'earnings', 'sales', 'proceeds', 'gross'], role: FieldRole.QUANTITY, meaning: 'Revenue', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['balance', 'outstanding', 'remaining', 'due', 'owed'], role: FieldRole.QUANTITY, meaning: 'Balance', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['payment amount', 'paymentamount', 'payment', 'pay', 'payout'], role: FieldRole.QUANTITY, meaning: 'Payment amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['currency', 'curr', 'currency code', 'currencycode'], role: FieldRole.QUANTITY, meaning: 'Currency', sensitivity: 'low', stability: 'stable' },
    { keys: ['tax amount', 'taxamount', 'tax', 'taxes', 'vat', 'gst'], role: FieldRole.QUANTITY, meaning: 'Tax amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['discount', 'disc', 'discount amount', 'discountamount', 'rebate'], role: FieldRole.QUANTITY, meaning: 'Discount', sensitivity: 'low', stability: 'contextual' },
    { keys: ['quantity', 'qty', 'count', 'number', 'num', 'units', 'pieces', 'lot size'], role: FieldRole.QUANTITY, meaning: 'Quantity/count', sensitivity: 'low', stability: 'contextual' },
    { keys: ['age', 'years old', 'yearsold'], role: FieldRole.QUANTITY, meaning: 'Age', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['weight', 'mass', 'wt'], role: FieldRole.QUANTITY, meaning: 'Weight', sensitivity: 'low', stability: 'contextual' },
    { keys: ['height', 'length', 'width', 'depth', 'size', 'dimension'], role: FieldRole.QUANTITY, meaning: 'Dimension', sensitivity: 'low', stability: 'contextual' },
    { keys: ['percentage', 'percent', 'pct', 'ratio', 'rate'], role: FieldRole.QUANTITY, meaning: 'Percentage/ratio', sensitivity: 'low', stability: 'contextual' },
    { keys: ['score', 'rating', 'rank', 'grade', 'points'], role: FieldRole.QUANTITY, meaning: 'Score/rating', sensitivity: 'low', stability: 'contextual' },

    //  Spatial (location and geography) 
    { keys: ['street address', 'address', 'address1', 'address line 1', 'street', 'street1', 'mailing address', 'physical address'], role: FieldRole.SPATIAL, meaning: 'Street address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['address line 2', 'address2', 'address line2', 'apt', 'suite', 'unit', 'street2'], role: FieldRole.SPATIAL, meaning: 'Address line 2', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['city', 'town', 'municipality', 'locality'], role: FieldRole.SPATIAL, meaning: 'City', sensitivity: 'low', stability: 'contextual' },
    { keys: ['state', 'province', 'region', 'state province', 'stateprovince'], role: FieldRole.SPATIAL, meaning: 'State/province', sensitivity: 'low', stability: 'contextual' },
    { keys: ['postal code', 'zip', 'zipcode', 'zip code', 'postcode', 'post code'], role: FieldRole.SPATIAL, meaning: 'Postal code', sensitivity: 'low', stability: 'stable' },
    { keys: ['county', 'parish', 'district', 'borough'], role: FieldRole.SPATIAL, meaning: 'County/district', sensitivity: 'low', stability: 'stable' },
    { keys: ['country', 'nation', 'country code', 'countrycode'], role: FieldRole.SPATIAL, meaning: 'Country', sensitivity: 'low', stability: 'stable' },
    { keys: ['latitude', 'lat'], role: FieldRole.SPATIAL, meaning: 'Latitude', sensitivity: 'low', stability: 'stable' },
    { keys: ['longitude', 'lng', 'lon', 'long'], role: FieldRole.SPATIAL, meaning: 'Longitude', sensitivity: 'low', stability: 'stable' },
    { keys: ['full address', 'fulladdress', 'complete address', 'location', 'site'], role: FieldRole.SPATIAL, meaning: 'Full address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['po box', 'pobox', 'p.o. box'], role: FieldRole.SPATIAL, meaning: 'PO Box', sensitivity: 'low', stability: 'stable' },

    //  Relational (foreign keys, linked records) 
    { keys: ['parent id', 'parentid', 'parent'], role: FieldRole.RELATIONAL, meaning: 'Parent record', sensitivity: 'low', stability: 'stable' },
    { keys: ['customer id', 'customerid', 'customer', 'cust id', 'custid', 'client id', 'clientid', 'client'], role: FieldRole.RELATIONAL, meaning: 'Customer reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['user id', 'userid', 'user', 'member id', 'memberid'], role: FieldRole.RELATIONAL, meaning: 'User reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['account id', 'accountid', 'account', 'acct id', 'acctid'], role: FieldRole.RELATIONAL, meaning: 'Account reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['organization id', 'organizationid', 'orgid', 'org id', 'company id', 'companyid'], role: FieldRole.RELATIONAL, meaning: 'Organization reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['case id', 'caseid', 'case', 'case number', 'casenumber', 'ticket', 'ticket id', 'ticketid'], role: FieldRole.RELATIONAL, meaning: 'Case/ticket reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['order id', 'orderid'], role: FieldRole.RELATIONAL, meaning: 'Order reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['product id', 'productid', 'prod id', 'prodid', 'item id', 'itemid'], role: FieldRole.RELATIONAL, meaning: 'Product reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['vendor id', 'vendorid', 'supplier id', 'supplierid', 'vendor', 'supplier'], role: FieldRole.RELATIONAL, meaning: 'Vendor reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['employee id', 'employeeid', 'employee', 'emp id', 'empid', 'worker id'], role: FieldRole.RELATIONAL, meaning: 'Employee reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['owner', 'assigned to', 'assignedto', 'assignee', 'responsible', 'created by', 'createdby', 'modified by', 'modifiedby', 'author'], role: FieldRole.RELATIONAL, meaning: 'Person reference', sensitivity: 'low', stability: 'contextual' },

    //  Temporal (dates and times) 
    { keys: ['date', 'dt'], role: FieldRole.TEMPORAL, meaning: 'Date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['created date', 'createdat', 'created at', 'created', 'creation date', 'datecreated', 'date created', 'created on', 'createdon'], role: FieldRole.TEMPORAL, meaning: 'Creation date', sensitivity: 'low', stability: 'stable' },
    { keys: ['modified date', 'updatedat', 'updated at', 'updated', 'modifiedat', 'modified at', 'last modified', 'datemodified', 'date modified', 'modified on', 'modifiedon', 'last updated', 'lastupdated'], role: FieldRole.TEMPORAL, meaning: 'Last modified date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['deleted date', 'deletedat', 'deleted at', 'deleted', 'deletion date', 'removed date'], role: FieldRole.TEMPORAL, meaning: 'Deletion date', sensitivity: 'low', stability: 'stable' },
    { keys: ['start date', 'startdate', 'begin date', 'begindate', 'from date', 'fromdate', 'effective date', 'effectivedate', 'start'], role: FieldRole.TEMPORAL, meaning: 'Start date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['end date', 'enddate', 'finish date', 'finishdate', 'to date', 'todate', 'expiry date', 'expirydate', 'expiration date', 'expires', 'due date', 'duedate', 'deadline', 'end'], role: FieldRole.TEMPORAL, meaning: 'End date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['timestamp', 'ts', 'datetime', 'date time'], role: FieldRole.TEMPORAL, meaning: 'Timestamp', sensitivity: 'low', stability: 'stable' },
    { keys: ['year', 'yr', 'fiscal year', 'fiscalyear', 'fy'], role: FieldRole.TEMPORAL, meaning: 'Year', sensitivity: 'low', stability: 'stable' },
    { keys: ['month', 'mo', 'period'], role: FieldRole.TEMPORAL, meaning: 'Month', sensitivity: 'low', stability: 'stable' },
    { keys: ['quarter', 'qtr', 'q'], role: FieldRole.TEMPORAL, meaning: 'Quarter', sensitivity: 'low', stability: 'stable' },
    { keys: ['date of birth', 'dob', 'birthdate', 'birth date', 'birthday'], role: FieldRole.TEMPORAL, meaning: 'Date of birth', sensitivity: 'high', stability: 'stable' },
    { keys: ['hire date', 'hiredate', 'hired date', 'date hired', 'employment date', 'start date'], role: FieldRole.TEMPORAL, meaning: 'Hire date', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['termination date', 'terminationdate', 'term date', 'termdate', 'separation date', 'end of employment'], role: FieldRole.TEMPORAL, meaning: 'Termination date', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['duration', 'elapsed', 'time spent', 'timespent', 'hours', 'minutes'], role: FieldRole.TEMPORAL, meaning: 'Duration', sensitivity: 'low', stability: 'contextual' },
    { keys: ['time', 'clock time'], role: FieldRole.TEMPORAL, meaning: 'Time', sensitivity: 'low', stability: 'contextual' },
    { keys: ['day', 'day of week', 'weekday'], role: FieldRole.TEMPORAL, meaning: 'Day', sensitivity: 'low', stability: 'stable' },

    //  Technical (system/internal fields) 
    { keys: ['uuid', 'guid', 'unique id', 'uniqueid'], role: FieldRole.TECHNICAL, meaning: 'UUID', sensitivity: 'low', stability: 'stable' },
    { keys: ['hash', 'checksum', 'md5', 'sha256', 'sha1', 'digest'], role: FieldRole.TECHNICAL, meaning: 'Hash/checksum', sensitivity: 'low', stability: 'stable' },
    { keys: ['version', 'ver', 'revision', 'rev'], role: FieldRole.TECHNICAL, meaning: 'Version', sensitivity: 'low', stability: 'contextual' },
    { keys: ['sequence number', 'sequencenumber', 'seq', 'sequence', 'sort order', 'sortorder', 'display order', 'ordinal'], role: FieldRole.TECHNICAL, meaning: 'Sequence number', sensitivity: 'low', stability: 'contextual' },
    { keys: ['batch id', 'batchid', 'batch', 'run id', 'runid'], role: FieldRole.TECHNICAL, meaning: 'Batch ID', sensitivity: 'low', stability: 'stable' },
    { keys: ['api key', 'apikey', 'token', 'access token', 'secret', 'secret key'], role: FieldRole.TECHNICAL, meaning: 'API key', sensitivity: 'high', stability: 'stable' },
    { keys: ['ip address', 'ipaddress', 'ip', 'ipv4', 'ipv6'], role: FieldRole.TECHNICAL, meaning: 'IP address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['external identifier', 'externalidentifier', 'external id', 'externalid', 'ext id', 'extid', 'ref', 'reference', 'reference number'], role: FieldRole.TECHNICAL, meaning: 'External identifier', sensitivity: 'low', stability: 'stable' },
    { keys: ['file path', 'filepath', 'path', 'filename', 'file name'], role: FieldRole.TECHNICAL, meaning: 'File path', sensitivity: 'low', stability: 'contextual' },
    { keys: ['created by', 'createdby', 'author', 'creator'], role: FieldRole.TECHNICAL, meaning: 'Creator', sensitivity: 'low', stability: 'stable' },
    { keys: ['modified by', 'modifiedby', 'updated by', 'updatedby', 'last modified by', 'editor'], role: FieldRole.TECHNICAL, meaning: 'Last modifier', sensitivity: 'low', stability: 'stable' }
];

/**
 * Normalize a field name for comparison against definition keys.
 * Handles camelCase, snake_case, kebab-case, prefixes, suffixes.
 */
function normalizeFieldKey(fieldName) {
    return (fieldName || '')
        .toLowerCase()
        .replace(/([a-z])([A-Z])/g, '$1 $2')   // camelCase -> spaces
        .replace(/[-_]+/g, ' ')                  // separators -> spaces
        .replace(/\s+/g, ' ')                    // collapse whitespace
        .trim();
}

/**
 * Find the best matching definition for a field name.
 * Returns { definition, score, matchType } or null.
 */
function matchFieldToDefinition(fieldName) {
    if (!fieldName) return null;

    var normalized = normalizeFieldKey(fieldName);
    if (!normalized) return null;

    // Strip common prefixes (fld_, col_, field_, column_) and suffixes (_id, _key, _code, _num)
    var stripped = normalized
        .replace(/^(fld |col |field |column )/, '')
        .replace(/( id| key| code| num| no| number)$/, '');

    var bestMatch = null;
    var bestScore = 0;

    for (var i = 0; i < COMMON_DEFINITIONS.length; i++) {
        var def = COMMON_DEFINITIONS[i];
        var score = 0;
        var matchType = null;

        for (var k = 0; k < def.keys.length; k++) {
            var key = def.keys[k];

            // Exact match on normalized name
            if (normalized === key) {
                score = 1.0;
                matchType = 'exact';
                break;
            }

            // Exact match on stripped name
            if (stripped && stripped !== normalized && stripped === key) {
                score = 0.9;
                matchType = 'stripped';
                // Don't break, might find exact
            }

            // Contains match (field name contains the key or vice versa)
            if (score < 0.7) {
                if (normalized.includes(key) || key.includes(normalized)) {
                    var longer = normalized.length > key.length ? normalized : key;
                    var shorter = normalized.length > key.length ? key : normalized;
                    var containsScore = (shorter.length / longer.length) * 0.75;
                    if (containsScore > score) {
                        score = containsScore;
                        matchType = 'contains';
                    }
                }
            }
        }

        if (score > bestScore) {
            bestScore = score;
            bestMatch = { definition: def, score: score, matchType: matchType };
            if (score === 1.0) break; // Can't do better than exact
        }
    }

    // Minimum threshold
    return bestScore >= 0.4 ? bestMatch : null;
}

/**
 * Infer a field's semantic role from its name AND its data type.
 * Falls back to heuristics when no definition match is found.
 */
function inferFieldRole(fieldId, fieldMeta) {
    var fieldName = (fieldMeta && fieldMeta.fieldName) || fieldId;
    var fieldType = fieldMeta && fieldMeta.fieldType;

    // Try matching against known definitions first
    var match = matchFieldToDefinition(fieldName);
    if (match && match.score >= 0.4) {
        return {
            role: match.definition.role,
            confidence: match.score,
            meaning: match.definition.meaning,
            source: 'definition_match',
            matchType: match.matchType
        };
    }

    // Fallback: infer from field type
    if (fieldType === 'date' || fieldType === 'dateTime') {
        return { role: FieldRole.TEMPORAL, confidence: 0.6, meaning: 'Date field', source: 'type_inference' };
    }
    if (fieldType === 'number' || fieldType === 'currency' || fieldType === 'percent') {
        return { role: FieldRole.QUANTITY, confidence: 0.5, meaning: 'Numeric field', source: 'type_inference' };
    }
    if (fieldType === 'email') {
        return { role: FieldRole.CONTACT, confidence: 0.8, meaning: 'Email field', source: 'type_inference' };
    }
    if (fieldType === 'url') {
        return { role: FieldRole.CONTACT, confidence: 0.5, meaning: 'URL field', source: 'type_inference' };
    }
    if (fieldType === 'checkbox') {
        return { role: FieldRole.STATUS, confidence: 0.4, meaning: 'Boolean field', source: 'type_inference' };
    }
    if (fieldType === 'multipleRecordLinks') {
        return { role: FieldRole.RELATIONAL, confidence: 0.7, meaning: 'Linked records', source: 'type_inference' };
    }
    if (fieldType === 'multipleAttachments') {
        return { role: FieldRole.TECHNICAL, confidence: 0.5, meaning: 'Attachments', source: 'type_inference' };
    }

    // Fallback: heuristic patterns on the field name
    var norm = normalizeFieldKey(fieldName);
    if (/\b(id|key|pk|guid|uuid)\b/.test(norm)) {
        return { role: FieldRole.IDENTIFIER, confidence: 0.5, meaning: 'ID-like field', source: 'name_heuristic' };
    }
    if (/\b(date|time|created|updated|modified|timestamp)\b/.test(norm)) {
        return { role: FieldRole.TEMPORAL, confidence: 0.5, meaning: 'Time-like field', source: 'name_heuristic' };
    }
    if (/\b(name|title|label|subject|headline)\b/.test(norm)) {
        return { role: FieldRole.PRIMARY_IDENTITY, confidence: 0.5, meaning: 'Name-like field', source: 'name_heuristic' };
    }
    if (/\b(status|state|type|kind|category|active|enabled|flag)\b/.test(norm)) {
        return { role: FieldRole.STATUS, confidence: 0.4, meaning: 'Status-like field', source: 'name_heuristic' };
    }
    if (/\b(amount|price|cost|total|sum|count|qty|quantity|rate|fee|balance|revenue|payment|tax|discount|score|rating|percent|ratio)\b/.test(norm)) {
        return { role: FieldRole.QUANTITY, confidence: 0.4, meaning: 'Quantity-like field', source: 'name_heuristic' };
    }
    if (/\b(email|phone|mobile|cell|tel|fax|url|website|link)\b/.test(norm)) {
        return { role: FieldRole.CONTACT, confidence: 0.4, meaning: 'Contact-like field', source: 'name_heuristic' };
    }
    if (/\b(address|city|state|zip|postal|country|county|lat|lon|location)\b/.test(norm)) {
        return { role: FieldRole.SPATIAL, confidence: 0.4, meaning: 'Location-like field', source: 'name_heuristic' };
    }
    if (/\b(description|desc|notes|note|comment|remarks|memo|body|content|text|summary)\b/.test(norm)) {
        return { role: FieldRole.DESCRIPTIVE, confidence: 0.4, meaning: 'Descriptive field', source: 'name_heuristic' };
    }
    if (/\b(department|dept|team|role|position|manager|supervisor|job)\b/.test(norm)) {
        return { role: FieldRole.ORGANIZATIONAL, confidence: 0.4, meaning: 'Org field', source: 'name_heuristic' };
    }

    return { role: FieldRole.UNKNOWN, confidence: 0, meaning: 'Unknown', source: 'none' };
}

/**
 * Score a single field for left-to-right relevance.
 * Lower score = more relevant = further left.
 *
 * Scoring formula:
 *   base = ROLE_PRIORITY[role] * 100     (role is the primary sort factor)
 *   penalty adjustments:
 *     - High confidence match gets a bonus (moved left within role group)
 *     - Fields with "name" in them get extra left-push
 *     - Fields with only-ID suffixes get pushed right within their role group
 *     - Alphabetical tiebreaker within same score
 */
function scoreFieldRelevance(fieldId, fieldMeta) {
    var inference = inferFieldRole(fieldId, fieldMeta);
    var rolePriority = ROLE_PRIORITY[inference.role] !== undefined ? ROLE_PRIORITY[inference.role] : 11;

    // Base score from role (0-1100 range, in steps of 100)
    var score = rolePriority * 100;

    // Confidence adjustment: higher confidence = slightly more left (-0 to -40)
    score -= Math.round(inference.confidence * 40);

    // Name-like fields within identity get extra boost
    var norm = normalizeFieldKey((fieldMeta && fieldMeta.fieldName) || fieldId);
    if (inference.role === FieldRole.PRIMARY_IDENTITY) {
        // "name" or "full name" is the king column
        if (norm === 'name' || norm === 'full name' || norm === 'fullname' || norm === 'display name') {
            score -= 50;
        }
        // first name before last name
        if (norm.includes('first')) score -= 20;
        if (norm.includes('last')) score -= 10;
    }

    // Penalize pure ID fields (they look like "fldXyz123")
    if (/^fld[a-z0-9]+$/i.test(fieldId) && (!fieldMeta || !fieldMeta.fieldName || fieldMeta.fieldName === fieldId)) {
        score += 50; // Push raw field IDs to the right
    }

    return {
        fieldId: fieldId,
        score: score,
        role: inference.role,
        confidence: inference.confidence,
        meaning: inference.meaning,
        source: inference.source
    };
}

/**
 * Compute the intelligent default field order for a table.
 * This replaces the old alphabetical sort with semantic ordering.
 *
 * Returns an array of field IDs sorted by relevance (most relevant leftmost).
 */
function computeSmartFieldOrder(tableId) {
    var fields = META_FIELDS[tableId] || {};
    var fieldIds = Object.keys(fields);

    if (fieldIds.length === 0) return [];

    // Score every field
    var scored = fieldIds.map(function(fid) {
        return scoreFieldRelevance(fid, fields[fid]);
    });

    // Sort by score ascending (lower = more relevant = further left)
    // Tiebreaker: alphabetical by field name
    scored.sort(function(a, b) {
        if (a.score !== b.score) return a.score - b.score;
        var nameA = (fields[a.fieldId] && fields[a.fieldId].fieldName || a.fieldId).toLowerCase();
        var nameB = (fields[b.fieldId] && fields[b.fieldId].fieldName || b.fieldId).toLowerCase();
        return nameA.localeCompare(nameB);
    });

    // Log the smart ordering decision for debugging
    if (scored.length > 0) {
        console.log('Smart column order for table ' + tableId + ':',
            scored.slice(0, 8).map(function(s) {
                return (fields[s.fieldId] && fields[s.fieldId].fieldName || s.fieldId) +
                    ' [' + s.role + ', score=' + s.score + ']';
            }).join(' | ')
        );
    }

    return scored.map(function(s) { return s.fieldId; });
}

// ============ View Field Configuration ============

// Get the field configuration for a view (from cache or initialize default)
function getViewFieldConfig(tableId, viewId) {
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};

    // Return cached config if exists
    if (VIEW_FIELD_CONFIG[tableId][viewId]) {
        return VIEW_FIELD_CONFIG[tableId][viewId];
    }

    // Check if view has stored config in META_VIEWS
    var view = META_VIEWS[tableId]?.[viewId];
    if (view && (view.hiddenFieldIds || view.fieldOrder)) {
        VIEW_FIELD_CONFIG[tableId][viewId] = {
            hiddenFieldIds: view.hiddenFieldIds || [],
            fieldOrder: view.fieldOrder || []
        };
        return VIEW_FIELD_CONFIG[tableId][viewId];
    }

    // Initialize default config - show all fields in their natural order
    return initViewFieldConfig(tableId, viewId);
}

// Initialize default view field config (all fields visible)
function initViewFieldConfig(tableId, viewId) {
    // Use intelligent column ordering instead of alphabetical sort.
    // This puts the most relevant fields (names, identifiers) leftmost
    // and pushes metadata/technical fields to the right.
    var smartOrder = computeSmartFieldOrder(tableId);

    var config = {
        hiddenFieldIds: [],            // No fields hidden initially (all visible)
        fieldOrder: smartOrder.slice()  // Intelligent semantic order
    };

    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    VIEW_FIELD_CONFIG[tableId][viewId] = config;

    return config;
}

// Save view field configuration to memory and IndexedDB
async function saveViewFieldConfig(tableId, viewId, config) {
    // Update cache
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    VIEW_FIELD_CONFIG[tableId][viewId] = config;

    // Update META_VIEWS and persist to IndexedDB
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        // Create a synthetic view if it doesn't exist
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId,
            viewType: 'grid'
        };
    }

    // Merge config into view
    META_VIEWS[tableId][viewId].hiddenFieldIds = config.hiddenFieldIds;
    META_VIEWS[tableId][viewId].fieldOrder = config.fieldOrder;

    // Persist to IndexedDB
    await saveView(META_VIEWS[tableId][viewId]);
}

// Save view filters, sorts, and groupBy to IndexedDB
async function saveViewFiltersAndSorts(tableId, viewId, filters, sorts, groupBy) {
    if (!tableId || !viewId) return;

    // Update META_VIEWS
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        // Create a synthetic view if it doesn't exist
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId,
            viewType: 'grid'
        };
    }

    // Store filters, sorts, groupBy, and colorBy
    META_VIEWS[tableId][viewId].filters = filters || [];
    META_VIEWS[tableId][viewId].sorts = sorts || [];
    META_VIEWS[tableId][viewId].groupBy = groupBy || null;
    META_VIEWS[tableId][viewId].colorBy = currentColorBy || null;

    // Persist to IndexedDB
    await saveView(META_VIEWS[tableId][viewId]);
}

// Get view filters, sorts, groupBy, and colorBy
function getViewFiltersAndSorts(tableId, viewId) {
    if (!tableId || !viewId) return { filters: [], sorts: [], groupBy: null, colorBy: null };

    var view = META_VIEWS[tableId]?.[viewId];
    return {
        filters: (view && view.filters) ? view.filters.slice() : [],
        sorts: (view && view.sorts) ? view.sorts.slice() : [],
        groupBy: (view && view.groupBy) ? view.groupBy : null,
        colorBy: (view && view.colorBy) ? view.colorBy : null
    };
}

// Memoize visible fields per render cycle (same table+view = same result)
var _visibleFieldsCache = { key: null, result: null };
function invalidateVisibleFieldsCache() { _visibleFieldsCache.key = null; _visibleFieldsCache.result = null; }

// Get visible fields for current view in correct order
function getVisibleFieldsForView(tableId, viewId) {
    var ckey = tableId + '|' + (viewId || '_default');
    if (_visibleFieldsCache.key === ckey && _visibleFieldsCache.result) return _visibleFieldsCache.result;
    var config = getViewFieldConfig(tableId, viewId || '_default');
    var fields = META_FIELDS[tableId] || {};
    var allFieldIds = Object.keys(fields);

    // Hidden fields are in hiddenFieldIds; all others are visible
    var hiddenSet = new Set(config.hiddenFieldIds || []);
    var result = [];
    var addedSet = new Set();

    // First add fields from fieldOrder that are not hidden
    for (var fid of (config.fieldOrder || [])) {
        if (fields[fid] && !hiddenSet.has(fid) && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    // Add any remaining visible fields not in fieldOrder (newly added fields)
    for (var fid of allFieldIds) {
        if (!hiddenSet.has(fid) && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    _visibleFieldsCache.key = ckey;
    _visibleFieldsCache.result = result;
    return result;
}

// Get all fields in order (both visible and hidden) for the fields dropdown
function getAllFieldsInOrder(tableId, viewId) {
    var config = getViewFieldConfig(tableId, viewId || '_default');
    var fields = META_FIELDS[tableId] || {};
    var allFieldIds = Object.keys(fields);
    var result = [];
    var addedSet = new Set();

    // First add fields in fieldOrder
    for (var fid of (config.fieldOrder || [])) {
        if (fields[fid] && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    // Then add any remaining fields (newly added ones)
    for (var fid of allFieldIds) {
        if (!addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    return result;
}

// Toggle field visibility for current view
function toggleFieldVisibility(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    if (!config.hiddenFieldIds) config.hiddenFieldIds = [];

    var idx = config.hiddenFieldIds.indexOf(fieldId);
    if (idx >= 0) {
        // Field is hidden, make it visible
        config.hiddenFieldIds.splice(idx, 1);
    } else {
        // Field is visible, hide it
        config.hiddenFieldIds.push(fieldId);
    }

    // Ensure field is in fieldOrder
    if (!config.fieldOrder.includes(fieldId)) {
        config.fieldOrder.push(fieldId);
    }

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

// Move field up in order (optimized with DOM manipulation)
function moveFieldUp(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var idx = config.fieldOrder.indexOf(fieldId);
    if (idx > 0) {
        // Move column in DOM immediately (no full re-render)
        moveColumnInDOM(idx, idx - 1);

        // Swap with previous in array
        var temp = config.fieldOrder[idx - 1];
        config.fieldOrder[idx - 1] = config.fieldOrder[idx];
        config.fieldOrder[idx] = temp;

        // Fast update: in-memory + debounced save
        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();
    }
}

// Move field down in order (optimized with DOM manipulation)
function moveFieldDown(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var idx = config.fieldOrder.indexOf(fieldId);
    if (idx >= 0 && idx < config.fieldOrder.length - 1) {
        // Move column in DOM immediately (no full re-render)
        moveColumnInDOM(idx, idx + 1);

        // Swap with next in array
        var temp = config.fieldOrder[idx + 1];
        config.fieldOrder[idx + 1] = config.fieldOrder[idx];
        config.fieldOrder[idx] = temp;

        // Fast update: in-memory + debounced save
        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();
    }
}

// Show all fields
function showAllFields() {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var fields = META_FIELDS[currentTable] || {};
    var allFieldIds = Object.keys(fields);

    var config = getViewFieldConfig(currentTable, viewId);
    config.hiddenFieldIds = []; // Clear all hidden fields

    // Ensure all fields are in fieldOrder
    for (var fid of allFieldIds) {
        if (!config.fieldOrder.includes(fid)) {
            config.fieldOrder.push(fid);
        }
    }

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

// Hide all fields (except keep at least one visible)
function hideAllFields() {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var fields = META_FIELDS[currentTable] || {};
    var allFieldIds = Object.keys(fields);

    var config = getViewFieldConfig(currentTable, viewId);

    // Get all fields in order, keep the first one visible
    var orderedFields = getAllFieldsInOrder(currentTable, viewId);
    var firstField = orderedFields[0] || allFieldIds[0];

    // Hide all fields except the first one
    config.hiddenFieldIds = allFieldIds.filter(fid => fid !== firstField);

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

function getLocalStats() {
    return new Promise(async (resolve) => {
        try {
            var tempDb = await openDB();
            var count = await new Promise((res, rej) => {
                var tx = tempDb.transaction('data', 'readonly');
                var req = tx.objectStore('data').count();
                req.onsuccess = () => res(req.result);
                req.onerror = () => res(0);
            });
            var lastTimestamp = await new Promise((res, rej) => {
                var tx = tempDb.transaction('sync', 'readonly');
                var req = tx.objectStore('sync').get('lastEventTimestamp');
                req.onsuccess = () => res(req.result ? req.result.value : null);
                req.onerror = () => res(null);
            });
            tempDb.close();
            resolve({ count, lastTimestamp });
        } catch (e) {
            resolve({ count: 0, lastTimestamp: null });
        }
    });
}

// ============ Safe JSON Parsing ============

// Safely parse a fetch Response as JSON. If the server returns non-JSON
// (e.g. an HTML error page from a reverse proxy), this throws a clear
// error instead of the cryptic "Unexpected token '<'" message.
async function safeResponseJson(response, context) {
    var contentType = response.headers.get('content-type') || '';
    if (contentType && !contentType.includes('application/json')) {
        var preview = '';
        try { preview = (await response.text()).substring(0, 120); } catch (e) {}
        throw new Error(
            (context ? context + ': ' : '') +
            'Server returned ' + (contentType || 'unknown content type') +
            ' instead of JSON (HTTP ' + response.status + ').' +
            (preview.indexOf('<html') !== -1 || preview.indexOf('<!DOCTYPE') !== -1
                ? ' The server may be down or the URL may be incorrect.'
                : '')
        );
    }
    try {
        return await response.json();
    } catch (e) {
        throw new Error(
            (context ? context + ': ' : '') +
            'Invalid JSON response from server (HTTP ' + response.status + '). ' +
            'The server may be down or misconfigured.'
        );
    }
}

// ============ Synapse Login ============

var SYNAPSE_HOMESERVER_URL = 'https://app.aminoimmigration.com';
var SYNAPSE_SESSION_KEY = 'amino_synapse_session';

function _saveSynapseSession(session) {
    try {
        localStorage.setItem(SYNAPSE_SESSION_KEY, JSON.stringify(session));
    } catch (e) {
        console.warn('[Synapse] Could not save session:', e);
    }
}

function _loadSynapseSession() {
    try {
        var stored = localStorage.getItem(SYNAPSE_SESSION_KEY);
        return stored ? JSON.parse(stored) : null;
    } catch (e) {
        return null;
    }
}

function _clearSynapseSession() {
    localStorage.removeItem(SYNAPSE_SESSION_KEY);
}

async function verifySynapseSession() {
    var session = _loadSynapseSession();
    if (!session || !session.accessToken) return false;

    try {
        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/account/whoami', {
            headers: { 'Authorization': 'Bearer ' + session.accessToken }
        });
        if (!response.ok) {
            // Token expired or invalid
            _clearSynapseSession();
            return false;
        }
        // Verify the response is actually JSON from a Matrix server,
        // not an HTML page from a reverse proxy or misconfigured server
        var contentType = response.headers.get('content-type') || '';
        if (!contentType.includes('application/json')) {
            console.warn('[Synapse] Session verification returned non-JSON response (content-type: ' + contentType + '). Server may be misconfigured.');
            _clearSynapseSession();
            return false;
        }
        return true;
    } catch (e) {
        // Network error  allow offline access if session exists
        console.warn('[Synapse] Could not verify session, allowing cached session:', e);
        return true;
    }
}

async function trySynapseLogin() {
    var username = document.getElementById('synapse-username').value.trim();
    var password = document.getElementById('synapse-password').value.trim();

    if (!username || !password) {
        showSynapseError('Please enter your username and password.');
        return;
    }

    var btn = document.getElementById('synapse-login-btn');
    btn.textContent = 'Signing in...';
    btn.disabled = true;
    hideSynapseError();

    try {
        var body = {
            type: 'm.login.password',
            identifier: { type: 'm.id.user', user: username },
            password: password,
            initial_device_display_name: 'Amino Viewer'
        };

        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });

        var data = await safeResponseJson(response, 'Login');

        if (!response.ok) {
            throw new Error(data.error || 'Login failed');
        }

        _saveSynapseSession({
            accessToken: data.access_token,
            userId: data.user_id,
            deviceId: data.device_id
        });

        // Set up MatrixClient session for room operations
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, data.access_token, data.user_id, data.device_id);

        // Derive local encryption key from Synapse password
        var salt = new TextEncoder().encode('amino-local-encrypt:' + data.user_id);
        var derivedKey = await deriveKeyFromPassword(password, salt);

        // Check for existing encryption config and handle migration
        var existingConfig = getEncryptionConfig();
        if (existingConfig && existingConfig.verificationToken && existingConfig.type === 'synapse') {
            // Returning user  verify the derived key matches
            try {
                await decryptData(existingConfig.verificationToken, derivedKey);
            } catch (e) {
                // Password changed on Synapse  re-create encryption config with new key
                console.warn('[Synapse] Password changed, re-creating encryption config');
                var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, derivedKey);
                saveEncryptionConfig({
                    type: 'synapse',
                    userId: data.user_id,
                    verificationToken: verificationToken
                });
            }
        } else {
            // First time or migrating from old flow  create new encryption config
            var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, derivedKey);
            saveEncryptionConfig({
                type: 'synapse',
                userId: data.user_id,
                verificationToken: verificationToken
            });
        }

        encryptionKey = derivedKey;
        encryptionEnabled = true;
        await saveSessionKey(encryptionKey);

        // NOTE: AminoData layer is not used for the main hydration flow 
        // hydrateFromWebhooks() handles fetching from n8n directly.
        // Skipping AminoData.init() here to avoid a redundant /api/tables call.

        // Password no longer needed
        password = null;

        hideSynapseLoginScreen();

        // Decide whether to keep encrypted local data or clear for re-hydration.
        // If the same user logs back in with the same password, the derived key
        // will match the verification token and we can reuse cached data  it's
        // already AES-GCM-256 encrypted at rest and unreadable without the key.
        var retainLocalData = false;
        if (existingConfig && existingConfig.type === 'synapse'
            && existingConfig.userId === data.user_id
            && existingConfig.verificationToken) {
            try {
                await decryptData(existingConfig.verificationToken, derivedKey);
                retainLocalData = true;
                console.log('[Synapse] Returning user with valid key  retaining encrypted local data');
            } catch (e) {
                console.log('[Synapse] Key mismatch (password changed or different user)  clearing local data');
            }
        }

        if (!retainLocalData) {
            try {
                var freshDb = await openDB();
                db = freshDb;
                await clearAllData();
                db.close();
                db = null;
            } catch (clearErr) {
                console.warn('[Synapse] Could not clear local data for fresh sync:', clearErr);
            }
        }

        // Go directly to app initialization  will hydrate all rooms from Synapse
        try {
            await init();
        } catch (initErr) {
            console.error('[Synapse] Init failed after login:', initErr);
            hideLoadingOverlay();
            showSynapseError('Signed in but initialization failed: ' + initErr.message);
            showSynapseLoginScreen();
        }
    } catch (err) {
        console.error('[Synapse] Login failed:', err);
        showSynapseError(err.message || 'Login failed. Please check your credentials.');
    } finally {
        btn.textContent = 'Sign In';
        btn.disabled = false;
    }
}

function showSynapseError(msg) {
    var el = document.getElementById('synapse-login-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function hideSynapseError() {
    var el = document.getElementById('synapse-login-error');
    el.style.display = 'none';
}

function showSynapseLoginScreen() {
    var el = document.getElementById('synapse-login-screen');
    el.classList.remove('hidden', 'fading-out');
    // Always show the login form, not the reset form
    document.getElementById('synapse-login-form').style.display = 'block';
    document.getElementById('synapse-reset-form').style.display = 'none';
}

function hideSynapseLoginScreen() {
    var el = document.getElementById('synapse-login-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    setTimeout(function() { el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

async function initSynapseLogin() {
    var valid = await verifySynapseSession();
    if (valid) {
        // Session is valid  restore MatrixClient and proceed
        var session = _loadSynapseSession();
        if (session) {
            MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
        }
        return true;
    }
    // No valid session  show Synapse login screen
    showSynapseLoginScreen();
    return false;
}

// ============ Password Reset ============

var _resetClientSecret = null;
var _resetSid = null;

function showPasswordReset() {
    document.getElementById('synapse-login-form').style.display = 'none';
    document.getElementById('synapse-reset-form').style.display = 'block';
    _showResetStep(1);
    _resetClientSecret = null;
    _resetSid = null;
    document.getElementById('synapse-reset-error').style.display = 'none';
    document.getElementById('synapse-reset-success').style.display = 'none';
}

function hidePasswordReset() {
    document.getElementById('synapse-reset-form').style.display = 'none';
    document.getElementById('synapse-login-form').style.display = 'block';
    document.getElementById('synapse-reset-email').value = '';
    document.getElementById('synapse-reset-error').style.display = 'none';
    document.getElementById('synapse-reset-success').style.display = 'none';
}

function _showResetStep(step) {
    document.querySelectorAll('.synapse-reset-step').forEach(function(el) { el.classList.remove('active'); });
    var stepEl = document.getElementById('synapse-reset-step' + step);
    if (stepEl) stepEl.classList.add('active');
}

function _showResetError(msg) {
    var el = document.getElementById('synapse-reset-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function _hideResetError() {
    document.getElementById('synapse-reset-error').style.display = 'none';
}

async function requestPasswordReset() {
    var email = document.getElementById('synapse-reset-email').value.trim();
    if (!email) {
        _showResetError('Please enter your email address.');
        return;
    }

    var btn = document.getElementById('synapse-reset-send-btn');
    btn.disabled = true;
    btn.textContent = 'Sending...';
    _hideResetError();

    try {
        // Generate a unique client_secret for this reset flow
        _resetClientSecret = 'amino_reset_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/account/password/email/requestToken', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                email: email,
                client_secret: _resetClientSecret,
                send_attempt: 1
            })
        });

        var data = await response.json().catch(function() { return {}; });

        if (!response.ok) {
            if (data.errcode === 'M_THREEPID_NOT_FOUND') {
                throw new Error('No account found with that email address.');
            }
            throw new Error(data.error || 'Failed to send reset email (HTTP ' + response.status + ')');
        }

        _resetSid = data.sid;

        // Move to step 2  user must verify email then enter new password
        _showResetStep(2);

    } catch (e) {
        console.error('[Reset] Failed to request password reset:', e);
        _showResetError(e.message || 'Failed to send reset email.');
    } finally {
        btn.disabled = false;
        btn.textContent = 'Send Reset Email';
    }
}

async function confirmPasswordReset() {
    var newPassword = document.getElementById('synapse-reset-new-password').value;
    var confirmPassword = document.getElementById('synapse-reset-confirm-password').value;

    if (!newPassword) {
        _showResetError('Please enter a new password.');
        return;
    }
    if (newPassword.length < 8) {
        _showResetError('Password must be at least 8 characters.');
        return;
    }
    if (newPassword !== confirmPassword) {
        _showResetError('Passwords do not match.');
        return;
    }

    if (!_resetSid || !_resetClientSecret) {
        _showResetError('Reset session expired. Please start over.');
        return;
    }

    var btn = document.getElementById('synapse-reset-confirm-btn');
    btn.disabled = true;
    btn.textContent = 'Resetting...';
    _hideResetError();

    try {
        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/account/password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                new_password: newPassword,
                logout_devices: false,
                auth: {
                    type: 'm.login.email.identity',
                    threepid_creds: {
                        sid: _resetSid,
                        client_secret: _resetClientSecret
                    },
                    threepidCreds: {
                        sid: _resetSid,
                        client_secret: _resetClientSecret
                    }
                }
            })
        });

        if (!response.ok) {
            var data = await response.json().catch(function() { return {}; });
            if (data.errcode === 'M_THREEPID_AUTH_FAILED') {
                throw new Error('Email not yet verified. Please click the link in your email first, then try again.');
            }
            throw new Error(data.error || 'Failed to reset password (HTTP ' + response.status + ')');
        }

        // Success  show step 3
        _showResetStep(3);
        document.getElementById('synapse-reset-new-password').value = '';
        document.getElementById('synapse-reset-confirm-password').value = '';
        _resetClientSecret = null;
        _resetSid = null;

    } catch (e) {
        console.error('[Reset] Failed to confirm password reset:', e);
        _showResetError(e.message || 'Failed to reset password.');
    } finally {
        btn.disabled = false;
        btn.textContent = 'Reset Password';
    }
}

// ============ View Selection ============

function showViewSelection() {
    var el = document.getElementById('view-selection-screen');
    el.classList.remove('hidden');
}

function hideViewSelection() {
    var el = document.getElementById('view-selection-screen');
    el.classList.add('hidden');
}

function selectDatabaseView() {
    hideViewSelection();
    // Database view is the current default  already rendered by init()
}

function selectInterfaceView() {
    hideViewSelection();
    // Interface view  to be developed
    // For now, fall through to database view
}

function synapseLogout() {
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        // Fire and forget logout request
        fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/logout', {
            method: 'POST',
            headers: {
                'Authorization': 'Bearer ' + session.accessToken,
                'Content-Type': 'application/json'
            }
        }).catch(function() {});
    }
    _clearSynapseSession();
}

// Wire up Synapse login UI
document.getElementById('synapse-login-btn').onclick = trySynapseLogin;
document.getElementById('synapse-username').onkeydown = function(e) { if (e.key === 'Enter') document.getElementById('synapse-password').focus(); };
document.getElementById('synapse-password').onkeydown = function(e) { if (e.key === 'Enter') trySynapseLogin(); };

// Wire up password reset UI
document.getElementById('synapse-reset-email').onkeydown = function(e) { if (e.key === 'Enter') requestPasswordReset(); };
document.getElementById('synapse-reset-new-password').onkeydown = function(e) { if (e.key === 'Enter') document.getElementById('synapse-reset-confirm-password').focus(); };
document.getElementById('synapse-reset-confirm-password').onkeydown = function(e) { if (e.key === 'Enter') confirmPasswordReset(); };

// Wire up view selection UI
document.getElementById('view-as-database-btn').onclick = selectDatabaseView;
document.getElementById('view-as-interface-btn').onclick = selectInterfaceView;

// ============ Auth ============

document.getElementById('auth-submit').onclick = tryAuth;
document.getElementById('api-key-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('set-filter-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('auth-clear').onclick = clearLocalAndReset;
document.getElementById('connect-api-key-input').onkeydown = (e) => { if (e.key === 'Enter') submitConnectApi(); };
document.getElementById('connect-api-set-filter').onkeydown = (e) => { if (e.key === 'Enter') submitConnectApi(); };

async function initAuthScreen() {
    // No-op: auth is handled exclusively via Synapse login (trySynapseLogin).
}

// Silently restore Matrix session without blocking app startup
function restoreMatrixSessionQuietly() {
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
        updateMatrixStatus();
    }
}

async function clearLocalAndReset() {
    if (!confirm('Clear all local data?')) return;
    try {
        db = await openDB();
        await clearAllData();
        db.close();
        db = null;
    } catch (e) {
        console.error('Clear error:', e);
    }
    // Clear stale form state and errors
    document.getElementById('api-key-input').value = '';
    document.getElementById('set-filter-input').value = '';
    document.getElementById('auth-error').style.display = 'none';
    initAuthScreen();
}

async function tryAuth() {
    // No-op: auth is via Synapse login.
    showAuthError('API key authentication has been replaced. Please use the Synapse login.');
}

function showAuthError(msg) {
    var el = document.getElementById('auth-error');
    el.textContent = msg;
    el.style.display = 'block';
}

var _hideAuthTimeout = null;
function hideAuthScreen() {
    var el = document.getElementById('auth-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        if (_hideAuthTimeout) { clearTimeout(_hideAuthTimeout); _hideAuthTimeout = null; }
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    _hideAuthTimeout = setTimeout(function() { _hideAuthTimeout = null; el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

function showAuthScreen() {
    // Cancel any pending hide timeout to prevent race condition
    if (_hideAuthTimeout) { clearTimeout(_hideAuthTimeout); _hideAuthTimeout = null; }

    var el = document.getElementById('auth-screen');
    el.classList.remove('hidden', 'fading-out');
    if (pollInterval) clearInterval(pollInterval);
    SyncHistory.stopPolling();
    initAuthScreen();
}

function logout() {
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = null;
    SynapseSync.stop();
    // Stop n8n webhook data layer polling and clear its encryption key
    AminoData.logout(false); // Keep encrypted data in IndexedDB for next session
    // Close stale IndexedDB connection
    if (db) {
        try { db.close(); } catch (e) { /* ignore */ }
        db = null;
    }
    clearSessionKey();
    // Clear encryption state
    encryptionKey = null;
    encryptionEnabled = false;
    // Log out of Synapse and show login screen
    synapseLogout();
    showSynapseLoginScreen();
}

async function manualSync() {
    // Manual sync: restart the Synapse sync loop
    if (!SynapseSync.running) {
        SynapseSync.start();
    }
}

// ============ Airtable Manual Sync ============

var _syncBtnCooldownTimer = null;

async function manualAirtableSync() {
    var btn = document.getElementById('airtable-sync-btn');
    var textEl = document.getElementById('sync-btn-text');

    // Check if still in cooldown
    if (btn && btn.classList.contains('cooldown')) return;

    // Visual: show syncing state
    if (btn) btn.classList.add('syncing');
    if (textEl) textEl.textContent = 'Syncing...';

    try {
        // 1. Trigger n8n to pull from Airtable
        var result = await AminoData.triggerAirtableSync();

        if (!result.triggered && result.cooldownRemaining > 0) {
            // Was rate-limited  start cooldown UI
            _startSyncCooldownUI(result.cooldownRemaining);
            return;
        }

        if (result.error) {
            console.warn('[ManualSync] Airtable trigger had error:', result.error);
        }

        // 2. Also ensure Synapse sync is running to pick up the changes
        if (!SynapseSync.running) {
            SynapseSync.start();
        }

        // 3. Brief delay for n8n to process, then show cooldown
        if (btn) btn.classList.remove('syncing');
        if (textEl) textEl.textContent = 'Triggered';

        // Start cooldown countdown after a short feedback delay
        setTimeout(function() {
            _startSyncCooldownUI(result.cooldownRemaining || 60000);
        }, 1500);

    } catch (err) {
        console.error('[ManualSync] Error:', err);
        if (btn) btn.classList.remove('syncing');
        if (textEl) textEl.textContent = 'Sync';
    }
}

function _startSyncCooldownUI(remainingMs) {
    var btn = document.getElementById('airtable-sync-btn');
    var textEl = document.getElementById('sync-btn-text');

    if (btn) {
        btn.classList.remove('syncing');
        btn.classList.add('cooldown');
    }

    if (_syncBtnCooldownTimer) clearInterval(_syncBtnCooldownTimer);

    var endTime = Date.now() + remainingMs;

    function tick() {
        var left = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
        if (left <= 0) {
            clearInterval(_syncBtnCooldownTimer);
            _syncBtnCooldownTimer = null;
            if (btn) btn.classList.remove('cooldown');
            if (textEl) textEl.textContent = 'Sync';
            return;
        }
        if (textEl) textEl.textContent = left + 's';
    }

    tick();
    _syncBtnCooldownTimer = setInterval(tick, 1000);
}

// ============ Intelligent Auto-Sync on Tab Focus ============
// When the user returns to the tab after being away, trigger an Airtable
// sync if enough time has passed (respects the data-layer cooldown).

(function() {
    var IDLE_THRESHOLD = 60000; // 60s away before auto-triggering on return
    var _lastHidden = 0;

    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            _lastHidden = Date.now();
            return;
        }

        // Tab became visible  check if we've been away long enough
        var away = Date.now() - _lastHidden;
        if (_lastHidden > 0 && away >= IDLE_THRESHOLD) {
            // Check cooldown before triggering
            var status = AminoData.getAirtableSyncStatus();
            if (status.cooldownRemaining <= 0 && !status.inFlight) {
                console.log('[AutoSync] Tab refocused after ' + Math.round(away / 1000) + 's  triggering Airtable sync');
                manualAirtableSync();
            }
        }
    });
})();

// Skip auth and go directly to CSV upload
async function skipAuthAndUploadCSV() {
    // Prompt for file FIRST - if user cancels, stay on auth screen
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return; // User cancelled - stay on auth screen

        // Now hide auth screen and initialize the app
        hideAuthScreen();

        META_TABLES = {};
        META_FIELDS = {};
        META_VIEWS = {};
        TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
        currentTable = null;
        currentPage = 0;
        currentRecordIds = [];
        originalRecordIds = [];
        totalRecords = 0;
        lastEventTimestamp = null;

        loadSidebarState();
        initSidebarSearch();

        db = await openDB();
        appOpenedEventId = await getMaxEventId();

        var tables = await getAllTables();
        var fields = await getAllFields();
        var views = await getAllViews();

        tables.forEach(t => META_TABLES[t.tableId] = t);
        fields.forEach(f => {
            if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
            META_FIELDS[f.tableId][f.fieldId] = f;
        });
        views.forEach(v => {
            if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
            META_VIEWS[v.tableId][v.viewId] = v;
        });

        await loadTableSettings();
        updateConnectApiButton();

        // Process the selected file directly instead of opening another picker
        await processCSVFile(file);
    };

    input.click();
}

// Skip auth and go directly to .amo snapshot upload
async function skipAuthAndUploadAmo() {
    // Prompt for file FIRST - if user cancels, stay on auth screen
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.amo';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return; // User cancelled - stay on auth screen

        // Now hide auth screen and initialize the app
        hideAuthScreen();

        META_TABLES = {};
        META_FIELDS = {};
        META_VIEWS = {};
        TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
        currentTable = null;
        currentPage = 0;
        currentRecordIds = [];
        originalRecordIds = [];
        totalRecords = 0;
        lastEventTimestamp = null;

        loadSidebarState();
        initSidebarSearch();

        db = await openDB();
        appOpenedEventId = await getMaxEventId();

        var tables = await getAllTables();
        var fields = await getAllFields();
        var views = await getAllViews();

        tables.forEach(t => META_TABLES[t.tableId] = t);
        fields.forEach(f => {
            if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
            META_FIELDS[f.tableId][f.fieldId] = f;
        });
        views.forEach(v => {
            if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
            META_VIEWS[v.tableId][v.viewId] = v;
        });

        await loadTableSettings();
        updateConnectApiButton();

        // Process the selected file directly instead of opening another picker
        await processAmoFile(file);
    };

    input.click();
}

function updateConnectApiButton() {
    // No-op: Synapse auth replaces API key
    var btn = document.getElementById('connect-api-btn');
    if (btn) {
        btn.style.display = 'none';
    }
}

// Connect API modal functions
function showConnectApiModal() {
    var modal = document.getElementById('connect-api-modal');
    modal.style.display = 'flex';
    document.getElementById('connect-api-key-input').value = '';
    document.getElementById('connect-api-set-filter').value = '';
    document.getElementById('connect-api-error').style.display = 'none';
    document.getElementById('connect-api-key-input').focus();
}

function hideConnectApiModal() {
    document.getElementById('connect-api-modal').style.display = 'none';
}

async function submitConnectApi() {
    // No-op: auth is via Synapse login.
    var errEl = document.getElementById('connect-api-error');
    if (errEl) {
        errEl.textContent = 'API key authentication has been replaced by Synapse login.';
        errEl.style.display = 'block';
    }
}

// ============ Data Processing ============

function parsePayload(payload) {
    if (typeof payload === 'string') {
        try { return JSON.parse(payload); } catch { return null; }
    }
    return payload;
}

// Infer field type from a sample value (used for auto-discovered fields)
function inferFieldType(value) {
    if (value === null || value === undefined) return 'unknown';
    if (Array.isArray(value)) {
        // Check if it's an attachment array (objects with url property)
        if (value.length > 0 && typeof value[0] === 'object' && value[0].url) {
            return 'multipleAttachments';
        }
        // Check if it's a linked record array (strings starting with 'rec')
        if (value.length > 0 && typeof value[0] === 'string' && value[0].startsWith('rec')) {
            return 'multipleRecordLinks';
        }
        return 'multipleSelects';
    }
    if (typeof value === 'object') {
        // Could be a single attachment or other complex type
        if (value.url) return 'multipleAttachments';
        return 'object';
    }
    if (typeof value === 'number') {
        return Number.isInteger(value) ? 'number' : 'number';
    }
    if (typeof value === 'boolean') return 'checkbox';
    if (typeof value === 'string') {
        // Try to detect dates
        if (/^\d{4}-\d{2}-\d{2}/.test(value)) return 'date';
        // Try to detect emails
        if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) return 'email';
        // Try to detect URLs
        if (/^https?:\/\//.test(value)) return 'url';
        return 'singleLineText';
    }
    return 'unknown';
}

// Fast in-memory event processing for CSV import - skips IndexedDB entirely
// Calls onProgress periodically for UI updates
async function processEventsMemoryOnly(events, onProgress) {
    if (!events || !Array.isArray(events)) return;

    var tableDataMap = {}; // tableId -> { recordId -> fields }
    var total = events.length;

    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;

        if (recordType === 'table') {
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.displayNameFieldId) tableData.displayNameFieldId = payload.displayNameFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            if (payload.readOnly != null) fieldData.readOnly = payload.readOnly;
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else if (recordType === 'viewConfig') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) {
                META_VIEWS[tableId][viewId] = { tableId, viewId };
            }
            var viewData = META_VIEWS[tableId][viewId];
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.hiddenFieldIds) viewData.hiddenFieldIds = payload.hiddenFieldIds;
            if (payload.fieldOrder) viewData.fieldOrder = payload.fieldOrder;
            if (payload.filters) viewData.filters = payload.filters;
            if (payload.sorts) viewData.sorts = payload.sorts;
            if (payload.folderId !== undefined) viewData.folderId = payload.folderId;

        } else if (recordType === 'tableSettings') {
            // User-specific table and view settings
            if (payload.tables) TABLE_SETTINGS.tables = payload.tables;
            if (payload.tableOrder) TABLE_SETTINGS.tableOrder = payload.tableOrder;
            if (payload.views) TABLE_SETTINGS.views = payload.views;

        } else {
            // Data record
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            // Auto-create placeholder table
            if (!META_TABLES[tableId]) {
                META_TABLES[tableId] = {
                    tableId: tableId,
                    tableName: tableId,
                    _placeholder: true
                };
            }

            // Auto-create placeholder fields
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            var allFieldIds = [
                ...Object.keys(pfields.INS || {}),
                ...Object.keys(pfields.ALT || {}),
                ...Object.keys(pfields.SYN || {}),
                ...(Array.isArray(pfields.NUL) ? pfields.NUL : [])
            ];
            for (var fid of allFieldIds) {
                if (!META_FIELDS[tableId][fid]) {
                    var sampleValue = (pfields.INS && pfields.INS[fid]) || (pfields.ALT && pfields.ALT[fid]) || (pfields.SYN && pfields.SYN[fid]);
                    META_FIELDS[tableId][fid] = {
                        tableId: tableId,
                        fieldId: fid,
                        fieldName: fid,
                        fieldType: inferFieldType(sampleValue),
                        _placeholder: true
                    };
                }
            }

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) tableDataMap[tableId][recordId] = {};

            var state = tableDataMap[tableId][recordId];
            if (pfields.INS) Object.assign(state, pfields.INS);
            if (pfields.ALT) Object.assign(state, pfields.ALT);
            if (pfields.SYN) Object.assign(state, pfields.SYN);
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => delete state[fieldId]);
            }
        }

        // Report progress and yield to UI every 5000 events
        if (i > 0 && i % 5000 === 0) {
            if (onProgress) onProgress(i, total, Object.keys(META_TABLES).length);
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Store data records in a memory-only snapshot (for showing table data)
    // Structure: IN_MEMORY_DATA[tableId][recordId] = { fields }
    window.IN_MEMORY_DATA = tableDataMap;

    if (onProgress) onProgress(total, total, Object.keys(META_TABLES).length);
}

// Process events into IndexedDB records, field history, and schema metadata.
//
// Options:
//   historyOnly (boolean, default false)  when true, only builds field
//       history entries and saves schema metadata (tables/fields/views).
//       Data records are NOT written to IndexedDB, preserving the
//       webhook-hydrated current state.  Record state is still tracked
//       in memory (starting from {}) so that oldValue / newValue in
//       history entries are accurate relative to the event sequence.
async function processEvents(events, options) {
    if (!events || !Array.isArray(events)) return;

    options = options || {};
    var historyOnly = !!options.historyOnly;

    var tables = [];
    var fields = [];
    var views = [];
    var dataRecords = [];
    var fieldHistoryEntries = [];
    var tableDataMap = {}; // tableId -> { recordId -> fields }

    // Pre-load existing record states from IndexedDB for accurate history
    // oldValue tracking.  In historyOnly mode we skip pre-loading so that
    // the in-memory state starts from {} and history old/new values reflect
    // the chronological event sequence rather than the current DB snapshot.
    if (!historyOnly) {
        // First pass: collect all unique [tableId, recordId] pairs for data records
        var recordsToLoad = {}; // tableId -> Set of recordIds
        for (var e of events) {
            if (!e || !e.set || !e.recordId) continue;
            var payload = parsePayload(e.payload);
            if (!payload || typeof payload !== 'object') continue;
            var recordType = payload._set;
            // Only load state for data records (not table/field/view metadata)
            if (recordType !== 'table' && recordType !== 'field' && recordType !== 'view') {
                var tableId = e.set.replace('airtable:', '');
                if (!recordsToLoad[tableId]) recordsToLoad[tableId] = new Set();
                recordsToLoad[tableId].add(e.recordId);
            }
        }

        // Load existing records from IndexedDB
        for (var tableId in recordsToLoad) {
            var recordIds = Array.from(recordsToLoad[tableId]);
            if (recordIds.length > 0) {
                var existingRecords = await getRecordsByIds(tableId, recordIds);
                if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
                for (var rec of existingRecords) {
                    // Pre-populate with existing field values
                    tableDataMap[tableId][rec.recordId] = { ...rec.fields };
                }
            }
        }
    }

    for (var e of events) {
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;
        var eventId = e.id;
        var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

        if (recordType === 'table') {
            // Tables: recordId starts with "tbl", set points to base
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.displayNameFieldId) tableData.displayNameFieldId = payload.displayNameFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            tables.push(tableData);
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            // Fields: recordId starts with "fld", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            if (payload.readOnly != null) fieldData.readOnly = payload.readOnly;
            fields.push(fieldData);
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            // Views: recordId starts with "viw", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            views.push(viewData);
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else if (recordType === 'viewConfig') {
            // View configuration updates: hiddenFieldIds, fieldOrder, filters, sorts
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;

            // Initialize META_VIEWS if needed
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) {
                META_VIEWS[tableId][viewId] = { tableId, viewId };
            }

            // Update the view with config data
            var viewData = META_VIEWS[tableId][viewId];
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.hiddenFieldIds) viewData.hiddenFieldIds = payload.hiddenFieldIds;
            if (payload.fieldOrder) viewData.fieldOrder = payload.fieldOrder;
            if (payload.filters) viewData.filters = payload.filters;
            if (payload.sorts) viewData.sorts = payload.sorts;
            if (payload.folderId !== undefined) viewData.folderId = payload.folderId;

            views.push(viewData);

        } else if (recordType === 'tableSettings') {
            // User-specific table and view settings
            if (payload.tables) TABLE_SETTINGS.tables = payload.tables;
            if (payload.tableOrder) TABLE_SETTINGS.tableOrder = payload.tableOrder;
            if (payload.views) TABLE_SETTINGS.views = payload.views;

        } else {
            // Data record: recordId starts with "rec"
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            // Auto-create placeholder table if not seen yet (will be updated when real metadata arrives)
            if (!META_TABLES[tableId]) {
                var placeholderTable = {
                    tableId: tableId,
                    tableName: tableId,  // Use ID as placeholder name
                    _placeholder: true   // Mark as placeholder for later update
                };
                META_TABLES[tableId] = placeholderTable;
                tables.push(placeholderTable);
            }

            // Auto-create placeholder fields from INS/ALT/SYN/NUL keys
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            var allFieldIds = [
                ...Object.keys(pfields.INS || {}),
                ...Object.keys(pfields.ALT || {}),
                ...Object.keys(pfields.SYN || {}),
                ...(Array.isArray(pfields.NUL) ? pfields.NUL : [])
            ];
            for (var fid of allFieldIds) {
                if (!META_FIELDS[tableId][fid]) {
                    // Get a sample value to infer type
                    var sampleValue = (pfields.INS && pfields.INS[fid]) || (pfields.ALT && pfields.ALT[fid]) || (pfields.SYN && pfields.SYN[fid]);
                    var placeholderField = {
                        tableId: tableId,
                        fieldId: fid,
                        fieldName: fid,  // Use ID as placeholder name
                        fieldType: inferFieldType(sampleValue),
                        _placeholder: true  // Mark as placeholder for later update
                    };
                    META_FIELDS[tableId][fid] = placeholderField;
                    fields.push(placeholderField);
                }
            }

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) {
                // Initialize new record (existing records pre-loaded above)
                tableDataMap[tableId][recordId] = {};
            }

            var state = tableDataMap[tableId][recordId];

            // Default first ALT as INS: if record state is empty (new record) and
            // there's no INS but there IS ALT, promote ALT to INS
            if (Object.keys(state).length === 0 && !pfields.INS && pfields.ALT) {
                pfields = { INS: pfields.ALT, NUL: pfields.NUL };
            }

            // Capture field history for INS (insert/create)
            if (pfields.INS) {
                for (var fieldId in pfields.INS) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'created',
                        oldValue: null,
                        newValue: pfields.INS[fieldId]
                    });
                }
                Object.assign(state, pfields.INS);
            }

            // Capture field history for ALT (alter/update)
            if (pfields.ALT) {
                for (var fieldId in pfields.ALT) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'updated',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.ALT[fieldId]
                    });
                }
                Object.assign(state, pfields.ALT);
            }

            // Capture field history for SYN (sync/snapshot)
            if (pfields.SYN) {
                for (var fieldId in pfields.SYN) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'synced',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.SYN[fieldId]
                    });
                }
                Object.assign(state, pfields.SYN);
            }

            // Capture field history for NUL (nullify/delete)
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'deleted',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: null
                    });
                    delete state[fieldId];
                });
            }
        }

        // Track the latest event timestamp for incremental sync
        if (e.created_at && (!lastEventTimestamp || e.created_at > lastEventTimestamp)) {
            lastEventTimestamp = e.created_at;
        }
    }

    // In historyOnly mode, skip saving data records to IndexedDB  the
    // webhook-hydrated current state is authoritative.  We still save
    // schema metadata (tables/fields/views) since room state events carry
    // richer schema info (field types, options, readOnly flags).
    if (!historyOnly) {
        // Convert tableDataMap to dataRecords array and save per-table to limit peak memory
        var dataRecords = [];
        for (var tableId in tableDataMap) {
            for (var recordId in tableDataMap[tableId]) {
                dataRecords.push({
                    tableId,
                    recordId,
                    fields: tableDataMap[tableId][recordId]
                });
            }
            // Free this table's data from the map after converting
            delete tableDataMap[tableId];
        }

        // Save batch (schema + data records)
        if (tables.length || fields.length || views.length || dataRecords.length) {
            await saveBatch(tables, fields, views, dataRecords);
        }
        dataRecords = null; // release
    } else {
        // historyOnly: save schema metadata only, no data records
        if (tables.length || fields.length || views.length) {
            await saveBatch(tables, fields, views, []);
        }
        tableDataMap = null; // release  not needed for storage
    }

    // Save field history in batches to avoid peak memory from huge array
    if (fieldHistoryEntries.length > 0) {
        var histBatchSize = 1000;
        for (var fhi = 0; fhi < fieldHistoryEntries.length; fhi += histBatchSize) {
            await saveFieldHistory(fieldHistoryEntries.slice(fhi, fhi + histBatchSize));
        }
    }
    fieldHistoryEntries = null; // release

    // Save raw events for Events view
    await saveRawEvents(events);
}

function applyPayloadFields(target, payload) {
    if (!payload.fields) return;
    var fields = payload.fields;
    if (fields.INS) Object.assign(target, fields.INS);
    if (fields.ALT) Object.assign(target, fields.ALT);
    if (fields.SYN) Object.assign(target, fields.SYN);
    if (fields.NUL && Array.isArray(fields.NUL)) {
        fields.NUL.forEach(k => delete target[k]);
    }
}

// ============ UI ============

// Fast DOM-only search filter  uses CSS class toggling for minimal reflow
function filterSidebarDOM(query) {
    var searchQuery = (query || '').toLowerCase().trim();
    var tableList = document.getElementById('table-list');
    if (!tableList) return;

    // Toggle a single class on the container to control search-mode styles via CSS
    // This avoids touching every element's style.display individually
    var isSearching = !!searchQuery;
    tableList.classList.toggle('sidebar-searching', isSearching);

    if (!isSearching) {
        // Clear any per-item hidden classes when search is cleared
        var hidden = tableList.querySelectorAll('.sidebar-search-hidden');
        for (var i = 0; i < hidden.length; i++) {
            hidden[i].classList.remove('sidebar-search-hidden');
        }
        return;
    }

    // Only update the per-wrapper match/hide class (batch reads then writes)
    var wrappers = tableList.querySelectorAll('.table-wrapper[data-table-id]');
    var names = new Array(wrappers.length);
    for (var i = 0; i < wrappers.length; i++) {
        var tableId = wrappers[i].getAttribute('data-table-id');
        if (tableId === '_events' || tableId === '_sync_status') {
            names[i] = null;
        } else {
            var nameEl = wrappers[i].querySelector('.table-name');
            names[i] = nameEl ? nameEl.textContent.toLowerCase() : tableId.toLowerCase();
        }
    }
    for (var i = 0; i < wrappers.length; i++) {
        var shouldHide = names[i] === null || !names[i].includes(searchQuery);
        wrappers[i].classList.toggle('sidebar-search-hidden', shouldHide);
    }
}

async function renderSidebar(forceRefresh) {
    var tableList = document.getElementById('table-list');
    // Build new content into a DocumentFragment off-screen to avoid visible blink
    var fragment = document.createDocumentFragment();

    var now = Date.now();
    var cacheValid = !forceRefresh && _sidebarCache.tables && (now - _sidebarCache.timestamp < SIDEBAR_CACHE_TTL);

    var tables, tableCounts, maxCount, eventsCount;

    if (cacheValid) {
        // Use cached data for fast re-renders (search, pin toggle, section toggle)
        tables = _sidebarCache.tables;
        tableCounts = _sidebarCache.tableCounts;
        maxCount = _sidebarCache.maxCount;
        eventsCount = _sidebarCache.eventsCount;
    } else {
        // Fetch fresh data from DB
        tables = await getAllTables();

        // Also get tables from META_TABLES (in-memory from current session)
        var metaTableIds = Object.keys(META_TABLES);
        for (var i = 0; i < metaTableIds.length; i++) {
            var tid = metaTableIds[i];
            if (!tables.find(t => t.tableId === tid)) {
                tables.push(META_TABLES[tid]);
            }
        }

        // Get record counts for all tables in parallel (for count bar visualization)
        tableCounts = {};
        maxCount = 0;
        var countAndEvents = await Promise.all([
            Promise.all(tables.map(function(table) {
                return getRecordCountForTable(table.tableId).then(function(count) {
                    return { tableId: table.tableId, count: count };
                });
            })),
            getRawEventsCount()
        ]);
        var countResults = countAndEvents[0];
        eventsCount = countAndEvents[1];
        countResults.forEach(function(r) {
            tableCounts[r.tableId] = r.count;
            if (r.count > maxCount) maxCount = r.count;
        });
        if (eventsCount > maxCount) maxCount = eventsCount;

        // Update cache
        _sidebarCache.tables = tables;
        _sidebarCache.tableCounts = tableCounts;
        _sidebarCache.maxCount = maxCount;
        _sidebarCache.eventsCount = eventsCount;
        _sidebarCache.timestamp = now;
    }

    // Filter tables by search query
    var searchQuery = SIDEBAR_STATE.searchQuery.toLowerCase().trim();
    var filteredTables = tables;
    if (searchQuery) {
        filteredTables = tables.filter(t => {
            var name = (t.tableName || t.tableId || '').toLowerCase();
            return name.includes(searchQuery);
        });
    }

    // Group tables by type
    var groupedTables = {
        primary: [],
        operational: [],
        collection: [],
        reference: [],
        dev: []
    };

    filteredTables.forEach(table => {
        var tableName = table.tableName || table.tableId;
        var type = getTableType(tableName);
        // Map 'events' type to operational
        if (type === 'events') type = 'operational';
        if (groupedTables[type]) {
            groupedTables[type].push(table);
        } else {
            groupedTables.operational.push(table);
        }
    });

    // Sort each group alphabetically (except primary which has a fixed order)
    var primaryOrder = ['client info', 'case master view', 'events'];
    Object.keys(groupedTables).forEach(type => {
        if (type === 'primary') {
            groupedTables[type].sort((a, b) => {
                var aIdx = primaryOrder.indexOf((a.tableName || a.tableId).toLowerCase());
                var bIdx = primaryOrder.indexOf((b.tableName || b.tableId).toLowerCase());
                return aIdx - bIdx;
            });
        } else {
            groupedTables[type].sort((a, b) => (a.tableName || a.tableId).localeCompare(b.tableName || b.tableId));
        }
    });

    // Helper to render a table item
    function renderTableItem(table, showExpandArrow = true) {
        var tableId = table.tableId;
        var tableName = table.tableName || tableId;
        var type = getTableType(tableName);
        var config = TABLE_TYPE_CONFIG[type] || TABLE_TYPE_CONFIG.operational;
        var count = tableCounts[tableId] || 0;
        var isPinned = SIDEBAR_STATE.pinnedTables.includes(tableId);
        var isActive = tableId === currentTable;
        var barWidth = Math.round(getCountBarWidth(count, maxCount) * 20);

        var wrapper = document.createElement('div');
        wrapper.className = 'table-wrapper';
        wrapper.setAttribute('data-table-id', tableId);

        var div = document.createElement('div');
        div.className = 'table-item' + (isActive ? ' active expanded' : '');
        div.style.cssText = isActive ? '--active-color: ' + config.color + ';' : '';

        // Set the ::before background color for active state
        if (isActive) {
            div.style.setProperty('--type-color', config.color);
        }

        div.innerHTML =
            '<span class="table-icon type-' + type + '">' + config.icon + '</span>' +
            '<span class="table-name">' + esc(tableName) + '</span>' +
            '<button class="pin-btn' + (isPinned ? ' pinned' : '') + '" onclick="toggleTablePin(\'' + esc(tableId) + '\', event)" title="' + (isPinned ? 'Unpin' : 'Pin') + '">' +
                (isPinned ? SIDEBAR_ICONS.starFilled : SIDEBAR_ICONS.star) +
            '</button>' +
            '<span class="count-bar-wrapper">' +
                '<span class="count-bar" style="width: ' + barWidth + 'px; background: ' + config.color + ';"></span>' +
                '<span class="count-value" style="color: ' + config.color + ';">' + formatRecordCount(count) + '</span>' +
            '</span>' +
            (showExpandArrow ? '<span class="expand-arrow">&#9654;</span>' : '');

        div.oncontextmenu = ((t) => (e) => {
            showTableContextMenu(e, t);
        })(tableId);

        div.onclick = ((t) => (e) => {
            // Don't toggle if clicking pin button
            if (e.target.closest('.pin-btn')) return;
            toggleTableViews(t, e);
        })(tableId);

        wrapper.appendChild(div);

        // Create views list container
        var viewsList = document.createElement('div');
        viewsList.className = 'table-views-list' + (isActive ? ' expanded' : '');
        viewsList.id = 'views-list-' + tableId;
        // Use cached views for instant rendering instead of showing "Loading views..."
        if (META_VIEWS[tableId] && Object.keys(META_VIEWS[tableId]).length > 0) {
            viewsList.innerHTML = renderViewsListHTML(tableId);
        } else {
            viewsList.innerHTML = '<div class="table-view-item loading" style="color: #6b7280; font-style: italic;">Loading views...</div>';
        }
        wrapper.appendChild(viewsList);

        return wrapper;
    }

    // Helper to render a section header
    function renderSectionHeader(sectionId, title, icon, color, count) {
        var isExpanded = SIDEBAR_STATE.expandedSections[sectionId];
        var header = document.createElement('div');
        header.className = 'sidebar-section-header' + (isExpanded ? '' : ' collapsed');
        header.innerHTML =
            SIDEBAR_ICONS.chevronDown +
            '<span class="section-icon" style="color: ' + color + ';">' + icon + '</span>' +
            '<span>' + title + '</span>' +
            '<span class="section-count">' + count + '</span>';
        header.onclick = () => toggleSidebarSection(sectionId);
        header._sectionId = sectionId;
        return header;
    }

    // Collect table IDs that need views loaded (for after DOM swap)
    var _viewLoadQueue = [];

    // If not searching, show pinned and recent sections
    if (!searchQuery) {
        // Events Stream (always at top)
        var eventsWrapper = document.createElement('div');
        eventsWrapper.className = 'table-wrapper';
        eventsWrapper.setAttribute('data-table-id', '_events');

        var eventsDiv = document.createElement('div');
        eventsDiv.className = 'table-item events-item' + (currentTable === '_events' ? ' active' : '');
        var eventsBarWidth = Math.round(getCountBarWidth(eventsCount, maxCount) * 20);
        eventsDiv.innerHTML =
            '<span class="table-icon type-events">' + TABLE_TYPE_CONFIG.events.icon + '</span>' +
            '<span class="table-name">Events Stream</span>' +
            '<span class="count-bar-wrapper">' +
                '<span class="count-bar" style="width: ' + eventsBarWidth + 'px; background: ' + TABLE_TYPE_CONFIG.events.color + ';"></span>' +
                '<span class="count-value" style="color: ' + TABLE_TYPE_CONFIG.events.color + ';">' + formatRecordCount(eventsCount) + '</span>' +
            '</span>';
        eventsDiv.onclick = () => showEventsView();
        eventsWrapper.appendChild(eventsDiv);
        fragment.appendChild(eventsWrapper);

        // Sync Status (below Events Stream)
        var syncStatusWrapper = document.createElement('div');
        syncStatusWrapper.className = 'table-wrapper';
        syncStatusWrapper.setAttribute('data-table-id', '_sync_status');

        var syncStatusDiv = document.createElement('div');
        syncStatusDiv.className = 'table-item sync-status-item' + (currentTable === '_sync_status' ? ' active' : '');
        syncStatusDiv.innerHTML =
            '<span class="table-icon type-sync-status">' + TABLE_TYPE_CONFIG.syncStatus.icon + '</span>' +
            '<span class="table-name">Sync Status</span>';
        syncStatusDiv.onclick = () => showSyncStatusView();
        syncStatusWrapper.appendChild(syncStatusDiv);
        fragment.appendChild(syncStatusWrapper);

        // Pinned Section
        var pinnedTables = tables.filter(t => SIDEBAR_STATE.pinnedTables.includes(t.tableId));
        if (pinnedTables.length > 0) {
            fragment.appendChild(renderSectionHeader('pinned', 'Pinned', SIDEBAR_ICONS.starFilled, '#fbbf24', pinnedTables.length));
            if (SIDEBAR_STATE.expandedSections.pinned) {
                pinnedTables.forEach(table => {
                    fragment.appendChild(renderTableItem(table));
                    _viewLoadQueue.push(table.tableId);
                });
            }
        }

        // Recent Section
        var recentTables = SIDEBAR_STATE.recentTables
            .filter(id => !SIDEBAR_STATE.pinnedTables.includes(id))
            .map(id => tables.find(t => t.tableId === id))
            .filter(t => t);
        if (recentTables.length > 0) {
            fragment.appendChild(renderSectionHeader('recent', 'Recent', SIDEBAR_ICONS.clock, '#9ca3af', recentTables.length));
            if (SIDEBAR_STATE.expandedSections.recent) {
                recentTables.forEach(table => {
                    fragment.appendChild(renderTableItem(table));
                    _viewLoadQueue.push(table.tableId);
                });
            }
        }

        // Divider
        if (pinnedTables.length > 0 || recentTables.length > 0) {
            var divider = document.createElement('div');
            divider.className = 'sidebar-divider';
            fragment.appendChild(divider);
        }
    }

    // Grouped Sections
    var sectionConfig = [
        { id: 'primary', key: 'primary', label: 'Primary', color: '#ef4444' },
        { id: 'operational', key: 'operational', label: 'Operational', color: '#3b82f6' },
        { id: 'collections', key: 'collection', label: 'Collections', color: '#8b5cf6' },
        { id: 'reference', key: 'reference', label: 'Reference', color: '#10b981' },
        { id: 'dev', key: 'dev', label: 'Dev / Testing', color: '#6b7280' }
    ];

    sectionConfig.forEach(section => {
        var sectionTables = groupedTables[section.key] || [];
        // When searching, show all matching tables; otherwise filter out pinned from main sections
        if (!searchQuery) {
            sectionTables = sectionTables.filter(t => !SIDEBAR_STATE.pinnedTables.includes(t.tableId));
        }
        if (sectionTables.length === 0 && searchQuery) return;
        if (sectionTables.length === 0 && !SIDEBAR_STATE.expandedSections[section.id]) return;

        var config = TABLE_TYPE_CONFIG[section.key] || TABLE_TYPE_CONFIG.operational;
        fragment.appendChild(renderSectionHeader(section.id, section.label, config.icon, section.color, sectionTables.length));

        if (SIDEBAR_STATE.expandedSections[section.id] || searchQuery) {
            sectionTables.forEach(table => {
                fragment.appendChild(renderTableItem(table));
                _viewLoadQueue.push(table.tableId);
            });
        }
    });

    // Atomic DOM swap: replace all children at once to eliminate blink
    tableList.innerHTML = '';
    tableList.appendChild(fragment);

    // Load views for visible tables (after DOM is in place)
    // Prioritize the active table, then load others with idle callbacks
    var activeTid = currentTable;
    if (activeTid && _viewLoadQueue.includes(activeTid)) {
        loadTableViewsAsync(activeTid);
    }
    for (var _qi = 0; _qi < _viewLoadQueue.length; _qi++) {
        var _tid = _viewLoadQueue[_qi];
        if (_tid === activeTid) continue;
        // Use requestIdleCallback if available, otherwise setTimeout(0)
        if (typeof requestIdleCallback === 'function') {
            requestIdleCallback(loadTableViewsAsync.bind(null, _tid));
        } else {
            setTimeout(loadTableViewsAsync.bind(null, _tid), 0);
        }
    }

    // Active indicator color is set via --type-color CSS variable on renderTableItem above.
}

// Render views list HTML from cached META_VIEWS (synchronous, no DB hit)
function renderViewsListHTML(tableId) {
    var html = '';

    // Add "All Fields" default option first
    var isDefaultActive = currentTable === tableId && (!currentView || currentView === '_default');
    html += '<div class="table-view-item' + (isDefaultActive ? ' active' : '') + '" onclick="selectTableView(\'' + esc(tableId) + '\', \'_default\')">' +
            '<span class="view-icon">&#9638;</span>' +
            '<span class="view-name table-view-default">All Fields</span>' +
            '</div>';

    // Group views by folder
    var viewsByFolder = { '_root': [] };
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    for (var vid of viewIds) {
        if (vid === '_default') continue;
        var view = META_VIEWS[tableId][vid];
        var folderId = view.folderId || '_root';
        if (!viewsByFolder[folderId]) viewsByFolder[folderId] = [];
        viewsByFolder[folderId].push(view);
    }

    // Render root-level views first
    for (var view of viewsByFolder['_root'] || []) {
        html += renderViewItem(tableId, view);
    }

    // Render folders and their views
    var folderIds = Object.keys(VIEW_FOLDERS[tableId] || {});
    folderIds.sort((a, b) => {
        var fa = VIEW_FOLDERS[tableId][a];
        var fb = VIEW_FOLDERS[tableId][b];
        return (fa.sortOrder || 0) - (fb.sortOrder || 0);
    });

    for (var fid of folderIds) {
        var folder = VIEW_FOLDERS[tableId][fid];
        var isExpanded = folder.isExpanded !== false;

        html += '<div class="table-view-folder' + (isExpanded ? ' expanded' : '') + '" data-folder-id="' + esc(fid) + '" onclick="toggleViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)">';
        html += '<span class="folder-icon">&#9654;</span>';
        html += '<span class="folder-name">&#128193; ' + esc(folder.folderName || 'Folder') + '</span>';
        html += '<span class="folder-actions">';
        html += '<button class="folder-action-btn" onclick="renameViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)" title="Rename">&#9998;</button>';
        html += '<button class="folder-action-btn" onclick="deleteViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)" title="Delete">&#128465;</button>';
        html += '</span>';
        html += '</div>';

        html += '<div class="folder-views-list' + (isExpanded ? ' expanded' : '') + '" id="folder-views-' + esc(fid) + '">';
        for (var view of viewsByFolder[fid] || []) {
            html += renderViewItem(tableId, view, true);
        }
        html += '</div>';
    }

    // Add "New view" button
    html += '<div class="table-view-add-btn" onclick="openCreateViewModal(\'' + esc(tableId) + '\')">';
    html += '<span class="add-icon">+</span>';
    html += '<span>New view</span>';
    html += '</div>';

    return html;
}

// Track in-flight view load requests to prevent duplicate fetches
var _viewLoadInFlight = {};

// Load views for a table and populate the views list
async function loadTableViewsAsync(tableId) {
    var viewsList = document.getElementById('views-list-' + tableId);
    if (!viewsList) return;

    // If views are already cached, render immediately from cache (no blink)
    if (META_VIEWS[tableId] && Object.keys(META_VIEWS[tableId]).length > 0) {
        viewsList.innerHTML = renderViewsListHTML(tableId);
        return;
    }

    // Deduplicate: if already loading this table's views, skip
    if (_viewLoadInFlight[tableId]) return;
    _viewLoadInFlight[tableId] = true;

    try {
        // Fetch views and folders in parallel instead of sequentially
        var results = await Promise.all([
            getViewsForTable(tableId),
            getFoldersForTable(tableId)
        ]);
        var views = results[0];
        var folders = results[1];

        // Cache views in META_VIEWS
        if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
        views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

        // Load sharing metadata for views and attach as _sharing
        try {
            var sharedViews = await SharedViews.getVisibleViewsForTable(tableId);
            var sharingMap = {};
            sharedViews.forEach(function(sv) { sharingMap[sv.viewId] = sv; });

            // Merge shared views that aren't in local DB yet (from other users)
            sharedViews.forEach(function(sv) {
                if (sv.viewId && !META_VIEWS[tableId][sv.viewId] && sv.viewName) {
                    META_VIEWS[tableId][sv.viewId] = {
                        tableId: sv.tableId,
                        viewId: sv.viewId,
                        viewName: sv.viewName,
                        viewType: sv.viewType || 'grid',
                        filters: sv.filters || [],
                        sorts: sv.sorts || [],
                        groupBy: sv.groupBy || null,
                        hiddenFieldIds: sv.hiddenFieldIds || [],
                        fieldOrder: sv.fieldOrder || [],
                        tags: sv.tags || [],
                        folderId: sv.folderId || null
                    };
                }
            });

            // Attach sharing metadata to cached views for rendering
            Object.keys(META_VIEWS[tableId]).forEach(function(vid) {
                META_VIEWS[tableId][vid]._sharing = sharingMap[vid] || null;
            });
        } catch (e) {
            console.warn('[loadTableViewsAsync] Failed to load sharing metadata:', e);
        }

        // Cache folders in VIEW_FOLDERS
        if (!VIEW_FOLDERS[tableId]) VIEW_FOLDERS[tableId] = {};
        folders.forEach(f => VIEW_FOLDERS[tableId][f.folderId] = f);

        viewsList.innerHTML = renderViewsListHTML(tableId);
    } finally {
        delete _viewLoadInFlight[tableId];
    }
}

// Render a single view item
function renderViewItem(tableId, view, inFolder) {
    var isActive = currentTable === tableId && currentView === view.viewId;
    var viewName = view.viewName || view.viewId;
    var viewIcon = getViewTypeIcon(view.viewType);
    var paddingClass = inFolder ? ' style="padding-left: 52px;"' : '';

    // Check sharing status (from in-memory cache if available)
    var sharingBadge = '';
    var viewSharing = view._sharing;
    if (viewSharing && viewSharing.sharing && viewSharing.sharing !== 'private') {
        var badgeIcon = SharedViews.getSharingIcon(viewSharing);
        var isShared = viewSharing.sharing !== 'private';
        sharingBadge = '<span class="view-sharing-badge' + (isShared ? ' shared' : '') + '" title="' +
            esc(SharedViews.getSharingLabel(viewSharing)) + '">' + badgeIcon + '</span>';
    }

    return '<div class="table-view-item' + (isActive ? ' active' : '') + '"' + paddingClass + ' ' +
           'data-table-id="' + esc(tableId) + '" data-view-id="' + esc(view.viewId) + '" ' +
           'onclick="selectTableView(\'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'ondblclick="startViewRename(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'oncontextmenu="showViewContextMenu(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')">' +
           '<span class="view-icon">' + viewIcon + '</span>' +
           '<span class="view-name">' + esc(viewName) + '</span>' +
           sharingBadge +
           '</div>';
}

// Toggle view folder expanded state
async function toggleViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var folder = VIEW_FOLDERS[tableId]?.[folderId];
    if (!folder) return;

    folder.isExpanded = !folder.isExpanded;
    await saveFolder(folder);

    // Update UI
    var folderEl = document.querySelector('.table-view-folder[data-folder-id="' + folderId + '"]');
    var viewsListEl = document.getElementById('folder-views-' + folderId);

    if (folderEl && viewsListEl) {
        if (folder.isExpanded) {
            folderEl.classList.add('expanded');
            viewsListEl.classList.add('expanded');
        } else {
            folderEl.classList.remove('expanded');
            viewsListEl.classList.remove('expanded');
        }
    }
}

// Create a new view folder
async function createViewFolder(tableId) {
    var folderName = prompt('Enter folder name:');
    if (!folderName) return;

    var folderId = 'vfld' + Date.now();
    var folder = {
        folderId: folderId,
        tableId: tableId,
        folderName: folderName,
        parentFolderId: null,
        sortOrder: Object.keys(VIEW_FOLDERS[tableId] || {}).length,
        isExpanded: true
    };

    await saveFolder(folder);
    if (!VIEW_FOLDERS[tableId]) VIEW_FOLDERS[tableId] = {};
    VIEW_FOLDERS[tableId][folderId] = folder;

    // Also sync to backend
    await saveFolderToBackend(folder, 'create');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Rename a view folder
async function renameViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var folder = VIEW_FOLDERS[tableId]?.[folderId];
    if (!folder) return;

    var newName = prompt('Enter new folder name:', folder.folderName);
    if (!newName || newName === folder.folderName) return;

    folder.folderName = newName;
    await saveFolder(folder);

    // Sync to backend
    await saveFolderToBackend(folder, 'update');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Delete a view folder
async function deleteViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    if (!confirm('Delete this folder? Views will be moved to the root level.')) return;

    // Move all views in this folder to root
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    for (var vid of viewIds) {
        var view = META_VIEWS[tableId][vid];
        if (view.folderId === folderId) {
            view.folderId = null;
            await saveView(view);
        }
    }

    // Delete the folder
    await deleteFolder(folderId);
    delete VIEW_FOLDERS[tableId][folderId];

    // Sync to backend
    await saveFolderToBackend({ folderId: folderId, tableId: tableId }, 'delete');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Save folder to backend (local only  data flows Airtable  n8n  Matrix)
async function saveFolderToBackend(folder, operator) {
    // Folder config is stored locally. The client does not write to Matrix.
    // Folders are persisted via user preferences (Matrix account data).
    try {
        await UserPreferences.set('viewFolder:' + folder.folderId, folder);
    } catch (error) {
        console.error('Failed to save folder:', error);
    }
}

// View context menu state
var contextMenuViewId = null;
var contextMenuTableId = null;

// Show view context menu
function showViewContextMenu(event, tableId, viewId) {
    event.preventDefault();
    event.stopPropagation();

    contextMenuTableId = tableId;
    contextMenuViewId = viewId;

    // Update sharing label/icon in context menu
    var view = META_VIEWS[tableId] && META_VIEWS[tableId][viewId];
    var sharing = view && view._sharing;
    var shareIcon = document.getElementById('ctx-share-icon');
    var shareLabel = document.getElementById('ctx-share-label');
    if (shareIcon && shareLabel) {
        shareIcon.innerHTML = SharedViews.getSharingIcon(sharing);
        shareLabel.textContent = sharing && sharing.sharing !== 'private'
            ? SharedViews.getSharingLabel(sharing)
            : 'Share view...';
    }

    var menu = document.getElementById('view-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close view context menu
function closeViewContextMenu() {
    var menu = document.getElementById('view-context-menu');
    menu.classList.remove('open');
    contextMenuViewId = null;
    contextMenuTableId = null;
}

// Table context menu state
var tableContextMenuTableId = null;

// Show table context menu
function showTableContextMenu(event, tableId) {
    event.preventDefault();
    event.stopPropagation();

    tableContextMenuTableId = tableId;

    var menu = document.getElementById('table-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close table context menu
function closeTableContextMenu() {
    var menu = document.getElementById('table-context-menu');
    menu.classList.remove('open');
    tableContextMenuTableId = null;
}

// Column context menu state
var contextMenuFieldId = null;

// Show column context menu
function showColumnContextMenu(event, fieldId) {
    event.preventDefault();
    event.stopPropagation();

    contextMenuFieldId = fieldId;

    // Update display name menu item label
    var displayNameItem = document.getElementById('ctx-set-display-name');
    if (displayNameItem) {
        var isCurrentDisplayName = currentTable && META_TABLES[currentTable] && META_TABLES[currentTable].displayNameFieldId === fieldId;
        displayNameItem.innerHTML = isCurrentDisplayName
            ? '<span>&#127991;</span> Remove display name'
            : '<span>&#127991;</span> Set as display name';
    }

    var menu = document.getElementById('column-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close column context menu
function closeColumnContextMenu() {
    var menu = document.getElementById('column-context-menu');
    menu.classList.remove('open');
    contextMenuFieldId = null;
}

// Hide column from context menu
function hideColumnFromContextMenu() {
    if (!contextMenuFieldId) return;
    var fieldId = contextMenuFieldId;
    closeColumnContextMenu();
    toggleFieldVisibility(fieldId);
}

// Get the display name field ID for a table (explicit setting or fallback to first visible field)
function getDisplayNameFieldId(tableId) {
    var table = META_TABLES[tableId];
    if (table && table.displayNameFieldId) {
        // Verify the field still exists
        var fields = META_FIELDS[tableId] || {};
        if (fields[table.displayNameFieldId]) {
            return table.displayNameFieldId;
        }
    }
    return null;
}

// Set a field as the display name for its table
async function setDisplayNameFromContextMenu() {
    if (!contextMenuFieldId || !currentTable) return;
    var fieldId = contextMenuFieldId;
    closeColumnContextMenu();

    var table = META_TABLES[currentTable];
    if (!table) return;

    // Toggle: if already the display name, clear it
    if (table.displayNameFieldId === fieldId) {
        delete table.displayNameFieldId;
    } else {
        table.displayNameFieldId = fieldId;
    }

    await saveTable(table);
    renderTable();
}

// Create view folder from table context menu
async function createViewFolderFromContextMenu() {
    if (!tableContextMenuTableId) return;
    var tableId = tableContextMenuTableId;
    closeTableContextMenu();
    await createViewFolder(tableId);

    // Ensure the table's views list is expanded so the user can see the new folder
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItem = wrapper.querySelector('.table-item');
        var viewsList = wrapper.querySelector('.table-views-list');
        if (tableItem && !tableItem.classList.contains('expanded')) {
            tableItem.classList.add('expanded');
        }
        if (viewsList && !viewsList.classList.contains('expanded')) {
            viewsList.classList.add('expanded');
        }
    }
}

// Move view to folder
async function moveViewToFolder() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var folders = VIEW_FOLDERS[contextMenuTableId] || {};
    var folderNames = Object.values(folders).map(f => f.folderName);

    var options = ['(Root level)', ...folderNames];
    var choice = prompt('Move to folder:\n' + options.map((n, i) => i + ': ' + n).join('\n') + '\n\nEnter number:');

    if (choice === null) {
        closeViewContextMenu();
        return;
    }

    var choiceIdx = parseInt(choice);
    if (isNaN(choiceIdx) || choiceIdx < 0 || choiceIdx >= options.length) {
        closeViewContextMenu();
        return;
    }

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    if (choiceIdx === 0) {
        view.folderId = null;
    } else {
        var folderIds = Object.keys(folders);
        view.folderId = folderIds[choiceIdx - 1];
    }

    await saveView(view);
    markViewDirty('folderId', view.folderId);

    closeViewContextMenu();
    await loadTableViewsAsync(contextMenuTableId);
}

// Start inline view rename (double-click)
function startViewRename(event, tableId, viewId) {
    event.preventDefault();
    event.stopPropagation();

    var view = META_VIEWS[tableId]?.[viewId];
    if (!view) return;

    var viewItem = event.currentTarget;
    var nameSpan = viewItem.querySelector('.view-name');
    if (!nameSpan) return;

    // Create input element
    var input = document.createElement('input');
    input.type = 'text';
    input.className = 'view-name-input';
    input.value = view.viewName || '';
    input.setAttribute('data-table-id', tableId);
    input.setAttribute('data-view-id', viewId);

    // Replace span with input
    nameSpan.style.display = 'none';
    nameSpan.parentNode.insertBefore(input, nameSpan.nextSibling);
    input.focus();
    input.select();

    // Handle blur and enter key
    input.addEventListener('blur', finishViewRename);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            input.value = view.viewName || '';
            input.blur();
        }
    });
    input.addEventListener('click', function(e) {
        e.stopPropagation();
    });
}

// Finish inline view rename
async function finishViewRename(event) {
    var input = event.target;
    var tableId = input.getAttribute('data-table-id');
    var viewId = input.getAttribute('data-view-id');
    var newName = input.value.trim();

    var view = META_VIEWS[tableId]?.[viewId];
    var nameSpan = input.previousElementSibling;

    // Restore the span
    if (nameSpan) {
        nameSpan.style.display = '';
    }
    input.remove();

    if (!view || !newName || newName === view.viewName) {
        return;
    }

    // Update the view name
    view.viewName = newName;
    await saveView(view);
    markViewDirty('viewName', newName);

    // Refresh the UI
    await loadTableViewsAsync(tableId);
    renderViewSelector();
}

// Rename view (from context menu)
async function renameView() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    closeViewContextMenu();

    // Find the view item and trigger inline rename
    var viewItem = document.querySelector('.table-view-item[data-view-id="' + contextMenuViewId + '"]');
    if (viewItem) {
        var fakeEvent = {
            preventDefault: function() {},
            stopPropagation: function() {},
            currentTarget: viewItem
        };
        startViewRename(fakeEvent, contextMenuTableId, contextMenuViewId);
    } else {
        // Fallback to prompt if element not found
        var newName = prompt('Enter new view name:', view.viewName);
        if (!newName || newName === view.viewName) {
            return;
        }
        view.viewName = newName;
        await saveView(view);
        markViewDirty('viewName', newName);
        await loadTableViewsAsync(contextMenuTableId);
        renderViewSelector();
    }
}

// Delete view
async function deleteView() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    if (!confirm('Delete this view?')) {
        closeViewContextMenu();
        return;
    }

    // Remove sharing metadata (unpublishes from org space if shared)
    try {
        await SharedViews.deleteViewSharing(contextMenuTableId, contextMenuViewId);
    } catch (e) {
        console.warn('[deleteView] Failed to clean up sharing metadata:', e);
    }

    // Remove from META_VIEWS
    delete META_VIEWS[contextMenuTableId][contextMenuViewId];

    // Remove from IndexedDB
    await new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readwrite');
        tx.objectStore('views').delete([contextMenuTableId, contextMenuViewId]);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });

    // If current view was deleted, switch to default
    if (currentView === contextMenuViewId) {
        currentView = '_default';
        renderViewSelector();
        renderFieldsDropdown();
        updateFieldsCount();
        await renderTable();
    }

    closeViewContextMenu();
    await loadTableViewsAsync(contextMenuTableId);
}

// Manage view tags from context menu
async function manageViewTags() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    var currentTags = (view.tags || []).join(', ');
    var newTags = prompt('Enter tags (comma-separated):', currentTags);

    if (newTags !== null) {
        view.tags = newTags.split(',').map(t => t.trim()).filter(t => t);
        await saveView(view);
        markViewDirty('tags', view.tags);
        await loadTableViewsAsync(contextMenuTableId);
    }

    closeViewContextMenu();
}

// Add view to workspace from context menu
async function addViewToWorkspaceMenu() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var wsIds = Object.keys(WORKSPACES);

    if (wsIds.length === 0) {
        var name = prompt('No workspaces exist. Enter a name to create one:');
        if (name) {
            var wsId = await createWorkspace(name);
            await addViewToWorkspace(contextMenuViewId, wsId);
            renderWorkspaceTabs();
            await loadTableViewsAsync(contextMenuTableId);
        }
        closeViewContextMenu();
        return;
    }

    var options = wsIds.map((wid, i) => {
        var ws = WORKSPACES[wid];
        var inWs = ws.viewIds.includes(contextMenuViewId) ? ' [already added]' : '';
        return i + ': ' + ws.workspaceName + inWs;
    });
    options.push(wsIds.length + ': Create new workspace...');

    var choice = prompt('Add to workspace:\n' + options.join('\n') + '\n\nEnter number:');

    if (choice !== null) {
        var idx = parseInt(choice);
        if (idx >= 0 && idx < wsIds.length) {
            await addViewToWorkspace(contextMenuViewId, wsIds[idx]);
            renderWorkspaceTabs();
        } else if (idx === wsIds.length) {
            var name = prompt('Enter workspace name:');
            if (name) {
                var wsId = await createWorkspace(name);
                await addViewToWorkspace(contextMenuViewId, wsId);
                renderWorkspaceTabs();
            }
        }
    }

    closeViewContextMenu();
}

// Set parent view from context menu
async function setViewParent() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    var views = META_VIEWS[contextMenuTableId] || {};
    var options = ['0: (No parent - root level)'];
    var viewIds = [''];

    var idx = 1;
    for (var vid in views) {
        if (vid === '_default' || vid === contextMenuViewId) continue;
        var v = views[vid];
        options.push(idx + ': ' + (v.viewName || vid));
        viewIds.push(vid);
        idx++;
    }

    var choice = prompt('Set parent view (for nesting):\n' + options.join('\n') + '\n\nEnter number:');

    if (choice !== null) {
        var choiceIdx = parseInt(choice);
        if (choiceIdx >= 0 && choiceIdx < viewIds.length) {
            view.parentViewId = viewIds[choiceIdx] || null;
            await saveView(view);
            markViewDirty('parentViewId', view.parentViewId);
            await loadTableViewsAsync(contextMenuTableId);
        }
    }

    closeViewContextMenu();
}

// ============ Share View Functions ============

var _shareViewTableId = null;
var _shareViewId = null;

async function openShareViewMenu() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    _shareViewTableId = contextMenuTableId;
    _shareViewId = contextMenuViewId;
    closeViewContextMenu();

    var view = META_VIEWS[_shareViewTableId] && META_VIEWS[_shareViewTableId][_shareViewId];
    var viewName = (view && view.viewName) ? view.viewName : _shareViewId;

    // Get current sharing status
    var sharing = await SharedViews.getViewSharing(_shareViewTableId, _shareViewId);

    // Update modal header
    var nameEl = document.getElementById('share-view-name');
    if (nameEl) nameEl.textContent = 'Sharing settings for "' + viewName + '"';

    // Show owner info
    var ownerEl = document.getElementById('share-view-owner');
    if (ownerEl) {
        if (sharing.ownerId) {
            ownerEl.textContent = 'Created by ' + sharing.ownerId;
            ownerEl.style.display = '';
        } else {
            ownerEl.style.display = 'none';
        }
    }

    // Set current sharing level
    var radios = document.querySelectorAll('input[name="share-level"]');
    radios.forEach(function(radio) {
        radio.checked = radio.value === (sharing.sharing || 'private');
    });

    // Show/hide users section
    onShareLevelChange();

    // If sharing is 'specific', load and check the shared users
    if (sharing.sharing === 'specific') {
        await _loadShareUsersList(sharing.sharedWith || []);
    }

    // Show modal
    document.getElementById('share-view-modal').classList.add('open');
}

function onShareLevelChange() {
    var selected = document.querySelector('input[name="share-level"]:checked');
    var usersSection = document.getElementById('share-users-section');
    if (selected && selected.value === 'specific') {
        usersSection.style.display = '';
        _loadShareUsersList([]);
    } else {
        usersSection.style.display = 'none';
    }
}

async function _loadShareUsersList(preselectedUserIds) {
    var listEl = document.getElementById('share-users-list');
    if (!listEl) return;
    listEl.innerHTML = '<div class="share-users-loading">Loading org members...</div>';

    var members = await SharedViews.getOrgMembers();
    var currentUserId = MatrixClient.getUserId();

    if (members.length === 0) {
        listEl.innerHTML = '<div class="share-users-loading">No org members found. Make sure you are logged into Synapse.</div>';
        return;
    }

    var html = '';
    for (var i = 0; i < members.length; i++) {
        var m = members[i];
        if (m.userId === currentUserId) continue; // skip self
        var isChecked = preselectedUserIds.indexOf(m.userId) >= 0;
        html += '<label class="share-user-item">' +
            '<input type="checkbox" value="' + esc(m.userId) + '"' + (isChecked ? ' checked' : '') + '>' +
            '<div>' +
            '<div class="user-name">' + esc(m.displayName) + '</div>' +
            '<div class="user-id">' + esc(m.userId) + '</div>' +
            '</div>' +
            '</label>';
    }

    listEl.innerHTML = html;
}

async function submitShareView() {
    if (!_shareViewTableId || !_shareViewId) return;

    var selected = document.querySelector('input[name="share-level"]:checked');
    if (!selected) return;

    var sharing = selected.value;
    var sharedWith = [];

    if (sharing === 'specific') {
        var checkboxes = document.querySelectorAll('#share-users-list input[type="checkbox"]:checked');
        checkboxes.forEach(function(cb) {
            sharedWith.push(cb.value);
        });
    }

    var submitBtn = document.getElementById('share-view-submit');
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Saving...';
    }

    try {
        await SharedViews.shareView(_shareViewTableId, _shareViewId, sharing, sharedWith);
        closeShareViewModal();

        // Refresh sidebar to update sharing badges
        await loadTableViewsAsync(_shareViewTableId);
    } catch (e) {
        console.error('[ShareView] Failed to share view:', e);
        alert('Failed to update sharing: ' + e.message);
    } finally {
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Save Sharing';
        }
    }
}

function closeShareViewModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('share-view-modal').classList.remove('open');
    _shareViewTableId = null;
    _shareViewId = null;
}

// Open create view modal directly (not from default view protection)
function openCreateViewModal(tableId) {
    if (tableId) {
        // Temporarily switch context to the target table
        currentTable = tableId;
    }

    pendingViewAction = null;

    // Close any open dropdowns so they don't overlap the modal
    closeAllDropdowns();

    // Set the reason text
    var reasonEl = document.getElementById('create-view-reason');
    if (reasonEl) {
        reasonEl.textContent = 'Create a custom view with your own filters, sorting, and field configuration.';
    }

    // Set default view name
    var nameInput = document.getElementById('create-view-name');
    if (nameInput) {
        nameInput.value = generateDefaultViewName();
    }

    // Reset other fields
    document.getElementById('create-view-type').value = 'grid';
    document.getElementById('create-view-tags').value = '';

    // Populate parent view options
    populateParentViewOptions();

    // Populate workspace options
    populateWorkspaceOptions();

    // Show modal
    document.getElementById('create-view-modal').classList.add('open');

    // Focus name input
    setTimeout(() => nameInput?.focus(), 100);
}

// Close context menu on click outside
document.addEventListener('click', function() {
    closeViewContextMenu();
    closeTableContextMenu();
    closeColumnContextMenu();
});

// Clean up state from special views (Events, Sync Status) before switching
function cleanupSpecialViewState() {
    // Clean up events view state
    expandedPayloads.clear();
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;
    if (eventsScrollHandler) {
        var container = document.querySelector('.table-container');
        if (container) container.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }
    if (changelogScrollHandler) {
        var container = document.querySelector('.table-container');
        if (container) container.removeEventListener('scroll', changelogScrollHandler);
        changelogScrollHandler = null;
    }

    // Clean up sync status listener
    if (syncStatusUnsubscribe) { syncStatusUnsubscribe(); syncStatusUnsubscribe = null; }

    // Restore view controls bar visibility
    var viewControlsBar = document.getElementById('view-controls-bar');
    if (viewControlsBar) viewControlsBar.style.display = '';
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = '';
}

// Toggle the expanded views list for a table
function toggleTableViews(tableId, event) {
    event.stopPropagation();

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (!wrapper) return;

    var tableItem = wrapper.querySelector('.table-item');
    var viewsList = wrapper.querySelector('.table-views-list');

    if (tableItem.classList.contains('expanded')) {
        // Collapse
        tableItem.classList.remove('expanded');
        viewsList.classList.remove('expanded');
    } else {
        // Expand
        tableItem.classList.add('expanded');
        viewsList.classList.add('expanded');

        // If clicking a different table, also load it with its default view
        if (currentTable !== tableId) {
            showTable(tableId);
        }
    }
}

// Select a view from the sidebar and show the table
async function selectTableView(tableId, viewId) {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Auto-save any pending changes before navigating
    await autoSaveBeforeNavigation();
    if (navVersion !== myNav) return; // Another navigation started, abort

    // Clean up any special view state (Events, Sync Status)
    cleanupSpecialViewState();

    // Update sidebar active states - only clear previous active, not all items
    var prevActive = document.querySelectorAll('.table-item.active, .table-view-item.active');
    for (var i = 0; i < prevActive.length; i++) prevActive[i].classList.remove('active');

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItemEl = wrapper.querySelector('.table-item');
        if (tableItemEl) tableItemEl.classList.add('active');
        // Find and mark the selected view as active using data attribute
        var viewItem = wrapper.querySelector('.table-view-item[data-view-id="' + viewId + '"]');
        if (viewItem) viewItem.classList.add('active');
    }

    // If switching to a different table, load it first
    if (currentTable !== tableId) {
        // Release previous table's field data to free memory
        // Keep META_VIEWS cached since it's small and used by sidebar for instant rendering
        if (currentTable) {
            delete META_FIELDS[currentTable];
        }
        originalRecordIds = [];
        currentRecordIds = [];

        currentTable = tableId;
        currentPage = 0;

        var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
        if (navVersion !== myNav) return;
        var tableName = table.tableName || tableId;
        document.getElementById('title').textContent = tableName;

        // Show loading state immediately
        showTableLoading('Loading table structure...');

        // Load fields, views, and record IDs in parallel
        var parallelResults = await Promise.all([
            getFieldsForTable(tableId),
            getViewsForTable(tableId),
            getRecordIdsForTable(tableId)
        ]);
        if (navVersion !== myNav) return;

        var fields = parallelResults[0];
        var views = parallelResults[1];
        var recordIds = parallelResults[2];

        META_FIELDS[tableId] = {};
        fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

        META_VIEWS[tableId] = {};
        views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

        originalRecordIds = recordIds;
        currentRecordIds = originalRecordIds;
        totalRecords = currentRecordIds.length;
    }

    // Set the current view
    currentView = viewId;

    // Load and apply view filters, sorts, groupBy, and colorBy
    var viewConfig = getViewFiltersAndSorts(tableId, viewId);
    currentFilters = viewConfig.filters;
    currentSorts = viewConfig.sorts;
    currentGroupBy = viewConfig.groupBy;
    currentColorBy = viewConfig.colorBy;
    currentSearchQuery = ''; // Reset search when switching views

    // Update filter/sort/group/color button states
    updateFilterCount();
    updateSortCount();
    updateGroupButtonState();
    updateColorButtonState();
    var searchInput = document.getElementById('view-search-input');
    if (searchInput) searchInput.value = '';

    // Render view selector and fields dropdown
    renderViewSelector();
    renderFieldsDropdown();
    updateFieldsCount();

    // Render the table
    await renderTable();
}

function updateStatus(msg, isSynced, progress, detail) {
    var dot = document.getElementById('status-dot');
    var text = document.getElementById('status-text');
    var progressBar = document.getElementById('progress-bar');
    var progressFill = document.getElementById('progress-fill');
    var statusDetail = document.getElementById('status-detail');

    dot.className = 'status-dot ' + (isSynced ? 'synced' : 'loading');
    text.textContent = msg;

    if (typeof progress === 'number' && progress >= 0) {
        progressBar.style.display = 'block';
        progressFill.style.width = Math.min(100, progress) + '%';
    } else {
        progressBar.style.display = 'none';
    }

    statusDetail.textContent = detail || '';
}

// ============ Loading Overlay ============

var refreshCountdownInterval = null;
var lastSyncTime = null;

function showLoadingOverlay() {
    var overlay = document.getElementById('loading-overlay');
    overlay.classList.remove('hidden', 'fading-out');
}

function hideLoadingOverlay() {
    var overlay = document.getElementById('loading-overlay');
    overlay.classList.add('fading-out');
    overlay.addEventListener('transitionend', function handler() {
        overlay.removeEventListener('transitionend', handler);
        overlay.classList.add('hidden');
        overlay.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    setTimeout(function() { overlay.classList.add('hidden'); overlay.classList.remove('fading-out'); }, 500);
}

var _loadingStartTime = null;
var _loadingPrevRecords = 0;
var _loadingPrevTime = null;
var _loadingSmoothedSpeed = 0;

function _formatElapsed(ms) {
    var secs = Math.floor(ms / 1000);
    if (secs < 60) return secs + 's';
    var mins = Math.floor(secs / 60);
    secs = secs % 60;
    return mins + 'm ' + (secs < 10 ? '0' : '') + secs + 's';
}

function updateLoadingOverlay(status, detail, progress, tables, fields, records, tableProgress) {
    var statusEl = document.getElementById('loading-status');
    var detailEl = document.getElementById('loading-detail');
    var progressEl = document.getElementById('loading-progress-fill');
    var tablesEl = document.getElementById('loading-tables');
    var fieldsEl = document.getElementById('loading-fields');
    var recordsEl = document.getElementById('loading-records');
    var tableProgressEl = document.getElementById('loading-table-progress');
    var speedEl = document.getElementById('loading-speed');

    if (statusEl) statusEl.textContent = status || 'Loading...';
    if (detailEl) detailEl.textContent = detail || '';
    if (progressEl) progressEl.style.width = Math.min(100, progress || 0) + '%';
    if (tablesEl) tablesEl.textContent = (tables || 0).toLocaleString();
    if (fieldsEl) fieldsEl.textContent = (fields || 0).toLocaleString();
    if (recordsEl) recordsEl.textContent = (records || 0).toLocaleString();
    if (tableProgressEl) tableProgressEl.textContent = tableProgress || '';

    // Speed and elapsed time calculation
    var now = Date.now();
    var totalRecords = records || 0;
    if (!_loadingStartTime && totalRecords > 0) {
        _loadingStartTime = now;
        _loadingPrevTime = now;
        _loadingPrevRecords = 0;
    }

    if (speedEl && _loadingStartTime && totalRecords > 0) {
        var elapsedMs = now - _loadingStartTime;
        var elapsed = _formatElapsed(elapsedMs);

        // Calculate instantaneous speed over recent interval
        var intervalMs = now - (_loadingPrevTime || now);
        if (intervalMs > 200) {
            var intervalRecords = totalRecords - _loadingPrevRecords;
            var instantSpeed = intervalRecords / (intervalMs / 1000);
            // Smooth with exponential moving average
            _loadingSmoothedSpeed = _loadingSmoothedSpeed > 0
                ? _loadingSmoothedSpeed * 0.7 + instantSpeed * 0.3
                : instantSpeed;
            _loadingPrevTime = now;
            _loadingPrevRecords = totalRecords;
        }

        var speedStr = _loadingSmoothedSpeed > 0
            ? Math.round(_loadingSmoothedSpeed).toLocaleString() + ' records/sec'
            : '';
        speedEl.textContent = elapsed + (speedStr ? '  \u00B7  ' + speedStr : '');
    } else if (speedEl) {
        speedEl.textContent = '';
    }
}

function setRefreshIndicatorSyncing(isSyncing) {
    var indicator = document.getElementById('refresh-indicator');
    var textEl = document.getElementById('last-refresh-text');
    if (!indicator) return;

    if (isSyncing) {
        indicator.classList.add('syncing');
        textEl.textContent = 'Checking for updates...';
    } else {
        indicator.classList.remove('syncing');
        lastSyncTime = Date.now();
        startRefreshCountdown();
    }
}

function startRefreshCountdown() {
    if (refreshCountdownInterval) clearInterval(refreshCountdownInterval);

    var textEl = document.getElementById('last-refresh-text');
    if (!textEl) return;

    function updateCountdown() {
        var elapsed = Math.floor((Date.now() - lastSyncTime) / 1000);
        var remaining = Math.max(0, 180 - elapsed);

        if (remaining > 0) {
            textEl.textContent = 'Auto-refresh in ' + remaining + 's';
        } else {
            textEl.textContent = 'Refreshing soon...';
        }
    }

    updateCountdown();
    refreshCountdownInterval = setInterval(updateCountdown, 1000);
}

async function showTable(tableId) {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Auto-save any pending changes before switching tables
    await autoSaveBeforeNavigation();
    if (navVersion !== myNav) return;

    // Clean up special view state (Events, Sync Status)
    cleanupSpecialViewState();

    // Release previous table's field data to free memory (re-loaded on demand)
    // Keep META_VIEWS cached since it's small and used by sidebar for instant rendering
    if (currentTable && currentTable !== tableId) {
        delete META_FIELDS[currentTable];
    }
    // Release previous record IDs
    originalRecordIds = [];
    currentRecordIds = [];

    currentTable = tableId;
    currentView = null; // Reset view when switching tables
    currentPage = 0;
    invalidateFilterCache(); // New table  stale cache
    clearRecordCache();      // New table  stale records

    // Track as recently accessed table
    addToRecentTables(tableId);

    // Reset search and other controls (filters/sorts will be loaded from view)
    if (typeof currentGroupBy !== 'undefined') currentGroupBy = null;
    if (typeof currentColorBy !== 'undefined') currentColorBy = null;
    if (typeof currentSearchQuery !== 'undefined') currentSearchQuery = '';

    // Reset non-filter/sort button states and search input
    var groupBtn = document.getElementById('group-btn');
    var colorBtn = document.getElementById('color-btn');
    var searchInput = document.getElementById('view-search-input');
    if (groupBtn) groupBtn.classList.remove('active');
    if (colorBtn) colorBtn.classList.remove('active');
    if (searchInput) searchInput.value = '';

    var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
    if (navVersion !== myNav) return;
    var tableName = table.tableName || tableId;

    document.getElementById('title').textContent = tableName;

    // Update tab bar - open or activate tab for this table
    var tableType = table.tableType || 'operational';
    var tabIcons = { events: '\u26A1', operational: '\u25A6', collection: '\uD83D\uDCC5', reference: '\uD83D\uDCD6', dev: '\u2699' };
    openTableInTab(tableId, tableName, tabIcons[tableType] || '\u25A6');

    // Update sidebar - only clear previous active elements, then expand new one
    var prevActive = document.querySelectorAll('.table-item.active, .table-view-item.active');
    for (var i = 0; i < prevActive.length; i++) prevActive[i].classList.remove('active');

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItem = wrapper.querySelector('.table-item');
        var viewsList = wrapper.querySelector('.table-views-list');
        if (tableItem) {
            tableItem.classList.add('active', 'expanded');
            // Set the type color for the active indicator
            var tableName_temp = (META_TABLES[tableId]?.tableName || tableId);
            var type_temp = getTableType(tableName_temp);
            var config_temp = TABLE_TYPE_CONFIG[type_temp] || TABLE_TYPE_CONFIG.operational;
            tableItem.style.setProperty('--type-color', config_temp.color);
        }
        if (viewsList) {
            viewsList.classList.add('expanded');
        }
    }

    // Show loading state immediately
    showTableLoading('Loading table structure...');

    // Load fields, views, and record IDs in parallel instead of sequentially
    var parallelResults = await Promise.all([
        getFieldsForTable(tableId),
        getViewsForTable(tableId),
        getRecordIdsForTable(tableId)
    ]);
    if (navVersion !== myNav) return;

    var fields = parallelResults[0];
    var views = parallelResults[1];
    var recordIds = parallelResults[2];

    META_FIELDS[tableId] = {};
    fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

    META_VIEWS[tableId] = {};
    views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

    originalRecordIds = recordIds;
    currentRecordIds = originalRecordIds;
    totalRecords = currentRecordIds.length;

    // Set current view to the first available view or default
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    if (viewIds.length > 0 && !currentView) {
        // Check if there's a saved preference or use first view
        currentView = viewIds[0];
    } else if (!currentView) {
        currentView = '_default';
    }

    // Load and apply view filters, sorts, groupBy, and colorBy
    var viewConfig = getViewFiltersAndSorts(tableId, currentView);
    currentFilters = viewConfig.filters;
    currentSorts = viewConfig.sorts;
    currentGroupBy = viewConfig.groupBy;
    currentColorBy = viewConfig.colorBy;

    // Update critical button states synchronously (cheap DOM writes)
    updateFilterCount();
    updateSortCount();

    // Show table headers immediately with skeleton rows (even before data loads)
    renderTableHeaders();

    // Defer non-critical UI updates so the table skeleton paints first
    var _deferredViewId = currentView;
    var _deferredTableId = tableId;
    queueMicrotask(function() {
        updateGroupButtonState();
        updateColorButtonState();
        updateSidebarViewActive(_deferredTableId, _deferredViewId);
        renderViewSelector();
        renderFieldsDropdown();
        updateFieldsCount();
    });

    // Now render full table with data
    await renderTable();
}

// Update the sidebar to highlight the active view
function updateSidebarViewActive(tableId, viewId) {
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (!wrapper) return;

    // Clear only currently active items (cheaper than iterating all)
    var prevActive = wrapper.querySelectorAll('.table-view-item.active');
    for (var i = 0; i < prevActive.length; i++) prevActive[i].classList.remove('active');

    // Use data-view-id attribute for O(1) lookup
    var target = wrapper.querySelector('.table-view-item[data-view-id="' + viewId + '"]');
    if (target) target.classList.add('active');
}

function showTableLoading(message) {
    var container = document.getElementById('table-container');
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>' + esc(message) + '</h3></div>';
    document.getElementById('pagination').style.display = 'none';
}

function renderTableHeaders() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');
    var fields = META_FIELDS[currentTable] || {};

    // Use view field configuration for visible fields
    var viewId = currentView || '_default';
    var colList = getVisibleFieldsForView(currentTable, viewId);

    if (colList.length === 0) {
        // No visible fields, show empty state
        container.innerHTML = '<div class="empty-state"><h3>No visible fields</h3><p>Click the Fields button to show columns</p></div>';
        return;
    }

    var colNames = {};
    colList.forEach(fid => {
        colNames[fid] = fields[fid]?.fieldName || fid;
    });

    // Build table with headers and skeleton rows
    var html = '<table id="table"><thead><tr><th style="width: 70px;">Actions</th><th>ID</th>';
    colList.forEach(col => {
        html += '<th title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    // Add skeleton loading rows
    for (var i = 0; i < 5; i++) {
        html += '<tr class="skeleton-row"><td><div class="skeleton-cell" style="width: 50px;"></div></td><td><div class="skeleton-cell" style="width: 60px;"></div></td>';
        colList.forEach(() => {
            html += '<td><div class="skeleton-cell" style="width: ' + (60 + Math.random() * 80) + 'px;"></div></td>';
        });
        html += '</tr>';
    }

    html += '</tbody></table>';
    container.innerHTML = html;
}

async function renderTable() {
    if (!currentTable) return;
    // Skip rendering if we're in a special view (Events or Sync Status)
    if (currentTable === '_events' || currentTable === '_sync_status') return;

    var renderNav = navVersion; // Capture current nav version for stale check

    // Check if table container exists - may not exist during early loading
    var tableContainer = document.getElementById('table-container');
    if (!tableContainer) {
        console.log('renderTable: table-container not ready yet');
        return;
    }

    // Apply filters, search, and sorts
    var needsFiltering = currentFilters.length > 0 || currentSearchQuery || currentSorts.length > 0;
    if (needsFiltering) {
        currentRecordIds = await getFilteredSortedRecords();
        if (navVersion !== renderNav) return; // Navigation changed, abort stale render
    } else {
        // Reuse original array directly when no filters are active (avoid copying large arrays)
        currentRecordIds = originalRecordIds;
    }
    totalRecords = currentRecordIds.length;

    var tableEl = document.getElementById('table');

    // Determine which records to display
    var displayRecordIds;
    var isGrouped = !!currentGroupBy;

    if (isGrouped) {
        // When grouping, show all records (no pagination) - capped to limit memory
        var maxGroupedRecords = 500;
        displayRecordIds = currentRecordIds.slice(0, maxGroupedRecords);
    } else {
        // Standard pagination
        displayRecordIds = currentRecordIds.slice(currentPage * PAGE_SIZE, (currentPage + 1) * PAGE_SIZE);

        // Check if we're on a page beyond available data (can happen after filtering)
        if (displayRecordIds.length === 0 && currentPage > 0) {
            currentPage = 0;
            displayRecordIds = currentRecordIds.slice(0, PAGE_SIZE);
        }
    }

    if (displayRecordIds.length === 0) {
        if (tableEl) tableEl.innerHTML = '';
        var emptyMsg = (currentFilters.length > 0 || currentSearchQuery)
            ? '<div class="empty-state"><h3>No matching records</h3><p>Try adjusting your filters or search</p></div>'
            : '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        tableContainer.innerHTML = emptyMsg;
        document.getElementById('pagination').style.display = 'none';
        updateRecordCountBadge();
        return;
    }

    // Fetch records before clearing the container to avoid a white flash
    var records = await getRecordsByIds(currentTable, displayRecordIds);
    if (navVersion !== renderNav) return; // Navigation changed, abort stale render
    var recordMap = {};
    records.forEach(r => recordMap[r.recordId] = r.fields || {});

    // Get columns from view configuration
    var fields = META_FIELDS[currentTable] || {};

    // Compute formula column values for all displayed records
    _applyFormulaColumns(currentTable, fields, recordMap);
    var viewId = currentView || '_default';
    var colList = getVisibleFieldsForView(currentTable, viewId);

    // If no visible fields but we have data, initialize with all fields
    if (colList.length === 0 && Object.keys(fields).length === 0) {
        // Discover from data
        var colSet = {};
        records.forEach(r => {
            if (r.fields) Object.keys(r.fields).forEach(k => colSet[k] = true);
        });
        colList = Object.keys(colSet).sort();
    }

    var colNames = {};
    colList.forEach(fid => {
        colNames[fid] = fields[fid]?.fieldName || fid;
    });

    // Build color map if color-by is active
    var colorMap = null;
    if (currentColorBy) {
        colorMap = buildColorMap(displayRecordIds, recordMap, currentColorBy, colNames);
    }

    // Get group field name for header display
    var groupFieldName = currentGroupBy ? (fields[currentGroupBy]?.fieldName || currentGroupBy) : null;

    // Pre-compute per-column metadata once (avoids per-cell function calls)
    var _colMeta = colList.map(function(col) {
        var f = fields[col];
        var isComp = f && isComputedFieldType(f.fieldType);
        var isRO = !isComp && f && isReadOnlyField(f);
        return {
            id: col,
            escapedId: esc(col),
            name: colNames[col],
            field: f,
            isComputed: isComp,
            isReadOnly: isRO,
            computedLabel: isComp ? esc(computedFieldLabel(f.fieldType)) : '',
            readOnlyLabel: isRO ? esc(readOnlyFieldLabel(f)) : ''
        };
    });

    // Build table with draggable headers
    var displayNameFid = getDisplayNameFieldId(currentTable);
    var html = '<thead><tr><th style="width: 70px; cursor: default;">Actions</th>';
    colList.forEach((col, idx) => {
        var colField = fields[col];
        var colIsComputed = colField && isComputedFieldType(colField.fieldType);
        var colIsReadOnly = colField && isReadOnlyField(colField);
        var colIsDisplayName = col === displayNameFid;
        var colTitle = esc(col) + (colIsDisplayName ? ' (Display name)' : '') + (colIsComputed ? ' (' + computedFieldLabel(colField.fieldType) + ')' : (colIsReadOnly ? ' (Read-only)' : ''));
        html += '<th draggable="true" data-field-id="' + esc(col) + '" data-field-index="' + idx + '" ' +
                'ondragstart="handleColumnDragStart(event)" ondragover="handleColumnDragOver(event)" ' +
                'ondrop="handleColumnDrop(event)" ondragend="handleColumnDragEnd(event)" ' +
                'oncontextmenu="showColumnContextMenu(event, \'' + esc(col) + '\')" ' +
                'title="' + colTitle + '">' + esc(colNames[col]);
        if (colIsDisplayName) {
            html += '<span class="display-name-icon" title="Display name field"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg></span>';
        }
        if (colIsComputed) {
            html += '<span class="formula-icon" title="' + esc(computedFieldLabel(colField.fieldType)) + '">' +
                    '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 2H4a1 1 0 0 0-1 1v5"/><path d="M15 2h5a1 1 0 0 1 1 1v5"/><path d="M20 15v5a1 1 0 0 1-1 1h-5"/><path d="M4 15v5a1 1 0 0 0 1 1h5"/><path d="m9 12 2 2 4-4"/></svg></span>';
        } else if (colIsReadOnly) {
            html += '<span class="readonly-icon" title="' + esc(readOnlyFieldLabel(colField)) + '">' +
                    '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg></span>';
        }
        html += '</th>';
    });
    html += '</tr></thead><tbody>';

    if (isGrouped) {
        // Group records by field value
        var groups = groupRecordsByField(displayRecordIds, recordMap, currentGroupBy, colNames);

        // Render grouped rows
        var groupIndex = 0;
        for (var groupKey in groups) {
            var groupRecords = groups[groupKey];
            var groupId = 'group-' + groupIndex;

            // Group header row
            html += '<tr class="group-header-row" data-group-id="' + groupId + '" onclick="toggleGroup(\'' + groupId + '\', event)">';
            html += '<td colspan="' + (colList.length + 1) + '">';
            html += '<span class="group-toggle">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg>';
            html += '<span class="group-name">' + esc(groupFieldName) + ': ' + esc(groupKey) + '</span>';
            html += '<span class="group-count">(' + groupRecords.length + ')</span>';
            html += '</span>';
            html += '</td></tr>';

            // Group data rows
            groupRecords.forEach(rid => {
                var row = recordMap[rid] || {};
                var colorAttr = '';
                if (colorMap) {
                    var cv = row[currentColorBy];
                    if (cv === undefined && colNames) cv = row[colNames[currentColorBy]];
                    var ck = getGroupKeyFromValue(cv);
                    if (ck in colorMap) colorAttr = ' data-color-idx="' + colorMap[ck] + '"';
                }
                html += '<tr class="group-row" data-group-id="' + groupId + '" data-record-id="' + esc(rid) + '" data-table-id="' + esc(currentTable) + '"' + colorAttr + ' ondblclick="handleRowDblClick(event, \'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" style="cursor: default;">';
                html += '<td><button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="View field history">';
                html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
                html += 'History</button></td>';
                for (var _ci = 0; _ci < _colMeta.length; _ci++) {
                    var cm = _colMeta[_ci];
                    var value = row[cm.id];
                    if (value === undefined) value = row[cm.name];
                    if (cm.isComputed) {
                        html += '<td class="cell-formula" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" onclick="handleFormulaCellClick(event, this)" title="' + cm.computedLabel + '  click for info">' + formatCell(value) + '</td>';
                    } else if (cm.isReadOnly) {
                        html += '<td class="cell-readonly" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" title="' + cm.readOnlyLabel + '  read-only">' + formatCell(value) + '</td>';
                    } else {
                        html += '<td class="inline-editable" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" onclick="startInlineCellEdit(event, this)">' + formatCell(value) + '</td>';
                    }
                }
                html += '</tr>';
            });

            groupIndex++;
        }
    } else {
        // Standard flat rendering
        displayRecordIds.forEach(rid => {
            var row = recordMap[rid] || {};
            var colorAttr = '';
            if (colorMap) {
                var cv = row[currentColorBy];
                if (cv === undefined && colNames) cv = row[colNames[currentColorBy]];
                var ck = getGroupKeyFromValue(cv);
                if (ck in colorMap) colorAttr = ' data-color-idx="' + colorMap[ck] + '"';
            }
            html += '<tr data-record-id="' + esc(rid) + '" data-table-id="' + esc(currentTable) + '"' + colorAttr + ' ondblclick="handleRowDblClick(event, \'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" style="cursor: default;">';
            html += '<td><button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="View field history">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
            html += 'History</button></td>';
            for (var _ci = 0; _ci < _colMeta.length; _ci++) {
                var cm = _colMeta[_ci];
                var value = row[cm.id];
                if (value === undefined) value = row[cm.name];
                if (cm.isComputed) {
                    html += '<td class="cell-formula" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" onclick="handleFormulaCellClick(event, this)" title="' + cm.computedLabel + '  click for info">' + formatCell(value) + '</td>';
                } else if (cm.isReadOnly) {
                    html += '<td class="cell-readonly" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" title="' + cm.readOnlyLabel + '  read-only">' + formatCell(value) + '</td>';
                } else {
                    html += '<td class="inline-editable" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" onclick="startInlineCellEdit(event, this)">' + formatCell(value) + '</td>';
                }
            }
            html += '</tr>';
        });
    }

    html += '</tbody>';

    // Replace container content in one shot after data is ready (no intermediate blank state)
    tableContainer.innerHTML = '<table id="table"></table>';
    tableEl = document.getElementById('table');
    tableEl.innerHTML = html;

    // Update pagination (hide when grouped)
    if (isGrouped) {
        document.getElementById('pagination').style.display = 'none';
    } else {
        document.getElementById('pagination').style.display = '';
        updatePagination();
    }

    // Update record count badge
    updateRecordCountBadge();
}

// Group records by a field value
function groupRecordsByField(recordIds, recordMap, fieldId, colNames) {
    var groups = {};
    var emptyGroupKey = '(Empty)';

    recordIds.forEach(rid => {
        var row = recordMap[rid] || {};
        var value = row[fieldId];
        if (value === undefined) value = row[colNames[fieldId]];

        // Convert value to display string for grouping
        var groupKey = getGroupKeyFromValue(value);

        if (!groups[groupKey]) {
            groups[groupKey] = [];
        }
        groups[groupKey].push(rid);
    });

    // Sort groups: put (Empty) last, then sort alphabetically
    var sortedGroups = {};
    var keys = Object.keys(groups).sort((a, b) => {
        if (a === emptyGroupKey) return 1;
        if (b === emptyGroupKey) return -1;
        return a.localeCompare(b);
    });
    keys.forEach(k => sortedGroups[k] = groups[k]);

    return sortedGroups;
}

// Get a display string for grouping from a cell value
function getGroupKeyFromValue(value) {
    if (value == null || value === '') return '(Empty)';

    if (Array.isArray(value)) {
        if (value.length === 0) return '(Empty)';
        // For arrays, join values for display
        return value.map(v => {
            if (typeof v === 'object' && v !== null) {
                return v.name || v.filename || v.email || v.id || JSON.stringify(v);
            }
            return String(v);
        }).join(', ');
    }

    if (typeof value === 'object') {
        return value.name || value.filename || value.email || value.url || JSON.stringify(value);
    }

    return String(value);
}

// Toggle group visibility (Ctrl+click or Cmd+click collapses/expands ALL groups)
function toggleGroup(groupId, event) {
    var headerRow = document.querySelector('.group-header-row[data-group-id="' + groupId + '"]');
    var isCollapsed = headerRow.classList.contains('collapsed');

    if (event && (event.ctrlKey || event.metaKey)) {
        // Ctrl+click: toggle ALL groups to match the opposite of clicked group's state
        var allHeaders = document.querySelectorAll('.group-header-row');
        allHeaders.forEach(function(h) {
            var gid = h.getAttribute('data-group-id');
            var rows = document.querySelectorAll('.group-row[data-group-id="' + gid + '"]');
            if (isCollapsed) {
                h.classList.remove('collapsed');
                rows.forEach(function(r) { r.classList.remove('hidden'); });
            } else {
                h.classList.add('collapsed');
                rows.forEach(function(r) { r.classList.add('hidden'); });
            }
        });
    } else {
        // Normal click: toggle just this group
        var dataRows = document.querySelectorAll('.group-row[data-group-id="' + groupId + '"]');
        if (isCollapsed) {
            headerRow.classList.remove('collapsed');
            dataRows.forEach(function(row) { row.classList.remove('hidden'); });
        } else {
            headerRow.classList.add('collapsed');
            dataRows.forEach(function(row) { row.classList.add('hidden'); });
        }
    }
}

function formatCell(v) {
    if (v == null || v === '') {
        return '<span class="cell-empty"></span>';
    }

    if (Array.isArray(v)) {
        if (v.length === 0) return '<span class="cell-empty"></span>';

        // Check if it's an array of objects (linked records, attachments, etc.)
        if (typeof v[0] === 'object' && v[0] !== null) {
            var items = v.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return '<span class="cell-array">' + items.map(i => '<span class="tag">' + esc(i) + '</span>').join('') + '</span>';
        }

        // Simple array - join with commas
        return '<span class="cell-array">' + v.map(i => '<span class="tag">' + esc(String(i)) + '</span>').join('') + '</span>';
    }

    if (typeof v === 'object') {
        // Single object
        if (v.name) return esc(v.name);
        if (v.filename) return esc(v.filename);
        if (v.email) return esc(v.email);
        if (v.url) return '<a class="cell-link" href="' + esc(v.url) + '" target="_blank">' + esc(v.url.slice(0, 40)) + '</a>';
        return esc(JSON.stringify(v).slice(0, 50));
    }

    if (typeof v === 'boolean') {
        return '<span class="cell-bool ' + v + '">' + (v ? 'Yes' : 'No') + '</span>';
    }

    if (typeof v === 'number') {
        return '<span class="cell-number">' + v.toLocaleString() + '</span>';
    }

    // String - check for URLs
    var str = String(v);
    if (str.startsWith('http://') || str.startsWith('https://')) {
        return '<a class="cell-link" href="' + esc(str) + '" target="_blank">' + esc(str.slice(0, 50)) + '</a>';
    }

    return esc(str);
}

function updatePagination() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    var start = currentPage * PAGE_SIZE + 1;
    var end = Math.min((currentPage + 1) * PAGE_SIZE, totalRecords);

    document.getElementById('page-info').textContent = start + '-' + end + ' of ' + totalRecords.toLocaleString();
    document.getElementById('prev-btn').disabled = currentPage === 0;
    document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
    document.getElementById('pagination').style.display = totalRecords > PAGE_SIZE ? 'flex' : 'none';
}

function prevPage() {
    if (currentPage > 0) {
        currentPage--;
        renderTable();
    }
}

function nextPage() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    if (currentPage < totalPages - 1) {
        currentPage++;
        renderTable();
    }
}

// ============ API ============

// Fetch all records of a specific set type (table, field, view)
// Fetch all pages and filter events client-side by set type
async function fetchAllBySet(setType, onProgress) {
    var allEvents = [];
    var page = 1;
    var iterations = 0;
    while (true) {
        // Fetch using page-based pagination
        var result = await fetchPage(page);
        if (!result.events || result.events.length === 0) break;

        // Filter events client-side by payload._set
        var matchingEvents = result.events.filter(function(e) {
            if (!e || !e.payload) return false;
            var payload = parsePayload(e.payload);
            return payload && payload._set === setType;
        });

        for (var m = 0; m < matchingEvents.length; m++) allEvents.push(matchingEvents[m]);
        if (onProgress) onProgress(allEvents.length);
        if (!result.hasMore) break;
        page = result.nextPage;
        iterations++;
        if (iterations > 100) break; // Safety limit for schema
    }
    return allEvents;
}

// Fetch events (Deprecated - Xano API removed)
// The client now reads from Matrix Synapse. This stub is kept for backward compatibility.
var FETCH_PAGE_TIMEOUT = 30000;
var FETCH_PAGE_RETRIES = 3;

async function fetchPage(page, createdAfter, options) {
    // Xano API has been removed. All data flows through Matrix Synapse.
    console.warn('[fetchPage] Xano API removed  data now served via Matrix /sync');
    return { events: [], hasMore: false, nextPage: null };
}

// fullSync (Deprecated - Xano API removed)
// Initial data loading is now handled by hydrateFromSynapse() which replays
// all law.firm.schema.object events from Matrix rooms.
async function fullSync() {
    console.warn('[fullSync] Xano API removed  use hydrateFromSynapse() instead');
    await hydrateFromSynapse();
}

// incrementalSync (Deprecated - Xano API removed)
// Incremental updates are now handled by SynapseSync which long-polls Matrix /sync.
var _incrementalSyncRunning = false;
async function incrementalSync() {
    console.warn('[incrementalSync] Xano API removed  updates delivered via Matrix /sync');
    // Ensure SynapseSync is running for incremental updates
    if (!SynapseSync.running) {
        SynapseSync.start();
    }
}

// ============ Sync Status View ============

var syncStatusUnsubscribe = null;
var queueStatusUnsubscribe = null;

async function showSyncStatusView() {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Open tab for sync status
    openTableInTab('_sync_status', 'Sync Status', '\uD83D\uDD04');

    // Clean up events view state
    expandedPayloads.clear();
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;
    if (eventsScrollHandler) {
        var evContainer = document.querySelector('.table-container');
        if (evContainer) evContainer.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }
    if (changelogScrollHandler) {
        var evContainer = document.querySelector('.table-container');
        if (evContainer) evContainer.removeEventListener('scroll', changelogScrollHandler);
        changelogScrollHandler = null;
    }

    currentTable = '_sync_status';
    currentView = null;

    // Update sidebar selection
    document.querySelectorAll('.sidebar .table-item').forEach(el => el.classList.remove('active', 'expanded'));
    document.querySelectorAll('.sidebar .table-view-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.sidebar .table-item.sync-status-item')?.classList.add('active');

    // Hide view controls and show sync status view
    document.getElementById('view-controls-bar').style.display = 'none';
    document.getElementById('title').textContent = 'Sync Status';
    document.getElementById('pagination').style.display = 'none';

    // Hide toolbar views section
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = 'none';

    // Show loading state immediately
    var container = document.querySelector('.table-container');
    if (container) container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading sync status...</h3></div>';

    await renderSyncStatusView();
    if (navVersion !== myNav) return;

    // Subscribe to live updates
    if (syncStatusUnsubscribe) syncStatusUnsubscribe();
    syncStatusUnsubscribe = SyncHistory.onChange(() => {
        if (currentTable === '_sync_status') renderSyncStatusView();
    });
    if (queueStatusUnsubscribe) queueStatusUnsubscribe();
    queueStatusUnsubscribe = OfflineSyncQueue.onChange(() => {
        if (currentTable === '_sync_status') renderSyncStatusView();
    });
}

async function renderSyncStatusView() {
    var container = document.querySelector('.table-container');
    var stats = SyncHistory.getStats();
    var passiveStats = { isRunning: false, pulled: 0, verified: 0 };
    var totalEventsCount = await getRawEventsCount();

    // Fetch offline queue state
    var queueEntries = [];
    var queueCount = 0;
    try {
        queueEntries = await OfflineSyncQueue.getAll();
        queueCount = queueEntries.length;
    } catch (e) { /* db may not be ready */ }

    // Determine overall sync state
    var syncState = 'synced';
    var syncLabel = 'Up to Date';
    if (queueCount > 0) {
        syncState = 'queued';
        syncLabel = queueCount + ' Edit' + (queueCount !== 1 ? 's' : '') + ' Queued';
    } else if (SyncHistory.isPolling) {
        syncState = 'syncing';
        syncLabel = 'Checking...';
    } else if (stats.errorCount > 0 && stats.errorCount === stats.totalSyncs + stats.totalPolls) {
        syncState = 'error';
        syncLabel = 'Errors Detected';
    }

    var html = '<div class="sync-status-view">';

    // Header
    html += '<div class="sync-status-header">';
    html += '<h2>Sync Status</h2>';
    html += '<span class="sync-status-badge ' + syncState + '">' + syncLabel + '</span>';
    html += '</div>';

    // Summary cards
    html += '<div class="sync-status-cards">';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Total Events in DB</div>';
    html += '<div class="card-value">' + totalEventsCount.toLocaleString() + '</div>';
    html += '<div class="card-sub">Last event timestamp: ' + (lastEventTimestamp ? formatTimestamp(lastEventTimestamp) : 'N/A') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Events Synced (Session)</div>';
    html += '<div class="card-value">' + stats.totalEventsProcessed.toLocaleString() + '</div>';
    html += '<div class="card-sub">' + stats.totalSyncs + ' sync operation' + (stats.totalSyncs !== 1 ? 's' : '') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Snapshots Updated</div>';
    html += '<div class="card-value">' + stats.totalSnapshotsUpdated.toLocaleString() + '</div>';
    html += '<div class="card-sub">Passive: ' + passiveStats.pulled + ' pulled, ' + passiveStats.verified + ' verified</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Local Edits Propagated</div>';
    html += '<div class="card-value">' + stats.successfulEdits.toLocaleString() + '</div>';
    html += '<div class="card-sub">' + stats.totalFieldsEdited + ' field' + (stats.totalFieldsEdited !== 1 ? 's' : '') + ' changed' + (stats.failedEdits > 0 ? ', ' + stats.failedEdits + ' failed' : '') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card' + (queueCount > 0 ? ' queue-highlight' : '') + '">';
    html += '<div class="card-label">Offline Queue</div>';
    html += '<div class="card-value">' + queueCount + '</div>';
    var pendingCount = queueEntries.filter(function(e) { return e.status === 'pending'; }).length;
    var failedCount = queueEntries.filter(function(e) { return e.status === 'failed'; }).length;
    html += '<div class="card-sub">' + (queueCount === 0 ? 'All synced' : pendingCount + ' pending' + (failedCount > 0 ? ', ' + failedCount + ' failed' : '')) + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Last Sync</div>';
    html += '<div class="card-value" style="font-size: 16px;">' + (stats.lastSyncTime ? formatSyncTimestamp(stats.lastSyncTime) : 'Never') + '</div>';
    html += '<div class="card-sub">Last poll: ' + (stats.lastPollTime ? formatSyncTimestamp(stats.lastPollTime) : 'Never') + '</div>';
    html += '</div>';

    html += '</div>';

    // Polling controls
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (SyncHistory.isPolling ? (SyncHistory.consecutiveFailures > 0 ? 'red' : 'green') : 'amber') + '"></span>Database Polling</h3>';
    html += '<div class="sync-poll-controls">';
    html += '<button class="btn-poll primary" onclick="SyncHistory.pollForUpdates(); renderSyncStatusView();">';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>';
    html += 'Poll Now</button>';
    if (SyncHistory.isPolling) {
        html += '<button class="btn-poll" onclick="SyncHistory.stopPolling(); renderSyncStatusView();">Stop Auto-Poll</button>';
        if (SyncHistory.consecutiveFailures > 0) {
            html += '<span style="font-size: 12px; color: #ef4444;">Backing off: ' + Math.round(SyncHistory.currentPollInterval / 1000) + 's interval (' + SyncHistory.consecutiveFailures + ' consecutive failure' + (SyncHistory.consecutiveFailures > 1 ? 's' : '') + ')</span>';
        } else {
            html += '<span style="font-size: 12px; color: #6b7280;">Polling every ' + (SyncHistory.POLL_INTERVAL / 1000) + 's</span>';
        }
    } else {
        html += '<button class="btn-poll" onclick="SyncHistory.startPolling(); renderSyncStatusView();">Start Auto-Poll</button>';
        html += '<span style="font-size: 12px; color: #6b7280;">Auto-poll is off</span>';
    }
    html += '</div>';
    html += '</div>';

    // Offline sync queue section
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (queueCount > 0 ? 'amber' : 'green') + '"></span>Offline Queue';
    if (queueCount > 0) {
        html += ' <span class="queue-count-badge">' + queueCount + '</span>';
    }
    html += '</h3>';

    if (queueCount === 0) {
        html += '<div style="text-align: center; padding: 20px; color: #9ca3af; font-size: 13px;">No pending edits. All changes are synced to the cloud.</div>';
    } else {
        html += '<div class="sync-poll-controls" style="margin-bottom: 12px;">';
        html += '<button class="btn-poll primary" onclick="OfflineSyncQueue.drain().then(function() { renderSyncStatusView(); });">';
        html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5M5 12l7-7 7 7"/></svg>';
        html += ' Retry All Now</button>';
        html += '<button class="btn-poll" onclick="if(confirm(\'Discard all queued edits? This cannot be undone.\')) { OfflineSyncQueue.discardAll().then(function() { renderSyncStatusView(); }); }">';
        html += 'Discard All</button>';
        if (OfflineSyncQueue._draining) {
            html += '<span style="font-size: 12px; color: #fbbf24;">Syncing queued edits...</span>';
        } else if (!navigator.onLine) {
            html += '<span style="font-size: 12px; color: #f87171;">Offline  edits will sync when connection returns</span>';
        } else {
            html += '<span style="font-size: 12px; color: #6b7280;">' + queueCount + ' edit' + (queueCount !== 1 ? 's' : '') + ' waiting to sync</span>';
        }
        html += '</div>';

        html += '<table class="sync-history-table">';
        html += '<thead><tr>';
        html += '<th>Record</th>';
        html += '<th>Table</th>';
        html += '<th>Fields</th>';
        html += '<th>Status</th>';
        html += '<th>Retries</th>';
        html += '<th>Queued At</th>';
        html += '<th>Error</th>';
        html += '<th>Actions</th>';
        html += '</tr></thead>';
        html += '<tbody>';

        for (var qi = 0; qi < queueEntries.length; qi++) {
            var qe = queueEntries[qi];
            var fieldCount = qe.fieldChanges ? Object.keys(qe.fieldChanges).length : 0;
            var statusClass = qe.status === 'failed' ? 'error' : (qe.status === 'retrying' ? 'syncing' : 'queued');
            html += '<tr>';
            html += '<td style="font-size: 12px; font-family: monospace; color: #9ca3af;">' + esc(qe.recordId || '') + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280;">' + esc(qe.tableId || '') + '</td>';
            html += '<td>' + fieldCount + ' field' + (fieldCount !== 1 ? 's' : '') + '</td>';
            html += '<td><span class="sync-result-badge ' + statusClass + '">' + esc(qe.status || 'pending') + '</span></td>';
            html += '<td style="text-align: center;">' + (qe.retries || 0) + '</td>';
            html += '<td style="white-space: nowrap; font-size: 12px; color: #6b7280;">' + formatSyncTimestamp(qe.createdAt) + '</td>';
            html += '<td style="font-size: 12px; color: #f87171; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + esc(qe.error || '') + '</td>';
            html += '<td><button class="btn-poll" style="font-size: 11px; padding: 2px 8px;" onclick="OfflineSyncQueue.discard(' + qe.id + ').then(function() { renderSyncStatusView(); });">Discard</button></td>';
            html += '</tr>';
        }

        html += '</tbody></table>';
    }
    html += '</div>';

    // Sync history table
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (stats.errorCount > 0 ? 'red' : 'green') + '"></span>Sync History</h3>';

    if (SyncHistory.entries.length === 0) {
        html += '<div style="text-align: center; padding: 32px; color: #9ca3af; font-size: 13px;">No sync operations recorded yet. Syncs will appear here as they occur.</div>';
    } else {
        html += '<table class="sync-history-table">';
        html += '<thead><tr>';
        html += '<th>Time</th>';
        html += '<th>Type</th>';
        html += '<th>Result</th>';
        html += '<th>Events</th>';
        html += '<th>Snapshots</th>';
        html += '<th>Duration</th>';
        html += '<th>Detail</th>';
        html += '</tr></thead>';
        html += '<tbody>';

        var displayEntries = SyncHistory.entries.slice(0, 50);
        for (var i = 0; i < displayEntries.length; i++) {
            var entry = displayEntries[i];
            html += '<tr>';
            html += '<td style="white-space: nowrap; font-size: 12px; color: #6b7280;">' + formatSyncTimestamp(entry.timestamp) + '</td>';
            html += '<td><span class="sync-type-badge ' + entry.type + '">' + entry.type + '</span></td>';
            html += '<td><span class="sync-result-badge ' + entry.result + '">' + entry.result.replace('-', ' ') + '</span></td>';
            html += '<td>' + (entry.eventsFound || 0) + '</td>';
            html += '<td>' + (entry.snapshotsUpdated || 0) + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280;">' + (entry.duration > 0 ? entry.duration + 'ms' : '-') + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + esc(entry.detail || '') + '</td>';
            html += '</tr>';
        }

        html += '</tbody></table>';
        if (SyncHistory.entries.length > 50) {
            html += '<div style="text-align: center; padding: 8px; color: #9ca3af; font-size: 12px;">Showing 50 of ' + SyncHistory.entries.length + ' entries</div>';
        }
    }
    html += '</div>';

    // Activity log (mirrors SyncStatusFeed)
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (SyncStatusFeed.isActive ? 'green' : 'amber') + '"></span>Activity Log</h3>';
    html += '<div class="sync-activity-log">';
    if (SyncStatusFeed.lines.length === 0) {
        html += '<div class="log-empty">No sync activity logged yet</div>';
    } else {
        var logLines = SyncStatusFeed.lines.slice(-50);
        for (var j = 0; j < logLines.length; j++) {
            var line = logLines[j];
            html += '<div class="log-line ' + line.type + '">';
            html += '<span class="timestamp">' + line.timestamp + '</span>';
            html += '<span class="message">' + esc(line.message) + '</span>';
            html += '</div>';
        }
    }
    html += '</div>';
    html += '</div>';

    html += '</div>';
    container.innerHTML = html;

    // Scroll activity log to bottom
    var logEl = container.querySelector('.sync-activity-log');
    if (logEl) logEl.scrollTop = logEl.scrollHeight;
}

function formatSyncTimestamp(ts) {
    var d;
    if (ts instanceof Date) {
        d = ts;
    } else if (typeof ts === 'number') {
        d = new Date(ts);
    } else {
        d = new Date(ts);
    }
    if (isNaN(d.getTime())) return String(ts);
    var now = new Date();
    var isToday = d.toDateString() === now.toDateString();
    var time = d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });
    if (isToday) return time;
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' + time;
}

// ============ Synapse Sync ============
// ============ Synapse Sync ============

// SynapseSync: real-time sync from Matrix room timelines via /sync long-poll
// Each Airtable table has its own room. Events are law.firm.schema.object + law.firm.record.mutate.
var SynapseSync = {
    running: false,
    since: null,
    tableRooms: [],       // [{ tableId, roomId, name }]
    roomToTable: {},      // roomId  tableId
    _backoffMs: 1000,

    async discoverTableRooms() {
        // Discover table rooms via a single /sync call with a state filter.
        // We filter for law.firm.schema.table and law.firm.vault.metadata state
        // events so we find them regardless of what state_key was used.
        try {
            var session = _loadSynapseSession();
            if (!session || !session.accessToken) return [];

            var filter = JSON.stringify({
                room: {
                    state: {
                        types: ['law.firm.schema.table', 'law.firm.vault.metadata']
                    },
                    timeline: { limit: 0 },
                    ephemeral: { types: [] },
                    account_data: { types: [] }
                },
                account_data: { types: [] },
                presence: { types: [] }
            });

            var syncRes = await fetch(
                SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/sync?timeout=0&filter=' + encodeURIComponent(filter),
                { headers: { 'Authorization': 'Bearer ' + session.accessToken } }
            );
            if (!syncRes.ok) {
                console.error('[SynapseSync] Discovery sync failed:', syncRes.status);
                return [];
            }
            var syncData = await safeResponseJson(syncRes, 'Room discovery');

            var tableRooms = [];
            var joinRooms = (syncData.rooms && syncData.rooms.join) || {};

            for (var roomId in joinRooms) {
                var roomData = joinRooms[roomId];
                var stateEvents = (roomData.state && roomData.state.events) || [];

                // A single room can host multiple tables (e.g. matter rooms),
                // so collect every table-identifying state event we find.
                for (var i = 0; i < stateEvents.length; i++) {
                    var evt = stateEvents[i];
                    if (!evt.content) continue;

                    if (evt.type === 'law.firm.vault.metadata') {
                        var tid = evt.content.tableId || evt.content.table_id;
                        if (tid) {
                            tableRooms.push({
                                tableId: tid,
                                roomId: roomId,
                                name: evt.content.tableName || evt.content.table_name || evt.content.name || tid
                            });
                        }
                    } else if (evt.type === 'law.firm.schema.table') {
                        var tid2 = evt.content.tableId || evt.content.table_id || evt.content.id;
                        if (tid2) {
                            tableRooms.push({
                                tableId: tid2,
                                roomId: roomId,
                                name: evt.content.name || evt.content.tableName || evt.content.table_name || tid2
                            });
                        }
                    }
                }
            }

            if (tableRooms.length > 0) {
                // State-event discovery found rooms  use them
                this.tableRooms = tableRooms;
                this.roomToTable = {};
                for (var tr of tableRooms) {
                    this.roomToTable[tr.roomId] = tr.tableId;
                }
            } else if (this.tableRooms.length > 0) {
                // No rooms found via state events, but API-populated mappings exist 
                // keep them (bot-created rooms may lack state events)
                console.log('[SynapseSync] No rooms found via state events, keeping ' + this.tableRooms.length + ' API-populated mappings');
            }

            console.log('[SynapseSync] Discovered ' + this.tableRooms.length + ' table rooms');
            return this.tableRooms;
        } catch (err) {
            console.error('[SynapseSync] Room discovery failed:', err);
            return this.tableRooms || [];
        }
    },

    async start() {
        if (this.running) return;
        this.running = true;
        this._backoffMs = 1000;

        // Load saved sync token
        try {
            this.since = await getSyncMeta('synapseSyncToken');
        } catch (e) {
            this.since = null;
        }

        // Discover table rooms if not already done
        if (this.tableRooms.length === 0) {
            await this.discoverTableRooms();
            // Re-render sidebar so Rooms section appears
            if (this.tableRooms.length > 0) {
                invalidateSidebarCache();
                renderSidebar(true);
            }
        }

        if (this.tableRooms.length === 0) {
            console.log('[SynapseSync] No table rooms found  sync idle');
            this.running = false;
            return;
        }

        console.log('[SynapseSync] Starting sync loop with ' + this.tableRooms.length + ' rooms');
        this._loop();
    },

    stop() {
        this.running = false;
        console.log('[SynapseSync] Stopped');
    },

    async _loop() {
        while (this.running) {
            try {
                var session = _loadSynapseSession();
                if (!session || !session.accessToken) {
                    console.warn('[SynapseSync] No session  stopping');
                    this.running = false;
                    return;
                }

                var roomIds = this.tableRooms.map(function(r) { return r.roomId; });

                // Build sync filter: listen for law.firm.schema.object AND law.firm.record.mutate
                // timeline events, plus schema state events (table/field metadata + vault metadata)
                var filter = JSON.stringify({
                    room: {
                        rooms: roomIds,
                        timeline: {
                            types: ['law.firm.schema.object', 'law.firm.record.mutate'],
                            limit: 100
                        },
                        state: {
                            types: ['law.firm.schema.table', 'law.firm.schema.field', 'law.firm.vault.metadata']
                        }
                    }
                });

                var url = SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/sync?timeout=30000&filter=' + encodeURIComponent(filter);
                if (this.since) {
                    url += '&since=' + encodeURIComponent(this.since);
                }

                var res = await fetch(url, {
                    headers: { 'Authorization': 'Bearer ' + session.accessToken }
                });

                if (!res.ok) {
                    throw new Error('Sync failed: ' + res.status);
                }

                var syncData = await safeResponseJson(res, 'Sync');
                await this._processSync(syncData);

                this.since = syncData.next_batch;
                await setSyncMeta('synapseSyncToken', this.since);

                // Reset backoff on success
                this._backoffMs = 1000;
            } catch (err) {
                console.error('[SynapseSync] Error:', err);
                // Exponential backoff
                await new Promise(function(resolve) { setTimeout(resolve, SynapseSync._backoffMs); });
                this._backoffMs = Math.min(this._backoffMs * 2, 300000); // max 5 min
            }
        }
    },

    // Convert a law.firm.schema.object or law.firm.record.mutate Matrix event
    // to the synthetic format processEvents expects.
    _convertSchemaObjectEvent: function(tevt, fallbackTableId) {
        var c = tevt.content;
        if (!c || !c.recordId) return null;

        var evtTableId = fallbackTableId;
        // Extract table ID from the 'set' field (e.g. "airtable:tblXXX")
        if (c.set) {
            evtTableId = c.set.replace('airtable:', '');
        }
        // law.firm.record.mutate events may carry tableId directly
        if (!evtTableId && c.tableId) {
            evtTableId = c.tableId;
        }

        var syntheticEvent = {
            id: tevt.event_id,
            set: 'airtable:' + evtTableId,
            recordId: c.recordId,
            operator: c.op,
            // sourceTimestamp might be seconds (migration) or milliseconds (n8n/client).
            // Heuristic: anything below 10 billion is seconds (covers dates through 2286).
            created_at: (function() {
                var ts = c.sourceTimestamp;
                if (ts) {
                    if (ts < 10000000000) ts = ts * 1000; // seconds  milliseconds
                    return ts;
                }
                return tevt.origin_server_ts;
            })(),
            payload: c.payload || { fields: {} }
        };

        // If payload doesn't have fields with EO operators, construct from op + fields
        if (syntheticEvent.payload && !syntheticEvent.payload.fields) {
            syntheticEvent.payload.fields = {};
        }

        // Handle case where event has flat fields + op but no EO-structured payload
        // (covers both law.firm.schema.object and law.firm.record.mutate flat formats)
        if (c.op && c.fields && !c.payload) {
            syntheticEvent.payload = { fields: {} };
            if (c.op === 'INS') {
                syntheticEvent.payload.fields.INS = c.fields;
            } else if (c.op === 'ALT') {
                syntheticEvent.payload.fields.ALT = c.fields;
            } else if (c.op === 'NUL') {
                syntheticEvent.payload.fields.NUL = Array.isArray(c.fields) ? c.fields : Object.keys(c.fields);
            }
        }

        // Handle law.firm.record.mutate structured payload format
        // where fields are at content.payload.fields.ALT / .INS / .NUL
        // (already handled above via c.payload passthrough)

        return syntheticEvent;
    },

    async _processSync(syncData) {
        var joinedRooms = syncData.rooms && syncData.rooms.join ? syncData.rooms.join : {};
        var newEvents = 0;

        for (var roomId in joinedRooms) {
            var tableId = this.roomToTable[roomId];
            if (!tableId) continue;

            var roomData = joinedRooms[roomId];

            // Process state events (schema changes)
            var stateEvents = roomData.state && roomData.state.events ? roomData.state.events : [];
            for (var i = 0; i < stateEvents.length; i++) {
                var evt = stateEvents[i];
                if (evt.type === 'law.firm.schema.table' && evt.content) {
                    await saveTable({ tableId: evt.content.tableId || evt.content.table_id || tableId, tableName: evt.content.name || evt.content.tableName || tableId });
                    if (META_TABLES) META_TABLES[tableId] = { tableId: tableId, tableName: evt.content.name || evt.content.tableName || tableId };
                } else if (evt.type === 'law.firm.schema.field' && evt.content) {
                    var fieldData = { tableId: tableId, fieldId: evt.content.fieldId || evt.content.field_id || evt.state_key, fieldName: evt.content.name, fieldType: evt.content.type, options: evt.content.options };
                    if (evt.content.readOnly != null) fieldData.readOnly = evt.content.readOnly;
                    await saveField(fieldData);
                    if (META_FIELDS && META_FIELDS[tableId]) META_FIELDS[tableId][fieldData.fieldId] = fieldData;
                } else if (evt.type === 'law.firm.vault.metadata' && evt.content) {
                    // Update table metadata from vault metadata
                    var vaultTableId = evt.content.tableId || evt.content.table_id || tableId;
                    var vaultTableName = evt.content.tableName || evt.content.table_name || evt.content.name || tableId;
                    await saveTable({ tableId: vaultTableId, tableName: vaultTableName });
                    if (META_TABLES) META_TABLES[vaultTableId] = { tableId: vaultTableId, tableName: vaultTableName };
                }
            }

            // Process timeline events (law.firm.schema.object + law.firm.record.mutate)
            var timelineEvents = roomData.timeline && roomData.timeline.events ? roomData.timeline.events : [];
            for (var j = 0; j < timelineEvents.length; j++) {
                var tevt = timelineEvents[j];
                if ((tevt.type === 'law.firm.schema.object' || tevt.type === 'law.firm.record.mutate') && tevt.content) {
                    var syntheticEvent = this._convertSchemaObjectEvent(tevt, tableId);
                    if (!syntheticEvent) continue;

                    try {
                        await processEvents([syntheticEvent]);
                        newEvents++;
                    } catch (procErr) {
                        console.error('[SynapseSync] Error processing event:', procErr);
                    }
                }
            }
        }

        if (newEvents > 0) {
            console.log('[SynapseSync] Processed ' + newEvents + ' new events');
            // Re-render current table if visible
            if (currentTable) {
                await showTable(currentTable, true);
            }
            await renderSidebar(false);
        }
    }
};

// Look up the Matrix room ID for a table, using SynapseSync room map first,
// then AminoData as fallback (if initialized). Returns null if not found.
function _getRoomForTable(tableId) {
    // Try SynapseSync room map first (always available after discovery)
    if (typeof SynapseSync !== 'undefined' && SynapseSync.tableRooms && SynapseSync.tableRooms.length > 0) {
        for (var i = 0; i < SynapseSync.tableRooms.length; i++) {
            if (SynapseSync.tableRooms[i].tableId === tableId) {
                return SynapseSync.tableRooms[i].roomId;
            }
        }
    }
    // Fall back to AminoData if initialized
    if (typeof AminoData !== 'undefined' && AminoData.isInitialized && AminoData.isInitialized()) {
        return AminoData.getRoomForTable(tableId);
    }
    return null;
}

// Build a reverse map of roomId -> tableId from SynapseSync, for use in
// changelog and other functions that iterate over rooms.
function _getRoomTableMap() {
    var map = {};
    if (typeof SynapseSync !== 'undefined' && SynapseSync.tableRooms) {
        for (var i = 0; i < SynapseSync.tableRooms.length; i++) {
            var tr = SynapseSync.tableRooms[i];
            map[tr.roomId] = tr.tableId;
        }
    }
    return map;
}

// hydrateFromSynapse: full initial hydration from Synapse table rooms
// Replays all law.firm.schema.object + law.firm.record.mutate events to build local state
async function hydrateFromSynapse() {
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) {
            console.warn('[Hydration] No Synapse session  cannot hydrate');
            return false;
        }

        // Discover table rooms (vault rooms)
        var tableRooms = await SynapseSync.discoverTableRooms();
        if (tableRooms.length === 0) {
            console.log('[Hydration] No table rooms found');
            return false;
        }

        updateStatus('Hydrating from Synapse...', false, 0, 'Found ' + tableRooms.length + ' tables');
        var totalProcessed = 0;
        var totalFieldsFound = 0;
        var totalRecordsFound = 0;

        // Reset speed tracking for this hydration run
        _loadingStartTime = null;
        _loadingPrevRecords = 0;
        _loadingPrevTime = null;
        _loadingSmoothedSpeed = 0;

        updateLoadingOverlay('Downloading data...', 'Found ' + tableRooms.length + ' tables', 0, tableRooms.length, 0, 0, null);

        for (var idx = 0; idx < tableRooms.length; idx++) {
            var tr = tableRooms[idx];
            var progressPct = Math.round((idx / tableRooms.length) * 100);
            updateStatus('Hydrating ' + tr.name + '...', false, progressPct, 'Table ' + (idx + 1) + ' of ' + tableRooms.length);
            updateLoadingOverlay('Downloading ' + tr.name + '...', 'Table ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, totalFieldsFound, totalRecordsFound, 'Reading schema...');

            // 1. Read schema state events for this room
            try {
                var stateRes = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/rooms/' + encodeURIComponent(tr.roomId) + '/state', {
                    headers: { 'Authorization': 'Bearer ' + session.accessToken }
                });
                if (stateRes.ok) {
                    var stateEvents = await safeResponseJson(stateRes, 'Room state');
                    for (var i = 0; i < stateEvents.length; i++) {
                        var evt = stateEvents[i];
                        if (evt.type === 'law.firm.vault.metadata' && evt.content) {
                            var vaultTableId = evt.content.tableId || evt.content.table_id || tr.tableId;
                            var vaultTableName = evt.content.tableName || evt.content.table_name || evt.content.name || tr.name;
                            await saveTable({ tableId: vaultTableId, tableName: vaultTableName });
                        } else if (evt.type === 'law.firm.schema.table' && evt.content) {
                            await saveTable({ tableId: evt.content.tableId || evt.content.table_id || tr.tableId, tableName: evt.content.name || evt.content.tableName || tr.name });
                        } else if (evt.type === 'law.firm.schema.field' && evt.content) {
                            await saveField({ tableId: tr.tableId, fieldId: evt.content.fieldId || evt.content.field_id || evt.state_key, fieldName: evt.content.name, fieldType: evt.content.type, options: evt.content.options });
                            totalFieldsFound++;
                        }
                    }
                    updateLoadingOverlay('Downloading ' + tr.name + '...', 'Table ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, totalFieldsFound, totalRecordsFound, 'Schema loaded \u2014 fetching records...');
                }
            } catch (stateErr) {
                console.warn('[Hydration] State read failed for ' + tr.name + ':', stateErr);
            }

            // 2. Paginate full timeline for law.firm.schema.object + law.firm.record.mutate events
            var from = null;
            var roomEvents = 0;
            while (true) {
                try {
                    var msgUrl = SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/rooms/' + encodeURIComponent(tr.roomId) + '/messages?dir=f&limit=100';
                    if (from) msgUrl += '&from=' + encodeURIComponent(from);
                    msgUrl += '&filter=' + encodeURIComponent(JSON.stringify({ types: ['law.firm.schema.object', 'law.firm.record.mutate'] }));

                    var msgRes = await fetch(msgUrl, {
                        headers: { 'Authorization': 'Bearer ' + session.accessToken }
                    });
                    if (!msgRes.ok) break;

                    var msgData = await safeResponseJson(msgRes, 'Room messages');
                    var chunk = msgData.chunk || [];
                    if (chunk.length === 0) break;

                    // Process each event using the shared converter (handles both event types)
                    for (var j = 0; j < chunk.length; j++) {
                        var mevt = chunk[j];
                        if ((mevt.type === 'law.firm.schema.object' || mevt.type === 'law.firm.record.mutate') && mevt.content) {
                            var synEvent = SynapseSync._convertSchemaObjectEvent(mevt, tr.tableId);
                            if (!synEvent) continue;

                            try {
                                await processEvents([synEvent]);
                                roomEvents++;
                                totalProcessed++;
                                totalRecordsFound++;

                                // Update every 10 records for responsive feedback
                                if (roomEvents % 10 === 0) {
                                    updateLoadingOverlay('Downloading ' + tr.name + '...', 'Table ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, totalFieldsFound, totalRecordsFound, roomEvents.toLocaleString() + ' records in this table...');
                                }
                            } catch (procErr) {
                                console.warn('[Hydration] Event processing error:', procErr);
                            }
                        }
                    }

                    // Update loading overlay with record progress at page boundary
                    updateLoadingOverlay('Downloading ' + tr.name + '...', 'Table ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, totalFieldsFound, totalRecordsFound, roomEvents.toLocaleString() + ' records in this table...');

                    from = msgData.end;
                    if (!from) break;
                } catch (pageErr) {
                    console.warn('[Hydration] Pagination error for ' + tr.name + ':', pageErr);
                    break;
                }
            }

            console.log('[Hydration] ' + tr.name + ': ' + roomEvents + ' events processed');
        }

        updateLoadingOverlay('Encrypting and saving...', 'Finalizing ' + totalProcessed.toLocaleString() + ' records', 95, tableRooms.length, totalFieldsFound, totalRecordsFound, 'Writing to local storage...');

        // Save sync token for incremental updates going forward
        try {
            var syncRes = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/sync?timeout=0&filter=' + encodeURIComponent(JSON.stringify({ room: { rooms: tableRooms.map(function(r) { return r.roomId; }), timeline: { limit: 0 } } })), {
                headers: { 'Authorization': 'Bearer ' + session.accessToken }
            });
            if (syncRes.ok) {
                var syncData = await safeResponseJson(syncRes, 'Sync token');
                SynapseSync.since = syncData.next_batch;
                await setSyncMeta('synapseSyncToken', syncData.next_batch);
            }
        } catch (tokenErr) {
            console.warn('[Hydration] Could not save sync token:', tokenErr);
        }

        updateLoadingOverlay('Sync complete', totalProcessed.toLocaleString() + ' records downloaded and encrypted', 100, tableRooms.length, totalFieldsFound, totalRecordsFound, '');
        updateStatus('Hydration complete: ' + totalProcessed + ' events', true, 100, null);
        return totalProcessed > 0;
    } catch (err) {
        console.error('[Hydration] Failed:', err);
        return false;
    }
}

// ============ Matrix History Backfill ============

// After hydrating current record state from the webhook DB API, replay
// Matrix room timelines to build field-level change history.  Uses
// processEvents({ historyOnly: true }) so that data records in IndexedDB
// are NOT overwritten  the webhook-hydrated state remains authoritative.
// Only field history entries and schema metadata are written.
// Each room is processed in full (all pages collected first) so that
// records spanning multiple pages have accurate oldValue tracking.
async function backfillHistoryFromMatrix() {
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) {
            console.warn('[HistoryBackfill] No Synapse session  skipping');
            return false;
        }

        // Use SynapseSync.tableRooms (already populated by ensureRoomMembership)
        var tableRooms = (SynapseSync.tableRooms || []).filter(function(tr) { return !!tr.roomId; });
        if (tableRooms.length === 0) {
            console.log('[HistoryBackfill] No table rooms  skipping history backfill');
            return false;
        }

        console.log('[HistoryBackfill] Backfilling history from ' + tableRooms.length + ' Matrix rooms');
        SyncStatusFeed.log('Backfilling field history from Matrix...');
        updateLoadingOverlay('Backfilling history...', 'Reading ' + tableRooms.length + ' rooms', 0, tableRooms.length, 0, 0, null);

        var totalEvents = 0;

        for (var idx = 0; idx < tableRooms.length; idx++) {
            var tr = tableRooms[idx];
            var tableName = tr.name || tr.tableId;
            var progressPct = Math.round((idx / tableRooms.length) * 100);
            updateLoadingOverlay('Backfilling history  ' + tableName, 'Room ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, 0, totalEvents, null);

            // Read schema state events (fields) for this room
            try {
                var stateRes = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/rooms/' + encodeURIComponent(tr.roomId) + '/state', {
                    headers: { 'Authorization': 'Bearer ' + session.accessToken }
                });
                if (stateRes.ok) {
                    var stateEvents = await safeResponseJson(stateRes, 'Room state');
                    for (var si = 0; si < stateEvents.length; si++) {
                        var sevt = stateEvents[si];
                        if (sevt.type === 'law.firm.schema.field' && sevt.content) {
                            var fieldMeta = {
                                tableId: tr.tableId,
                                fieldId: sevt.content.fieldId || sevt.content.field_id || sevt.state_key,
                                fieldName: sevt.content.name || sevt.content.fieldName || sevt.state_key,
                                fieldType: sevt.content.type || sevt.content.fieldType || 'unknown',
                                options: sevt.content.options
                            };
                            if (!META_FIELDS[tr.tableId]) META_FIELDS[tr.tableId] = {};
                            // Only update if currently a placeholder or missing
                            var existing = META_FIELDS[tr.tableId][fieldMeta.fieldId];
                            if (!existing || existing._placeholder) {
                                META_FIELDS[tr.tableId][fieldMeta.fieldId] = fieldMeta;
                                await saveField(fieldMeta);
                            }
                        }
                    }
                }
            } catch (stateErr) {
                console.warn('[HistoryBackfill] State read failed for ' + tableName + ':', stateErr);
            }

            // Paginate the full timeline to collect ALL mutation events for
            // this room, then process them in a single historyOnly call.
            // Collecting all events first ensures that records spanning
            // multiple pages have accurate oldValue tracking (the in-memory
            // state is maintained across the full chronological sequence).
            var from = null;
            var allRoomEvents = [];
            while (true) {
                try {
                    var msgUrl = SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/rooms/' + encodeURIComponent(tr.roomId) + '/messages?dir=f&limit=100';
                    if (from) msgUrl += '&from=' + encodeURIComponent(from);
                    msgUrl += '&filter=' + encodeURIComponent(JSON.stringify({ types: ['law.firm.schema.object', 'law.firm.record.mutate'] }));

                    var msgRes = await fetch(msgUrl, {
                        headers: { 'Authorization': 'Bearer ' + session.accessToken }
                    });
                    if (!msgRes.ok) break;

                    var msgData = await safeResponseJson(msgRes, 'Room messages');
                    var chunk = msgData.chunk || [];
                    if (chunk.length === 0) break;

                    // Convert Matrix events to the synthetic format
                    for (var j = 0; j < chunk.length; j++) {
                        var mevt = chunk[j];
                        if ((mevt.type === 'law.firm.schema.object' || mevt.type === 'law.firm.record.mutate') && mevt.content) {
                            var synEvent = SynapseSync._convertSchemaObjectEvent(mevt, tr.tableId);
                            if (synEvent) allRoomEvents.push(synEvent);
                        }
                    }

                    if (allRoomEvents.length % 50 === 0 && allRoomEvents.length > 0) {
                        updateLoadingOverlay('Backfilling history  ' + tableName, 'Room ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, 0, totalEvents + allRoomEvents.length, allRoomEvents.length + ' events collected...');
                    }

                    from = msgData.end;
                    if (!from) break;
                } catch (pageErr) {
                    console.warn('[HistoryBackfill] Pagination error for ' + tableName + ':', pageErr);
                    break;
                }
            }

            // Process all collected events for this room in one call with
            // historyOnly: true  writes field history and schema metadata
            // but does NOT overwrite the webhook-hydrated record data.
            if (allRoomEvents.length > 0) {
                await processEvents(allRoomEvents, { historyOnly: true });
                totalEvents += allRoomEvents.length;
                console.log('[HistoryBackfill] ' + tableName + ': ' + allRoomEvents.length + ' events (history only)');
            }
            allRoomEvents = null; // release memory for this room
        }

        SyncStatusFeed.success('History backfill complete: ' + totalEvents + ' events from ' + tableRooms.length + ' rooms');
        console.log('[HistoryBackfill] Complete: ' + totalEvents + ' total events (history only  record data preserved from webhook)');
        return totalEvents > 0;
    } catch (err) {
        console.error('[HistoryBackfill] Failed:', err);
        SyncStatusFeed.error('History backfill failed: ' + err.message);
        return false;
    }
}

// ============ Webhook Hydration ============

// Fetch from n8n webhook API using the Synapse access token.
// Uses query-parameter auth by default to avoid CORS preflight (the
// Authorization header triggers an OPTIONS preflight that n8n may not
// handle).  Falls back to Authorization header only if query-param auth
// returns 401 (meaning the server didn't recognise the token in the URL).
async function webhookFetch(path) {
    var session = _loadSynapseSession();
    if (!session || !session.accessToken) throw new Error('No Synapse session');

    var MAX_RETRIES = 2;
    var lastErr = null;

    for (var attempt = 0; attempt <= MAX_RETRIES; attempt++) {
        if (attempt > 0) {
            // Exponential backoff: 1s, 3s
            var delay = attempt === 1 ? 1000 : 3000;
            console.log('[webhookFetch] Retry ' + attempt + '/' + MAX_RETRIES + ' for ' + path + ' (waiting ' + delay + 'ms)');
            await new Promise(function(r) { setTimeout(r, delay); });
        }

        // Primary: query-param auth  avoids CORS preflight entirely
        var separator = path.indexOf('?') === -1 ? '?' : '&';
        var url = N8N_WEBHOOK_BASE + path + separator + 'access_token=' + encodeURIComponent(session.accessToken);

        var response;
        try {
            response = await fetch(url);
        } catch (fetchErr) {
            // Network / CORS failure on the simple request  try header auth
            // as a last resort (will trigger OPTIONS preflight).
            console.warn('[webhookFetch] Query-param fetch failed (' + fetchErr.message + '), retrying with header auth for ' + path);
            try {
                response = await fetch(N8N_WEBHOOK_BASE + path, {
                    headers: { 'Authorization': 'Bearer ' + session.accessToken }
                });
            } catch (headerErr) {
                lastErr = new Error('Webhook unreachable (CORS/network): ' + headerErr.message);
                continue;
            }
        }

        if (response.status === 401) {
            // Query-param token may not have been picked up  retry with header
            console.warn('[webhookFetch] 401 with query-param auth, retrying with header auth for ' + path);
            try {
                response = await fetch(N8N_WEBHOOK_BASE + path, {
                    headers: { 'Authorization': 'Bearer ' + session.accessToken }
                });
            } catch (headerErr) {
                throw new Error('Webhook auth retry failed (CORS/network): ' + headerErr.message);
            }
            if (response.status === 401) {
                throw new Error('Webhook auth failed (Synapse token rejected)');
            }
        }

        // Retry on 5xx server errors (transient failures, n8n overload, etc.)
        if (response.status >= 500) {
            var errBody = '';
            try { errBody = await response.text(); } catch (e) {}
            console.warn('[webhookFetch] Server error ' + response.status + ' for ' + path + (errBody ? '  body: ' + errBody.substring(0, 200) : ''));
            lastErr = new Error('Webhook API error: ' + response.status + (errBody ? ' (' + errBody.substring(0, 100) + ')' : ''));
            continue;
        }

        if (!response.ok) {
            var errBody2 = '';
            try { errBody2 = await response.text(); } catch (e) {}
            throw new Error('Webhook API error: ' + response.status + (errBody2 ? ' (' + errBody2.substring(0, 100) + ')' : ''));
        }
        return safeResponseJson(response, 'Webhook API');
    }

    // All retries exhausted
    throw lastErr || new Error('Webhook API failed after ' + (MAX_RETRIES + 1) + ' attempts');
}

// hydrateFromWebhooks: fetch current state from n8n webhook API and store in main app IndexedDB
async function hydrateFromWebhooks() {
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) {
            console.warn('[WebhookHydration] No Synapse session  cannot hydrate');
            return false;
        }

        console.log('[WebhookHydration] Starting hydration from n8n webhook API');
        SyncStatusFeed.log('Hydrating from webhook API...');

        // 1. Fetch table list
        updateStatus('Fetching tables from webhook API...', false, 0, null);
        var tablesData = await webhookFetch('/amino-tables');
        var webhookTables = tablesData.tables || [];

        if (webhookTables.length === 0) {
            console.log('[WebhookHydration] No tables returned from webhook API');
            SyncStatusFeed.warn('Webhook API returned 0 tables');
            return false;
        }

        console.log('[WebhookHydration] Found ' + webhookTables.length + ' tables');
        SyncStatusFeed.info('Found ' + webhookTables.length + ' tables via webhook API');

        // Populate SynapseSync room mappings immediately so _getRoomForTable()
        // works as soon as hydration finishes (before ensureRoomMembership runs).
        var roomTables = webhookTables.filter(function(t) { return !!t.matrix_room_id; });
        if (roomTables.length > 0) {
            SynapseSync.tableRooms = roomTables.map(function(t) {
                return { tableId: t.table_id, roomId: t.matrix_room_id, name: t.table_name || t.table_id };
            });
            SynapseSync.roomToTable = {};
            for (var rm = 0; rm < roomTables.length; rm++) {
                SynapseSync.roomToTable[roomTables[rm].matrix_room_id] = roomTables[rm].table_id;
            }
            console.log('[WebhookHydration] Populated ' + SynapseSync.tableRooms.length + ' tableroom mappings');
        }

        var totalRecords = 0;
        var totalFields = 0;
        var failedTables = 0;
        var consecutiveRecordFailures = 0;

        // Reset speed tracking for this hydration run
        _loadingStartTime = null;
        _loadingPrevRecords = 0;
        _loadingPrevTime = null;
        _loadingSmoothedSpeed = 0;

        updateLoadingOverlay('Downloading from API...', 'Found ' + webhookTables.length + ' tables', 0, webhookTables.length, 0, 0, null);

        // 2. For each table, fetch records and store in main app IndexedDB
        for (var idx = 0; idx < webhookTables.length; idx++) {
            var wt = webhookTables[idx];
            var tableId = wt.table_id;
            var tableName = wt.table_name || tableId;
            var progressPct = Math.round((idx / webhookTables.length) * 100);

            updateStatus('Downloading ' + tableName + '...', false, progressPct, 'Table ' + (idx + 1) + ' of ' + webhookTables.length);
            updateLoadingOverlay('Downloading ' + tableName + '...', 'Table ' + (idx + 1) + ' of ' + webhookTables.length, progressPct, webhookTables.length, totalFields, totalRecords, 'Fetching records...');

            // Save table metadata
            await saveTable({ tableId: tableId, tableName: tableName });
            META_TABLES[tableId] = { tableId: tableId, tableName: tableName };

            // Fetch records for this table
            try {
                var recordsData = await webhookFetch('/amino-records?tableId=' + encodeURIComponent(tableId));
                var records = recordsData.records || [];

                if (records.length > 0) {
                    // Process records in batches to avoid blocking
                    var BATCH = 200;
                    for (var b = 0; b < records.length; b += BATCH) {
                        var batch = records.slice(b, b + BATCH);
                        var dataRecords = [];
                        var fieldsToSave = [];

                        for (var r = 0; r < batch.length; r++) {
                            var rec = batch[r];
                            var fields = rec.fields;
                            if (!fields || typeof fields !== 'object') continue;

                            // If fields is a string (JSON from postgres), parse it
                            if (typeof fields === 'string') {
                                try { fields = JSON.parse(fields); } catch (e) { continue; }
                            }

                            // Auto-discover field metadata from record data
                            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
                            var fieldIds = Object.keys(fields);
                            for (var fi = 0; fi < fieldIds.length; fi++) {
                                var fid = fieldIds[fi];
                                if (!META_FIELDS[tableId][fid]) {
                                    var fieldMeta = {
                                        tableId: tableId,
                                        fieldId: fid,
                                        fieldName: fid,
                                        fieldType: inferFieldType(fields[fid]),
                                        _placeholder: true
                                    };
                                    META_FIELDS[tableId][fid] = fieldMeta;
                                    fieldsToSave.push(fieldMeta);
                                    totalFields++;
                                }
                            }

                            dataRecords.push({
                                tableId: tableId,
                                recordId: rec.id,
                                fields: fields
                            });
                        }

                        // Save field metadata
                        for (var fs = 0; fs < fieldsToSave.length; fs++) {
                            await saveField(fieldsToSave[fs]);
                        }

                        // Save data records (uses main app's encryption)
                        if (dataRecords.length > 0) {
                            await saveBatch([], [], [], dataRecords);
                        }

                        totalRecords += dataRecords.length;

                        // Update progress within this table's batch processing
                        var recordsSoFar = Math.min(b + BATCH, records.length);
                        updateLoadingOverlay('Downloading ' + tableName + '...', 'Table ' + (idx + 1) + ' of ' + webhookTables.length, progressPct, webhookTables.length, totalFields, totalRecords, recordsSoFar.toLocaleString() + ' of ' + records.length.toLocaleString() + ' records saved');
                    }
                }

                consecutiveRecordFailures = 0; // reset on success
                console.log('[WebhookHydration] ' + tableName + ': ' + records.length + ' records');
                updateLoadingOverlay('Downloading ' + tableName + '...', 'Table ' + (idx + 1) + ' of ' + webhookTables.length, progressPct, webhookTables.length, totalFields, totalRecords, records.length.toLocaleString() + ' records \u2714');

            } catch (recErr) {
                failedTables++;
                consecutiveRecordFailures++;
                // After 2 consecutive failures, stop trying remaining tables.
                // This avoids flooding the console with CORS errors for every
                // table when the records endpoint is unreachable.
                if (consecutiveRecordFailures >= 2) {
                    console.warn('[WebhookHydration] ' + consecutiveRecordFailures + ' consecutive record fetch failures  skipping remaining tables (likely CORS). Will fall back to Synapse.');
                    SyncStatusFeed.warn('Record endpoint unreachable (CORS/network)  falling back to Synapse room replay');
                    break;
                } else {
                    console.warn('[WebhookHydration] Failed to fetch records for ' + tableName + ':', recErr);
                    SyncStatusFeed.error('Failed to fetch records for ' + tableName + ': ' + recErr.message);
                }
            }
        }

        updateLoadingOverlay('Sync complete', totalRecords.toLocaleString() + ' records downloaded', 100, webhookTables.length, totalFields, totalRecords, '');
        updateStatus('Webhook hydration complete: ' + totalRecords + ' records', true, 100, null);
        SyncStatusFeed.success('Webhook hydration complete: ' + totalRecords + ' records across ' + webhookTables.length + ' tables' + (failedTables > 0 ? ' (' + failedTables + ' tables failed)' : ''));

        SyncHistory.record({
            type: 'full',
            result: totalRecords > 0 ? 'success' : 'no-change',
            eventsFound: totalRecords,
            detail: 'Webhook hydration: ' + totalRecords + ' records from ' + webhookTables.length + ' tables' + (failedTables > 0 ? ' (' + failedTables + ' tables failed)' : '')
        });

        // Capture a Matrix sync token so SynapseSync doesn't do a full initial sync.
        // timeout=0 returns immediately with just the token.
        // timeline limit=0 means we don't download any events (we already have the data from Postgres).
        try {
            var tokenFilter = JSON.stringify({
                room: {
                    timeline: { limit: 0 },
                    state: { lazy_load_members: true }
                },
                presence: { types: [] }
            });
            var tokenRes = await fetch(
                SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/sync?timeout=0&filter=' +
                encodeURIComponent(tokenFilter),
                { headers: { 'Authorization': 'Bearer ' + session.accessToken } }
            );
            if (tokenRes.ok) {
                var tokenData = await tokenRes.json();
                if (tokenData.next_batch) {
                    SynapseSync.since = tokenData.next_batch;
                    await setSyncMeta('synapseSyncToken', tokenData.next_batch);
                    console.log('[WebhookHydration] Captured sync token:', tokenData.next_batch);
                }
            }
        } catch (e) {
            console.warn('[WebhookHydration] Failed to capture sync token (non-fatal):', e.message);
        }

        // Consider hydration successful if we got any records, even if some
        // tables failed. This prevents re-hydrating from scratch every page
        // load due to a single flaky table endpoint.
        return totalRecords > 0;
    } catch (err) {
        console.error('[WebhookHydration] Failed:', err);
        SyncStatusFeed.error('Webhook hydration failed: ' + err.message);
        return false;
    }
}

// Incremental sync from webhooks  fetch records updated since last webhook sync
async function webhookIncrementalSync() {
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) return 0;

        // Get the last webhook sync timestamp
        var lastWebhookSync = null;
        try {
            lastWebhookSync = await getSyncMeta('lastWebhookSync');
        } catch (e) {}

        if (!lastWebhookSync) {
            // No previous webhook sync  do a full hydration instead
            return 0;
        }

        var tablesData = await webhookFetch('/amino-tables');
        var tables = tablesData.tables || [];
        var totalUpdated = 0;

        var consecutiveSyncFailures = 0;
        for (var i = 0; i < tables.length; i++) {
            var tableId = tables[i].table_id;
            try {
                var data = await webhookFetch(
                    '/amino-records-since?tableId=' + encodeURIComponent(tableId) +
                    '&since=' + encodeURIComponent(lastWebhookSync)
                );
                var records = data.records || [];
                consecutiveSyncFailures = 0;
                if (records.length === 0) continue;

                var dataRecords = [];
                for (var r = 0; r < records.length; r++) {
                    var rec = records[r];
                    var fields = rec.fields;
                    if (!fields || typeof fields !== 'object') continue;
                    if (typeof fields === 'string') {
                        try { fields = JSON.parse(fields); } catch (e) { continue; }
                    }
                    dataRecords.push({
                        tableId: tableId,
                        recordId: rec.id,
                        fields: fields
                    });
                }

                if (dataRecords.length > 0) {
                    await saveBatch([], [], [], dataRecords);
                    totalUpdated += dataRecords.length;
                }
            } catch (tableErr) {
                consecutiveSyncFailures++;
                if (consecutiveSyncFailures >= 2) {
                    console.warn('[WebhookSync] ' + consecutiveSyncFailures + ' consecutive sync failures  aborting remaining tables');
                    break;
                }
                console.warn('[WebhookSync] Failed to sync table ' + tableId + ':', tableErr);
            }
        }

        // Update sync cursor
        await setSyncMeta('lastWebhookSync', new Date().toISOString());

        if (totalUpdated > 0) {
            window.dispatchEvent(new CustomEvent('amino:record-updated', {
                detail: { source: 'webhook-poll', count: totalUpdated }
            }));
        }

        return totalUpdated;
    } catch (err) {
        console.error('[WebhookSync] Incremental sync failed:', err);
        return 0;
    }
}

// ============ Room Membership ============

// Populate SynapseSync tableroom mappings from the webhook API.
// The webhook API is the canonical source for tableroom associations
// (discoverTableRooms() relies on state events that may not exist in
// bot-created rooms).
async function ensureRoomMembership() {
    var session = _loadSynapseSession();
    if (!session || !session.accessToken || !session.userId) return;

    try {
        var tablesData = await webhookFetch('/amino-tables');
        var tables = (tablesData.tables || []).filter(function(t) { return !!t.matrix_room_id; });
        if (tables.length === 0) return;

        SynapseSync.tableRooms = tables.map(function(t) {
            return { tableId: t.table_id, roomId: t.matrix_room_id, name: t.table_name || t.table_id };
        });
        SynapseSync.roomToTable = {};
        for (var k = 0; k < tables.length; k++) {
            SynapseSync.roomToTable[tables[k].matrix_room_id] = tables[k].table_id;
        }
        console.log('[RoomMembership] Populated ' + SynapseSync.tableRooms.length + ' tableroom mappings from API');
    } catch (err) {
        console.warn('[RoomMembership] ensureRoomMembership failed:', err);
    }
}

// ============ Init ============

async function init() {
    META_TABLES = {};
    META_FIELDS = {};
    META_VIEWS = {};
    TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
    currentTable = null;
    currentPage = 0;
    currentRecordIds = [];
    originalRecordIds = [];
    totalRecords = 0;
    lastEventTimestamp = null;

    // Load sidebar state (pinned, recent, expanded sections)
    loadSidebarState();
    initSidebarSearch();

    db = await openDB();

    // Capture the highest event ID at app open time for "new" event indicators
    appOpenedEventId = await getMaxEventId();

    updateStatus('Loading local data...', false, null, null);

    var tables = await getAllTables();
    var fields = await getAllFields();
    var views = await getAllViews();

    // Load metadata into memory
    tables.forEach(t => META_TABLES[t.tableId] = t);
    fields.forEach(f => {
        if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
        META_FIELDS[f.tableId][f.fieldId] = f;
    });
    views.forEach(v => {
        if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
        META_VIEWS[v.tableId][v.viewId] = v;
    });

    // Load user-specific table settings
    await loadTableSettings();

    // Load user preferences from local + Synapse account data
    try {
        await UserPreferences.load();
        // Apply stored table settings from user preferences if they exist
        var storedTableSettings = UserPreferences.get('tableSettings');
        if (storedTableSettings && storedTableSettings.tables && Object.keys(storedTableSettings.tables).length > 0) {
            if (storedTableSettings.tables) TABLE_SETTINGS.tables = Object.assign(TABLE_SETTINGS.tables, storedTableSettings.tables);
            if (storedTableSettings.tableOrder && storedTableSettings.tableOrder.length > 0) TABLE_SETTINGS.tableOrder = storedTableSettings.tableOrder;
            if (storedTableSettings.views) TABLE_SETTINGS.views = Object.assign(TABLE_SETTINGS.views, storedTableSettings.views);
        }
    } catch (e) {
        console.warn('[init] Failed to load user preferences:', e);
    }

    // Initialize shared views module
    try {
        if (MatrixClient.isLoggedIn()) {
            var orgSpaceId = await MatrixClient.findOrgSpace();
            if (orgSpaceId) {
                SharedViews.setOrgSpaceId(orgSpaceId);
            }
        }
        await SharedViews.load();
    } catch (e) {
        console.warn('[init] Failed to load shared views:', e);
    }

    hideAuthScreen();

    // Populate room mappings early so _getRoomForTable() works as soon as the
    // UI is interactive (History modal, etc.). ensureRoomMembership() fetches
    // /amino-tables, populates SynapseSync.tableRooms / roomToTable, and joins
    // any rooms the user hasn't joined yet. On subsequent loads where rooms are
    // already joined, this returns quickly after two lightweight API calls.
    await ensureRoomMembership();

    // Check if records actually exist AND previous hydration completed fully.
    // Tables may have been saved by a partial hydration (some tables got
    // records, others failed).  The lastWebhookSync cursor is only set when
    // hydration succeeds for ALL tables, so its absence means we must retry.
    var hasRecords = false;
    var hydrationWasComplete = false;
    if (tables.length > 0) {
        try {
            var recordCount = await getCurrentRecordsCount();
            hasRecords = recordCount > 0;
        } catch (e) { /* treat as no records */ }
        if (hasRecords) {
            try {
                var lastSync = await getSyncMeta('lastWebhookSync');
                hydrationWasComplete = !!lastSync;
            } catch (e) { /* treat as incomplete */ }
        }
    }

    if (tables.length > 0 && hasRecords && hydrationWasComplete) {
        // Local data exists with actual records  render it
        updateStatus('Found ' + tables.length + ' tables', false, null, 'Loading data...');
        await renderSidebar(true);

        // Auto-select first table
        var firstTable = Object.keys(META_TABLES)[0];
        if (firstTable) {
            await showTable(firstTable);
        }
    } else {
        // Missing tables, records, or previous hydration was incomplete 
        // need hydration (retry on every load until it fully succeeds so
        // transient API failures don't strand the user with partial data).
        if (tables.length > 0 && hasRecords) {
            console.log('[init] Tables and records exist but hydration was incomplete  retrying');
            SyncStatusFeed.info('Previous hydration incomplete  retrying...');
            // Render table sidebar immediately for better UX while hydrating
            await renderSidebar(true);
        } else if (tables.length > 0) {
            console.log('[init] Tables exist but no records  retrying hydration');
            SyncStatusFeed.info('Records missing  retrying hydration...');
            // Render table sidebar immediately for better UX while hydrating
            await renderSidebar(true);
        }

        showLoadingOverlay();

        // Step 1: Hydrate current record state from DB API (fast, REST)
        var hydrated = false;
        try {
            updateLoadingOverlay('Connecting to API...', 'Fetching tables...', 0, 0, 0, 0, null);
            hydrated = await hydrateFromWebhooks();
            if (hydrated) {
                // Save webhook sync cursor so future incremental syncs work
                await setSyncMeta('lastWebhookSync', new Date().toISOString());
            }
        } catch (webhookErr) {
            console.warn('[init] Webhook hydration failed, trying Synapse rooms:', webhookErr);
            SyncStatusFeed.warn('Webhook hydration failed: ' + webhookErr.message + '  trying Synapse rooms');
        }

        if (!hydrated) {
            // Fall back to Synapse room replay (gets both records + history)
            updateLoadingOverlay('Connecting to Synapse...', 'Discovering rooms...', 0, 0, 0, 0, null);
            hydrated = await hydrateFromSynapse();
        }

        if (hydrated) {
            // Reload metadata after hydration
            tables = await getAllTables();
            fields = await getAllFields();
            views = await getAllViews();
            tables.forEach(t => META_TABLES[t.tableId] = t);
            fields.forEach(f => {
                if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
                META_FIELDS[f.tableId][f.fieldId] = f;
            });
            views.forEach(v => {
                if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
                META_VIEWS[v.tableId][v.viewId] = v;
            });

            // Render UI immediately so user can start working
            await renderSidebar(true);
            var firstTable = Object.keys(META_TABLES)[0];
            if (firstTable) {
                await showTable(firstTable);
            }

            // Step 2: Backfill field history from Matrix room timelines.
            // This runs after the UI is visible so the user isn't blocked.
            try {
                updateLoadingOverlay('Backfilling history...', 'Reading Matrix room timelines...', 0, 0, 0, 0, null);
                await backfillHistoryFromMatrix();
            } catch (backfillErr) {
                console.warn('[init] History backfill failed (non-fatal):', backfillErr);
                SyncStatusFeed.warn('History backfill failed: ' + backfillErr.message);
            }
        } else {
            // No data from either source  show empty state
            updateStatus('No data available  waiting for sync', true, null, null);
            await renderSidebar(true);
        }

        hideLoadingOverlay();
    }

    updateStatus('Up to date', true, null, null);

    // Start the refresh indicator countdown
    lastSyncTime = Date.now();
    startRefreshCountdown();

    // Start Synapse real-time sync (long-poll /sync for room events)
    SynapseSync.start();

    // Poll Postgres for changes every 60 seconds via webhookIncrementalSync.
    // This catches external Airtable edits faster than waiting for SynapseSync
    // to pick up the n8n-written Matrix events (up to 30-minute n8n poll gap).
    setInterval(async function() {
        try {
            await webhookIncrementalSync();
        } catch (e) {
            console.warn('[IncrementalSync] Poll failed:', e.message);
        }
    }, 60000);

    // Drain any offline-queued edits from a previous session
    try {
        var queuedCount = await OfflineSyncQueue.getCount();
        if (queuedCount > 0 && navigator.onLine) {
            SyncStatusFeed.info('Found ' + queuedCount + ' queued edit' + (queuedCount !== 1 ? 's' : '') + ' from previous session  retrying');
            OfflineSyncQueue.drain();
        } else if (queuedCount > 0) {
            SyncStatusFeed.warn(queuedCount + ' edit' + (queuedCount !== 1 ? 's' : '') + ' queued offline  will sync when connection returns');
        }
    } catch (e) {
        console.warn('[init] Failed to check offline queue:', e);
    }
}

// ============ Field History Modal ============

var currentHistoryData = [];
var currentHistoryRecordId = null;
var currentHistoryTableId = null;

async function openHistoryModal(tableId, recordId) {
    currentHistoryTableId = tableId;
    currentHistoryRecordId = recordId;

    // Set modal title
    var tableName = META_TABLES[tableId]?.tableName || tableId;
    document.getElementById('history-modal-title').textContent = 'Field History - ' + tableName;

    // Show modal with loading state
    var overlay = document.getElementById('history-modal-overlay');
    var body = document.getElementById('history-modal-body');
    body.innerHTML = '<div class="modal-empty"><div class="loading-spinner"></div><h3>Loading history...</h3></div>';
    overlay.classList.add('open');

    // Fetch history data
    try {
        // First fetch any new events from API for this specific record (incremental)
        await fetchAndProcessHistoryForRecord(tableId, recordId);

        // Then get all history from IndexedDB (includes newly fetched entries)
        currentHistoryData = await getFieldHistoryForRecord(tableId, recordId);
        renderHistoryModal();
    } catch (err) {
        console.error('Error loading history:', err);
        body.innerHTML = '<div class="modal-empty"><h3>Error loading history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closeHistoryModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('history-modal-overlay').classList.remove('open');
    currentHistoryData = [];
    currentHistoryRecordId = null;
    currentHistoryTableId = null;
}

function renderHistoryModal() {
    var body = document.getElementById('history-modal-body');
    var filterSelect = document.getElementById('history-field-filter');
    var countEl = document.getElementById('history-count');

    if (!currentHistoryData || currentHistoryData.length === 0) {
        body.innerHTML = '<div class="modal-empty"><h3>No history available</h3><p>Field changes will appear here after the next sync</p></div>';
        filterSelect.innerHTML = '<option value="">All Fields</option>';
        countEl.textContent = '0 changes';
        return;
    }

    // Build field filter options
    var fieldIds = [...new Set(currentHistoryData.map(h => h.fieldId))];
    var fields = META_FIELDS[currentHistoryTableId] || {};

    var filterHtml = '<option value="">All Fields</option>';
    fieldIds.forEach(fid => {
        var fieldName = fields[fid]?.fieldName || fid;
        filterHtml += '<option value="' + esc(fid) + '">' + esc(fieldName) + '</option>';
    });
    filterSelect.innerHTML = filterHtml;

    // Get selected filter
    var selectedField = filterSelect.value;
    var filteredData = selectedField
        ? currentHistoryData.filter(h => h.fieldId === selectedField)
        : currentHistoryData;

    countEl.textContent = filteredData.length + ' change' + (filteredData.length !== 1 ? 's' : '');

    // Render history items
    var html = '<div class="history-timeline">';

    for (var item of filteredData) {
        var fieldName = fields[item.fieldId]?.fieldName || item.fieldId;
        var changeTypeClass = item.changeType || 'updated';
        var timestamp = item.timestamp ? formatTimestamp(item.timestamp) : 'Unknown time';
        var histActor = item.actor || null;
        var histSource = item.source || null;

        html += '<div class="history-item">';
        html += '<div class="history-item-header">';
        html += '<span class="history-field-name">' + esc(fieldName) + '</span>';
        html += '<span class="history-change-type ' + changeTypeClass + '">' + changeTypeClass + '</span>';
        if (histActor) {
            html += '<span class="history-actor">' + esc(histActor) + '</span>';
        }
        if (histSource) {
            html += '<span class="history-source">' + esc(histSource.replace(/_/g, ' ')) + '</span>';
        }
        html += '<span class="history-timestamp">' + esc(timestamp) + '</span>';
        html += '<span class="history-event-id">Event #' + (item.eventId || '?') + '</span>';
        html += '</div>';

        html += '<div class="history-values">';

        // Old value
        if (item.changeType !== 'created') {
            html += '<div class="history-value-box ' + (item.oldValue === null ? 'null' : 'old') + '">';
            html += '<div class="history-value-label">Previous</div>';
            html += '<div class="history-value-content">' + formatHistoryValue(item.oldValue) + '</div>';
            html += '</div>';
            html += '<span class="history-arrow">&#8594;</span>';
        }

        // New value
        html += '<div class="history-value-box ' + (item.newValue === null ? 'null' : 'new') + '">';
        html += '<div class="history-value-label">' + (item.changeType === 'created' ? 'Initial Value' : 'New Value') + '</div>';
        html += '<div class="history-value-content">' + formatHistoryValue(item.newValue) + '</div>';
        html += '</div>';

        html += '</div>'; // .history-values

        // Revert button
        var revertValue = JSON.stringify(item.newValue);
        html += '<div class="history-item-actions">';
        html += '<button class="history-revert-btn" onclick="this.disabled=true;this.textContent=\'Reverting...\';revertFieldToHistoryState(';
        html += '\'' + esc(item.tableId) + '\',';
        html += '\'' + esc(item.recordId) + '\',';
        html += '\'' + esc(item.fieldId) + '\',';
        html += 'JSON.parse(decodeURIComponent(\'' + encodeURIComponent(revertValue) + '\'))';
        html += ')" title="Revert this field to this value">';
        html += '<svg viewBox="0 0 16 16" fill="none"><path d="M2 8a6 6 0 1 1 1.76 4.24" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M2 12V8h4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        html += 'Revert to this state';
        html += '</button>';
        html += '</div>';

        html += '</div>'; // .history-item
    }

    html += '</div>';
    body.innerHTML = html;
}

function filterHistoryByField() {
    renderHistoryModal();
}

async function revertFieldToHistoryState(tableId, recordId, fieldId, targetValue) {
    // Resolve the field key used in the record (fieldId or fieldName)
    var field = META_FIELDS[tableId]?.[fieldId];
    var fieldKey = fieldId;
    var recordData = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId])
        ? window.IN_MEMORY_DATA[tableId][recordId]
        : null;
    if (!recordData) {
        var rec = await getRecord(tableId, recordId);
        recordData = rec ? rec.fields : null;
    }
    if (recordData && recordData[fieldId] === undefined && field?.fieldName && recordData[field.fieldName] !== undefined) {
        fieldKey = field.fieldName;
    }

    // Get the current value before reverting (for history tracking)
    var currentValue = recordData ? (recordData[fieldKey] !== undefined ? recordData[fieldKey] : null) : null;

    // Build field changes
    var revertChanges = {};
    revertChanges[fieldKey] = targetValue !== undefined ? targetValue : null;

    // Save field history locally (optimistic)
    await saveFieldHistory([{
        tableId: tableId,
        recordId: recordId,
        fieldId: fieldId,
        eventId: null,
        timestamp: Date.now(),
        changeType: 'updated',
        oldValue: currentValue,
        newValue: targetValue !== undefined ? targetValue : null
    }]);

    try {
        await editRecord(tableId, recordId, revertChanges);

        // Refresh the history modal to show the new change
        currentHistoryData = await getFieldHistoryForRecord(tableId, recordId);
        renderHistoryModal();
    } catch (err) {
        console.error('[Revert] Failed to revert field:', err);
        // editRecord already handles rollback and error toast
    }
}

function formatTimestamp(ts) {
    if (!ts) return 'Unknown';
    var date = new Date(ts);
    var now = new Date();
    var diff = now - date;

    // If less than 24 hours, show relative time
    if (diff < 86400000) {
        if (diff < 60000) return 'Just now';
        if (diff < 3600000) return Math.floor(diff / 60000) + ' min ago';
        return Math.floor(diff / 3600000) + ' hour' + (Math.floor(diff / 3600000) !== 1 ? 's' : '') + ' ago';
    }

    // Otherwise show date and time
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatHistoryValue(value) {
    if (value === null || value === undefined) {
        return '<span style="color: #999; font-style: italic;">empty</span>';
    }

    if (Array.isArray(value)) {
        if (value.length === 0) return '<span style="color: #999; font-style: italic;">empty array</span>';

        // Check if it's an array of objects
        if (typeof value[0] === 'object' && value[0] !== null) {
            var items = value.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return items.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(i) + '</span>').join('');
        }

        return value.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(String(i)) + '</span>').join('');
    }

    if (typeof value === 'object') {
        if (value.name) return esc(value.name);
        if (value.filename) return esc(value.filename);
        if (value.email) return esc(value.email);
        return esc(JSON.stringify(value).slice(0, 100));
    }

    if (typeof value === 'boolean') {
        return '<span style="padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; ' +
            (value ? 'background: #d4edda; color: #155724;' : 'background: #f8d7da; color: #721c24;') + '">' +
            (value ? 'Yes' : 'No') + '</span>';
    }

    if (typeof value === 'number') {
        return '<span style="font-family: monospace;">' + value.toLocaleString() + '</span>';
    }

    return esc(String(value));
}

// Keyboard handler for modal
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        var overlay = document.getElementById('history-modal-overlay');
        if (overlay && overlay.classList.contains('open')) {
            closeHistoryModal();
        }
        // Also close PIT modal
        var pitOverlay = document.getElementById('pit-modal-overlay');
        if (pitOverlay && pitOverlay.classList.contains('open')) {
            closePitModal();
        }
        // Also close view selector and fields dropdown
        closeAllDropdowns();
    }
});

// ============ Events View ============

async function showEventsView() {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Open tab for events
    openTableInTab('_events', 'Events Stream', '\u26A1');

    // Clean up sync status listener
    if (syncStatusUnsubscribe) { syncStatusUnsubscribe(); syncStatusUnsubscribe = null; }

    currentTable = '_events';
    currentView = null;

    // Update sidebar selection
    document.querySelectorAll('.sidebar .table-item').forEach(el => el.classList.remove('active', 'expanded'));
    document.querySelectorAll('.sidebar .table-view-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.sidebar .table-item.events-item')?.classList.add('active');

    // Hide view controls and show events view
    document.getElementById('view-controls-bar').style.display = 'none';
    document.getElementById('title').textContent = 'Events Stream';
    document.getElementById('pagination').style.display = 'none';

    // Hide toolbar views section for events view
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = 'none';

    await renderEventsView();
    // Navigation guard check after async work (renderEventsView handles its own loading state)
}

async function renderEventsView() {
    var container = document.querySelector('.table-container');

    if (eventsActiveTab !== 'room-access') stopRoomAccessRefresh();

    // Clean up previous scroll handlers
    if (eventsScrollHandler) {
        container.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }
    if (changelogScrollHandler) {
        container.removeEventListener('scroll', changelogScrollHandler);
        changelogScrollHandler = null;
    }

    // Build tab bar + content shell
    var tabBarHtml = '<div class="events-tab-bar">';
    tabBarHtml += '<div class="events-tab' + (eventsActiveTab === 'events' ? ' active' : '') + '" onclick="switchEventsTab(\'events\')">Events</div>';
    tabBarHtml += '<div class="events-tab' + (eventsActiveTab === 'changelog' ? ' active' : '') + '" onclick="switchEventsTab(\'changelog\')">Changelog</div>';
    tabBarHtml += '<div class="events-tab' + (eventsActiveTab === 'room-access' ? ' active' : '') + '" onclick="switchEventsTab(\'room-access\')">Room Access</div>';
    tabBarHtml += '</div>';
    tabBarHtml += '<div id="events-tab-content" style="flex:1; overflow-y: auto; display: flex; flex-direction: column;"></div>';
    container.innerHTML = tabBarHtml;

    // Render the active tab's content
    if (eventsActiveTab === 'changelog') {
        await renderChangelogContent();
    } else if (eventsActiveTab === 'room-access') {
        await renderRoomAccessContent();
    } else {
        await renderEventsContent();
    }
}

function switchEventsTab(tab) {
    if (eventsActiveTab === tab) return;
    eventsActiveTab = tab;
    renderEventsView();
}

function stopRoomAccessRefresh() {
    if (roomAccessRefreshTimer) {
        clearTimeout(roomAccessRefreshTimer);
        roomAccessRefreshTimer = null;
    }
}

function scheduleRoomAccessRefresh() {
    stopRoomAccessRefresh();
    roomAccessRefreshTimer = setTimeout(async function() {
        if (eventsActiveTab !== 'room-access') return;
        await refreshRoomAccessSnapshot({ preserveSelection: true });
        scheduleRoomAccessRefresh();
    }, ROOM_ACCESS_REFRESH_MS);
}

function getRoomAccessTableMap() {
    if (typeof SynapseSync !== 'undefined' && SynapseSync && typeof SynapseSync.getRoomTableMap === 'function') {
        return SynapseSync.getRoomTableMap() || {};
    }
    if (typeof _getRoomTableMap === 'function') {
        return _getRoomTableMap() || {};
    }
    return {};
}

async function refreshRoomAccessSnapshot(opts) {
    opts = opts || {};
    if (roomAccessRefreshInFlight) return;
    roomAccessRefreshInFlight = true;
    try {
        var roomIds = MatrixClient.getJoinedRooms();
        var roomTableMap = getRoomAccessTableMap();
        var nextSnapshot = [];

        for (var i = 0; i < roomIds.length; i++) {
            var roomId = roomIds[i];
            var state = MatrixClient.getRoomStateFromCache(roomId) || {};
            var stateValues = Object.values(state);
            var tableId = roomTableMap[roomId] || null;
            var tableName = tableId && META_TABLES[tableId] ? (META_TABLES[tableId].tableName || tableId) : null;

            var latestEvents = [];
            try {
                var msgRes = await MatrixClient.getRoomMessages(roomId, { dir: 'b', limit: 5 });
                latestEvents = (msgRes && msgRes.chunk) ? msgRes.chunk : [];
            } catch (err) {
                latestEvents = [{ type: 'error', content: { message: err.message || 'Unable to fetch room timeline' } }];
            }

            nextSnapshot.push({
                roomId: roomId,
                roomName: MatrixClient.getRoomName(roomId) || roomId,
                tableId: tableId,
                tableName: tableName,
                isSpace: MatrixClient.isSpace(roomId),
                stateCount: stateValues.length,
                timelinePreview: latestEvents
            });
        }

        nextSnapshot.sort(function(a, b) {
            return (a.roomName || '').localeCompare(b.roomName || '');
        });
        roomAccessSnapshot = nextSnapshot;

        if (eventsActiveTab === 'room-access') {
            renderRoomAccessSnapshot(opts.preserveSelection);
        }
    } finally {
        roomAccessRefreshInFlight = false;
    }
}

function renderRoomTimelinePreview(ev) {
    if (!ev) return '<div class="room-access-preview-item">(empty)</div>';
    var type = ev.type || 'unknown';
    var sender = ev.sender || 'unknown';
    var ts = ev.origin_server_ts ? formatTimestamp(ev.origin_server_ts) : 'unknown time';
    var summary = '';

    if (type === 'law.firm.schema.object' && ev.content) {
        var c = ev.content;
        summary = (c.tableId || '?') + '  ' + (c.recordId || '?') + '  ' + (c.op || 'ALT');
    } else if (type === 'm.room.message' && ev.content) {
        summary = (ev.content.body || '').slice(0, 120);
    } else if (type === 'error' && ev.content) {
        summary = ev.content.message || 'error';
    } else {
        summary = JSON.stringify(ev.content || {}).slice(0, 140);
    }

    return '<div class="room-access-preview-item"><strong>' + esc(type) + '</strong>  ' + esc(sender) + '<br><span style="color:var(--text-muted)">' + esc(ts) + '</span><br>' + esc(summary) + '</div>';
}

function renderRoomAccessSnapshot(preserveSelection) {
    var container = document.getElementById('events-tab-content');
    if (!container) return;

    var connected = MatrixClient.isLoggedIn();
    var html = '<div class="room-access-layout">';
    html += '<div class="room-access-header">';
    html += '<div><h3 style="margin:0; font-size:16px;">Matrix Rooms + Live Data</h3><div class="room-access-meta">Auto-refreshes every ' + Math.round(ROOM_ACCESS_REFRESH_MS / 1000) + 's while this tab is active.</div></div>';
    html += '<div class="events-actions">';
    html += '<button class="btn" onclick="refreshRoomAccessSnapshot()">Refresh now</button>';
    html += '</div></div>';

    if (!connected) {
        html += '<div class="changelog-empty"><h3>Not connected</h3><p>Sign in with Synapse to inspect rooms and incoming timeline data.</p></div>';
        html += '</div>';
        container.innerHTML = html;
        return;
    }

    html += '<div class="room-access-meta">Showing ' + roomAccessSnapshot.length.toLocaleString() + ' accessible room' + (roomAccessSnapshot.length === 1 ? '' : 's') + '.</div>';
    html += '<div class="room-access-grid">';

    for (var i = 0; i < roomAccessSnapshot.length; i++) {
        var room = roomAccessSnapshot[i];
        html += '<div class="room-access-card">';
        html += '<div class="room-access-title"><div><div class="room-access-name">' + esc(room.roomName) + '</div><div class="room-access-id">' + esc(room.roomId) + '</div></div>';
        html += '<div class="room-access-badges">';
        if (room.isSpace) html += '<span class="room-access-badge space">Space</span>';
        if (room.tableId) html += '<span class="room-access-badge table">Table</span>';
        html += '<span class="room-access-badge timeline">Live</span>';
        html += '</div></div>';

        html += '<div class="room-access-summary">';
        html += '<div class="label">Table</div><div class="value">' + esc(room.tableName || room.tableId || '') + '</div>';
        html += '<div class="label">State events</div><div class="value">' + room.stateCount.toLocaleString() + '</div>';
        html += '</div>';

        html += '<div class="room-access-preview"><h4>Recent timeline events</h4>';
        if (!room.timelinePreview || room.timelinePreview.length === 0) {
            html += '<div class="room-access-preview-item">No recent timeline events.</div>';
        } else {
            for (var t = 0; t < room.timelinePreview.length; t++) {
                html += renderRoomTimelinePreview(room.timelinePreview[t]);
            }
        }
        html += '</div>';
        html += '</div>';
    }

    html += '</div></div>';
    container.innerHTML = html;
}

async function renderRoomAccessContent() {
    var container = document.getElementById('events-tab-content');
    if (!container) return;

    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading accessible rooms...</h3></div>';
    stopRoomAccessRefresh();
    await refreshRoomAccessSnapshot();
    scheduleRoomAccessRefresh();
}

async function renderEventsContent() {
    var container = document.getElementById('events-tab-content');
    if (!container) return;
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading events...</h3></div>';

    // Reset infinite scroll state
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;

    try {
        var totalEventsCount = await getRawEventsCount();
        var totalRecordsCount = await getCurrentRecordsCount();

        // Load initial batch of events
        var events = await fetchEventsForInfiniteScroll(eventsOffset, eventsPageSize);
        loadedEvents = events;
        eventsOffset = events.length;
        hasMoreEvents = events.length === eventsPageSize;

        // Count new events (events with ID > appOpenedEventId)
        var newEventsCount = events.filter(e => e.id > appOpenedEventId).length;

        var html = '';

        // Events controls bar
        html += '<div class="events-controls">';
        html += '<div class="events-filter-group">';
        html += '<label>Type:</label>';
        html += '<select onchange="setEventsTypeFilter(this.value)">';
        html += '<option value=""' + (!eventsTypeFilter ? ' selected' : '') + '>All Events</option>';
        html += '<option value="current"' + (eventsTypeFilter === 'current' ? ' selected' : '') + '>All Records (' + ENTITY_TYPE_NAMES['current'] + ')</option>';
        ['INS', 'ALT', 'NUL', 'SYN', 'table', 'field', 'view', 'viewConfig'].forEach(function(t) {
            html += '<option value="' + t + '"' + (eventsTypeFilter === t ? ' selected' : '') + '>' + ENTITY_TYPE_NAMES[t] + '</option>';
        });
        html += '</select>';
        html += '</div>';

        html += '<div class="events-filter-group">';
        html += '<label>Table:</label>';
        html += '<select onchange="setEventsSetFilter(this.value)">';
        html += '<option value="">All Tables</option>';
        for (var tid in META_TABLES) {
            var tableName = META_TABLES[tid].tableName || tid;
            var setVal = 'airtable:' + tid;
            html += '<option value="' + esc(setVal) + '"' + (eventsSetFilter === setVal ? ' selected' : '') + '>' + esc(tableName) + '</option>';
        }
        html += '</select>';
        html += '</div>';

        html += '<div class="events-filter-group">';
        html += '<label>Search:</label>';
        html += '<input type="text" placeholder="Search events..." value="' + esc(eventsSearchQuery) + '" onkeydown="if(event.key===\'Enter\')setEventsSearch(this.value)">';
        html += '</div>';

        // Show loaded count and total
        html += '<div class="events-stats" id="events-stats">';
        if (eventsTypeFilter === 'current') {
            html += 'Loaded ' + loadedEvents.length.toLocaleString();
            html += ' <span style="color: #666;">(' + totalRecordsCount.toLocaleString() + ' total records)</span>';
        } else {
            html += 'Loaded ' + loadedEvents.length.toLocaleString();
            html += ' <span style="color: #666;">(' + totalEventsCount.toLocaleString() + ' total events)</span>';
            if (newEventsCount > 0) {
                html += ' <span class="new-event-badge">' + newEventsCount + ' new</span>';
            }
        }
        html += '</div>';

        // Import/Export buttons
        html += '<div class="events-actions">';
        html += '<button class="btn" onclick="exportEventsToCSV()" title="Export events to CSV">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>';
        html += ' Export CSV';
        html += '</button>';
        html += '<button class="btn" onclick="exportEventsToAmo()" title="Export all events as .amo snapshot file">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>';
        html += ' Export .amo';
        html += '</button>';
        html += '<button class="btn" onclick="importEventsFromCSV()" title="Import events from CSV (deduplicates by ID)">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>';
        html += ' Import CSV';
        html += '</button>';
        html += '</div>';

        html += '</div>';

        // Events table
        html += '<table class="events-table">';
        html += '<thead><tr>';
        html += '<th style="width: 80px;">ID</th>';
        html += '<th style="width: 140px;">Timestamp</th>';
        html += '<th style="width: 90px;">Type</th>';
        html += '<th style="width: 140px;">Set</th>';
        html += '<th style="width: 130px;">Record ID</th>';
        html += '<th style="width: 140px;">Details</th>';
        html += '<th>Payload</th>';
        html += '<th style="width: 120px;">Actions</th>';
        html += '</tr></thead>';
        html += '<tbody id="events-tbody">';

        if (events.length === 0) {
            html += '<tr><td colspan="8" style="text-align: center; padding: 40px; color: #666;">No events found</td></tr>';
        } else {
            html += renderEventRows(events, newEventsCount);
        }

        html += '</tbody></table>';

        // Infinite scroll loading indicator
        html += '<div id="events-load-more" class="events-load-more" style="display: ' + (hasMoreEvents ? 'flex' : 'none') + ';">';
        html += '<div class="loading-spinner-small"></div>';
        html += '<span>Loading more events...</span>';
        html += '</div>';

        // End of events message
        html += '<div id="events-end-message" class="events-end-message" style="display: ' + (hasMoreEvents ? 'none' : 'block') + ';">';
        html += 'All events loaded';
        html += '</div>';

        container.innerHTML = html;

        // Set up infinite scroll on the actual scrolling parent (.table-container)
        var scrollParent = document.querySelector('.table-container');
        setupEventsInfiniteScroll(scrollParent, totalEventsCount, totalRecordsCount);

    } catch (err) {
        console.error('Error loading events:', err);
        container.innerHTML = '<div class="empty-state"><h3>Error loading events</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Helper function to fetch events based on current filters
async function fetchEventsForInfiniteScroll(offset, limit) {
    var events = [];

    if (eventsTypeFilter === 'current') {
        events = await getCurrentRecordsPaginated(offset, limit, eventsSetFilter, eventsSearchQuery);
    } else {
        if (eventsSearchQuery) {
            events = await searchRawEvents(eventsSearchQuery, limit, offset);
        } else if (eventsSetFilter) {
            events = await getRawEventsBySetPaginated(eventsSetFilter, offset, limit);
        } else {
            events = await getRawEventsPaginated(offset, limit);
        }

        // Apply type filter if set (post-filter since we need to parse payload)
        if (eventsTypeFilter) {
            events = events.filter(e => {
                var payload = parsePayload(e.payload);
                var baseType = payload?._set || 'data';
                // For data events, resolve to operator type (INS/ALT/NUL)
                var type = baseType;
                if (baseType === 'data') {
                    if (e.operator) {
                        type = e.operator;
                    } else if (payload && payload.fields) {
                        if (payload.fields.INS) type = 'INS';
                        else if (payload.fields.ALT) type = 'ALT';
                        else if (payload.fields.NUL) type = 'NUL';
                        else if (payload.fields.SYN) type = 'SYN';
                    }
                }
                return type === eventsTypeFilter;
            });
        }
    }

    return events;
}

// Render multiple event rows and track new events divider
function renderEventRows(events, newEventsCount) {
    var html = '';
    var addedDivider = loadedEvents.length > events.length; // Divider already added if we've loaded more than initial batch

    for (var i = 0; i < events.length; i++) {
        var event = events[i];
        var isNew = event.id > appOpenedEventId;

        // Add divider between new and old events (only once)
        if (!addedDivider && !isNew && newEventsCount > 0) {
            html += '<tr class="new-events-divider"><td colspan="7"><span class="new-events-divider-text">Events when app opened</span></td></tr>';
            addedDivider = true;
        }

        html += renderEventRow(event, isNew);
    }

    return html;
}

// Set up infinite scroll for events
function setupEventsInfiniteScroll(container, totalEventsCount, totalRecordsCount) {
    eventsScrollHandler = function() {
        // Check if we're near the bottom (within 200px)
        var scrollTop = container.scrollTop;
        var scrollHeight = container.scrollHeight;
        var clientHeight = container.clientHeight;

        if (scrollHeight - scrollTop - clientHeight < 200) {
            loadMoreEvents(totalEventsCount, totalRecordsCount);
        }
    };

    container.addEventListener('scroll', eventsScrollHandler);
}

// Load more events for infinite scroll
async function loadMoreEvents(totalEventsCount, totalRecordsCount) {
    if (isLoadingMoreEvents || !hasMoreEvents) return;

    isLoadingMoreEvents = true;
    var loadMoreDiv = document.getElementById('events-load-more');
    if (loadMoreDiv) loadMoreDiv.style.display = 'flex';

    try {
        var newEvents = await fetchEventsForInfiniteScroll(eventsOffset, eventsPageSize);

        if (newEvents.length === 0) {
            hasMoreEvents = false;
        } else {
            // Add new events to loaded array, capping total to prevent memory bloat
            for (var le = 0; le < newEvents.length; le++) loadedEvents.push(newEvents[le]);
            if (loadedEvents.length > MAX_LOADED_EVENTS) {
                loadedEvents = loadedEvents.slice(loadedEvents.length - MAX_LOADED_EVENTS);
            }
            eventsOffset += newEvents.length;
            hasMoreEvents = newEvents.length === eventsPageSize;

            // Count new events in this batch
            var newEventsCount = newEvents.filter(e => e.id > appOpenedEventId).length;

            // Append rows to tbody
            var tbody = document.getElementById('events-tbody');
            if (tbody) {
                var rowsHtml = renderEventRows(newEvents, newEventsCount);
                tbody.insertAdjacentHTML('beforeend', rowsHtml);
            }

            // Update stats
            updateEventsStats(totalEventsCount, totalRecordsCount);
        }
    } catch (err) {
        console.error('Error loading more events:', err);
    } finally {
        isLoadingMoreEvents = false;

        // Update loading indicator visibility
        var loadMoreDiv = document.getElementById('events-load-more');
        var endMessage = document.getElementById('events-end-message');

        if (loadMoreDiv) loadMoreDiv.style.display = hasMoreEvents ? 'none' : 'none';
        if (endMessage) endMessage.style.display = hasMoreEvents ? 'none' : 'block';
    }
}

// Update the events stats display
function updateEventsStats(totalEventsCount, totalRecordsCount) {
    var statsDiv = document.getElementById('events-stats');
    if (!statsDiv) return;

    var newEventsCount = loadedEvents.filter(e => e.id > appOpenedEventId).length;

    var html = '';
    if (eventsTypeFilter === 'current') {
        html += 'Loaded ' + loadedEvents.length.toLocaleString();
        html += ' <span style="color: #666;">(' + totalRecordsCount.toLocaleString() + ' total records)</span>';
    } else {
        html += 'Loaded ' + loadedEvents.length.toLocaleString();
        html += ' <span style="color: #666;">(' + totalEventsCount.toLocaleString() + ' total events)</span>';
        if (newEventsCount > 0) {
            html += ' <span class="new-event-badge">' + newEventsCount + ' new</span>';
        }
    }

    statsDiv.innerHTML = html;
}

function renderEventRow(event, isNew) {
    var payload = parsePayload(event.payload);
    var baseType = payload?._set || 'data';
    // For data events, show the operator (INS/ALT/NUL) instead of generic "data"
    var eventType = baseType;
    if (baseType === 'data') {
        if (event.operator) {
            eventType = event.operator;
        } else if (payload && payload.fields) {
            // Infer from payload fields
            if (payload.fields.INS) eventType = 'INS';
            else if (payload.fields.ALT) eventType = 'ALT';
            else if (payload.fields.NUL) eventType = 'NUL';
            else if (payload.fields.SYN) eventType = 'SYN';
        }
    }
    var isCurrentState = event._isCurrentState || eventType === 'current';
    var timestamp = event.created_at ? formatTimestamp(new Date(event.created_at).getTime()) : (isCurrentState ? 'Current' : 'Unknown');
    var isExpanded = expandedPayloads.has(event.id || event.recordId);

    var rowClass = isNew ? 'new-event' : (isCurrentState ? 'current-state-row' : '');
    var html = '<tr data-event-id="' + (event.id || event.recordId) + '"' + (rowClass ? ' class="' + rowClass + '"' : '') + '>';

    // ID column - show "" for current state
    if (isCurrentState) {
        html += '<td><span class="event-id current-state"></span></td>';
    } else {
        html += '<td><span class="event-id">' + event.id + (isNew ? '<span class="new-event-badge">NEW</span>' : '') + '</span></td>';
    }

    html += '<td><span class="event-timestamp">' + esc(timestamp) + '</span></td>';
    html += '<td><span class="event-type-badge ' + eventType + '">' + esc(ENTITY_TYPE_NAMES[eventType] || eventType) + '</span></td>';
    var setTableId = (event.set || '').replace('airtable:', '');
    var setDisplayName = (META_TABLES[setTableId] && META_TABLES[setTableId].tableName) || event.set || '';
    html += '<td><span class="event-set" title="' + esc(event.set || '') + '">' + esc(setDisplayName) + '</span></td>';
    html += '<td><span class="event-record-id">' + esc(event.recordId || '') + '</span></td>';

    // Details column - show field operation types and counts
    html += '<td class="event-details">';
    var fieldOps = getFieldOperationDetails(payload);
    if (fieldOps) {
        fieldOps.forEach(function(op) {
            html += '<span class="field-op-badge ' + op.type + '">' + op.type + ' <span class="field-count">' + op.label + '</span></span>';
        });
    } else if (eventType !== 'data') {
        html += '<span style="color: #9ca3af; font-size: 11px;"></span>';
    } else {
        html += '<span style="color: #9ca3af; font-size: 11px;"></span>';
    }
    html += '</td>';

    // Payload preview
    html += '<td class="payload-preview-container">';
    html += '<div class="payload-preview' + (isExpanded ? ' expanded' : '') + '" onclick="togglePayloadExpand(\'' + (event.id || event.recordId) + '\')">';
    html += formatPayloadPreview(payload, isExpanded);
    if (!isExpanded) {
        html += '<span class="payload-expand-btn">Expand</span>';
    } else {
        html += '<span class="payload-expand-btn">Collapse</span>';
    }
    html += '</div>';
    html += '</td>';

    // Actions
    html += '<td class="event-actions">';
    if (event.recordId && event.recordId.startsWith('rec')) {
        if (isCurrentState) {
            // For current state, show "View Record" button that opens profile
            var tableId = (event.set || '').replace('airtable:', '');
            html += '<button class="event-action-btn primary" onclick="openRecordProfile(\'' + esc(tableId) + '\', \'' + esc(event.recordId) + '\')" title="View full record details">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';
            html += 'View Record';
            html += '</button>';
        } else {
            html += '<button class="event-action-btn primary" onclick="viewRecordAtPointInTime(' + event.id + ', \'' + esc(event.recordId) + '\', \'' + esc(event.set || '') + '\')" title="View record state at this point in time">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M8 3v5l3 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="1.5"/></svg>';
            html += 'View State';
            html += '</button>';
        }
    }
    html += '</td>';

    html += '</tr>';
    return html;
}

function getFieldOperationDetails(payload) {
    if (!payload || !payload.fields) return null;

    var fields = payload.fields;
    var details = [];

    if (fields.INS && typeof fields.INS === 'object') {
        var count = Object.keys(fields.INS).length;
        details.push({ type: 'INS', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    if (fields.ALT && typeof fields.ALT === 'object') {
        var count = Object.keys(fields.ALT).length;
        details.push({ type: 'ALT', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    if (fields.NUL && Array.isArray(fields.NUL)) {
        var count = fields.NUL.length;
        if (count > 0) {
            details.push({ type: 'NUL', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
        }
    }

    if (fields.SYN && typeof fields.SYN === 'object') {
        var count = Object.keys(fields.SYN).length;
        details.push({ type: 'SYN', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    return details.length > 0 ? details : null;
}

function formatPayloadPreview(payload, expanded) {
    if (!payload) return '<span class="json-null">null</span>';

    // Try to extract INS/ALT/NUL field data for nice display
    var fields = payload.fields;
    var hasFieldData = fields && (fields.INS || fields.ALT || fields.NUL || fields.SYN);

    if (hasFieldData) {
        return formatPayloadFields(fields, expanded);
    }

    // Check if payload has context.data (alternative structure)
    if (payload.context && payload.context.data) {
        return formatPayloadFields({ INS: payload.context.data }, expanded);
    }

    // Fallback to raw JSON display
    try {
        var str = typeof payload === 'string' ? payload : JSON.stringify(payload, null, expanded ? 2 : 0);

        // Apply syntax highlighting
        str = esc(str)
            .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span>:')
            .replace(/: "([^"]*)"([,\n\}])/g, ': <span class="json-string">"$1"</span>$2')
            .replace(/: (-?\d+\.?\d*)([,\n\}])/g, ': <span class="json-number">$1</span>$2')
            .replace(/: (true|false)([,\n\}])/g, ': <span class="json-boolean">$1</span>$2')
            .replace(/: (null)([,\n\}])/g, ': <span class="json-null">$1</span>$2');

        return str;
    } catch (e) {
        return esc(String(payload));
    }
}

function formatPayloadFields(fields, expanded) {
    var html = '<div class="payload-fields">';
    var ops = ['INS', 'ALT', 'NUL'];
    var hasAnyFields = false;

    for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        var data = fields[op];
        if (!data) continue;

        // NUL is an array of field names, INS/ALT are objects
        if (op === 'NUL' && Array.isArray(data) && data.length > 0) {
            hasAnyFields = true;
            html += '<div class="payload-op-group">';
            html += '<span class="payload-op-label ' + op + '">' + op + '</span>';
            html += '<div class="payload-field-row">';
            html += '<span class="payload-field-value null">' + esc(data.join(', ')) + '</span>';
            html += '</div></div>';
        } else if (typeof data === 'object' && !Array.isArray(data)) {
            var keys = Object.keys(data);
            if (keys.length === 0) continue;

            hasAnyFields = true;
            html += '<div class="payload-op-group">';
            html += '<span class="payload-op-label ' + op + '">' + op + '</span>';

            // In collapsed mode, show limited fields
            var displayKeys = expanded ? keys : keys.slice(0, 3);

            for (var j = 0; j < displayKeys.length; j++) {
                var key = displayKeys[j];
                var value = data[key];
                html += '<div class="payload-field-row">';
                html += '<span class="payload-field-name">' + esc(getFieldDisplayName(key)) + '</span>';
                html += '<span class="payload-field-value ' + getValueClass(value) + '">' + formatFieldValue(value, expanded) + '</span>';
                html += '</div>';
            }

            if (!expanded && keys.length > 3) {
                html += '<div class="payload-field-row" style="color: #9ca3af; font-style: italic;">+' + (keys.length - 3) + ' more fields</div>';
            }

            html += '</div>';
        }
    }

    html += '</div>';
    return hasAnyFields ? html : '<span class="json-null">no field data</span>';
}

function getFieldDisplayName(fieldId) {
    // Try to get human-readable field name from schema
    if (window.fields && window.fields[fieldId]) {
        return window.fields[fieldId].name || fieldId;
    }
    // Truncate long field IDs
    if (fieldId.length > 20) {
        return fieldId.substring(0, 17) + '...';
    }
    return fieldId;
}

function getValueClass(value) {
    if (value === null || value === undefined) return 'null';
    if (Array.isArray(value)) return 'array';
    if (typeof value === 'object') return 'object';
    if (typeof value === 'number') return 'number';
    if (typeof value === 'boolean') return 'boolean';
    return 'string';
}

function formatFieldValue(value, expanded) {
    if (value === null || value === undefined) return 'null';

    if (Array.isArray(value)) {
        if (value.length === 0) return '[]';
        if (!expanded && value.length > 2) {
            return '[' + esc(String(value[0])) + ', ... +' + (value.length - 1) + ']';
        }
        return '[' + value.map(function(v) { return esc(String(v)); }).join(', ') + ']';
    }

    if (typeof value === 'object') {
        var keys = Object.keys(value);
        if (keys.length === 0) return '{}';
        if (!expanded) return '{' + keys.length + ' keys}';
        return esc(JSON.stringify(value));
    }

    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'number') return String(value);

    // String value - truncate if too long
    var str = String(value);
    if (!expanded && str.length > 50) {
        return esc(str.substring(0, 47)) + '...';
    }
    return esc(str);
}

function togglePayloadExpand(eventId) {
    if (expandedPayloads.has(eventId)) {
        expandedPayloads.delete(eventId);
    } else {
        expandedPayloads.add(eventId);
    }

    // Find the row and update just the payload cell instead of re-rendering everything
    var row = document.querySelector('tr[data-event-id="' + eventId + '"]');
    if (row) {
        var event = loadedEvents.find(e => (e.id || e.recordId) == eventId);
        if (event) {
            var payload = parsePayload(event.payload);
            var isExpanded = expandedPayloads.has(eventId);
            var payloadCell = row.querySelector('.payload-preview-container');
            if (payloadCell) {
                var html = '<div class="payload-preview' + (isExpanded ? ' expanded' : '') + '" onclick="togglePayloadExpand(\'' + eventId + '\')">';
                html += formatPayloadPreview(payload, isExpanded);
                if (!isExpanded) {
                    html += '<span class="payload-expand-btn">Expand</span>';
                } else {
                    html += '<span class="payload-expand-btn">Collapse</span>';
                }
                html += '</div>';
                payloadCell.innerHTML = html;
            }
        }
    }
}

function setEventsTypeFilter(type) {
    eventsTypeFilter = type;
    renderEventsView();
}

function setEventsSetFilter(set) {
    eventsSetFilter = set;
    renderEventsView();
}

function setEventsSearch(query) {
    eventsSearchQuery = query;
    renderEventsView();
}

// ============ Changelog Tab (drawn from Matrix room data) ============

// Fetch a changelog of mutations from Matrix rooms using SynapseSync room map.
// Paginates backwards (newest first) through law.firm.record.mutate events
// in each room, merges across rooms, and returns a unified list.
async function _fetchRoomChangelog(options) {
    options = options || {};
    var limit = options.limit || 50;
    var prevTokens = options.paginationTokens || {};
    var tableFilter = options.tableFilter || null;

    var roomTableMap = _getRoomTableMap();
    var roomIds = Object.keys(roomTableMap);

    if (tableFilter) {
        var filterRoom = _getRoomForTable(tableFilter);
        if (!filterRoom) throw new Error('No Matrix room for table: ' + tableFilter);
        roomIds = [filterRoom];
    }

    var perRoomEntries = [];
    var nextTokens = {};
    var anyHasMore = false;

    for (var r = 0; r < roomIds.length; r++) {
        var roomId = roomIds[r];
        var tableId = roomTableMap[roomId];
        var fromToken = prevTokens[roomId] || undefined;

        if (fromToken === 'exhausted') {
            nextTokens[roomId] = 'exhausted';
            continue;
        }

        try {
            var msgOpts = {
                dir: 'b',
                limit: limit,
                filter: { types: ['law.firm.schema.object', 'law.firm.record.mutate'] }
            };
            if (fromToken) msgOpts.from = fromToken;

            var response = await MatrixClient.getRoomMessages(roomId, msgOpts);
            if (!response || !response.chunk) {
                nextTokens[roomId] = 'exhausted';
                continue;
            }

            var chunk = response.chunk;
            for (var i = 0; i < chunk.length; i++) {
                var evt = chunk[i];
                var content = evt.content || {};
                if (!content.recordId) continue; // skip schema-level events (field definitions, etc.)


                // Decrypt if needed (gracefully skip failures)
                if (typeof AminoData !== 'undefined' && AminoData.isEncryptedPayload(content)) {
                    try {
                        var decryptedFields = await AminoData.decryptEventPayload(content);
                        content = {
                            recordId: content.recordId,
                            tableId: content.tableId,
                            op: content.op || 'ALT',
                            payload: content.payload,
                            set: content.set,
                            source: content.source,
                            sourceTimestamp: content.sourceTimestamp,
                            fields: decryptedFields
                        };
                    } catch (decErr) {
                        // Cannot decrypt  still show the entry with whatever metadata is available
                    }
                }

                var payload = content.payload || {};
                var fieldOps = payload.fields || {};

                // Handle flat format
                if (!fieldOps.ALT && !fieldOps.INS && !fieldOps.NUL && content.op && content.fields) {
                    fieldOps = {};
                    if (content.op === 'INS' || content.op === 'ALT') {
                        fieldOps[content.op] = content.fields;
                    } else if (content.op === 'NUL') {
                        fieldOps.NUL = content.fields;
                    }
                }

                perRoomEntries.push({
                    eventId: evt.event_id || null,
                    sender: evt.sender || null,
                    timestamp: evt.origin_server_ts || null,
                    tableId: tableId,
                    recordId: content.recordId || null,
                    op: content.op || 'ALT',
                    source: content.source || null,
                    sourceTimestamp: content.sourceTimestamp || null,
                    actor: payload._a || null,
                    fieldOps: fieldOps
                });
            }

            if (response.end && chunk.length >= limit) {
                nextTokens[roomId] = response.end;
                anyHasMore = true;
            } else {
                nextTokens[roomId] = 'exhausted';
            }
        } catch (err) {
            console.warn('[Changelog] Error fetching room', roomId, err.message);
            nextTokens[roomId] = prevTokens[roomId] || 'exhausted';
        }
    }

    // Sort newest first
    perRoomEntries.sort(function(a, b) {
        return (b.timestamp || 0) - (a.timestamp || 0);
    });

    var entries = perRoomEntries.slice(0, limit);
    if (perRoomEntries.length > limit) anyHasMore = true;

    return {
        entries: entries,
        paginationTokens: nextTokens,
        hasMore: anyHasMore
    };
}

async function renderChangelogContent() {
    var container = document.getElementById('events-tab-content');
    if (!container) return;
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading changelog from room data...</h3></div>';

    // Reset changelog state
    changelogEntries = [];
    changelogPaginationTokens = {};
    changelogHasMore = true;
    changelogIsLoading = false;

    // Clean up previous scroll handler
    if (changelogScrollHandler) {
        var scrollParent = document.querySelector('.table-container');
        if (scrollParent) scrollParent.removeEventListener('scroll', changelogScrollHandler);
        changelogScrollHandler = null;
    }

    try {
        // Check if Matrix is available and we have room mappings
        var roomTableMap = _getRoomTableMap();
        if (!MatrixClient.isLoggedIn() || Object.keys(roomTableMap).length === 0) {
            container.innerHTML = '<div class="changelog-empty"><h3>Not connected</h3><p>Changelog requires an active Matrix connection. Sign in with Synapse to view all changes from room data.</p></div>';
            return;
        }

        var result = await _fetchRoomChangelog({
            limit: 50,
            tableFilter: changelogTableFilter || undefined
        });

        changelogEntries = result.entries;
        changelogPaginationTokens = result.paginationTokens;
        changelogHasMore = result.hasMore;

        var html = '';

        // Changelog controls bar
        html += '<div class="events-controls">';
        html += '<div class="events-filter-group">';
        html += '<label>Table:</label>';
        html += '<select onchange="setChangelogTableFilter(this.value)">';
        html += '<option value="">All Tables</option>';
        for (var tid in META_TABLES) {
            var tableName = META_TABLES[tid].tableName || tid;
            html += '<option value="' + esc(tid) + '"' + (changelogTableFilter === tid ? ' selected' : '') + '>' + esc(tableName) + '</option>';
        }
        html += '</select>';
        html += '</div>';

        html += '<div class="events-stats">';
        html += 'Loaded ' + changelogEntries.length.toLocaleString() + ' changes';
        if (changelogHasMore) html += ' <span style="color: var(--text-muted);">(scroll for more)</span>';
        html += '</div>';
        html += '</div>';

        // Changelog entry list
        html += '<div class="changelog-list" id="changelog-list">';

        if (changelogEntries.length === 0) {
            html += '<div class="changelog-empty"><h3>No changes found</h3><p>No mutations have been recorded in the room data yet.</p></div>';
        } else {
            for (var i = 0; i < changelogEntries.length; i++) {
                html += renderChangelogEntry(changelogEntries[i], i === changelogEntries.length - 1);
            }
        }

        html += '</div>';

        // Infinite scroll loading indicator
        html += '<div id="changelog-load-more" class="events-load-more" style="display: ' + (changelogHasMore ? 'flex' : 'none') + ';">';
        html += '<div class="loading-spinner-small"></div>';
        html += '<span>Loading more changes...</span>';
        html += '</div>';

        html += '<div id="changelog-end-message" class="events-end-message" style="display: ' + (changelogHasMore ? 'none' : 'block') + ';">';
        html += 'All changes loaded';
        html += '</div>';

        container.innerHTML = html;

        // Set up infinite scroll on the actual scrolling parent
        var scrollParent = document.querySelector('.table-container');
        setupChangelogInfiniteScroll(scrollParent);

    } catch (err) {
        console.error('Error loading changelog:', err);
        container.innerHTML = '<div class="changelog-empty"><h3>Error loading changelog</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function renderChangelogEntry(entry, isLast) {
    var op = entry.op || 'ALT';
    var opLabel = ENTITY_TYPE_NAMES[op] || op;
    var tableName = (META_TABLES[entry.tableId] && META_TABLES[entry.tableId].tableName) || entry.tableId || 'Unknown';
    var timeStr = entry.timestamp ? formatTimestamp(entry.timestamp) : 'Unknown';
    var fieldsMeta = META_FIELDS[entry.tableId] || {};

    var html = '<div class="changelog-entry">';

    // Timeline dot and line
    html += '<div class="changelog-timeline">';
    html += '<div class="changelog-dot ' + esc(op) + '"></div>';
    if (!isLast) html += '<div class="changelog-line"></div>';
    html += '</div>';

    // Content
    html += '<div class="changelog-content">';

    // Header row: op badge, table, record ID, timestamp
    html += '<div class="changelog-header">';
    html += '<span class="changelog-op ' + esc(op) + '">' + esc(opLabel) + '</span>';
    html += '<span class="changelog-table-badge">' + esc(tableName) + '</span>';
    if (entry.recordId) {
        html += '<span class="changelog-record-id">' + esc(entry.recordId) + '</span>';
    }
    html += '<span class="changelog-time">' + esc(timeStr) + '</span>';
    html += '</div>';

    // Changed fields
    var fieldOps = entry.fieldOps || {};
    var hasFields = false;
    html += '<div class="changelog-fields">';

    // INS fields
    if (fieldOps.INS) {
        var insKeys = Object.keys(fieldOps.INS);
        for (var a = 0; a < insKeys.length; a++) {
            hasFields = true;
            var fname = resolveFieldName(fieldsMeta, insKeys[a]);
            html += '<div class="changelog-field">';
            html += '<span class="changelog-field-name">' + esc(fname) + '</span>';
            html += '<span class="changelog-field-arrow">&#8592;</span>';
            html += '<span class="changelog-field-value">' + esc(truncateValue(fieldOps.INS[insKeys[a]])) + '</span>';
            html += '</div>';
        }
    }

    // ALT fields
    if (fieldOps.ALT) {
        var altKeys = Object.keys(fieldOps.ALT);
        for (var b = 0; b < altKeys.length; b++) {
            hasFields = true;
            var fname = resolveFieldName(fieldsMeta, altKeys[b]);
            html += '<div class="changelog-field">';
            html += '<span class="changelog-field-name">' + esc(fname) + '</span>';
            html += '<span class="changelog-field-arrow">&#8592;</span>';
            html += '<span class="changelog-field-value">' + esc(truncateValue(fieldOps.ALT[altKeys[b]])) + '</span>';
            html += '</div>';
        }
    }

    // SYN fields
    if (fieldOps.SYN) {
        var synKeys = Object.keys(fieldOps.SYN);
        for (var s = 0; s < synKeys.length; s++) {
            hasFields = true;
            var fname = resolveFieldName(fieldsMeta, synKeys[s]);
            html += '<div class="changelog-field">';
            html += '<span class="changelog-field-name">' + esc(fname) + '</span>';
            html += '<span class="changelog-field-arrow">&#8592;</span>';
            html += '<span class="changelog-field-value">' + esc(truncateValue(fieldOps.SYN[synKeys[s]])) + '</span>';
            html += '</div>';
        }
    }

    // NUL fields
    if (fieldOps.NUL) {
        var nulFields = Array.isArray(fieldOps.NUL) ? fieldOps.NUL : Object.keys(fieldOps.NUL);
        for (var c = 0; c < nulFields.length; c++) {
            hasFields = true;
            var fname = resolveFieldName(fieldsMeta, nulFields[c]);
            html += '<div class="changelog-field">';
            html += '<span class="changelog-field-name">' + esc(fname) + '</span>';
            html += '<span class="changelog-field-arrow">&#8592;</span>';
            html += '<span class="changelog-field-value" style="font-style: italic; opacity: 0.6;">deleted</span>';
            html += '</div>';
        }
    }

    if (!hasFields) {
        html += '<div class="changelog-field" style="opacity: 0.5; font-style: italic;">No field details available</div>';
    }

    html += '</div>';

    // Actor/sender info
    if (entry.actor || entry.sender || entry.source) {
        html += '<div class="changelog-actor">';
        if (entry.actor) html += 'by ' + esc(entry.actor);
        else if (entry.sender) html += 'by ' + esc(entry.sender);
        if (entry.source) html += ' via ' + esc(entry.source);
        html += '</div>';
    }

    html += '</div>'; // .changelog-content
    html += '</div>'; // .changelog-entry

    return html;
}

function resolveFieldName(fieldsMeta, fieldId) {
    if (fieldsMeta[fieldId] && fieldsMeta[fieldId].fieldName) {
        return fieldsMeta[fieldId].fieldName;
    }
    return fieldId;
}

function truncateValue(val) {
    if (val === null || val === undefined) return '';
    var str = typeof val === 'object' ? JSON.stringify(val) : String(val);
    if (str.length > 120) return str.substring(0, 117) + '...';
    return str;
}

function setChangelogTableFilter(tableId) {
    changelogTableFilter = tableId;
    renderChangelogContent();
}

function setupChangelogInfiniteScroll(scrollParent) {
    changelogScrollHandler = function() {
        var scrollTop = scrollParent.scrollTop;
        var scrollHeight = scrollParent.scrollHeight;
        var clientHeight = scrollParent.clientHeight;

        if (scrollHeight - scrollTop - clientHeight < 200) {
            loadMoreChangelog();
        }
    };
    scrollParent.addEventListener('scroll', changelogScrollHandler);
}

async function loadMoreChangelog() {
    if (changelogIsLoading || !changelogHasMore) return;
    changelogIsLoading = true;

    var loadMoreDiv = document.getElementById('changelog-load-more');
    if (loadMoreDiv) loadMoreDiv.style.display = 'flex';

    try {
        var result = await _fetchRoomChangelog({
            limit: 50,
            paginationTokens: changelogPaginationTokens,
            tableFilter: changelogTableFilter || undefined
        });

        if (result.entries.length === 0) {
            changelogHasMore = false;
        } else {
            for (var i = 0; i < result.entries.length; i++) {
                changelogEntries.push(result.entries[i]);
            }
            changelogPaginationTokens = result.paginationTokens;
            changelogHasMore = result.hasMore;

            // Append to the list
            var list = document.getElementById('changelog-list');
            if (list) {
                // Remove isLast styling from previously last entry
                var lastEntry = list.querySelector('.changelog-entry:last-child .changelog-timeline');
                if (lastEntry && !lastEntry.querySelector('.changelog-line')) {
                    var line = document.createElement('div');
                    line.className = 'changelog-line';
                    lastEntry.appendChild(line);
                }
                var newHtml = '';
                for (var j = 0; j < result.entries.length; j++) {
                    var isLast = (j === result.entries.length - 1) && !changelogHasMore;
                    newHtml += renderChangelogEntry(result.entries[j], isLast);
                }
                list.insertAdjacentHTML('beforeend', newHtml);
            }

            // Update stats
            var statsDiv = document.querySelector('.events-controls .events-stats');
            if (statsDiv) {
                var statsHtml = 'Loaded ' + changelogEntries.length.toLocaleString() + ' changes';
                if (changelogHasMore) statsHtml += ' <span style="color: var(--text-muted);">(scroll for more)</span>';
                statsDiv.innerHTML = statsHtml;
            }
        }
    } catch (err) {
        console.error('Error loading more changelog:', err);
    } finally {
        changelogIsLoading = false;
        var loadMoreDiv = document.getElementById('changelog-load-more');
        var endMessage = document.getElementById('changelog-end-message');
        if (loadMoreDiv) loadMoreDiv.style.display = changelogHasMore ? 'none' : 'none';
        if (endMessage) endMessage.style.display = changelogHasMore ? 'none' : 'block';
    }
}

// ============ Events CSV Export/Import ============

async function exportEventsToCSV() {
    try {
        // Show progress
        showImportStatus('Exporting...', 'Collecting events from database...', 'progress', 0);

        // Get all events from IndexedDB
        var allEvents = [];
        var batchSize = 1000;
        var offset = 0;
        var totalCount = await getRawEventsCount();

        while (true) {
            var batch = await getRawEventsPaginated(offset, batchSize);
            if (batch.length === 0) break;
            for (var bi = 0; bi < batch.length; bi++) allEvents.push(batch[bi]);
            offset += batch.length;

            var progress = Math.round((allEvents.length / totalCount) * 50);
            showImportStatus('Exporting...', 'Collected ' + allEvents.length.toLocaleString() + ' of ' + totalCount.toLocaleString() + ' events', 'progress', progress);
        }

        if (allEvents.length === 0) {
            showImportStatus('No Events', 'No events to export.', 'error');
            return;
        }

        showImportStatus('Exporting...', 'Building CSV file...', 'progress', 60);

        // CSV header
        var csvLines = ['id,set,recordId,created_at,payload'];

        // Convert events to CSV rows
        for (var i = 0; i < allEvents.length; i++) {
            var event = allEvents[i];
            var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);

            // Escape CSV fields
            var row = [
                event.id,
                escapeCSVField(event.set || ''),
                escapeCSVField(event.recordId || ''),
                escapeCSVField(event.created_at || ''),
                escapeCSVField(payloadStr)
            ];
            csvLines.push(row.join(','));

            if (i % 1000 === 0) {
                var progress = 60 + Math.round((i / allEvents.length) * 30);
                showImportStatus('Exporting...', 'Processing event ' + i.toLocaleString() + ' of ' + allEvents.length.toLocaleString(), 'progress', progress);
            }
        }

        showImportStatus('Exporting...', 'Creating download...', 'progress', 95);

        // Create and download file
        var csvContent = csvLines.join('\n');
        var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        var url = URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = url;
        link.download = 'events_export_' + new Date().toISOString().slice(0, 10) + '.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        showImportStatus('Export Complete', 'Exported ' + allEvents.length.toLocaleString() + ' events to CSV.', 'success');

    } catch (err) {
        console.error('Error exporting events:', err);
        showImportStatus('Export Failed', err.message, 'error');
    }
}

async function exportEventsToAmo() {
    try {
        showImportStatus('Exporting...', 'Collecting events from database...', 'progress', 0);

        var allEvents = [];
        var batchSize = 1000;
        var offset = 0;
        var totalCount = await getRawEventsCount();

        while (true) {
            var batch = await getRawEventsPaginated(offset, batchSize);
            if (batch.length === 0) break;
            for (var bi = 0; bi < batch.length; bi++) allEvents.push(batch[bi]);
            offset += batch.length;

            var progress = Math.round((allEvents.length / totalCount) * 50);
            showImportStatus('Exporting...', 'Collected ' + allEvents.length.toLocaleString() + ' of ' + totalCount.toLocaleString() + ' events', 'progress', progress);
        }

        if (allEvents.length === 0) {
            showImportStatus('No Events', 'No events to export.', 'error');
            return;
        }

        // Decrypt events if encryption is enabled
        if (encryptionEnabled && encryptionKey) {
            showImportStatus('Exporting...', 'Decrypting events...', 'progress', 55);
            allEvents = await Promise.all(allEvents.map(function(e) { return decryptEventFromStorage(e); }));
        }

        showImportStatus('Exporting...', 'Building .amo file...', 'progress', 70);

        var binary = AmoFormat.produceEvents(allEvents, { tables: META_TABLES, fields: META_FIELDS });

        showImportStatus('Exporting...', 'Creating download...', 'progress', 95);

        var blob = new Blob([binary], { type: 'application/x-amino-snapshot' });
        var url = URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = url;
        link.download = 'amino_snapshot_' + new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-') + '.amo';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        var sizeStr = binary.length < 1024
            ? binary.length + ' B'
            : binary.length < 1048576
                ? (binary.length / 1024).toFixed(1) + ' KB'
                : (binary.length / 1048576).toFixed(1) + ' MB';

        showImportStatus('Export Complete', 'Exported ' + allEvents.length.toLocaleString() + ' events (' + sizeStr + ') to .amo file.', 'success');

    } catch (err) {
        console.error('Error exporting .amo:', err);
        showImportStatus('Export Failed', err.message, 'error');
    }
}

function escapeCSVField(value) {
    if (value === null || value === undefined) return '';
    var str = String(value);
    // If contains comma, newline, or quote, wrap in quotes and escape inner quotes
    if (str.includes(',') || str.includes('\n') || str.includes('"') || str.includes('\r')) {
        return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
}

function parseCSVLine(line) {
    var result = [];
    var current = '';
    var inQuotes = false;
    var i = 0;

    while (i < line.length) {
        var char = line[i];

        if (inQuotes) {
            if (char === '"') {
                // Check for escaped quote
                if (i + 1 < line.length && line[i + 1] === '"') {
                    current += '"';
                    i += 2;
                    continue;
                } else {
                    inQuotes = false;
                    i++;
                    continue;
                }
            }
            current += char;
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === ',') {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        i++;
    }
    result.push(current);
    return result;
}

async function importEventsFromCSV() {
    // Create file input
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;

        try {
            showImportStatus('Importing...', 'Reading file...', 'progress', 0);

            var text = await file.text();
            var lines = text.split(/\r?\n/);
            text = null; // Release original text string to free memory

            if (lines.length < 2) {
                showImportStatus('Import Failed', 'CSV file is empty or has no data rows.', 'error');
                return;
            }

            // Parse header
            var header = parseCSVLine(lines[0]);
            var idIndex = header.indexOf('id');
            var setIndex = header.indexOf('set');
            var recordIdIndex = header.indexOf('recordId');
            var createdAtIndex = header.indexOf('created_at');
            var payloadIndex = header.indexOf('payload');

            if (idIndex === -1) {
                showImportStatus('Import Failed', 'CSV must have an "id" column.', 'error');
                return;
            }

            showImportStatus('Importing...', 'Parsing CSV data...', 'progress', 10);

            // Parse all event rows
            var events = [];
            for (var i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                var fields = parseCSVLine(lines[i]);
                var event = {
                    id: parseInt(fields[idIndex], 10)
                };

                if (isNaN(event.id)) continue; // Skip invalid IDs

                if (setIndex !== -1) event.set = fields[setIndex] || '';
                if (recordIdIndex !== -1) event.recordId = fields[recordIdIndex] || '';
                if (createdAtIndex !== -1) event.created_at = fields[createdAtIndex] || '';
                if (payloadIndex !== -1) {
                    var payloadStr = fields[payloadIndex] || '{}';
                    try {
                        event.payload = JSON.parse(payloadStr);
                    } catch (e) {
                        event.payload = payloadStr;
                    }
                }

                events.push(event);

                if (i % 1000 === 0) {
                    showImportStatus('Importing...', 'Parsed ' + events.length.toLocaleString() + ' events...', 'progress', 10 + Math.round((i / lines.length) * 20));
                }
            }

            if (events.length === 0) {
                showImportStatus('Import Failed', 'No valid events found in CSV.', 'error');
                return;
            }

            showImportStatus('Importing...', 'Checking for duplicates...', 'progress', 35);

            // Get existing event IDs from IndexedDB for deduplication
            var existingIds = await getExistingEventIds();

            showImportStatus('Importing...', 'Found ' + existingIds.size.toLocaleString() + ' existing events. Filtering duplicates...', 'progress', 50);

            // Filter out duplicates
            var newEvents = events.filter(function(e) {
                return !existingIds.has(e.id);
            });
            existingIds = null; // Release

            var totalEventCount = events.length;
            var duplicateCount = totalEventCount - newEvents.length;
            events = null; // Release original array  only newEvents needed now

            if (newEvents.length === 0) {
                showImportStatus('Import Complete', 'All ' + totalEventCount.toLocaleString() + ' events already exist (no new events to import).', 'success');
                return;
            }

            showImportStatus('Importing...', 'Importing ' + newEvents.length.toLocaleString() + ' new events (skipping ' + duplicateCount.toLocaleString() + ' duplicates)...', 'progress', 60);

            // Import events in batches
            var batchSize = 500;
            var imported = 0;

            for (var j = 0; j < newEvents.length; j += batchSize) {
                var batch = newEvents.slice(j, j + batchSize);
                await saveRawEvents(batch);
                imported += batch.length;

                var progress = 60 + Math.round((imported / newEvents.length) * 35);
                showImportStatus('Importing...', 'Imported ' + imported.toLocaleString() + ' of ' + newEvents.length.toLocaleString() + ' events...', 'progress', progress);
            }

            showImportStatus('Import Complete',
                'Imported ' + newEvents.length.toLocaleString() + ' new events' +
                (duplicateCount > 0 ? ' (skipped ' + duplicateCount.toLocaleString() + ' duplicates)' : '') + '.',
                'success');

            // Refresh the events view
            if (currentTable === '_events') {
                renderEventsView();
            }

        } catch (err) {
            console.error('Error importing events:', err);
            showImportStatus('Import Failed', err.message, 'error');
        }
    };

    input.click();
}

async function getExistingEventIds() {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var ids = new Set();

        var req = store.openKeyCursor();
        req.onsuccess = function(e) {
            var cursor = e.target.result;
            if (cursor) {
                ids.add(cursor.key);
                cursor.continue();
            } else {
                resolve(ids);
            }
        };
        req.onerror = function() {
            reject(req.error);
        };
    });
}

function showImportStatus(title, details, type, progress) {
    var existing = document.querySelector('.import-status');
    if (existing) existing.remove();

    var div = document.createElement('div');
    div.className = 'import-status' + (type === 'success' ? ' success' : type === 'error' ? ' error' : '');

    var icon = type === 'success' ? '' : type === 'error' ? '' : '';
    var titleClass = type === 'success' ? ' success' : type === 'error' ? ' error' : '';

    div.innerHTML = '<div class="import-status-title' + titleClass + '">' + icon + ' ' + esc(title) + '</div>' +
                    '<div class="import-status-details">' + esc(details) + '</div>' +
                    (type === 'progress' ? '<div class="import-progress"><div class="import-progress-bar" style="width: ' + (progress || 0) + '%"></div></div>' : '');

    document.body.appendChild(div);

    // Auto-remove success/error messages after 5 seconds
    if (type === 'success' || type === 'error') {
        setTimeout(function() {
            if (div.parentNode) div.remove();
        }, 5000);
    }
}

// Skip setup and upload CSV file directly
var skipSyncAbortController = null;

// Build in-memory lookup map for events by recordId
function buildInMemoryEventsByRecord(events) {
    var map = new Map();
    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (e.recordId) {
            if (!map.has(e.recordId)) {
                map.set(e.recordId, []);
            }
            map.get(e.recordId).push(e);
        }
    }
    return map;
}

// Background save events to IndexedDB (non-blocking)
async function backgroundSaveToIndexedDB(events, onProgress) {
    isBackgroundSaveInProgress = true;
    var batchSize = 500;
    var saved = 0;
    var total = events.length;

    try {
        // Phase 1: Save raw events
        for (var j = 0; j < events.length; j += batchSize) {
            var batch = events.slice(j, j + batchSize);
            await saveRawEvents(batch);
            saved += batch.length;

            if (onProgress) {
                onProgress(saved, total);
            }

            // Yield to main thread periodically to keep UI responsive
            if (j % 2000 === 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Phase 2: Save metadata (tables, fields, views)
        var tables = Object.values(META_TABLES);
        var fields = [];
        for (var tid in META_FIELDS) {
            for (var fid in META_FIELDS[tid]) {
                fields.push(META_FIELDS[tid][fid]);
            }
        }
        var views = [];
        for (var tid in META_VIEWS) {
            for (var vid in META_VIEWS[tid]) {
                views.push(META_VIEWS[tid][vid]);
            }
        }

        // Save metadata first (tables, fields, views)
        if (tables.length || fields.length || views.length) {
            await saveBatch(tables, fields, views, []);
        }

        // Phase 3: Save data records from IN_MEMORY_DATA per-table and free each table's data after save
        if (window.IN_MEMORY_DATA) {
            var tableIds = Object.keys(window.IN_MEMORY_DATA);
            for (var ti = 0; ti < tableIds.length; ti++) {
                var tableId = tableIds[ti];
                var tableData = window.IN_MEMORY_DATA[tableId];
                if (!tableData) continue;
                var dataRecords = [];
                for (var recordId in tableData) {
                    dataRecords.push({
                        tableId: tableId,
                        recordId: recordId,
                        fields: tableData[recordId]
                    });
                }
                if (dataRecords.length > 0) {
                    // Save in sub-batches to avoid large transactions
                    for (var di = 0; di < dataRecords.length; di += batchSize) {
                        var dataBatch = dataRecords.slice(di, di + batchSize);
                        await saveBatch([], [], [], dataBatch);
                    }
                }
                // Free this table's in-memory data now that it's persisted
                delete window.IN_MEMORY_DATA[tableId];
                // Yield to GC and UI
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Phase 4: Build and save field history from raw events
        // Group events by tableId and recordId, then build history per-record
        // Save incrementally to avoid accumulating a huge array
        var eventsByTableAndRecord = {};
        var maxId = 0;
        var lastEventCreatedAt = null;
        for (var i = 0; i < events.length; i++) {
            var evt = events[i];
            if (evt.id > maxId) { maxId = evt.id; lastEventCreatedAt = evt.created_at; }
            if (evt.recordId && evt.set && evt.set.startsWith('airtable:')) {
                var tableId = evt.set.replace('airtable:', '');
                var key = tableId + '|' + evt.recordId;
                if (!eventsByTableAndRecord[key]) {
                    eventsByTableAndRecord[key] = { tableId: tableId, recordId: evt.recordId, events: [] };
                }
                eventsByTableAndRecord[key].events.push(evt);
            }
        }

        // Process field history in batches, saving and releasing as we go
        var historyBatch = [];
        var totalHistoryEntries = 0;
        var recordKeys = Object.keys(eventsByTableAndRecord);
        for (var k = 0; k < recordKeys.length; k++) {
            var group = eventsByTableAndRecord[recordKeys[k]];
            var historyEntries = buildFieldHistoryFromRawEvents(group.tableId, group.recordId, group.events);
            // Free the events for this record immediately
            group.events = null;
            for (var he = 0; he < historyEntries.length; he++) {
                historyBatch.push(historyEntries[he]);
            }
            totalHistoryEntries += historyEntries.length;

            // Save when batch is large enough
            if (historyBatch.length >= batchSize) {
                await saveFieldHistory(historyBatch);
                historyBatch = [];
            }

            // Yield periodically to keep UI responsive
            if (k % 500 === 0 && k > 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
        // Save remaining
        if (historyBatch.length > 0) {
            await saveFieldHistory(historyBatch);
        }
        if (totalHistoryEntries > 0) {
            console.log('Saved ' + totalHistoryEntries + ' field history entries');
        }
        eventsByTableAndRecord = null; // release

        // Update the last event timestamp in IndexedDB
        var lastEvent = lastEventCreatedAt ? { created_at: lastEventCreatedAt } : null;
        if (lastEvent && lastEvent.created_at) {
            await setSyncMeta('lastEventTimestamp', lastEvent.created_at);
        }

        console.log('Background IndexedDB save complete: ' + saved + ' events, ' + dataRecords.length + ' records');

        // Clear in-memory cache after successful IndexedDB save to free memory
        // (functions will now read from IndexedDB)
        inMemoryEvents = null;
        inMemoryEventsByRecord = null;
        window.IN_MEMORY_DATA = null;

    } catch (err) {
        console.error('Background IndexedDB save failed:', err);
        // Keep in-memory cache if save failed
    } finally {
        isBackgroundSaveInProgress = false;
    }
}

// Process a CSV file directly (called from skipAuthAndUploadCSV or loading overlay)
async function processCSVFile(file) {
        try {
            // Update the loading overlay to show import progress
            updateLoadingOverlay('Importing from file...', 'Reading CSV...', 5, 0, 0, 0, 'Starting import...');

            var text = await file.text();
            var lines = text.split(/\r?\n/);

            if (lines.length < 2) {
                alert('CSV file is empty or has no data rows.');
                return;
            }

            // Parse header
            var header = parseCSVLine(lines[0]);
            var idIndex = header.indexOf('id');
            var setIndex = header.indexOf('set');
            var recordIdIndex = header.indexOf('recordId');
            var createdAtIndex = header.indexOf('created_at');
            var payloadIndex = header.indexOf('payload');

            if (idIndex === -1) {
                alert('CSV must have an "id" column.');
                return;
            }

            updateLoadingOverlay('Importing from file...', 'Parsing CSV data...', 10, 0, 0, 0, '');

            // Parse all event rows
            var events = [];
            var tablesCount = 0;
            var fieldsCount = 0;
            var recordsCount = 0;

            for (var i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                var fields = parseCSVLine(lines[i]);
                var event = {
                    id: parseInt(fields[idIndex], 10)
                };

                if (isNaN(event.id)) continue;

                if (setIndex !== -1) event.set = fields[setIndex] || '';
                if (recordIdIndex !== -1) event.recordId = fields[recordIdIndex] || '';
                if (createdAtIndex !== -1) event.created_at = fields[createdAtIndex] || '';
                if (payloadIndex !== -1) {
                    var payloadStr = fields[payloadIndex] || '{}';
                    try {
                        event.payload = JSON.parse(payloadStr);
                    } catch (err) {
                        event.payload = payloadStr;
                    }
                }

                events.push(event);

                // Count types for progress display
                if (event.payload && event.payload._set) {
                    if (event.payload._set === 'table') tablesCount++;
                    else if (event.payload._set === 'field') fieldsCount++;
                    else recordsCount++;
                } else {
                    recordsCount++;
                }

                if (i % 5000 === 0) {
                    var progress = 10 + Math.round((i / lines.length) * 40);
                    updateLoadingOverlay('Importing from file...', 'Parsed ' + events.length.toLocaleString() + ' events...', progress, tablesCount, fieldsCount, recordsCount, '');
                }
            }

            if (events.length === 0) {
                alert('No valid events found in CSV.');
                return;
            }

            // Sort events by ID to ensure proper order
            events.sort(function(a, b) { return a.id - b.id; });

            updateLoadingOverlay('Importing from file...', 'Processing ' + events.length.toLocaleString() + ' events...', 55, tablesCount, fieldsCount, recordsCount, '');

            // Store events in memory for instant access (before IndexedDB save)
            inMemoryEvents = events;
            inMemoryEventsByRecord = buildInMemoryEventsByRecord(events);

            // Process events using fast memory-only approach (no IndexedDB)
            await processEventsMemoryOnly(events, function(processed, total, tableCount) {
                var pct = 55 + Math.round((processed / total) * 30);
                updateLoadingOverlay('Importing from file...', 'Processing events: ' + processed.toLocaleString() + ' / ' + total.toLocaleString(), pct, tableCount, fieldsCount, recordsCount, '');
            });

            // Update the last event timestamp in memory
            var maxId = events.reduce(function(max, e) { return Math.max(max, e.id); }, 0);
            var lastEvent = events.find(function(e) { return e.id === maxId; });
            if (lastEvent && lastEvent.created_at) {
                lastEventTimestamp = lastEvent.created_at;
            }

            updateLoadingOverlay('Import complete!', 'Rendering interface...', 90, tablesCount, fieldsCount, recordsCount, '');

            // Render the UI immediately - data is in memory
            await renderSidebar();

            // Auto-select first table
            var firstTable = Object.keys(META_TABLES)[0];
            if (firstTable) {
                await showTable(firstTable);
            }

            // Hide overlay - app is ready to use!
            updateLoadingOverlay('Import complete!', events.length.toLocaleString() + ' events loaded', 100, tablesCount, fieldsCount, recordsCount, '');
            setTimeout(hideLoadingOverlay, 300);

            updateStatus('Up to date', true, null, null);

            // Start the refresh indicator countdown
            lastSyncTime = Date.now();
            startRefreshCountdown();

            // Synapse sync is started after init()  no API_KEY polling needed.

            // Background: Save to IndexedDB for next visit (non-blocking)
            // This happens after the UI is ready, so user can start working immediately
            updateStatus('Caching locally...', true, null, null);
            backgroundSaveToIndexedDB(events, function(saved, total) {
                var pct = Math.round((saved / total) * 100);
                updateStatus('Caching: ' + pct + '%', true, null, null);
            }).then(function() {
                updateStatus('Up to date', true, null, null);
            });

        } catch (err) {
            console.error('Error importing file:', err);
            alert('Error importing file: ' + err.message);
        }
}

// Also keep the original function for calls from the loading overlay (opens file picker)
async function skipSetupAndUploadFile() {
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;
        await processCSVFile(file);
    };
    input.click();
}

// ============ .amo Snapshot Import ============

// Process an .amo file directly (called from skipAuthAndUploadAmo or loading overlay)
async function processAmoFile(file) {

        try {
            updateLoadingOverlay('Importing .amo snapshot...', 'Reading file...', 5, 0, 0, 0, '');

            var buffer = await file.arrayBuffer();

            // Detect and validate format
            var format;
            try {
                format = AmoFormat.detectFormat(buffer);
            } catch (err) {
                alert('Unrecognized file format. Please select a valid .amo snapshot file.');
                return;
            }

            updateLoadingOverlay('Importing .amo snapshot...', 'Parsing snapshot data...', 15, 0, 0, 0, '');

            var amoData;
            if (format === 'amo') {
                amoData = AmoFormat.read(buffer);
            } else if (format === 'json-gz') {
                var decompressed = pako.ungzip(new Uint8Array(buffer), { to: 'string' });
                var records = JSON.parse(decompressed);
                amoData = { tables: {}, cursor: 0, ts: Math.floor(Date.now() / 1000) };
                // Convert flat snapshot records to table-grouped format
                for (var i = 0; i < records.length; i++) {
                    var rec = records[i];
                    var tbl = rec.source_table || 'unknown';
                    if (!amoData.tables[tbl]) amoData.tables[tbl] = [];
                    var rowData = Object.assign({}, rec.data || {});
                    if (rec.record_id) rowData.record_id = rec.record_id;
                    amoData.tables[tbl].push(rowData);
                    if (rec.last_amino_event > amoData.cursor) amoData.cursor = rec.last_amino_event;
                }
            } else if (format === 'json') {
                var text = new TextDecoder().decode(buffer);
                var records = JSON.parse(text);
                amoData = { tables: {}, cursor: 0, ts: Math.floor(Date.now() / 1000) };
                for (var i = 0; i < records.length; i++) {
                    var rec = records[i];
                    var tbl = rec.source_table || 'unknown';
                    if (!amoData.tables[tbl]) amoData.tables[tbl] = [];
                    var rowData = Object.assign({}, rec.data || {});
                    if (rec.record_id) rowData.record_id = rec.record_id;
                    amoData.tables[tbl].push(rowData);
                    if (rec.last_amino_event > amoData.cursor) amoData.cursor = rec.last_amino_event;
                }
            } else {
                alert('Unsupported snapshot format.');
                return;
            }

            var tableNames = Object.keys(amoData.tables);
            if (tableNames.length === 0) {
                alert('Snapshot file contains no data.');
                return;
            }

            updateLoadingOverlay('Importing .amo snapshot...', 'Building tables and fields...', 40, tableNames.length, 0, 0, '');

            // Restore table/field metadata from snapshot if available
            var savedMeta = amoData.meta || {};
            if (savedMeta.tables) {
                var savedTableIds = Object.keys(savedMeta.tables);
                for (var m = 0; m < savedTableIds.length; m++) {
                    var tid = savedTableIds[m];
                    META_TABLES[tid] = savedMeta.tables[tid];
                }
            }
            if (savedMeta.fields) {
                var savedFieldTableIds = Object.keys(savedMeta.fields);
                for (var m = 0; m < savedFieldTableIds.length; m++) {
                    var tid = savedFieldTableIds[m];
                    if (!META_FIELDS[tid]) META_FIELDS[tid] = {};
                    var fieldIds = Object.keys(savedMeta.fields[tid]);
                    for (var f = 0; f < fieldIds.length; f++) {
                        META_FIELDS[tid][fieldIds[f]] = savedMeta.fields[tid][fieldIds[f]];
                    }
                }
            }

            // Build IN_MEMORY_DATA, META_TABLES, and META_FIELDS from snapshot
            var tableDataMap = {};
            var totalRecords = 0;
            var totalFields = 0;

            for (var t = 0; t < tableNames.length; t++) {
                var fullTableName = tableNames[t];
                var tableId = fullTableName.replace('airtable:', '');
                var rows = amoData.tables[fullTableName];

                // Create placeholder table metadata only if not already restored from snapshot meta
                if (!META_TABLES[tableId]) {
                    META_TABLES[tableId] = {
                        tableId: tableId,
                        tableName: tableId,
                        _placeholder: true
                    };
                }

                if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
                if (!tableDataMap[tableId]) tableDataMap[tableId] = {};

                for (var r = 0; r < rows.length; r++) {
                    var row = rows[r];
                    var recordId = row.record_id;
                    if (!recordId) continue;

                    // Build data object excluding record_id
                    var data = {};
                    var keys = Object.keys(row);
                    for (var k = 0; k < keys.length; k++) {
                        if (keys[k] !== 'record_id') {
                            data[keys[k]] = row[keys[k]];

                            // Auto-create placeholder field metadata only if not already restored
                            if (!META_FIELDS[tableId][keys[k]]) {
                                META_FIELDS[tableId][keys[k]] = {
                                    tableId: tableId,
                                    fieldId: keys[k],
                                    fieldName: keys[k],
                                    fieldType: inferFieldType(row[keys[k]]),
                                    _placeholder: true
                                };
                                totalFields++;
                            }
                        }
                    }

                    tableDataMap[tableId][recordId] = data;
                    totalRecords++;

                    if (totalRecords % 5000 === 0) {
                        var pct = 40 + Math.round((t / tableNames.length) * 40);
                        updateLoadingOverlay('Importing .amo snapshot...', 'Processed ' + totalRecords.toLocaleString() + ' records...', pct, tableNames.length, totalFields, totalRecords, '');
                        await new Promise(function(resolve) { setTimeout(resolve, 0); });
                    }
                }
            }

            // Store in memory for immediate UI access
            window.IN_MEMORY_DATA = tableDataMap;

            // Set the snapshot cursor so incremental sync only fetches records newer than the file
            if (amoData.cursor > 0) {
                await AminoSync.setLastSnapshotEventId(amoData.cursor);
                console.log('[AmoImport] Set lastSnapshotEventId to ' + amoData.cursor + ' from imported file');
            }

            updateLoadingOverlay('Import complete!', 'Rendering interface...', 90, tableNames.length, totalFields, totalRecords, '');

            // Render the UI
            await renderSidebar();

            // Auto-select first table
            var firstTable = Object.keys(META_TABLES)[0];
            if (firstTable) {
                await showTable(firstTable);
            }

            // Hide overlay
            updateLoadingOverlay('Import complete!', totalRecords.toLocaleString() + ' records from ' + tableNames.length + ' tables', 100, tableNames.length, totalFields, totalRecords, '');
            setTimeout(hideLoadingOverlay, 300);

            updateStatus('Up to date', true, null, null);

            // Start the refresh indicator countdown
            lastSyncTime = Date.now();
            startRefreshCountdown();

            console.log('AMO import complete: ' + totalRecords + ' records across ' + tableNames.length + ' tables');

        } catch (err) {
            console.error('Error importing .amo file:', err);
            alert('Error importing .amo file: ' + err.message);
        }
}

// Also keep the original function for calls from the loading overlay (opens file picker)
async function skipSetupAndUploadAmoFile() {
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.amo';
    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;
        await processAmoFile(file);
    };
    input.click();
}


// ============ Point in Time View ============

var _pitRevertState = null; // Stores reconstructed state for revert

async function viewRecordAtPointInTime(eventId, recordId, set) {
    var overlay = document.getElementById('pit-modal-overlay');
    var body = document.getElementById('pit-modal-body');

    // Show loading state
    body.innerHTML = '<div class="pit-empty-state"><div class="loading-spinner"></div><h3>Replaying events...</h3><p>Building record state at event #' + eventId + '</p></div>';
    overlay.classList.add('open');

    try {
        // Get all events for this record up to the specified event ID
        var events = await getRawEventsByRecordId(recordId, eventId);

        if (events.length === 0) {
            body.innerHTML = '<div class="pit-empty-state"><h3>No events found</h3><p>Could not find any events for this record.</p></div>';
            return;
        }

        // Determine the table ID from the set
        var tableId = set ? set.replace('airtable:', '') : null;

        // Replay events to build the record state
        var recordState = {};
        var lastTimestamp = null;

        for (var e of events) {
            var payload = parsePayload(e.payload);
            if (!payload || !payload.fields) continue;

            var fields = payload.fields;

            // Default first ALT as INS if record state is empty and no INS exists
            if (Object.keys(recordState).length === 0 && !fields.INS && fields.ALT) {
                fields = { INS: fields.ALT, NUL: fields.NUL };
            }

            // Apply INS (insert)
            if (fields.INS) {
                Object.assign(recordState, fields.INS);
            }

            // Apply ALT (alter)
            if (fields.ALT) {
                Object.assign(recordState, fields.ALT);
            }

            // Apply SYN (sync)
            if (fields.SYN) {
                Object.assign(recordState, fields.SYN);
            }

            // Apply NUL (nullify)
            if (fields.NUL && Array.isArray(fields.NUL)) {
                fields.NUL.forEach(k => delete recordState[k]);
            }

            if (e.created_at) {
                lastTimestamp = e.created_at;
            }
        }

        // Update modal header
        var tableName = META_TABLES[tableId]?.tableName || tableId || 'Unknown Table';
        document.getElementById('pit-modal-title').textContent = tableName;
        document.getElementById('pit-modal-event-badge').textContent = 'Event #' + eventId;
        document.getElementById('pit-modal-timestamp').textContent = lastTimestamp ? formatTimestamp(new Date(lastTimestamp).getTime()) : '';

        // Render the record state
        var html = '<div class="pit-record-card">';
        html += '<div class="pit-record-header">';
        html += '<span class="pit-table-name">' + esc(tableName) + '</span>';
        html += '<span class="pit-record-id">' + esc(recordId) + '</span>';
        if (tableId && META_TABLES[tableId]) {
            html += '<button class="event-action-btn pit-go-to-table" onclick="goToRecordInTable(\'' + esc(tableId) + '\', \'' + esc(recordId) + '\')">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M6 3L11 8L6 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
            html += 'View Current Record';
            html += '</button>';
        }
        html += '</div>';

        html += '<div class="pit-record-fields">';

        var fieldIds = Object.keys(recordState);
        if (fieldIds.length === 0) {
            html += '<div class="pit-empty-state">No fields recorded at this point in time</div>';
        } else {
            // Sort fields by name
            var fieldsInfo = META_FIELDS[tableId] || {};
            fieldIds.sort((a, b) => {
                var nameA = (fieldsInfo[a]?.fieldName || a).toLowerCase();
                var nameB = (fieldsInfo[b]?.fieldName || b).toLowerCase();
                return nameA.localeCompare(nameB);
            });

            for (var fieldId of fieldIds) {
                var fieldName = fieldsInfo[fieldId]?.fieldName || fieldId;
                var value = recordState[fieldId];

                html += '<div class="pit-field-row">';
                html += '<div class="pit-field-name">' + esc(fieldName) + '</div>';
                html += '<div class="pit-field-value">' + formatHistoryValue(value) + '</div>';
                html += '</div>';
            }
        }

        html += '</div>'; // .pit-record-fields

        // Revert action
        html += '<div class="pit-record-actions">';
        html += '<button class="pit-revert-btn" onclick="revertRecordToPointInTime()" title="Revert this record to the state shown above">';
        html += '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M2 2v5h5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.5 7A6.5 6.5 0 1 1 3 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';
        html += 'Revert to This State';
        html += '</button>';
        html += '</div>';

        html += '</div>'; // .pit-record-card

        // Store state for revert
        _pitRevertState = { tableId: tableId, recordId: recordId, fields: recordState, eventId: eventId };

        body.innerHTML = html;

    } catch (err) {
        console.error('Error viewing record at point in time:', err);
        _pitRevertState = null;
        body.innerHTML = '<div class="pit-empty-state"><h3>Error</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closePitModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('pit-modal-overlay').classList.remove('open');
    _pitRevertState = null;
}

async function revertRecordToPointInTime() {
    if (!_pitRevertState) return;

    var state = _pitRevertState;
    var btn = document.querySelector('.pit-revert-btn');

    // Two-click confirmation
    if (!btn.classList.contains('pit-revert-confirm')) {
        btn.classList.add('pit-revert-confirm');
        btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M8 3v5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><circle cx="8" cy="11.5" r="0.75" fill="currentColor"/><circle cx="8" cy="8" r="6.5" stroke="currentColor" stroke-width="1.5"/></svg> Confirm Revert?';
        return;
    }

    btn.disabled = true;
    btn.textContent = 'Reverting...';

    try {
        await editRecord(state.tableId, state.recordId, state.fields);
        btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M3 8.5L6.5 12L13 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg> Reverted';
        btn.style.background = 'rgba(34, 197, 94, 0.15)';
        btn.style.color = '#4ade80';
        _pitRevertState = null;
        setTimeout(function() { closePitModal(); }, 1200);
    } catch (err) {
        console.error('Error reverting record:', err);
        btn.disabled = false;
        btn.classList.remove('pit-revert-confirm');
        btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M2 2v5h5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.5 7A6.5 6.5 0 1 1 3 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg> Revert Failed - Retry';
        btn.style.background = 'rgba(239, 68, 68, 0.15)';
        btn.style.color = '#f87171';
    }
}

function goToRecordInTable(tableId, recordId) {
    closePitModal();
    showTable(tableId);
    // Open the record profile after navigating
    setTimeout(function() {
        openRecordProfile(tableId, recordId);
    }, 100);
}

// ============ Record Profile Panel ============

var profileCurrentTableId = null;
var profileCurrentRecordId = null;
var profileConfigureMode = false;
var profileFieldPicker = null;

// Default profile configuration - one block with all visible fields in 2 columns
function getDefaultProfileConfig(tableId, viewId) {
    var visibleFields = getVisibleFieldsForView(tableId, viewId || '_default');
    return {
        blocks: [
            {
                id: 'block-1',
                columns: 2,
                fieldIds: visibleFields.slice()
            }
        ]
    };
}

// Get profile configuration for a view
// Returns { config: {...}, isDefault: boolean }
function getProfileConfig(tableId, viewId) {
    var view = META_VIEWS[tableId]?.[viewId || '_default'];
    if (view && view.profileConfig && view.profileConfig.blocks && view.profileConfig.blocks.length > 0) {
        return { config: view.profileConfig, isDefault: false };
    }
    return { config: getDefaultProfileConfig(tableId, viewId), isDefault: true };
}

// Save profile configuration for a view
async function saveProfileConfig(tableId, viewId, config) {
    viewId = viewId || '_default';
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId
        };
    }
    META_VIEWS[tableId][viewId].profileConfig = config;
    await saveView(META_VIEWS[tableId][viewId]);
}

// Open record profile panel
async function openRecordProfile(tableId, recordId, viewId) {
    profileCurrentTableId = tableId;
    profileCurrentRecordId = recordId;

    // Use current view if not specified
    if (!viewId && tableId === currentTable) {
        viewId = currentView;
    }

    var overlay = document.getElementById('record-profile-overlay');
    overlay.classList.add('open');

    // Update header - use display name field value if set, otherwise table name
    var tableName = META_TABLES[tableId]?.tableName || tableId;
    var profileDisplayTitle = tableName;
    var dnFieldId = getDisplayNameFieldId(tableId);
    if (dnFieldId) {
        var dnRecords = await getRecordsByIds(tableId, [recordId]);
        if (dnRecords.length > 0) {
            var dnFields = dnRecords[0].fields || {};
            var dnFieldMeta = (META_FIELDS[tableId] || {})[dnFieldId];
            var dnValue = dnFields[dnFieldId];
            if (dnValue === undefined && dnFieldMeta) dnValue = dnFields[dnFieldMeta.fieldName];
            if (dnValue != null && dnValue !== '') {
                profileDisplayTitle = String(dnValue);
            }
        }
    }
    document.getElementById('profile-title').textContent = profileDisplayTitle;

    // Show view name
    var actualViewId = viewId || currentView || '_default';
    var viewData = META_VIEWS[tableId]?.[actualViewId];
    var viewName = viewData?.viewName || (actualViewId === '_default' ? 'All Fields' : actualViewId);
    document.getElementById('profile-view-name').textContent = viewName;

    document.getElementById('profile-record-id').textContent = recordId;

    // Reset configure mode
    profileConfigureMode = false;
    document.getElementById('profile-body').classList.remove('configure-mode');
    document.getElementById('profile-add-block-btn').style.display = 'none';
    document.getElementById('profile-configure-btn').innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg> Configure';

    // Reset to details tab
    profileCurrentTab = 'details';
    document.querySelectorAll('.profile-tab').forEach(function(tab) {
        tab.classList.toggle('active', tab.dataset.tab === 'details');
    });
    document.getElementById('profile-tab-details').classList.add('active');
    document.getElementById('profile-tab-sync-history').classList.remove('active');

    // Render profile content
    await renderRecordProfile();

    // Update navigation
    updateProfileNavigation();
}

// Close record profile panel
function closeRecordProfile(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('record-profile-overlay').classList.remove('open');
    closeFieldPicker();
    profileCurrentTableId = null;
    profileCurrentRecordId = null;
}

// Render the record profile content
async function renderRecordProfile() {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var body = document.getElementById('profile-body');
    var viewId = currentView || '_default';

    // Get record data
    var records = await getRecordsByIds(profileCurrentTableId, [profileCurrentRecordId]);
    if (records.length === 0) {
        body.innerHTML = '<div class="profile-empty-state">Record not found</div>';
        return;
    }

    var record = records[0];
    var recordFields = record.fields || {};
    var fields = META_FIELDS[profileCurrentTableId] || {};

    // Compute formula column values for this record
    _applyFormulaSingleRecord(profileCurrentTableId, fields, recordFields, profileCurrentRecordId);

    // Get profile configuration
    var profileResult = getProfileConfig(profileCurrentTableId, viewId);
    var config = profileResult.config;
    var isDefaultConfig = profileResult.isDefault;

    var html = '';

    config.blocks.forEach(function(block, blockIndex) {
        html += '<div class="profile-block" data-block-index="' + blockIndex + '">';

        // Block header (visible in configure mode)
        html += '<div class="profile-block-header">';
        html += '<span class="block-drag-handle" draggable="true" ondragstart="handleBlockDragStart(event, ' + blockIndex + ')" ondragover="handleBlockDragOver(event)" ondrop="handleBlockDrop(event, ' + blockIndex + ')">&#8942;&#8942;</span>';
        html += '<span class="block-title">Block ' + (blockIndex + 1) + '</span>';
        html += '<select class="block-cols-select" onchange="setBlockColumns(' + blockIndex + ', this.value)">';
        html += '<option value="1"' + (block.columns === 1 ? ' selected' : '') + '>1 column</option>';
        html += '<option value="2"' + (block.columns === 2 ? ' selected' : '') + '>2 columns</option>';
        html += '<option value="3"' + (block.columns === 3 ? ' selected' : '') + '>3 columns</option>';
        html += '</select>';
        html += '<button class="block-remove-btn" onclick="removeProfileBlock(' + blockIndex + ')" title="Remove block">&times;</button>';
        html += '</div>';

        // Block content
        html += '<div class="profile-block-content">';
        html += '<div class="profile-field-grid cols-' + block.columns + '">';

        block.fieldIds.forEach(function(fieldId, fieldIndex) {
            var field = fields[fieldId];
            var fieldName = field?.fieldName || fieldId;
            var value = recordFields[fieldId];
            if (value === undefined) value = recordFields[fieldName];

            // Skip fields with no data when using default config and not in configure mode
            var isEmpty = value == null || value === '' || (Array.isArray(value) && value.length === 0);
            if (isEmpty && isDefaultConfig && !profileConfigureMode) {
                return; // Skip this field
            }

            html += '<div class="profile-field-card" data-field-id="' + esc(fieldId) + '" data-block-index="' + blockIndex + '" data-field-index="' + fieldIndex + '" draggable="true" ondragstart="handleFieldDragStart(event)" ondragover="handleFieldDragOver(event)" ondragleave="handleFieldDragLeave(event)" ondrop="handleFieldDrop(event)">';
            var pfIsComputed = field && isComputedFieldType(field.fieldType);
            var pfIsReadOnly = !pfIsComputed && field && isReadOnlyField(field);
            html += '<div class="profile-field-name">';
            html += '<span class="field-drag-handle">&#8942;&#8942;</span>';
            html += esc(fieldName);
            if (pfIsComputed) {
                html += '<span class="formula-badge" onclick="event.stopPropagation(); showFormulaInfoPopover(this, META_FIELDS[\'' + esc(profileCurrentTableId) + '\'][\'' + esc(fieldId) + '\'])" title="Click to see formula details">' + esc(computedFieldLabel(field.fieldType)) + '</span>';
            } else if (pfIsReadOnly) {
                html += '<span class="readonly-badge" title="This field is read-only">' + esc(readOnlyFieldLabel(field)) + '</span>';
            }
            if (profileConfigureMode) {
                html += '<button style="margin-left: auto; background: none; border: none; color: #ccc; cursor: pointer; font-size: 12px;" onclick="removeFieldFromBlock(' + blockIndex + ', ' + fieldIndex + ')">&times;</button>';
            }
            html += '</div>';
            if (pfIsComputed) {
                // Formula fields: show value as read-only, click shows info popover
                if (isEmpty) {
                    html += '<div class="profile-field-value empty formula-readonly" data-edit-field-id="' + esc(fieldId) + '"></div>';
                } else {
                    html += '<div class="profile-field-value formula-readonly" data-edit-field-id="' + esc(fieldId) + '">' + formatCell(value) + '</div>';
                }
            } else if (pfIsReadOnly) {
                // Read-only fields: show value without edit handler
                if (isEmpty) {
                    html += '<div class="profile-field-value empty field-readonly" data-edit-field-id="' + esc(fieldId) + '"></div>';
                } else {
                    html += '<div class="profile-field-value field-readonly" data-edit-field-id="' + esc(fieldId) + '">' + formatCell(value) + '</div>';
                }
            } else if (isEmpty) {
                html += '<div class="profile-field-value empty" data-edit-field-id="' + esc(fieldId) + '" onclick="startProfileFieldEdit(this)"></div>';
            } else {
                html += '<div class="profile-field-value" data-edit-field-id="' + esc(fieldId) + '" onclick="startProfileFieldEdit(this)">' + formatCell(value) + '</div>';
            }
            html += '</div>';
        });

        html += '</div>'; // .profile-field-grid

        // Add field button (visible in configure mode)
        html += '<button class="profile-add-field-btn" onclick="showFieldPicker(event, ' + blockIndex + ')">+ Add Field</button>';

        html += '</div>'; // .profile-block-content
        html += '</div>'; // .profile-block
    });

    body.innerHTML = html;

    // Maintain configure mode if active
    if (profileConfigureMode) {
        body.classList.add('configure-mode');
    }
}

// Toggle configure mode
function toggleProfileConfigureMode() {
    profileConfigureMode = !profileConfigureMode;
    var body = document.getElementById('profile-body');
    var addBlockBtn = document.getElementById('profile-add-block-btn');
    var configureBtn = document.getElementById('profile-configure-btn');

    if (profileConfigureMode) {
        body.classList.add('configure-mode');
        addBlockBtn.style.display = '';
        configureBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"/></svg> Done';
    } else {
        body.classList.remove('configure-mode');
        addBlockBtn.style.display = 'none';
        configureBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg> Configure';
        closeFieldPicker();
    }

    renderRecordProfile();
}

// Set block columns
async function setBlockColumns(blockIndex, columns) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].columns = parseInt(columns);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Add a new block
async function addProfileBlock() {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    config.blocks.push({
        id: 'block-' + (config.blocks.length + 1) + '-' + Date.now(),
        columns: 2,
        fieldIds: []
    });

    await saveProfileConfig(profileCurrentTableId, viewId, config);
    renderRecordProfile();
}

// Remove a block
async function removeProfileBlock(blockIndex) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks.length > 1) {
        config.blocks.splice(blockIndex, 1);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Show field picker dropdown
function showFieldPicker(event, blockIndex) {
    event.stopPropagation();
    closeFieldPicker();

    var fields = META_FIELDS[profileCurrentTableId] || {};
    var fieldIds = Object.keys(fields);

    var picker = document.createElement('div');
    picker.className = 'profile-field-picker';
    picker.innerHTML = '<div class="profile-field-picker-header">Add Field</div>';

    fieldIds.sort(function(a, b) {
        var nameA = (fields[a]?.fieldName || a).toLowerCase();
        var nameB = (fields[b]?.fieldName || b).toLowerCase();
        return nameA.localeCompare(nameB);
    });

    fieldIds.forEach(function(fieldId) {
        var field = fields[fieldId];
        var fieldName = field?.fieldName || fieldId;
        var fieldType = field?.fieldType || 'text';

        var item = document.createElement('div');
        item.className = 'profile-field-picker-item';
        item.innerHTML = '<span>' + esc(fieldName) + '</span><span class="field-type-badge">' + esc(fieldType) + '</span>';
        item.onclick = function() {
            addFieldToBlock(blockIndex, fieldId);
            closeFieldPicker();
        };
        picker.appendChild(item);
    });

    // Position the picker
    var rect = event.target.getBoundingClientRect();
    picker.style.left = rect.left + 'px';
    picker.style.top = (rect.bottom + 4) + 'px';

    document.body.appendChild(picker);
    profileFieldPicker = picker;

    // Close on outside click
    setTimeout(function() {
        document.addEventListener('click', closeFieldPickerOnOutsideClick);
    }, 0);
}

function closeFieldPickerOnOutsideClick(event) {
    if (profileFieldPicker && !profileFieldPicker.contains(event.target)) {
        closeFieldPicker();
    }
}

function closeFieldPicker() {
    if (profileFieldPicker) {
        profileFieldPicker.remove();
        profileFieldPicker = null;
        document.removeEventListener('click', closeFieldPickerOnOutsideClick);
    }
}

// Add field to a block
async function addFieldToBlock(blockIndex, fieldId) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].fieldIds.push(fieldId);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Remove field from a block
async function removeFieldFromBlock(blockIndex, fieldIndex) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].fieldIds.splice(fieldIndex, 1);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Field drag and drop
var profileDragData = null;

function handleFieldDragStart(event) {
    if (!profileConfigureMode) {
        event.preventDefault();
        return;
    }
    var card = event.target.closest('.profile-field-card');
    profileDragData = {
        type: 'field',
        blockIndex: parseInt(card.dataset.blockIndex),
        fieldIndex: parseInt(card.dataset.fieldIndex),
        fieldId: card.dataset.fieldId
    };
    card.classList.add('dragging');
    event.dataTransfer.effectAllowed = 'move';
}

function handleFieldDragOver(event) {
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'field') return;
    event.preventDefault();
    var card = event.target.closest('.profile-field-card');
    if (card) {
        card.classList.add('drag-over');
    }
}

function handleFieldDragLeave(event) {
    var card = event.target.closest('.profile-field-card');
    if (card) {
        card.classList.remove('drag-over');
    }
}

async function handleFieldDrop(event) {
    event.preventDefault();
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'field') return;

    var targetCard = event.target.closest('.profile-field-card');
    if (!targetCard) return;

    var targetBlockIndex = parseInt(targetCard.dataset.blockIndex);
    var targetFieldIndex = parseInt(targetCard.dataset.fieldIndex);

    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    // Remove from source
    var fieldId = config.blocks[profileDragData.blockIndex].fieldIds.splice(profileDragData.fieldIndex, 1)[0];

    // Adjust target index if in same block and after source
    if (targetBlockIndex === profileDragData.blockIndex && targetFieldIndex > profileDragData.fieldIndex) {
        targetFieldIndex--;
    }

    // Insert at target
    config.blocks[targetBlockIndex].fieldIds.splice(targetFieldIndex, 0, fieldId);

    await saveProfileConfig(profileCurrentTableId, viewId, config);

    profileDragData = null;
    renderRecordProfile();
}

// Block drag and drop
function handleBlockDragStart(event, blockIndex) {
    if (!profileConfigureMode) {
        event.preventDefault();
        return;
    }
    profileDragData = {
        type: 'block',
        blockIndex: blockIndex
    };
    event.dataTransfer.effectAllowed = 'move';
}

function handleBlockDragOver(event) {
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'block') return;
    event.preventDefault();
}

async function handleBlockDrop(event, targetBlockIndex) {
    event.preventDefault();
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'block') return;

    if (targetBlockIndex === profileDragData.blockIndex) return;

    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    // Remove from source
    var block = config.blocks.splice(profileDragData.blockIndex, 1)[0];

    // Adjust target index if after source
    if (targetBlockIndex > profileDragData.blockIndex) {
        targetBlockIndex--;
    }

    // Insert at target
    config.blocks.splice(targetBlockIndex, 0, block);

    await saveProfileConfig(profileCurrentTableId, viewId, config);

    profileDragData = null;
    renderRecordProfile();
}

// ============ Inline Field Editing ============

var profileEditingFieldId = null;
var _profileEditCommitExplicit = false;

async function startProfileFieldEdit(element) {
    if (profileConfigureMode) return;
    if (profileEditingFieldId) return;

    // Don't edit if clicking a link
    if (event && event.target.tagName === 'A') return;

    var fieldId = element.dataset.editFieldId;
    if (!fieldId) return;

    // Don't edit formula/computed/read-only fields
    var pfField = META_FIELDS[profileCurrentTableId]?.[fieldId];
    if (pfField && isReadOnlyField(pfField)) return;

    profileEditingFieldId = fieldId;

    // Get current record data
    var records = await getRecordsByIds(profileCurrentTableId, [profileCurrentRecordId]);
    if (records.length === 0) { profileEditingFieldId = null; return; }

    var record = records[0];
    var recordFields = record.fields || {};
    var field = META_FIELDS[profileCurrentTableId]?.[fieldId];
    var fieldType = field?.fieldType || 'text';

    // Resolve the value (try fieldId first, then fieldName)
    var currentValue = recordFields[fieldId];
    if (currentValue === undefined && field?.fieldName) {
        currentValue = recordFields[field.fieldName];
    }

    var input;
    if (fieldType === 'checkbox' || typeof currentValue === 'boolean') {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = !!currentValue;
        input.className = 'profile-edit-checkbox';
        input.onchange = function() {
            _profileEditCommitExplicit = true;
            commitProfileFieldEdit(fieldId, input.checked, currentValue);
        };
    } else if (Array.isArray(currentValue) || (typeof currentValue === 'object' && currentValue !== null)) {
        input = document.createElement('textarea');
        input.className = 'profile-edit-input';
        input.value = JSON.stringify(currentValue, null, 2);
        input.rows = 4;
    } else {
        var strValue = currentValue != null ? String(currentValue) : '';
        if (strValue.length > 100 || strValue.includes('\n')) {
            input = document.createElement('textarea');
            input.className = 'profile-edit-input';
            input.value = strValue;
            input.rows = 3;
        } else {
            input = document.createElement('input');
            input.type = (fieldType === 'number' || typeof currentValue === 'number') ? 'number' : 'text';
            input.className = 'profile-edit-input';
            input.value = strValue;
        }
    }

    if (input.type !== 'checkbox') {
        input.onkeydown = function(e) {
            if (e.key === 'Enter' && !e.shiftKey && input.tagName !== 'TEXTAREA') {
                e.preventDefault();
                _profileEditCommitExplicit = true;
                commitProfileFieldEdit(fieldId, parseProfileEditValue(input.value, currentValue, fieldType), currentValue);
            }
            if (e.key === 'Escape') {
                cancelProfileFieldEdit();
            }
        };
        input.onblur = function() {
            setTimeout(function() {
                if (profileEditingFieldId === fieldId) {
                    _profileEditCommitExplicit = false;
                    commitProfileFieldEdit(fieldId, parseProfileEditValue(input.value, currentValue, fieldType), currentValue);
                }
            }, 150);
        };
    }

    element.innerHTML = '';
    element.appendChild(input);
    element.classList.add('editing');

    input.focus();
    if (input.select) input.select();
}

function parseProfileEditValue(strValue, originalValue, fieldType) {
    if (strValue === '') return '';

    if (typeof originalValue === 'number' || fieldType === 'number') {
        var num = Number(strValue);
        if (!isNaN(num)) return num;
    }

    if (Array.isArray(originalValue) || (typeof originalValue === 'object' && originalValue !== null)) {
        try { return JSON.parse(strValue); } catch (e) { return strValue; }
    }

    return strValue;
}

async function commitProfileFieldEdit(fieldId, newValue, originalValueFromInput) {
    if (!profileEditingFieldId) return;
    var wasExplicit = _profileEditCommitExplicit;
    _profileEditCommitExplicit = false;

    var tableId = profileCurrentTableId;
    var recordId = profileCurrentRecordId;
    if (!tableId || !recordId) { profileEditingFieldId = null; return; }

    // Safety: if the edit would clear a non-empty field and the commit was
    // triggered by blur (not an explicit Enter), cancel instead of saving.
    var preEditValue = originalValueFromInput;
    var wouldClear = (newValue === '' || newValue === null || newValue === undefined) &&
                     preEditValue != null && preEditValue !== '' &&
                     !(typeof preEditValue === 'boolean');
    if (wouldClear && !wasExplicit) {
        profileEditingFieldId = null;
        renderRecordProfile();
        return;
    }

    profileEditingFieldId = null;

    // Get current record
    var records = await getRecordsByIds(tableId, [recordId]);
    if (records.length === 0) return;

    var record = records[0];
    var recordFields = record.fields || {};
    var field = META_FIELDS[tableId]?.[fieldId];

    // Determine the key used in the record fields
    var fieldKey = fieldId;
    var oldValue = recordFields[fieldId];
    if (oldValue === undefined && field?.fieldName && recordFields[field.fieldName] !== undefined) {
        fieldKey = field.fieldName;
        oldValue = recordFields[fieldKey];
    }

    // Skip if value hasn't changed
    if (JSON.stringify(oldValue) === JSON.stringify(newValue)) {
        renderRecordProfile();
        return;
    }

    // Save field history locally (optimistic  before server call)
    await saveFieldHistory([{
        tableId: tableId,
        recordId: recordId,
        fieldId: fieldId,
        eventId: null,
        timestamp: Date.now(),
        changeType: 'updated',
        oldValue: oldValue !== undefined ? oldValue : null,
        newValue: newValue
    }]);

    // Build the field changes payload using the field key (name or id)
    var fieldChanges = {};
    fieldChanges[fieldKey] = newValue;

    // Use editRecord for optimistic write + server sync.
    // editRecord handles IndexedDB update, API call, offline queue, and
    // dispatches amino:record-updated which re-renders the UI.
    try {
        var result = await editRecord(tableId, recordId, fieldChanges);
        if (result && result.queued) {
            // Edit was queued offline  don't show undo toast
        } else {
            // Show undo toast after successful save
            showUndoToast(tableId, recordId, fieldId, fieldKey, oldValue);
        }
    } catch (err) {
        console.error('[WriteAPI] Edit failed for', recordId, fieldKey, err);
        // editRecord already handled rollback/queue and showed error toast.
        renderRecordProfile();
    }
}

function cancelProfileFieldEdit() {
    profileEditingFieldId = null;
    renderRecordProfile();
}

// ============ Toast Notifications ============

function showToast(type, message, durationMs) {
    var container = document.getElementById('toast-container');
    if (!container) return;

    if (durationMs === undefined) {
        durationMs = type === 'error' ? 0 : (type === 'saving' ? 2000 : 3000);
    }

    var toast = document.createElement('div');
    toast.className = 'toast toast-' + type;

    if (type === 'saving') {
        toast.innerHTML = '<div class="toast-spinner"></div>';
    }

    var span = document.createElement('span');
    span.textContent = message;
    toast.appendChild(span);

    if (type === 'error' || durationMs === 0) {
        var btn = document.createElement('button');
        btn.className = 'toast-dismiss';
        btn.innerHTML = '&times;';
        btn.onclick = function() { dismissToast(toast); };
        toast.appendChild(btn);
    }

    container.appendChild(toast);

    if (durationMs > 0) {
        setTimeout(function() { dismissToast(toast); }, durationMs);
    }

    return toast;
}

function dismissToast(toast) {
    if (!toast || toast.classList.contains('removing')) return;
    toast.classList.add('removing');
    toast.addEventListener('animationend', function() {
        if (toast.parentNode) toast.parentNode.removeChild(toast);
    });
    // Fallback removal
    setTimeout(function() {
        if (toast.parentNode) toast.parentNode.removeChild(toast);
    }, 300);
}

// ============ Undo Toast ============

function showUndoToast(tableId, recordId, fieldId, fieldKey, previousValue) {
    var container = document.getElementById('toast-container');
    if (!container) return;

    var toast = document.createElement('div');
    toast.className = 'toast toast-undo';

    var span = document.createElement('span');
    span.textContent = 'Field updated';
    toast.appendChild(span);

    var undoBtn = document.createElement('button');
    undoBtn.className = 'toast-undo-btn';
    undoBtn.textContent = 'Undo';
    var undoUsed = false;
    undoBtn.onclick = function() {
        if (undoUsed) return;
        undoUsed = true;
        dismissToast(toast);
        // Revert the field to its previous value
        var revertChanges = {};
        revertChanges[fieldKey] = previousValue !== undefined ? previousValue : null;
        editRecord(tableId, recordId, revertChanges).then(function() {
            showToast('success', 'Change reverted');
        }).catch(function(err) {
            console.error('[Undo] Revert failed', err);
        });
    };
    toast.appendChild(undoBtn);

    var dismissBtn = document.createElement('button');
    dismissBtn.className = 'toast-dismiss';
    dismissBtn.innerHTML = '&times;';
    dismissBtn.onclick = function() { dismissToast(toast); };
    toast.appendChild(dismissBtn);

    container.appendChild(toast);

    // Auto-dismiss after 5 seconds
    setTimeout(function() { dismissToast(toast); }, 5000);

    return toast;
}

// ============ Write API  editRecord ============

var WRITE_API_BASE = 'https://n8n.intelechia.com/webhook/amino-write';

async function editRecord(tableId, recordId, fieldChanges) {
    var session = _loadSynapseSession();
    if (!session || !session.accessToken) {
        throw new Error('Not authenticated  cannot save to server');
    }

    //  Stage 1: Optimistic local update 
    var previousRecord = await getRecord(tableId, recordId);
    if (!previousRecord) {
        throw new Error('Record not found in local store');
    }
    var previousFields = previousRecord.fields || {};
    var optimisticFields = {};
    for (var k in previousFields) {
        optimisticFields[k] = previousFields[k];
    }
    for (var k2 in fieldChanges) {
        optimisticFields[k2] = fieldChanges[k2];
    }

    // Write optimistic state to IndexedDB immediately
    await saveDataRecord({
        tableId: tableId,
        recordId: recordId,
        fields: optimisticFields
    });

    // Update in-memory data if present
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
        for (var k3 in fieldChanges) {
            window.IN_MEMORY_DATA[tableId][recordId][k3] = fieldChanges[k3];
        }
    }

    // Dispatch optimistic UI update
    window.dispatchEvent(new CustomEvent('amino:record-updated', {
        detail: { recordId: recordId, tableId: tableId, fields: optimisticFields, optimistic: true }
    }));

    // Toast: saving
    var savingToast = showToast('saving', 'Saving...');
    var editStartTime = Date.now();
    var changedFieldCount = Object.keys(fieldChanges).length;

    try {
        //  Stage 2: Write to server 
        // Flat endpoint: PATCH /webhook/amino-write with {tableId, recordId, fields} in body
        var writeUrl = WRITE_API_BASE;
        var writeBody = JSON.stringify({ tableId: tableId, recordId: recordId, fields: fieldChanges });
        var response;

        try {
            response = await fetch(
                writeUrl + '?access_token=' + encodeURIComponent(session.accessToken),
                {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: writeBody
                }
            );
        } catch (patchErr) {
            // CORS preflight failure  retry with header auth
            console.warn('[editRecord] Query-param PATCH failed (' + patchErr.message + '), retrying with header auth');
            response = await fetch(writeUrl, {
                method: 'PATCH',
                headers: {
                    'Authorization': 'Bearer ' + session.accessToken,
                    'Content-Type': 'application/json'
                },
                body: writeBody
            });
        }

        // Dismiss the saving toast
        dismissToast(savingToast);

        if (!response.ok) {
            throw new Error('Server returned ' + response.status);
        }

        var result = await response.json();

        //  Stage 3: Confirm with canonical data 
        if (result.fields) {
            await saveDataRecord({
                tableId: tableId,
                recordId: recordId,
                fields: result.fields
            });

            // Update in-memory data with canonical snapshot
            if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
                window.IN_MEMORY_DATA[tableId][recordId] = result.fields;
            }

            // Dispatch canonical UI update
            window.dispatchEvent(new CustomEvent('amino:record-updated', {
                detail: { recordId: recordId, tableId: tableId, fields: result.fields, optimistic: false }
            }));
        }

        // Matrix event is NOT sent from the client  n8n handles it after
        // writing to Airtable, ensuring the event only fires on successful
        // Airtable write and keeping Postgres current_state consistent.

        // Record successful local edit in sync history
        var editDuration = Date.now() - editStartTime;
        SyncHistory.record({
            type: 'edit',
            result: 'success',
            eventsFound: changedFieldCount,
            duration: editDuration,
            detail: 'Local edit propagated: ' + recordId + ' (' + changedFieldCount + ' field' + (changedFieldCount !== 1 ? 's' : '') + ')'
        });
        SyncStatusFeed.success('Edit propagated: ' + recordId + ' \u2192 ' + changedFieldCount + ' field' + (changedFieldCount !== 1 ? 's' : '') + ' updated (' + editDuration + 'ms)');

        showToast('success', 'Saved \u2713');
        return result;

    } catch (err) {
        // Dismiss saving toast if still visible
        dismissToast(savingToast);

        //  Stage 4: Queue for offline retry instead of rolling back 
        // Keep the optimistic local data so the user sees their edit.
        // Enqueue the edit so it can be replayed when connectivity returns.
        try {
            await OfflineSyncQueue.enqueue(tableId, recordId, fieldChanges, err.message);
        } catch (queueErr) {
            console.error('[editRecord] Failed to enqueue offline edit:', queueErr);
            // If we can't even queue, roll back as last resort
            await saveDataRecord({ tableId: tableId, recordId: recordId, fields: previousFields });
            if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
                window.IN_MEMORY_DATA[tableId][recordId] = previousFields;
            }
            window.dispatchEvent(new CustomEvent('amino:record-updated', {
                detail: { recordId: recordId, tableId: tableId, fields: previousFields, optimistic: false, rolledBack: true }
            }));
            showToast('error', 'Save failed \u2014 please try again');
            throw err;
        }

        // Record the queued edit in sync history
        var editDuration = Date.now() - editStartTime;
        SyncHistory.record({
            type: 'edit',
            result: 'queued',
            eventsFound: changedFieldCount,
            duration: editDuration,
            error: err.message,
            detail: 'Edit queued offline: ' + recordId + ' \u2014 ' + err.message
        });

        showToast('warning', 'Saved locally \u2014 will sync when online');
        return { queued: true, recordId: recordId, tableId: tableId };
    }
}

// ============ Record Update Event Listener ============

window.addEventListener('amino:record-updated', function(e) {
    var detail = e.detail;
    if (!detail || !detail.tableId || !detail.recordId) return;

    // Re-render the record profile if it's showing this record
    if (profileCurrentTableId === detail.tableId && profileCurrentRecordId === detail.recordId) {
        renderRecordProfile();
    }

    // Re-render the table grid if showing the same table
    if (currentTable === detail.tableId) {
        // If an inline edit just committed, update only the affected cells instead of a full re-render.
        // This prevents destroying any active editing state and avoids visual flicker.
        if (_inlineEditJustCommitted) {
            _inlineEditJustCommitted = false;
            // Update all cells for this record in the DOM without a full re-render
            var row = document.querySelector('tr[data-record-id="' + CSS.escape(detail.recordId) + '"]');
            if (row) {
                var cells = row.querySelectorAll('td.inline-editable, td.cell-formula, td.cell-readonly');
                cells.forEach(function(cell) {
                    // Skip cell currently being edited
                    if (cell === _inlineEditingCell) return;
                    var fid = cell.dataset.fieldId;
                    if (fid && detail.fields) {
                        var val = detail.fields[fid];
                        if (val === undefined) {
                            // Try field name
                            var f = META_FIELDS[detail.tableId]?.[fid];
                            if (f?.fieldName) val = detail.fields[f.fieldName];
                        }
                        cell.innerHTML = formatCell(val);
                    }
                });
            }
            return;
        }
        // Clear inline editing cell before full re-render to avoid stale DOM
        _inlineEditingCell = null;
        renderTable();
    }
});

// ============ Live Field History from Matrix Sync ============

window.addEventListener('amino:record-mutate', function(e) {
    var d = e.detail;
    if (!d || !d.tableId || !d.recordId) return;

    var entries = [];
    var tableId = d.tableId;
    var recordId = d.recordId;
    var eventId = d.eventId || null;
    var timestamp = d.timestamp || Date.now();
    var sender = d.sender || null;
    var source = d.source || null;
    var sourceTimestamp = d.sourceTimestamp || null;
    var actor = d.actor || null;
    var fieldOps = d.fieldOps || {};
    var hasStructuredOps = !!(fieldOps.ALT || fieldOps.INS || fieldOps.NUL || fieldOps.SYN);

    // Common metadata for each history entry
    var baseMeta = {
        tableId: tableId, recordId: recordId,
        eventId: eventId, timestamp: timestamp, sender: sender,
        source: source, sourceTimestamp: sourceTimestamp, actor: actor
    };

    if (hasStructuredOps) {
        if (fieldOps.INS) {
            for (var fid in fieldOps.INS) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: fid, changeType: 'created', oldValue: null, newValue: fieldOps.INS[fid] }));
            }
        }
        if (fieldOps.ALT) {
            for (var fid in fieldOps.ALT) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: fid, changeType: 'updated', oldValue: null, newValue: fieldOps.ALT[fid] }));
            }
        }
        if (fieldOps.SYN) {
            for (var fid in fieldOps.SYN) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: fid, changeType: 'synced', oldValue: null, newValue: fieldOps.SYN[fid] }));
            }
        }
        if (fieldOps.NUL) {
            var nulFields = Array.isArray(fieldOps.NUL) ? fieldOps.NUL : Object.keys(fieldOps.NUL);
            for (var n = 0; n < nulFields.length; n++) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: nulFields[n], changeType: 'deleted', oldValue: null, newValue: null }));
            }
        }
    } else if (d.flatOp && d.flatFields) {
        var op = d.flatOp;
        var ff = d.flatFields;
        if (op === 'INS' || op === 'ALT') {
            var ct = op === 'INS' ? 'created' : 'updated';
            for (var fid in ff) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: fid, changeType: ct, oldValue: null, newValue: ff[fid] }));
            }
        } else if (op === 'NUL') {
            var rk = Array.isArray(ff) ? ff : Object.keys(ff);
            for (var r = 0; r < rk.length; r++) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: rk[r], changeType: 'deleted', oldValue: null, newValue: null }));
            }
        }
    }

    if (entries.length > 0) {
        saveFieldHistory(entries).catch(function(err) {
            console.error('[History] Error saving live field history:', err);
        });

        // Refresh sync history tab if currently viewing this record
        if (profileCurrentTab === 'sync-history' &&
            profileCurrentTableId === tableId &&
            profileCurrentRecordId === recordId) {
            renderProfileSyncHistory();
        }
    }
});

// Navigation between records
function updateProfileNavigation() {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var recordIndex = currentRecordIds.indexOf(profileCurrentRecordId);
    var total = currentRecordIds.length;

    document.getElementById('profile-nav-info').textContent = (recordIndex + 1) + ' of ' + total;
    document.getElementById('profile-prev-btn').disabled = recordIndex <= 0;
    document.getElementById('profile-next-btn').disabled = recordIndex >= total - 1;
}

async function navigateProfile(direction) {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var recordIndex = currentRecordIds.indexOf(profileCurrentRecordId);
    var newIndex = recordIndex + direction;

    if (newIndex >= 0 && newIndex < currentRecordIds.length) {
        profileCurrentRecordId = currentRecordIds[newIndex];
        document.getElementById('profile-record-id').textContent = profileCurrentRecordId;
        await renderRecordProfile();
        updateProfileNavigation();

        // Refresh sync history if that tab is active
        if (profileCurrentTab === 'sync-history') {
            renderProfileSyncHistory();
        }
    }
}

// Open history from profile
function openHistoryFromProfile() {
    if (profileCurrentTableId && profileCurrentRecordId) {
        openHistoryModal(profileCurrentTableId, profileCurrentRecordId);
    }
}

// Profile tab state
var profileCurrentTab = 'details';

// Switch profile tab
function switchProfileTab(tabName) {
    profileCurrentTab = tabName;

    // Update tab buttons
    document.querySelectorAll('.profile-tab').forEach(function(tab) {
        if (tab.dataset.tab === tabName) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // Update tab content
    document.querySelectorAll('.profile-tab-content').forEach(function(content) {
        content.classList.remove('active');
    });

    if (tabName === 'details') {
        document.getElementById('profile-tab-details').classList.add('active');
    } else if (tabName === 'sync-history') {
        document.getElementById('profile-tab-sync-history').classList.add('active');
        renderProfileSyncHistory();
    }
}

// Build field history entries from raw events (used for in-memory events from CSV)
function buildFieldHistoryFromRawEvents(tableId, recordId, events) {
    // Sort events by id ascending (oldest first for proper state tracking)
    var sorted = events.slice().sort((a, b) => (a.id || 0) - (b.id || 0));

    var state = {};
    var fieldHistoryEntries = [];

    for (var e of sorted) {
        if (!e || !e.recordId || e.recordId !== recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var pfields = payload.fields;
        if (!pfields || typeof pfields !== 'object') continue;

        var eventId = e.id;
        var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

        // Process INS (insert/create)
        if (pfields.INS) {
            for (var fieldId in pfields.INS) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'created',
                    oldValue: null,
                    newValue: pfields.INS[fieldId]
                });
            }
            Object.assign(state, pfields.INS);
        }

        // Process ALT (alter/update)
        if (pfields.ALT) {
            for (var fieldId in pfields.ALT) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'updated',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: pfields.ALT[fieldId]
                });
            }
            Object.assign(state, pfields.ALT);
        }

        // Process SYN (sync/snapshot)
        if (pfields.SYN) {
            for (var fieldId in pfields.SYN) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'synced',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: pfields.SYN[fieldId]
                });
            }
            Object.assign(state, pfields.SYN);
        }

        // Process NUL (nullify/delete)
        if (pfields.NUL && Array.isArray(pfields.NUL)) {
            pfields.NUL.forEach(fieldId => {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'deleted',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: null
                });
                delete state[fieldId];
            });
        }
    }

    // Return sorted by eventId descending (most recent first) for display
    return fieldHistoryEntries.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
}

// Render sync history in the profile tab
async function renderProfileSyncHistory() {
    var container = document.getElementById('profile-tab-sync-history');
    if (!profileCurrentTableId || !profileCurrentRecordId) {
        container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No record selected</h3><p>Select a record to view its sync history</p></div>';
        return;
    }

    // Show loading state
    container.innerHTML = '<div class="profile-sync-history-empty"><div class="loading-spinner"></div><h3>Loading sync history...</h3></div>';

    try {
        var history;

        // Check if we have in-memory events (from CSV import) - use them for instant display
        if (inMemoryEventsByRecord && inMemoryEventsByRecord.has(profileCurrentRecordId)) {
            var rawEvents = inMemoryEventsByRecord.get(profileCurrentRecordId);
            history = buildFieldHistoryFromRawEvents(profileCurrentTableId, profileCurrentRecordId, rawEvents);
            // Limit to 100 most recent entries
            if (history.length > 100) {
                history = history.slice(0, 100);
            }
        } else {
            // Fall back to API + IndexedDB when no in-memory events
            await fetchAndProcessHistoryForRecord(profileCurrentTableId, profileCurrentRecordId);
            // Get history from IndexedDB
            history = await getFieldHistoryForRecord(profileCurrentTableId, profileCurrentRecordId, 100);
        }

        if (!history || history.length === 0) {
            container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No sync history available for this record</h3><p>Field changes will appear here after syncing</p></div>';
            return;
        }

        // Get field metadata
        var fields = META_FIELDS[profileCurrentTableId] || {};

        // Render history items
        var html = '<div class="profile-sync-history-list">';

        history.forEach(function(item) {
            var fieldName = fields[item.fieldId]?.fieldName || item.fieldId;
            var changeType = item.changeType || 'updated';
            var timestamp = item.timestamp ? new Date(item.timestamp).toLocaleString() : 'Unknown';
            var sender = item.sender || null;
            // Show short sender (strip @...:server part to just the localpart)
            var senderDisplay = sender ? sender.replace(/^@/, '').replace(/:.*$/, '') : null;
            // Extract source metadata (e.g. "airtable_sync") and actor (e.g. "admin@rklacylaw.com")
            var source = item.source || null;
            var actor = item.actor || null;
            var sourceTimestamp = item.sourceTimestamp ? new Date(item.sourceTimestamp).toLocaleString() : null;

            html += '<div class="profile-sync-history-item">';
            html += '<div class="profile-sync-history-item-header">';
            html += '<span class="profile-sync-history-field">' + esc(fieldName) + '</span>';
            html += '<span class="profile-sync-history-type ' + changeType + '">' + changeType.charAt(0).toUpperCase() + changeType.slice(1) + '</span>';
            if (actor) {
                html += '<span class="profile-sync-history-actor" title="Changed by">' + esc(actor) + '</span>';
            } else if (senderDisplay) {
                html += '<span class="profile-sync-history-sender">' + esc(senderDisplay) + '</span>';
            }
            if (source) {
                html += '<span class="profile-sync-history-source" title="Source: ' + esc(source) + '">' + esc(source.replace(/_/g, ' ')) + '</span>';
            }
            html += '<span class="profile-sync-history-time" title="' + (sourceTimestamp ? 'Source: ' + esc(sourceTimestamp) : '') + '">' + esc(timestamp) + '</span>';
            html += '</div>';

            if (changeType !== 'created' || item.oldValue != null) {
                html += '<div class="profile-sync-history-values">';
                if (item.oldValue != null) {
                    html += '<div class="profile-sync-history-value old">';
                    html += '<div class="profile-sync-history-value-label">Old</div>';
                    html += formatSyncHistoryValue(item.oldValue);
                    html += '</div>';
                }
                if (item.newValue != null) {
                    html += '<div class="profile-sync-history-value new">';
                    html += '<div class="profile-sync-history-value-label">New</div>';
                    html += formatSyncHistoryValue(item.newValue);
                    html += '</div>';
                }
                html += '</div>';
            } else if (item.newValue != null) {
                html += '<div class="profile-sync-history-values">';
                html += '<div class="profile-sync-history-value new">';
                html += '<div class="profile-sync-history-value-label">Value</div>';
                html += formatSyncHistoryValue(item.newValue);
                html += '</div>';
                html += '</div>';
            }

            html += '</div>';
        });

        html += '</div>';
        container.innerHTML = html;

    } catch (err) {
        console.error('Error loading sync history:', err);
        container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>Error loading sync history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Format sync history value for display
function formatSyncHistoryValue(value) {
    if (value == null) return '<em>empty</em>';
    if (typeof value === 'object') {
        return esc(JSON.stringify(value));
    }
    return esc(String(value));
}

// Handle row click to open profile
function handleRowClick(event, tableId, recordId) {
    // Don't open profile if clicking on a button, link, or interactive element
    if (event.target.closest('button, a, input, select, textarea')) {
        return;
    }
    openRecordProfile(tableId, recordId);
}

// Double-click opens the record profile panel (modal on right)
function handleRowDblClick(event, tableId, recordId) {
    if (event.target.closest('button, a, input, select, textarea')) return;
    // Cancel any pending inline edit on this cell
    var cell = event.target.closest('td.inline-editable');
    if (cell && cell.classList.contains('inline-editing')) {
        cancelInlineCellEdit(cell);
    }
    openRecordProfile(tableId, recordId);
}

// ============ Computed / Formula Field Detection ============

// Airtable field types that are computed (read-only, not user-editable)
var COMPUTED_FIELD_TYPES = ['formula', 'rollup', 'lookup', 'count', 'autoNumber', 'createdTime', 'lastModifiedTime', 'createdBy', 'lastModifiedBy'];

// Additional Airtable field types that are inherently read-only (not computed, but not editable)
var READONLY_FIELD_TYPES = ['button', 'externalSyncSource'];

function isComputedFieldType(fieldType) {
    return COMPUTED_FIELD_TYPES.indexOf(fieldType) !== -1;
}

// Check if a field is read-only (not editable). This includes:
// - Computed field types (formula, rollup, lookup, etc.)
// - Explicitly read-only fields (readOnly flag from Airtable API)
// - Inherently non-editable field types (button, externalSyncSource)
function isReadOnlyField(field) {
    if (!field) return false;
    if (field.readOnly === true) return true;
    if (isComputedFieldType(field.fieldType)) return true;
    if (READONLY_FIELD_TYPES.indexOf(field.fieldType) !== -1) return true;
    return false;
}

// Get a human-readable label for why a field is read-only
function readOnlyFieldLabel(field) {
    if (!field) return 'Read-only';
    if (isComputedFieldType(field.fieldType)) return computedFieldLabel(field.fieldType);
    if (READONLY_FIELD_TYPES.indexOf(field.fieldType) !== -1) {
        var rtLabels = { button: 'Button', externalSyncSource: 'Sync Source' };
        return rtLabels[field.fieldType] || field.fieldType;
    }
    return 'Read-only';
}

// Get a human-readable label for a computed field type
function computedFieldLabel(fieldType) {
    var labels = { formula: 'Formula', rollup: 'Rollup', lookup: 'Lookup', count: 'Count', autoNumber: 'Auto Number', createdTime: 'Created Time', lastModifiedTime: 'Modified Time', createdBy: 'Created By', lastModifiedBy: 'Modified By' };
    return labels[fieldType] || fieldType;
}

// ============ Formula Column Computation ============
// Compute formula-type column values for every record in a recordMap.
// Uses the formula engine exposed by src/formulas/bridge.js (ES module).
// Called from renderTable() and renderRecordProfile() so that ALL rows
// display computed formula values, not just rows that had values stored.

var _compiledFormulaCache = {};   // tableId -> { fieldId -> { fn, deps, fieldName } }
var _compiledFormulaCacheKey = ''; // invalidation key

function _applyFormulaColumns(tableId, fields, recordMap) {
    var engine = window._formulaEngine;
    if (!engine) return;

    // Collect formula fields for this table
    var formulaFields = [];
    for (var fid in fields) {
        var f = fields[fid];
        if (f.fieldType === 'formula' && f.options && f.options.formula) {
            formulaFields.push(f);
        }
    }
    if (formulaFields.length === 0) return;

    // Build / reuse compiled formula cache per table
    var cacheKey = tableId + ':' + formulaFields.map(function(f) { return f.fieldId; }).join(',');
    var cached = _compiledFormulaCache[tableId];
    if (!cached || _compiledFormulaCacheKey !== cacheKey) {
        cached = {};
        var compiledList = [];
        for (var i = 0; i < formulaFields.length; i++) {
            var f = formulaFields[i];
            try {
                var ast = engine.parseAirtableFormula(f.options.formula);
                var refs = engine.collectFieldRefs(ast);
                var fn = engine.compileFormula(ast);
                var entry = { fieldId: f.fieldId, fieldName: f.fieldName, fn: fn, deps: refs };
                cached[f.fieldId] = entry;
                compiledList.push(entry);
            } catch (e) {
                console.warn('Formula compile error for ' + (f.fieldName || f.fieldId) + ':', e.message);
            }
        }

        // Topological sort so dependent formulas execute after their inputs
        var sorted = [];
        var visited = {};
        var visiting = {};
        function visit(entry) {
            if (visited[entry.fieldId]) return;
            if (visiting[entry.fieldId]) return; // circular  skip
            visiting[entry.fieldId] = true;
            for (var j = 0; j < entry.deps.length; j++) {
                var dep = entry.deps[j];
                // dep could be a fieldId or fieldName; check both
                var depEntry = cached[dep];
                if (!depEntry) {
                    // Try matching by fieldName
                    for (var k in cached) {
                        if (cached[k].fieldName === dep) { depEntry = cached[k]; break; }
                    }
                }
                if (depEntry) visit(depEntry);
            }
            delete visiting[entry.fieldId];
            visited[entry.fieldId] = true;
            sorted.push(entry);
        }
        for (var i = 0; i < compiledList.length; i++) visit(compiledList[i]);

        cached._sorted = sorted;
        _compiledFormulaCache[tableId] = cached;
        _compiledFormulaCacheKey = cacheKey;
    }

    var sorted = cached._sorted;
    if (!sorted || sorted.length === 0) return;

    // Execute every formula on every record in dependency order
    for (var rid in recordMap) {
        var row = recordMap[rid];
        for (var i = 0; i < sorted.length; i++) {
            var c = sorted[i];
            try {
                var value = c.fn(row, { recordId: rid });
                if (value !== null && value !== undefined && !(value && value.__error)) {
                    row[c.fieldId] = value;
                    if (c.fieldName && c.fieldName !== c.fieldId) {
                        row[c.fieldName] = value;
                    }
                }
            } catch (_e) {
                // Formula runtime error  leave cell empty
            }
        }
    }
}

// Compute formula values for a single record (used by profile view).
// Returns augmented copy of recordFields.
function _applyFormulaSingleRecord(tableId, fields, recordFields, recordId) {
    var engine = window._formulaEngine;
    if (!engine) return recordFields;

    // Use the same cache built by _applyFormulaColumns
    var cached = _compiledFormulaCache[tableId];
    if (!cached || !cached._sorted) {
        // Build cache by running _applyFormulaColumns with a temp map
        var tmp = {};
        tmp[recordId] = recordFields;
        _applyFormulaColumns(tableId, fields, tmp);
        return tmp[recordId];
    }

    var sorted = cached._sorted;
    for (var i = 0; i < sorted.length; i++) {
        var c = sorted[i];
        try {
            var value = c.fn(recordFields, { recordId: recordId });
            if (value !== null && value !== undefined && !(value && value.__error)) {
                recordFields[c.fieldId] = value;
                if (c.fieldName && c.fieldName !== c.fieldId) {
                    recordFields[c.fieldName] = value;
                }
            }
        } catch (_e) {
            // skip
        }
    }
    return recordFields;
}

// Show a formula/computed info popover next to a target element
var _formulaInfoPopover = null;
function showFormulaInfoPopover(targetEl, field) {
    closeFormulaInfoPopover();
    var fieldType = field?.fieldType || 'formula';
    var label = computedFieldLabel(fieldType);
    var expression = field?.options?.formula || field?.options?.expression || null;
    var referencedFieldIds = field?.options?.referencedFieldIds || null;
    var result = field?.options?.result || null;

    var popover = document.createElement('div');
    popover.className = 'formula-info-popover';

    var html = '<div class="formula-info-header">';
    html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4 12.5-12.5z"/></svg>';
    html += 'Computed Field</div>';
    html += '<div class="formula-info-type">' + esc(label) + '</div>';

    if (expression) {
        html += '<div class="formula-info-expression">' + esc(expression) + '</div>';
    } else if (fieldType === 'rollup' && field?.options?.recordLinkFieldId) {
        var rollupDesc = 'Rollup of field via linked records';
        if (field.options.fieldIdInLinkedTable) {
            var linkedTableFields = null;
            // Try to resolve the referenced field name
            for (var tid in META_FIELDS) {
                if (META_FIELDS[tid][field.options.fieldIdInLinkedTable]) {
                    var linkedField = META_FIELDS[tid][field.options.fieldIdInLinkedTable];
                    rollupDesc = 'Rollup of "' + (linkedField.fieldName || field.options.fieldIdInLinkedTable) + '"';
                    break;
                }
            }
        }
        if (field.options.result?.type) rollupDesc += '  ' + field.options.result.type;
        html += '<div class="formula-info-expression">' + esc(rollupDesc) + '</div>';
    } else if (fieldType === 'lookup' && field?.options?.recordLinkFieldId) {
        var lookupDesc = 'Looks up values from linked records';
        if (field.options.fieldIdInLinkedTable) {
            for (var tid in META_FIELDS) {
                if (META_FIELDS[tid][field.options.fieldIdInLinkedTable]) {
                    var linkedField = META_FIELDS[tid][field.options.fieldIdInLinkedTable];
                    lookupDesc = 'Lookup of "' + (linkedField.fieldName || field.options.fieldIdInLinkedTable) + '"';
                    break;
                }
            }
        }
        html += '<div class="formula-info-expression">' + esc(lookupDesc) + '</div>';
    } else if (fieldType === 'count') {
        html += '<div class="formula-info-expression">Counts linked records</div>';
    }

    html += '<div class="formula-info-note">This field is computed automatically and cannot be edited directly.</div>';

    popover.innerHTML = html;

    var rect = targetEl.getBoundingClientRect();
    document.body.appendChild(popover);

    // Position below the target, clamped to viewport
    var popRect = popover.getBoundingClientRect();
    var top = rect.bottom + 6;
    var left = rect.left;
    if (top + popRect.height > window.innerHeight - 10) top = rect.top - popRect.height - 6;
    if (left + popRect.width > window.innerWidth - 10) left = window.innerWidth - popRect.width - 10;
    if (left < 10) left = 10;
    popover.style.top = top + 'px';
    popover.style.left = left + 'px';

    _formulaInfoPopover = popover;
    setTimeout(function() {
        document.addEventListener('click', _closeFormulaInfoOnOutsideClick);
        document.addEventListener('keydown', _closeFormulaInfoOnEscape);
    }, 0);
}

function _closeFormulaInfoOnOutsideClick(event) {
    if (_formulaInfoPopover && !_formulaInfoPopover.contains(event.target)) {
        closeFormulaInfoPopover();
    }
}
function _closeFormulaInfoOnEscape(event) {
    if (event.key === 'Escape') closeFormulaInfoPopover();
}
function closeFormulaInfoPopover() {
    if (_formulaInfoPopover) {
        _formulaInfoPopover.remove();
        _formulaInfoPopover = null;
    }
    document.removeEventListener('click', _closeFormulaInfoOnOutsideClick);
    document.removeEventListener('keydown', _closeFormulaInfoOnEscape);
}

// Handle click on a formula/computed cell in the grid  show info popover
function handleFormulaCellClick(event, td) {
    if (event.target.closest('a')) return; // Allow link clicks
    event.stopPropagation();
    var fieldId = td.dataset.fieldId;
    var tableId = td.closest('tr')?.dataset.tableId || currentTable;
    var field = META_FIELDS[tableId]?.[fieldId];
    if (field) {
        showFormulaInfoPopover(td, field);
    }
}

// ============ Inline Cell Editing (Grid) ============

var _inlineEditingCell = null; // Currently editing cell element
var _inlineEditJustCommitted = false; // Suppress re-render right after inline commit
var _inlineEditCommitExplicit = false; // True when commit triggered by Enter/Tab (not blur)

async function startInlineCellEdit(event, td) {
    // Don't start edit if clicking a link, button, or already in an input
    if (event.target.closest('button, a, input, select, textarea')) return;

    // Don't edit formula/computed/read-only fields
    if (td.classList.contains('cell-formula') || td.classList.contains('cell-readonly')) return;

    // Already editing this cell
    if (td.classList.contains('inline-editing')) return;

    // Close any other inline edit first
    if (_inlineEditingCell && _inlineEditingCell !== td) {
        commitInlineCellEdit(_inlineEditingCell);
    }

    var fieldId = td.dataset.fieldId;
    var recordId = td.dataset.recordId;
    var tableId = td.closest('tr')?.dataset.tableId || currentTable;
    if (!fieldId || !recordId || !tableId) return;

    // Double-check field metadata for read-only fields (computed, explicit readOnly, etc.)
    var fieldMeta = META_FIELDS[tableId]?.[fieldId];
    if (fieldMeta && isReadOnlyField(fieldMeta)) return;

    // Get field metadata and current value
    var field = META_FIELDS[tableId]?.[fieldId];
    var fieldType = field?.fieldType || 'text';
    var recordData = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) ? window.IN_MEMORY_DATA[tableId][recordId] : null;
    // Fall back to IndexedDB when IN_MEMORY_DATA doesn't have the record
    if (!recordData) {
        try {
            var dbRecord = await getRecord(tableId, recordId);
            if (dbRecord && dbRecord.fields) recordData = dbRecord.fields;
        } catch (e) { /* ignore, will proceed with undefined */ }
    }
    var currentValue;
    if (recordData) {
        currentValue = recordData[fieldId];
        if (currentValue === undefined && field?.fieldName) currentValue = recordData[field.fieldName];
    }

    // Infer field type from value when metadata type is generic
    if (fieldType === 'text' || fieldType === 'singleLineText' || !fieldType) {
        if (typeof currentValue === 'boolean') fieldType = 'checkbox';
        else if (typeof currentValue === 'number') fieldType = 'number';
        else if (typeof currentValue === 'string') {
            if (/^\d{4}-\d{2}-\d{2}/.test(currentValue)) fieldType = 'date';
            else if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(currentValue)) fieldType = 'email';
            else if (/^https?:\/\//.test(currentValue)) fieldType = 'url';
        }
    }

    _inlineEditingCell = td;
    td.classList.add('inline-editing');
    td._inlineOriginalHTML = td.innerHTML;
    td._inlineFieldId = fieldId;
    td._inlineRecordId = recordId;
    td._inlineTableId = tableId;
    td._inlineOriginalValue = currentValue;

    var input;
    var isSelectInput = false;

    if (fieldType === 'checkbox' || typeof currentValue === 'boolean') {
        // Checkbox  toggle immediately on click
        input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = !!currentValue;
        input.className = 'inline-edit-checkbox';
        input.onchange = function() {
            commitInlineCellEdit(td, input.checked);
        };
    } else if (fieldType === 'singleSelect' && field?.options?.choices) {
        // Single select dropdown
        isSelectInput = true;
        input = document.createElement('select');
        input.className = 'inline-edit-input';
        var emptyOpt = document.createElement('option');
        emptyOpt.value = '';
        emptyOpt.textContent = '';
        input.appendChild(emptyOpt);
        field.options.choices.forEach(function(choice) {
            var opt = document.createElement('option');
            var choiceName = typeof choice === 'string' ? choice : (choice.name || choice.value || String(choice));
            opt.value = choiceName;
            opt.textContent = choiceName;
            if (choiceName === currentValue) opt.selected = true;
            input.appendChild(opt);
        });
        input.onchange = function() {
            commitInlineCellEdit(td, input.value || '');
        };
    } else if (fieldType === 'date' || fieldType === 'dateTime') {
        // Date picker
        input = document.createElement('input');
        input.type = fieldType === 'dateTime' ? 'datetime-local' : 'date';
        input.className = 'inline-edit-input';
        if (currentValue) {
            // Normalize ISO date strings for the input
            var dateStr = String(currentValue);
            if (input.type === 'date') {
                input.value = dateStr.slice(0, 10);
            } else {
                // datetime-local needs "YYYY-MM-DDTHH:MM" format
                input.value = dateStr.slice(0, 16);
            }
        }
    } else if (fieldType === 'email') {
        input = document.createElement('input');
        input.type = 'email';
        input.className = 'inline-edit-input';
        input.value = currentValue != null ? String(currentValue) : '';
    } else if (fieldType === 'url') {
        input = document.createElement('input');
        input.type = 'url';
        input.className = 'inline-edit-input';
        input.value = currentValue != null ? String(currentValue) : '';
    } else if (fieldType === 'number' || fieldType === 'currency' || fieldType === 'percent' || typeof currentValue === 'number') {
        input = document.createElement('input');
        input.type = 'number';
        input.className = 'inline-edit-input';
        input.value = currentValue != null ? String(currentValue) : '';
        if (fieldType === 'percent') input.step = '0.01';
        if (fieldType === 'currency') input.step = '0.01';
    } else if (Array.isArray(currentValue) || (typeof currentValue === 'object' && currentValue !== null)) {
        // JSON / arrays / objects  textarea
        input = document.createElement('textarea');
        input.className = 'inline-edit-input';
        input.value = currentValue != null ? JSON.stringify(currentValue, null, 2) : '';
        input.rows = 3;
    } else {
        // Default: text or multiline
        var strValue = currentValue != null ? String(currentValue) : '';
        if (strValue.length > 80 || strValue.includes('\n') || fieldType === 'multilineText' || fieldType === 'richText') {
            input = document.createElement('textarea');
            input.className = 'inline-edit-input';
            input.value = strValue;
            input.rows = Math.min(6, Math.max(2, strValue.split('\n').length));
        } else {
            input = document.createElement('input');
            input.type = 'text';
            input.className = 'inline-edit-input';
            input.value = strValue;
        }
    }

    if (input.type !== 'checkbox' && !isSelectInput) {
        input.onkeydown = function(e) {
            if (e.key === 'Enter' && !e.shiftKey && input.tagName !== 'TEXTAREA') {
                e.preventDefault();
                e.stopPropagation();
                _inlineEditCommitExplicit = true;
                commitInlineCellEdit(td);
            } else if (e.key === 'Escape') {
                e.stopPropagation();
                cancelInlineCellEdit(td);
            } else if (e.key === 'Tab') {
                e.preventDefault();
                e.stopPropagation();
                _inlineEditCommitExplicit = true;
                commitInlineCellEdit(td);
                // Move to adjacent cell
                moveToAdjacentCell(td, e.shiftKey);
            }
        };
        input.onblur = function() {
            setTimeout(function() {
                if (_inlineEditingCell === td) {
                    _inlineEditCommitExplicit = false;
                    commitInlineCellEdit(td);
                }
            }, 150);
        };
    } else if (isSelectInput) {
        // Select: Escape to cancel, blur to commit, Enter to commit
        input.onkeydown = function(e) {
            if (e.key === 'Escape') {
                e.stopPropagation();
                cancelInlineCellEdit(td);
            } else if (e.key === 'Tab') {
                e.preventDefault();
                e.stopPropagation();
                commitInlineCellEdit(td, input.value || '');
                moveToAdjacentCell(td, e.shiftKey);
            }
        };
        input.onblur = function() {
            setTimeout(function() {
                if (_inlineEditingCell === td) {
                    commitInlineCellEdit(td, input.value || '');
                }
            }, 150);
        };
    }

    // Prevent double-click from bubbling to row
    input.ondblclick = function(e) { e.stopPropagation(); };

    td.innerHTML = '';
    td.appendChild(input);
    input.focus();
    if (input.select && !isSelectInput) input.select();
}

// Move focus to adjacent editable cell (for Tab navigation)
function moveToAdjacentCell(td, backwards) {
    // Walk siblings to find the next editable (non-formula) cell
    var nextTd = backwards ? td.previousElementSibling : td.nextElementSibling;
    while (nextTd && !nextTd.classList.contains('inline-editable')) {
        nextTd = backwards ? nextTd.previousElementSibling : nextTd.nextElementSibling;
    }
    if (nextTd) {
        startInlineCellEdit({ target: nextTd, stopPropagation: function(){} }, nextTd);
        return;
    }
    // If no sibling cell, try next/prev row
    var row = td.closest('tr');
    var nextRow = backwards ? row?.previousElementSibling : row?.nextElementSibling;
    if (nextRow && !nextRow.classList.contains('group-header-row')) {
        var cells = nextRow.querySelectorAll('td.inline-editable');
        if (cells.length > 0) {
            var target = backwards ? cells[cells.length - 1] : cells[0];
            startInlineCellEdit({ target: target, stopPropagation: function(){} }, target);
        }
    }
}

function parseInlineCellValue(strValue, originalValue, fieldType) {
    if (strValue === '') return '';
    if (typeof originalValue === 'number' || fieldType === 'number') {
        var num = Number(strValue);
        if (!isNaN(num)) return num;
    }
    if (Array.isArray(originalValue) || (typeof originalValue === 'object' && originalValue !== null)) {
        try { return JSON.parse(strValue); } catch (e) { return strValue; }
    }
    return strValue;
}

async function commitInlineCellEdit(td, explicitValue) {
    if (!td || !td.classList.contains('inline-editing')) return;

    var fieldId = td._inlineFieldId;
    var recordId = td._inlineRecordId;
    var tableId = td._inlineTableId;
    var originalValue = td._inlineOriginalValue;
    var wasExplicit = _inlineEditCommitExplicit;
    _inlineEditCommitExplicit = false;

    // Get the new value from the input
    var inputEl = td.querySelector('input, textarea, select');
    var newValue;
    if (explicitValue !== undefined) {
        newValue = explicitValue;
    } else if (inputEl) {
        if (inputEl.type === 'checkbox') {
            newValue = inputEl.checked;
        } else if (inputEl.tagName === 'SELECT') {
            newValue = inputEl.value;
        } else {
            var field = META_FIELDS[tableId]?.[fieldId];
            var fieldType = field?.fieldType || 'text';
            newValue = parseInlineCellValue(inputEl.value, originalValue, fieldType);
        }
    } else {
        // No input found  just restore
        cancelInlineCellEdit(td);
        return;
    }

    // Safety: if the edit would clear a non-empty field and the commit was
    // triggered by blur (not an explicit Enter/Tab), cancel instead of saving.
    // This prevents accidental wipes from clicking away.
    var wouldClear = (newValue === '' || newValue === null || newValue === undefined) &&
                     originalValue != null && originalValue !== '' &&
                     !(typeof originalValue === 'boolean');
    if (wouldClear && !wasExplicit) {
        cancelInlineCellEdit(td);
        return;
    }

    // Clean up cell state
    td.classList.remove('inline-editing');
    _inlineEditingCell = null;

    // Check if value changed
    if (JSON.stringify(originalValue) === JSON.stringify(newValue)) {
        // No change  restore display
        td.innerHTML = td._inlineOriginalHTML;
        return;
    }

    // Show the new value immediately (optimistic)
    td.innerHTML = formatCell(newValue);

    // Determine the field key used in the record (fieldId or fieldName)
    var field = META_FIELDS[tableId]?.[fieldId];
    var fieldKey = fieldId;
    var recordData = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) ? window.IN_MEMORY_DATA[tableId][recordId] : null;
    if (recordData && recordData[fieldId] === undefined && field?.fieldName && recordData[field.fieldName] !== undefined) {
        fieldKey = field.fieldName;
    }

    var fieldChanges = {};
    fieldChanges[fieldKey] = newValue;

    // Save field history locally (optimistic  before server call)
    await saveFieldHistory([{
        tableId: tableId,
        recordId: recordId,
        fieldId: fieldId,
        eventId: null,
        timestamp: Date.now(),
        changeType: 'updated',
        oldValue: originalValue !== undefined ? originalValue : null,
        newValue: newValue
    }]);

    // Suppress full table re-render for the optimistic update  the cell is already showing the new value
    _inlineEditJustCommitted = true;

    try {
        var result = await editRecord(tableId, recordId, fieldChanges);
        if (result && result.queued) {
            // Edit was queued offline  don't show undo toast
        } else {
            // Show undo toast after successful save
            showUndoToast(tableId, recordId, fieldId, fieldKey, originalValue);
        }
    } catch (err) {
        console.error('[InlineEdit] Edit failed for', recordId, fieldKey, err);
        // editRecord already handled rollback/queue and showed error toast
        _inlineEditJustCommitted = false;
    }
}

function cancelInlineCellEdit(td) {
    if (!td) return;
    td.classList.remove('inline-editing');
    td.innerHTML = td._inlineOriginalHTML || '';
    if (_inlineEditingCell === td) _inlineEditingCell = null;
}

// ============ Grid Keyboard Navigation ============
// Allows arrow-key navigation between cells and Enter/F2 to start editing.
var _focusedCell = null;

function setFocusedCell(td) {
    if (_focusedCell) _focusedCell.classList.remove('cell-focused');
    _focusedCell = td;
    if (td) {
        td.classList.add('cell-focused');
        td.scrollIntoView({ block: 'nearest', inline: 'nearest' });
    }
}

document.addEventListener('click', function(e) {
    var cell = e.target.closest('td.inline-editable, td.cell-formula, td.cell-readonly');
    if (cell) {
        setFocusedCell(cell);
    }
});

document.addEventListener('keydown', function(e) {
    // Don't interfere if the profile overlay is open
    var overlay = document.getElementById('record-profile-overlay');
    if (overlay && overlay.classList.contains('open')) return;

    // Don't interfere if actively editing (input has its own key handlers)
    if (_inlineEditingCell) return;

    // Don't interfere if focus is in an unrelated input
    if (e.target.matches('input, textarea, select') && !e.target.closest('td.inline-editable')) return;

    if (!_focusedCell) return;

    var table = _focusedCell.closest('table');
    if (!table) return;

    if (e.key === 'Enter' || e.key === 'F2') {
        e.preventDefault();
        // For formula cells, show info popover instead of editing
        if (_focusedCell.classList.contains('cell-formula')) {
            handleFormulaCellClick({ target: _focusedCell, stopPropagation: function(){} }, _focusedCell);
        } else if (_focusedCell.classList.contains('cell-readonly')) {
            // Read-only cells: do nothing on Enter/F2
        } else {
            startInlineCellEdit({ target: _focusedCell, stopPropagation: function(){} }, _focusedCell);
        }
        return;
    }

    if (e.key === 'ArrowRight' || e.key === 'ArrowLeft' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        e.preventDefault();
        var row = _focusedCell.closest('tr');
        if (!row) return;

        // Include editable, formula, and read-only cells in keyboard navigation
        var cellsInRow = Array.from(row.querySelectorAll('td.inline-editable, td.cell-formula, td.cell-readonly'));
        var colIdx = cellsInRow.indexOf(_focusedCell);

        if (e.key === 'ArrowRight') {
            if (colIdx < cellsInRow.length - 1) {
                setFocusedCell(cellsInRow[colIdx + 1]);
            }
        } else if (e.key === 'ArrowLeft') {
            if (colIdx > 0) {
                setFocusedCell(cellsInRow[colIdx - 1]);
            }
        } else if (e.key === 'ArrowDown') {
            var nextRow = row.nextElementSibling;
            while (nextRow && nextRow.classList.contains('group-header-row')) nextRow = nextRow.nextElementSibling;
            if (nextRow) {
                var nextCells = nextRow.querySelectorAll('td.inline-editable, td.cell-formula, td.cell-readonly');
                if (nextCells[colIdx]) setFocusedCell(nextCells[colIdx]);
                else if (nextCells.length > 0) setFocusedCell(nextCells[nextCells.length - 1]);
            }
        } else if (e.key === 'ArrowUp') {
            var prevRow = row.previousElementSibling;
            while (prevRow && prevRow.classList.contains('group-header-row')) prevRow = prevRow.previousElementSibling;
            if (prevRow) {
                var prevCells = prevRow.querySelectorAll('td.inline-editable, td.cell-formula, td.cell-readonly');
                if (prevCells[colIdx]) setFocusedCell(prevCells[colIdx]);
                else if (prevCells.length > 0) setFocusedCell(prevCells[prevCells.length - 1]);
            }
        }
    }
});

// Keyboard navigation for profile
document.addEventListener('keydown', function(e) {
    var overlay = document.getElementById('record-profile-overlay');
    if (!overlay.classList.contains('open')) return;

    if (e.key === 'Escape') {
        closeRecordProfile();
    } else if (e.key === 'ArrowLeft' && !e.target.matches('input, textarea, select')) {
        navigateProfile(-1);
    } else if (e.key === 'ArrowRight' && !e.target.matches('input, textarea, select')) {
        navigateProfile(1);
    }
});

// ============ View Selector & Fields Dropdown UI ============

// Toggle view selector dropdown
function toggleViewSelector() {
    var dropdown = document.getElementById('view-selector-dropdown');
    var fieldsDropdown = document.getElementById('fields-dropdown');

    // Close fields dropdown if open
    fieldsDropdown.classList.remove('open');

    dropdown.classList.toggle('open');
}

// Toggle fields dropdown
function toggleFieldsDropdown() {
    var dropdown = document.getElementById('fields-dropdown');
    var viewDropdown = document.getElementById('view-selector-dropdown');

    // Close view dropdown if open
    viewDropdown.classList.remove('open');

    dropdown.classList.toggle('open');

    // Focus search input and clear it when opening
    if (dropdown.classList.contains('open')) {
        var searchInput = document.getElementById('fields-search-input');
        if (searchInput) {
            searchInput.value = '';
            filterFieldsDropdown('');
            setTimeout(function() { searchInput.focus(); }, 50);
        }
    }
}

// Close all dropdowns
function closeAllDropdowns() {
    document.getElementById('view-selector-dropdown')?.classList.remove('open');
    document.getElementById('fields-dropdown')?.classList.remove('open');
}

// Click outside handler to close dropdowns
document.addEventListener('click', function(e) {
    var viewSelector = document.getElementById('view-selector-container');
    var fieldsBtn = document.getElementById('fields-btn');
    var fieldsDropdown = document.getElementById('fields-dropdown');

    // Close view selector if clicked outside
    if (viewSelector && !viewSelector.contains(e.target)) {
        document.getElementById('view-selector-dropdown')?.classList.remove('open');
    }

    // Close fields dropdown if clicked outside
    if (fieldsBtn && fieldsDropdown && !fieldsBtn.contains(e.target) && !fieldsDropdown.contains(e.target)) {
        fieldsDropdown.classList.remove('open');
    }
});

// Get view type icon
function getViewTypeIcon(viewType) {
    switch ((viewType || '').toLowerCase()) {
        case 'grid': return '&#9638;';
        case 'gallery': return '&#128444;';
        case 'kanban': return '&#9636;';
        case 'calendar': return '&#128197;';
        case 'timeline': return '&#8594;';
        case 'form': return '&#128196;';
        default: return '&#9638;';
    }
}

// Render view selector dropdown
function renderViewSelector() {
    if (!currentTable) return;

    var dropdown = document.getElementById('view-selector-dropdown');
    var currentViewIcon = document.getElementById('current-view-icon');
    var currentViewName = document.getElementById('current-view-name');

    var views = META_VIEWS[currentTable] || {};
    var viewIds = Object.keys(views);

    // Update current view display
    var viewId = currentView || '_default';
    var currentViewObj = views[viewId];
    if (currentViewObj) {
        currentViewIcon.innerHTML = getViewTypeIcon(currentViewObj.viewType);
        currentViewName.textContent = currentViewObj.viewName || viewId;
    } else {
        currentViewIcon.innerHTML = '&#9638;';
        currentViewName.textContent = 'All Fields';
    }

    // Build dropdown
    var html = '<div class="view-selector-dropdown-header">Views</div>';

    // Add "All Fields" default option
    var isDefaultActive = !currentView || currentView === '_default';
    html += '<div class="view-selector-option' + (isDefaultActive ? ' active' : '') + '" onclick="selectView(\'_default\')">';
    html += '<span class="view-type-icon">&#9638;</span>';
    html += '<span class="view-option-name">All Fields</span>';
    if (isDefaultActive) html += '<span class="view-check">&#10003;</span>';
    html += '</div>';

    // Add existing views
    for (var vid of viewIds) {
        if (vid === '_default') continue;
        var view = views[vid];
        var isActive = currentView === vid;
        var viewSharing = view._sharing;
        var sharingBadge = '';
        if (viewSharing && viewSharing.sharing && viewSharing.sharing !== 'private') {
            sharingBadge = '<span class="view-sharing-badge shared" title="' +
                esc(SharedViews.getSharingLabel(viewSharing)) + '">' +
                SharedViews.getSharingIcon(viewSharing) + '</span>';
        }
        html += '<div class="view-selector-option' + (isActive ? ' active' : '') + '" onclick="selectView(\'' + esc(vid) + '\')">';
        html += '<span class="view-type-icon">' + getViewTypeIcon(view.viewType) + '</span>';
        html += '<span class="view-option-name">' + esc(view.viewName || vid) + '</span>';
        html += sharingBadge;
        if (isActive) html += '<span class="view-check">&#10003;</span>';
        html += '</div>';
    }

    // Add "Create New View" option at bottom
    html += '<div style="border-top: 1px solid #eee; margin-top: 4px; padding-top: 4px;"></div>';
    html += '<div class="view-selector-option" onclick="openCreateViewModal()" style="color: #2d6cdf;">';
    html += '<span class="view-type-icon">+</span>';
    html += '<span class="view-option-name">Create New View</span>';
    html += '</div>';

    dropdown.innerHTML = html;
}

// Select a view
async function selectView(viewId) {
    // Short-circuit if the requested view is already active (avoids full re-render)
    if (viewId === currentView) {
        closeAllDropdowns();
        return;
    }

    // Auto-save any pending changes before switching views
    await autoSaveBeforeNavigation();

    currentView = viewId;
    invalidateVisibleFieldsCache(); // view changed  stale field order
    closeAllDropdowns();

    // Load and apply view filters, sorts, groupBy, and colorBy for the new view
    if (currentTable) {
        var viewConfig = getViewFiltersAndSorts(currentTable, viewId);
        currentFilters = viewConfig.filters;
        currentSorts = viewConfig.sorts;
        currentGroupBy = viewConfig.groupBy;
        currentColorBy = viewConfig.colorBy;
        updateFilterCount();
        updateSortCount();
        updateGroupButtonState();
        updateColorButtonState();
    }

    // Update sidebar to reflect the new active view
    if (currentTable) {
        updateSidebarViewActive(currentTable, viewId);
    }

    // Render view selector to update current view display
    renderViewSelector();

    // Render fields dropdown for new view
    renderFieldsDropdown();
    updateFieldsCount();

    // Re-render table with new view's field configuration
    await renderTable();
}

// Render fields dropdown
function renderFieldsDropdown() {
    if (!currentTable) return;

    var list = document.getElementById('fields-dropdown-list');
    var fields = META_FIELDS[currentTable] || {};
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);
    var hiddenSet = new Set(config.hiddenFieldIds || []);

    // Get all fields in order
    var allFieldIds = getAllFieldsInOrder(currentTable, viewId);

    var html = '';
    for (var i = 0; i < allFieldIds.length; i++) {
        var fid = allFieldIds[i];
        var field = fields[fid];
        if (!field) continue;

        var isVisible = !hiddenSet.has(fid);
        var fieldName = field.fieldName || fid;
        var fieldType = field.fieldType || 'unknown';

        html += '<div class="fields-dropdown-item" data-field-id="' + esc(fid) + '" draggable="true">';

        // Drag handle
        html += '<span class="field-drag-handle" title="Drag to reorder">&#9776;</span>';

        // Checkbox
        html += '<div class="field-checkbox' + (isVisible ? ' checked' : '') + '" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<span class="check-icon">&#10003;</span>';
        html += '</div>';

        // Field info
        html += '<div class="field-info" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<div class="field-name">' + esc(fieldName) + '</div>';
        html += '<div class="field-type">' + esc(fieldType) + '</div>';
        html += '</div>';

        // Move buttons
        html += '<div class="field-move-btns">';
        if (i > 0) {
            html += '<button class="field-move-btn" onclick="moveFieldUp(\'' + esc(fid) + '\')" title="Move up">&#9650;</button>';
        } else {
            html += '<button class="field-move-btn" disabled style="opacity: 0.3;">&#9650;</button>';
        }
        if (i < allFieldIds.length - 1) {
            html += '<button class="field-move-btn" onclick="moveFieldDown(\'' + esc(fid) + '\')" title="Move down">&#9660;</button>';
        } else {
            html += '<button class="field-move-btn" disabled style="opacity: 0.3;">&#9660;</button>';
        }
        html += '</div>';

        html += '</div>';
    }

    list.innerHTML = html;
    initFieldsDropdownDrag();

    // Preserve search filter if active
    var searchInput = document.getElementById('fields-search-input');
    if (searchInput && searchInput.value) {
        filterFieldsDropdown(searchInput.value);
    }
}

// Update visible fields count badge
function updateFieldsCount() {
    if (!currentTable) return;

    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);
    var fields = META_FIELDS[currentTable] || {};
    var totalFields = Object.keys(fields).length;
    var hiddenCount = (config.hiddenFieldIds || []).length;
    var visibleCount = totalFields - hiddenCount;

    var countEl = document.getElementById('fields-visible-count');
    if (countEl) {
        countEl.textContent = visibleCount + '/' + totalFields;
    }
}

// Filter fields dropdown by search query
function filterFieldsDropdown(query) {
    var list = document.getElementById('fields-dropdown-list');
    if (!list) return;
    var items = list.querySelectorAll('.fields-dropdown-item');
    var lowerQuery = (query || '').toLowerCase().trim();

    for (var i = 0; i < items.length; i++) {
        var nameEl = items[i].querySelector('.field-name');
        var name = nameEl ? nameEl.textContent.toLowerCase() : '';
        if (!lowerQuery || name.indexOf(lowerQuery) >= 0) {
            items[i].style.display = '';
        } else {
            items[i].style.display = 'none';
        }
    }
}

// --- Drag-to-reorder for fields dropdown ---
var draggedFieldItem = null;
var draggedFieldId = null;

function initFieldsDropdownDrag() {
    var list = document.getElementById('fields-dropdown-list');
    if (!list) return;

    list.addEventListener('dragstart', function(e) {
        var item = e.target.closest('.fields-dropdown-item');
        if (!item) return;
        draggedFieldItem = item;
        draggedFieldId = item.dataset.fieldId;
        item.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', draggedFieldId);
    });

    list.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        var item = e.target.closest('.fields-dropdown-item');
        if (!item || item === draggedFieldItem) return;

        // Clear previous indicators
        list.querySelectorAll('.drag-over-above, .drag-over-below').forEach(function(el) {
            el.classList.remove('drag-over-above', 'drag-over-below');
        });

        // Determine if above or below midpoint
        var rect = item.getBoundingClientRect();
        var midY = rect.top + rect.height / 2;
        if (e.clientY < midY) {
            item.classList.add('drag-over-above');
        } else {
            item.classList.add('drag-over-below');
        }
    });

    list.addEventListener('dragleave', function(e) {
        var item = e.target.closest('.fields-dropdown-item');
        if (item) {
            item.classList.remove('drag-over-above', 'drag-over-below');
        }
    });

    list.addEventListener('dragend', function() {
        list.querySelectorAll('.dragging, .drag-over-above, .drag-over-below').forEach(function(el) {
            el.classList.remove('dragging', 'drag-over-above', 'drag-over-below');
        });
        draggedFieldItem = null;
        draggedFieldId = null;
    });

    list.addEventListener('drop', function(e) {
        e.preventDefault();

        var item = e.target.closest('.fields-dropdown-item');
        if (!item || !draggedFieldId) return;

        var targetFieldId = item.dataset.fieldId;
        if (targetFieldId === draggedFieldId) return;

        // Determine insert position based on drop location
        var rect = item.getBoundingClientRect();
        var midY = rect.top + rect.height / 2;
        var insertAfter = e.clientY >= midY;

        // Perform reorder
        if (!currentTable) return;
        var viewId = currentView || '_default';
        var config = getViewFieldConfig(currentTable, viewId);

        var fromIdx = config.fieldOrder.indexOf(draggedFieldId);
        var toIdx = config.fieldOrder.indexOf(targetFieldId);
        if (fromIdx < 0 || toIdx < 0) return;

        // Remove from old position
        config.fieldOrder.splice(fromIdx, 1);

        // Recalculate target index after removal
        var newToIdx = config.fieldOrder.indexOf(targetFieldId);
        var insertIdx = insertAfter ? newToIdx + 1 : newToIdx;
        config.fieldOrder.splice(insertIdx, 0, draggedFieldId);

        // Move column in table DOM
        moveColumnInDOM(fromIdx, insertIdx);

        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();

        // Restore search filter if active
        var searchInput = document.getElementById('fields-search-input');
        if (searchInput && searchInput.value) {
            filterFieldsDropdown(searchInput.value);
        }
    });
}

function esc(s) {
    if (s == null) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ============ View Controls (Filter, Sort, Group, etc.) ============

var currentFilters = [];
var currentSorts = [];
var currentGroupBy = null;
var currentColorBy = null;
var currentRowHeight = 'medium';
var currentSearchQuery = '';

// Original unfiltered/unsorted record IDs
var originalRecordIds = [];

// Get cell value from a record for filtering/sorting
function getCellValue(record, fieldId) {
    if (!record || !record.fields) return null;
    var value = record.fields[fieldId];
    if (value === undefined) {
        // Try field name lookup
        var fields = META_FIELDS[currentTable] || {};
        var fieldName = fields[fieldId]?.fieldName;
        if (fieldName) value = record.fields[fieldName];
    }
    return value;
}

// Convert value to string for comparison
function valueToString(value) {
    if (value == null) return '';
    if (Array.isArray(value)) {
        return value.map(v => {
            if (typeof v === 'object' && v !== null) {
                return v.name || v.filename || v.email || v.id || JSON.stringify(v);
            }
            return String(v);
        }).join(' ');
    }
    if (typeof value === 'object') {
        return value.name || value.filename || value.email || value.url || JSON.stringify(value);
    }
    return String(value);
}

// Check if a record matches a single filter
function matchesFilter(record, filter) {
    var value = getCellValue(record, filter.fieldId);
    var strValue = valueToString(value).toLowerCase();
    var filterValue = (filter.value || '').toLowerCase();

    switch (filter.operator) {
        case 'contains':
            return strValue.includes(filterValue);
        case 'equals':
            return strValue === filterValue;
        case 'not_equals':
            return strValue !== filterValue;
        case 'is_empty':
            return value == null || value === '' || (Array.isArray(value) && value.length === 0);
        case 'is_not_empty':
            return value != null && value !== '' && !(Array.isArray(value) && value.length === 0);
        default:
            return true;
    }
}

// Check if a record matches search query
function matchesSearch(record, query) {
    if (!query) return true;
    var fields = record.fields || {};
    for (var key in fields) {
        var strValue = valueToString(fields[key]).toLowerCase();
        if (strValue.includes(query)) return true;
    }
    return false;
}

// Compare two values for sorting
function compareValues(a, b, direction) {
    // Handle nulls
    if (a == null && b == null) return 0;
    if (a == null) return direction === 'asc' ? -1 : 1;
    if (b == null) return direction === 'asc' ? 1 : -1;

    // Convert to strings for comparison
    var strA = valueToString(a).toLowerCase();
    var strB = valueToString(b).toLowerCase();

    // Try numeric comparison
    var numA = parseFloat(strA);
    var numB = parseFloat(strB);
    if (!isNaN(numA) && !isNaN(numB)) {
        var result = numA - numB;
        return direction === 'asc' ? result : -result;
    }

    // String comparison
    var result = strA.localeCompare(strB);
    return direction === 'asc' ? result : -result;
}

// Cache for filtered/sorted results  avoids redundant IndexedDB reads when
// re-rendering the same view with the same filters (e.g. toggling back to a tab).
var _filterCache = { key: null, result: null };
function _filterCacheKey() {
    return currentTable + '|' + currentView + '|' + JSON.stringify(currentFilters) + '|' +
           JSON.stringify(currentSorts) + '|' + currentSearchQuery + '|' + originalRecordIds.length;
}
function invalidateFilterCache() { _filterCache.key = null; _filterCache.result = null; }

// Apply all filters, search, and sorts to get filtered record IDs
// Processes records in batches to avoid loading entire dataset into memory at once
async function getFilteredSortedRecords() {
    if (!currentTable) return [];

    // Return cached result if filters/sorts/search haven't changed
    var cacheKey = _filterCacheKey();
    if (_filterCache.key === cacheKey && _filterCache.result) {
        return _filterCache.result.slice();
    }

    var hasFilters = currentFilters.length > 0;
    var hasSearch = !!currentSearchQuery;
    var hasSorts = currentSorts.length > 0;
    var needsRecordData = hasFilters || hasSearch || hasSorts;

    // If no filters/search/sorts, just return a copy
    if (!needsRecordData) return originalRecordIds.slice();

    // Larger batches reduce IDB transaction overhead; safe because record cache
    // prevents duplicate reads when the sort phase re-fetches the same records.
    var BATCH_SIZE = 1000;
    var filteredIds = [];
    var filterCount = currentFilters.length; // cache length outside loop

    // Phase 1: Filter in batches  only load BATCH_SIZE records at a time
    for (var batchStart = 0; batchStart < originalRecordIds.length; batchStart += BATCH_SIZE) {
        var batchIds = originalRecordIds.slice(batchStart, batchStart + BATCH_SIZE);
        var batchRecords = await getRecordsByIds(currentTable, batchIds);
        var batchById = {};
        for (var r = 0; r < batchRecords.length; r++) {
            batchById[batchRecords[r].recordId] = batchRecords[r];
        }

        for (var b = 0; b < batchIds.length; b++) {
            var id = batchIds[b];
            var record = batchById[id];
            if (!record) continue;

            if (hasSearch && !matchesSearch(record, currentSearchQuery)) continue;
            // Inline filter check  avoids per-record closure allocation from .every()
            if (hasFilters) {
                var pass = true;
                for (var fi = 0; fi < filterCount; fi++) {
                    if (!matchesFilter(record, currentFilters[fi])) { pass = false; break; }
                }
                if (!pass) continue;
            }

            filteredIds.push(id);
        }
        // batchRecords and batchById go out of scope here  GC can reclaim
    }

    // Phase 2: Sort  only load the sort field values, not full records
    if (hasSorts && filteredIds.length > 1) {
        // For sorting we need field values, but only for filtered records and only sort fields
        var sortCache = {};
        for (var s = 0; s < filteredIds.length; s += BATCH_SIZE) {
            var sortBatchIds = filteredIds.slice(s, s + BATCH_SIZE);
            var sortBatchRecords = await getRecordsByIds(currentTable, sortBatchIds);
            for (var sr = 0; sr < sortBatchRecords.length; sr++) {
                var rec = sortBatchRecords[sr];
                var vals = {};
                for (var si = 0; si < currentSorts.length; si++) {
                    vals[currentSorts[si].fieldId] = getCellValue(rec, currentSorts[si].fieldId);
                }
                sortCache[rec.recordId] = vals;
            }
        }

        filteredIds.sort(function(idA, idB) {
            var valsA = sortCache[idA] || {};
            var valsB = sortCache[idB] || {};
            for (var i = 0; i < currentSorts.length; i++) {
                var sort = currentSorts[i];
                var cmp = compareValues(valsA[sort.fieldId], valsB[sort.fieldId], sort.direction);
                if (cmp !== 0) return cmp;
            }
            return 0;
        });
        sortCache = null; // release
    }

    // Cache the result for subsequent renders with the same config
    _filterCache.key = cacheKey;
    _filterCache.result = filteredIds;
    return filteredIds;
}

// Close all view control dropdowns
function closeViewControlDropdowns() {
    document.querySelectorAll('.view-control-dropdown').forEach(d => d.classList.remove('open'));
}

// Toggle filter dropdown
function toggleFilterDropdown() {
    var dropdown = document.getElementById('filter-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        filterDropdownSearch = '';
        var searchInput = document.getElementById('filter-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderFilterDropdown();
    }
}

// Toggle sort dropdown
function toggleSortDropdown() {
    var dropdown = document.getElementById('sort-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        sortDropdownSearch = '';
        var searchInput = document.getElementById('sort-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderSortDropdown();
    }
}

// Toggle group dropdown
function toggleGroupDropdown() {
    var dropdown = document.getElementById('group-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        groupDropdownSearch = '';
        var searchInput = document.getElementById('group-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderGroupDropdown();
    }
}

// Toggle color dropdown
function toggleColorDropdown() {
    var dropdown = document.getElementById('color-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        var searchInput = document.getElementById('color-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderColorDropdown();
    }
}

// Toggle row height dropdown
function toggleRowHeightDropdown() {
    var dropdown = document.getElementById('row-height-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        updateRowHeightDropdown();
    }
}

// Get sorted fields for dropdown: alphabetical, with selected/used fields at top
function getSortedFieldsForDropdown(fields, usedFieldIds, filterText) {
    var filter = (filterText || '').toLowerCase().trim();
    var fieldArray = [];

    for (var fid in fields) {
        var field = fields[fid];
        var fieldName = field.fieldName || fid;

        // Filter by search text
        if (filter && !fieldName.toLowerCase().includes(filter)) {
            continue;
        }

        fieldArray.push({
            fieldId: fid,
            fieldName: fieldName,
            isUsed: usedFieldIds.indexOf(fid) !== -1
        });
    }

    // Sort: used fields first, then alphabetically
    fieldArray.sort(function(a, b) {
        if (a.isUsed !== b.isUsed) {
            return a.isUsed ? -1 : 1;
        }
        return a.fieldName.localeCompare(b.fieldName);
    });

    return fieldArray;
}

// Current search state for dropdowns
var filterDropdownSearch = '';
var sortDropdownSearch = '';
var groupDropdownSearch = '';

// Render filter dropdown
function renderFilterDropdown(filterText) {
    if (!currentTable) return;
    var list = document.getElementById('filter-list');

    if (filterText !== undefined) {
        filterDropdownSearch = filterText;
    }

    if (currentFilters.length === 0) {
        list.innerHTML = '<div class="empty-filters">No filters applied</div>';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};

    // Get used field IDs from current filters
    var usedFieldIds = currentFilters.map(function(f) { return f.fieldId; });
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filterDropdownSearch);

    var html = '';

    for (var i = 0; i < currentFilters.length; i++) {
        var filter = currentFilters[i];
        html += '<div class="filter-row">';
        html += '<select onchange="updateFilter(' + i + ', \'field\', this.value)">';

        // Add sorted fields to dropdown, ensuring selected field is always included
        var selectedInList = false;
        for (var j = 0; j < sortedFields.length; j++) {
            var sf = sortedFields[j];
            var sel = filter.fieldId === sf.fieldId ? ' selected' : '';
            if (sel) selectedInList = true;
            html += '<option value="' + esc(sf.fieldId) + '"' + sel + '>' + esc(sf.fieldName) + '</option>';
        }
        // If selected field was filtered out, still include it
        if (!selectedInList && fields[filter.fieldId]) {
            var selField = fields[filter.fieldId];
            html += '<option value="' + esc(filter.fieldId) + '" selected>' + esc(selField.fieldName || filter.fieldId) + '</option>';
        }

        html += '</select>';
        html += '<select onchange="updateFilter(' + i + ', \'operator\', this.value)">';
        html += '<option value="contains"' + (filter.operator === 'contains' ? ' selected' : '') + '>contains</option>';
        html += '<option value="equals"' + (filter.operator === 'equals' ? ' selected' : '') + '>equals</option>';
        html += '<option value="not_equals"' + (filter.operator === 'not_equals' ? ' selected' : '') + '>does not equal</option>';
        html += '<option value="is_empty"' + (filter.operator === 'is_empty' ? ' selected' : '') + '>is empty</option>';
        html += '<option value="is_not_empty"' + (filter.operator === 'is_not_empty' ? ' selected' : '') + '>is not empty</option>';
        html += '</select>';
        if (filter.operator !== 'is_empty' && filter.operator !== 'is_not_empty') {
            html += '<input type="text" value="' + esc(filter.value || '') + '" onchange="updateFilter(' + i + ', \'value\', this.value)" placeholder="Value">';
        }
        html += '<button class="filter-remove-btn" onclick="removeFilter(' + i + ')" title="Remove">&times;</button>';
        html += '</div>';
    }

    list.innerHTML = html;
    updateFilterCount();
}

// Filter filter dropdown based on search input
function filterFilterDropdown(filterText) {
    renderFilterDropdown(filterText);
}

// Add filter
function addFilter() {
    if (!currentTable) return;
    var fields = META_FIELDS[currentTable] || {};
    // Get sorted fields (alphabetically)
    var sortedFields = getSortedFieldsForDropdown(fields, [], '');
    var firstFieldId = sortedFields.length > 0 ? sortedFields[0].fieldId : null;
    if (!firstFieldId) return;

    currentFilters.push({
        fieldId: firstFieldId,
        operator: 'contains',
        value: ''
    });
    renderFilterDropdown();
    applyFilters();
}

// Update filter
function updateFilter(index, prop, value) {
    if (currentFilters[index]) {
        currentFilters[index][prop] = value;
        renderFilterDropdown();
        applyFilters();
    }
}

// Remove filter
function removeFilter(index) {
    currentFilters.splice(index, 1);
    renderFilterDropdown();
    applyFilters();
}

// Update filter count badge
function updateFilterCount() {
    var countEl = document.getElementById('filter-count');
    var btn = document.getElementById('filter-btn');
    if (currentFilters.length > 0) {
        countEl.textContent = currentFilters.length;
        countEl.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        countEl.style.display = 'none';
        btn.classList.remove('active');
    }
}

// Apply filters (re-render table)
async function applyFilters() {
    updateFilterCount();
    await renderTable();
    // Save filters to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('filters', currentFilters);
    }
}

// Render sort dropdown
function renderSortDropdown(filterText) {
    if (!currentTable) return;
    var list = document.getElementById('sort-list');

    if (filterText !== undefined) {
        sortDropdownSearch = filterText;
    }

    if (currentSorts.length === 0) {
        list.innerHTML = '<div class="empty-sorts">No sorts applied</div>';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};

    // Get used field IDs from current sorts
    var usedFieldIds = currentSorts.map(function(s) { return s.fieldId; });
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, sortDropdownSearch);

    var html = '';

    for (var i = 0; i < currentSorts.length; i++) {
        var sort = currentSorts[i];
        html += '<div class="sort-row">';
        html += '<select onchange="updateSort(' + i + ', \'field\', this.value)">';

        // Add sorted fields to dropdown, ensuring selected field is always included
        var selectedInList = false;
        for (var j = 0; j < sortedFields.length; j++) {
            var sf = sortedFields[j];
            var sel = sort.fieldId === sf.fieldId ? ' selected' : '';
            if (sel) selectedInList = true;
            html += '<option value="' + esc(sf.fieldId) + '"' + sel + '>' + esc(sf.fieldName) + '</option>';
        }
        // If selected field was filtered out, still include it
        if (!selectedInList && fields[sort.fieldId]) {
            var selField = fields[sort.fieldId];
            html += '<option value="' + esc(sort.fieldId) + '" selected>' + esc(selField.fieldName || sort.fieldId) + '</option>';
        }

        html += '</select>';
        html += '<div class="sort-direction-btns">';
        html += '<button class="sort-direction-btn' + (sort.direction === 'asc' ? ' active' : '') + '" onclick="updateSort(' + i + ', \'direction\', \'asc\')">AZ</button>';
        html += '<button class="sort-direction-btn' + (sort.direction === 'desc' ? ' active' : '') + '" onclick="updateSort(' + i + ', \'direction\', \'desc\')">ZA</button>';
        html += '</div>';
        html += '<button class="sort-remove-btn" onclick="removeSort(' + i + ')" title="Remove">&times;</button>';
        html += '</div>';
    }

    list.innerHTML = html;
    updateSortCount();
}

// Filter sort dropdown based on search input
function filterSortDropdown(filterText) {
    renderSortDropdown(filterText);
}

// Add sort
function addSort() {
    if (!currentTable) return;
    var fields = META_FIELDS[currentTable] || {};
    // Get sorted fields (alphabetically)
    var sortedFields = getSortedFieldsForDropdown(fields, [], '');
    var firstFieldId = sortedFields.length > 0 ? sortedFields[0].fieldId : null;
    if (!firstFieldId) return;

    currentSorts.push({
        fieldId: firstFieldId,
        direction: 'asc'
    });
    renderSortDropdown();
    applySorts();
}

// Update sort
function updateSort(index, prop, value) {
    if (currentSorts[index]) {
        currentSorts[index][prop] = value;
        renderSortDropdown();
        applySorts();
    }
}

// Remove sort
function removeSort(index) {
    currentSorts.splice(index, 1);
    renderSortDropdown();
    applySorts();
}

// Update sort count badge
function updateSortCount() {
    var countEl = document.getElementById('sort-count');
    var btn = document.getElementById('sort-btn');
    if (currentSorts.length > 0) {
        countEl.textContent = currentSorts.length;
        countEl.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        countEl.style.display = 'none';
        btn.classList.remove('active');
    }
}

// Apply sorts (re-render table)
async function applySorts() {
    updateSortCount();
    await renderTable();
    // Save sorts to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('sorts', currentSorts);
    }
}

// Render group dropdown
function renderGroupDropdown(filterText) {
    if (!currentTable) return;
    var container = document.getElementById('group-options');
    var fields = META_FIELDS[currentTable] || {};

    if (filterText !== undefined) {
        groupDropdownSearch = filterText;
    }

    var filter = (groupDropdownSearch || '').toLowerCase().trim();

    var html = '';

    // Show "None" option only if it matches filter or no filter
    if (!filter || 'none'.includes(filter)) {
        html += '<div class="group-option' + (!currentGroupBy ? ' none-selected' : '') + '" onclick="setGroupBy(null)">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>None</span>';
        html += '</div>';
    }

    // Get sorted fields with selected at top
    var usedFieldIds = currentGroupBy ? [currentGroupBy] : [];
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filter);

    for (var i = 0; i < sortedFields.length; i++) {
        var sf = sortedFields[i];
        var isSelected = currentGroupBy === sf.fieldId;
        html += '<div class="group-option' + (isSelected ? ' selected' : '') + '" onclick="setGroupBy(\'' + esc(sf.fieldId) + '\')">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>' + esc(sf.fieldName) + '</span>';
        html += '</div>';
    }

    if (!html) {
        html = '<div class="group-option" style="color: #999; cursor: default;">No matching fields</div>';
    }

    container.innerHTML = html;
}

// Filter group dropdown based on search input
function filterGroupDropdown(filterText) {
    renderGroupDropdown(filterText);
}

// Update group button state
function updateGroupButtonState() {
    var btn = document.getElementById('group-btn');
    if (currentGroupBy) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

// Set group by field
async function setGroupBy(fieldId) {
    currentGroupBy = fieldId;
    closeViewControlDropdowns();
    updateGroupButtonState();
    await renderTable();
    // Save groupBy to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('groupBy', currentGroupBy);
    }
}

// Color palette: 20 visually distinct colors for row coloring
var COLOR_PALETTE = [
    'rgba(59, 130, 246, 0.12)',   // blue
    'rgba(16, 185, 129, 0.12)',   // emerald
    'rgba(245, 158, 11, 0.12)',   // amber
    'rgba(239, 68, 68, 0.12)',    // red
    'rgba(139, 92, 246, 0.12)',   // violet
    'rgba(236, 72, 153, 0.12)',   // pink
    'rgba(6, 182, 212, 0.12)',    // cyan
    'rgba(249, 115, 22, 0.12)',   // orange
    'rgba(34, 197, 94, 0.12)',    // green
    'rgba(168, 85, 247, 0.12)',   // purple
    'rgba(14, 165, 233, 0.12)',   // sky
    'rgba(251, 146, 60, 0.12)',   // orange-light
    'rgba(52, 211, 153, 0.12)',   // emerald-light
    'rgba(244, 63, 94, 0.12)',    // rose
    'rgba(99, 102, 241, 0.12)',   // indigo
    'rgba(217, 70, 239, 0.12)',   // fuchsia
    'rgba(20, 184, 166, 0.12)',   // teal
    'rgba(234, 179, 8, 0.12)',    // yellow
    'rgba(248, 113, 113, 0.12)',  // red-light
    'rgba(96, 165, 250, 0.12)'   // blue-light
];
var COLOR_SWATCH_SOLID = [
    '#3b82f6','#10b981','#f59e0b','#ef4444','#8b5cf6',
    '#ec4899','#06b6d4','#f97316','#22c55e','#a855f7',
    '#0ea5e9','#fb923c','#34d399','#f43f5e','#6366f1',
    '#d946ef','#14b8a6','#eab308','#f87171','#60a5fa'
];

// Build a value-to-color-index map for the current color field
function buildColorMap(recordIds, recordMap, colorFieldId, colNames) {
    var map = {};
    var idx = 0;
    for (var i = 0; i < recordIds.length; i++) {
        var row = recordMap[recordIds[i]] || {};
        var value = row[colorFieldId];
        if (value === undefined && colNames) value = row[colNames[colorFieldId]];
        var key = getGroupKeyFromValue(value);
        if (!(key in map)) {
            map[key] = idx % COLOR_PALETTE.length;
            idx++;
        }
    }
    return map;
}

function updateColorButtonState() {
    var btn = document.getElementById('color-btn');
    if (currentColorBy) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

// Update record count badge next to filter button
function updateRecordCountBadge() {
    var badge = document.getElementById('record-count-badge');
    if (!badge) return;
    var isFiltered = currentFilters.length > 0 || currentSearchQuery;
    if (isFiltered) {
        badge.textContent = currentRecordIds.length.toLocaleString() + '/' + originalRecordIds.length.toLocaleString();
        badge.className = 'record-count-badge filtered';
    } else {
        badge.textContent = originalRecordIds.length.toLocaleString() + ' records';
        badge.className = 'record-count-badge';
    }
}

// Render color dropdown
function renderColorDropdown(filterText) {
    if (!currentTable) return;
    var container = document.getElementById('color-options');
    var fields = META_FIELDS[currentTable] || {};
    var filter = (filterText || '').toLowerCase().trim();

    var html = '';

    // Show "None" option only if it matches filter or no filter
    if (!filter || 'none'.includes(filter)) {
        html += '<div class="color-option' + (!currentColorBy ? ' none-selected' : '') + '" onclick="setColorBy(null)">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>None</span>';
        html += '</div>';
    }

    // Get sorted fields with selected at top
    var usedFieldIds = currentColorBy ? [currentColorBy] : [];
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filter);

    for (var i = 0; i < sortedFields.length; i++) {
        var sf = sortedFields[i];
        var isSelected = currentColorBy === sf.fieldId;
        html += '<div class="color-option' + (isSelected ? ' selected' : '') + '" onclick="setColorBy(\'' + esc(sf.fieldId) + '\')">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>' + esc(sf.fieldName) + '</span>';
        html += '</div>';
    }

    if (!html) {
        html = '<div class="color-option" style="color: #999; cursor: default;">No matching fields</div>';
    }

    container.innerHTML = html;
}

// Filter color dropdown based on search input
function filterColorDropdown(filterText) {
    renderColorDropdown(filterText);
}

// Set color by field
async function setColorBy(fieldId) {
    currentColorBy = fieldId;
    closeViewControlDropdowns();
    updateColorButtonState();
    await renderTable();
    // Persist colorBy to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('colorBy', currentColorBy);
    }
}

// Update row height dropdown selection
function updateRowHeightDropdown() {
    document.querySelectorAll('.row-height-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    var options = document.querySelectorAll('.row-height-option');
    options.forEach(opt => {
        if (opt.textContent.trim().toLowerCase().replace(' ', '-') === currentRowHeight ||
            (opt.textContent.trim() === 'Short' && currentRowHeight === 'short') ||
            (opt.textContent.trim() === 'Medium' && currentRowHeight === 'medium') ||
            (opt.textContent.trim() === 'Tall' && currentRowHeight === 'tall') ||
            (opt.textContent.trim() === 'Extra tall' && currentRowHeight === 'extra-tall')) {
            opt.classList.add('selected');
        }
    });
}

// Set row height
function setRowHeight(height) {
    currentRowHeight = height;
    closeViewControlDropdowns();

    var table = document.getElementById('table');
    if (table) {
        table.className = 'row-height-' + height;
    }
}

// Handle view search (debounced to avoid per-keystroke re-renders)
var _viewSearchTimer = null;
function handleViewSearch(query) {
    clearTimeout(_viewSearchTimer);
    var q = query.toLowerCase();
    _viewSearchTimer = setTimeout(function() {
        currentSearchQuery = q;
        renderTable();
    }, 150);
}

// Update closeAllDropdowns to also close view control dropdowns
var originalCloseAllDropdowns = closeAllDropdowns;
closeAllDropdowns = function() {
    originalCloseAllDropdowns();
    closeViewControlDropdowns();
};

// Add click handler for view control dropdowns
document.addEventListener('click', function(e) {
    var wrapper = e.target.closest('.view-control-wrapper');
    if (!wrapper) {
        closeViewControlDropdowns();
    }
});

// ============ Column Drag & Drop Reordering ============

var draggedColumnFieldId = null;

// Optimized DOM-based column movement (no full table re-render)
function moveColumnInDOM(fromIndex, toIndex) {
    var table = document.getElementById('table');
    if (!table) return false;

    // Account for the Actions column at index 0
    var domFromIndex = fromIndex + 1;
    var domToIndex = toIndex + 1;

    // Move header
    var headerRow = table.querySelector('thead tr');
    if (!headerRow) return false;

    var headers = headerRow.children;
    if (domFromIndex >= headers.length || domToIndex >= headers.length) return false;

    var headerToMove = headers[domFromIndex];
    var targetHeader = headers[domToIndex];

    if (domFromIndex < domToIndex) {
        // Moving right: insert after target
        targetHeader.after(headerToMove);
    } else {
        // Moving left: insert before target
        targetHeader.before(headerToMove);
    }

    // Update data-field-index attributes on all headers
    Array.from(headers).forEach((th, idx) => {
        if (idx > 0 && th.dataset.fieldIndex !== undefined) {
            th.dataset.fieldIndex = idx - 1;
        }
    });

    // Move cells in all body rows
    var bodyRows = table.querySelectorAll('tbody tr:not(.group-header-row)');
    bodyRows.forEach(row => {
        var cells = row.children;
        if (domFromIndex >= cells.length || domToIndex >= cells.length) return;

        var cellToMove = cells[domFromIndex];
        var targetCell = cells[domToIndex];

        if (domFromIndex < domToIndex) {
            targetCell.after(cellToMove);
        } else {
            targetCell.before(cellToMove);
        }
    });

    return true;
}

// Update field visibility in memory and trigger debounced save (no IndexedDB await)
function updateFieldVisibilityFast(tableId, viewId, newHiddenFieldIds) {
    // Update in-memory config
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    if (!VIEW_FIELD_CONFIG[tableId][viewId]) {
        VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [], fieldOrder: [] };
    }
    VIEW_FIELD_CONFIG[tableId][viewId].hiddenFieldIds = newHiddenFieldIds;

    // Update META_VIEWS as well for consistency
    if (META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId].hiddenFieldIds = newHiddenFieldIds;
    }

    invalidateVisibleFieldsCache();
    // Mark dirty for debounced auto-save (uses existing system)
    markViewDirty('hiddenFieldIds', newHiddenFieldIds);
}

// Update field order in memory and trigger debounced save
function updateFieldOrderFast(tableId, viewId, newFieldOrder) {
    // Update in-memory config
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    if (!VIEW_FIELD_CONFIG[tableId][viewId]) {
        VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [], fieldOrder: [] };
    }
    VIEW_FIELD_CONFIG[tableId][viewId].fieldOrder = newFieldOrder;

    // Update META_VIEWS as well for consistency
    if (META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId].fieldOrder = newFieldOrder;
    }

    invalidateVisibleFieldsCache();
    // Mark dirty for debounced auto-save (uses existing system)
    markViewDirty('fieldOrder', newFieldOrder);
}

function handleColumnDragStart(event) {
    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId) return;

    draggedColumnFieldId = th.dataset.fieldId;
    th.classList.add('dragging');

    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', draggedColumnFieldId);
}

function handleColumnDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';

    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId) return;

    // Remove drag-over class from all headers
    document.querySelectorAll('th.drag-over').forEach(el => el.classList.remove('drag-over'));

    // Add drag-over class to current target
    if (th.dataset.fieldId !== draggedColumnFieldId) {
        th.classList.add('drag-over');
    }
}

function handleColumnDragEnd(event) {
    // Remove all drag classes
    document.querySelectorAll('th.dragging').forEach(el => el.classList.remove('dragging'));
    document.querySelectorAll('th.drag-over').forEach(el => el.classList.remove('drag-over'));
    draggedColumnFieldId = null;
}

function handleColumnDrop(event) {
    event.preventDefault();

    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId || !draggedColumnFieldId) {
        handleColumnDragEnd(event);
        return;
    }

    var targetFieldId = th.dataset.fieldId;
    if (targetFieldId === draggedColumnFieldId) {
        handleColumnDragEnd(event);
        return;
    }

    // Reorder the fields (synchronous DOM update)
    reorderColumn(draggedColumnFieldId, targetFieldId);

    handleColumnDragEnd(event);
}

function reorderColumn(draggedFieldId, targetFieldId) {
    if (!currentTable) return;

    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var fromIdx = config.fieldOrder.indexOf(draggedFieldId);
    var toIdx = config.fieldOrder.indexOf(targetFieldId);

    if (fromIdx < 0 || toIdx < 0) return;

    // Optimized: Move columns in DOM immediately (no full re-render)
    var domMoved = moveColumnInDOM(fromIdx, toIdx);

    // Update the field order array
    config.fieldOrder.splice(fromIdx, 1);
    var insertIdx = fromIdx < toIdx ? toIdx - 1 : toIdx;
    config.fieldOrder.splice(insertIdx, 0, draggedFieldId);

    // Fast update: in-memory + debounced save (no blocking await)
    updateFieldOrderFast(currentTable, viewId, config.fieldOrder);

    // Update fields dropdown to reflect new order
    renderFieldsDropdown();
}

// ============ Default View Protection & View Creation ============

// Check if current view is the default view (cannot be modified directly)
function isDefaultView() {
    return !currentView || currentView === '_default';
}

// Generate default view name: "{Table Name} {DateTime}"
function generateDefaultViewName() {
    var tableName = 'View';
    if (currentTable && META_TABLES[currentTable]) {
        tableName = META_TABLES[currentTable].tableName || currentTable;
    }
    var now = new Date();
    var dateStr = now.toLocaleDateString() + ' ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    return tableName + ' ' + dateStr;
}

// Show create view modal when user tries to modify default view
function promptCreateViewFromDefault(action, data, reason) {
    pendingViewAction = { action: action, data: data };

    // Close any open dropdowns so they don't overlap the modal
    closeAllDropdowns();

    // Set the reason text
    var reasonEl = document.getElementById('create-view-reason');
    if (reasonEl) {
        reasonEl.textContent = reason || 'The default view cannot be modified. Create a new view to customize.';
    }

    // Set default view name
    var nameInput = document.getElementById('create-view-name');
    if (nameInput) {
        nameInput.value = generateDefaultViewName();
    }

    // Reset other fields
    document.getElementById('create-view-type').value = 'grid';
    document.getElementById('create-view-tags').value = '';

    // Populate parent view options
    populateParentViewOptions();

    // Populate workspace options
    populateWorkspaceOptions();

    // Show modal
    document.getElementById('create-view-modal').classList.add('open');

    // Focus name input
    setTimeout(() => nameInput?.focus(), 100);
}

// Populate parent view dropdown for nesting
function populateParentViewOptions() {
    var select = document.getElementById('create-view-parent');
    if (!select || !currentTable) return;

    var html = '<option value="">(No parent - root level)</option>';
    var views = META_VIEWS[currentTable] || {};

    for (var vid in views) {
        if (vid === '_default') continue;
        var view = views[vid];
        html += '<option value="' + esc(vid) + '">' + esc(view.viewName || vid) + '</option>';
    }

    select.innerHTML = html;
}

// Populate workspace dropdown
function populateWorkspaceOptions() {
    var select = document.getElementById('create-view-workspace');
    if (!select) return;

    var html = '<option value="">(None)</option>';

    for (var wid in WORKSPACES) {
        var ws = WORKSPACES[wid];
        html += '<option value="' + esc(wid) + '">' + esc(ws.workspaceName) + '</option>';
    }

    // Add option to create new workspace
    html += '<option value="_new">+ Create new workspace...</option>';

    select.innerHTML = html;
}

// Close create view modal
function closeCreateViewModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('create-view-modal').classList.remove('open');
    pendingViewAction = null;
}

// Submit create view
async function submitCreateView() {
    var nameInput = document.getElementById('create-view-name');
    var typeSelect = document.getElementById('create-view-type');
    var parentSelect = document.getElementById('create-view-parent');
    var tagsInput = document.getElementById('create-view-tags');
    var workspaceSelect = document.getElementById('create-view-workspace');

    var viewName = nameInput.value.trim();
    if (!viewName) {
        alert('Please enter a view name');
        nameInput.focus();
        return;
    }

    // Disable button to prevent double-clicks
    var submitBtn = document.getElementById('create-view-submit');
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Creating...';
    }

    try {
        var viewType = typeSelect.value;
        var parentViewId = parentSelect.value || null;
        var tags = tagsInput.value.split(',').map(t => t.trim()).filter(t => t);
        var workspaceId = workspaceSelect.value;

        // Handle "create new workspace" option
        if (workspaceId === '_new') {
            var wsName = prompt('Enter workspace name:');
            if (wsName) {
                workspaceId = await createWorkspace(wsName);
            } else {
                workspaceId = null;
            }
        }

        // Create the new view
        var newViewId = 'viw_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        var newView = {
            tableId: currentTable,
            viewId: newViewId,
            viewName: viewName,
            viewType: viewType,
            parentViewId: parentViewId,
            tags: tags,
            hiddenFieldIds: [],
            fieldOrder: [],
            filters: [],
            sorts: [],
            groupBy: null,
            folderId: null
        };

        // If there was a pending action (filter, sort, etc.), apply it to the new view
        if (pendingViewAction) {
            switch (pendingViewAction.action) {
                case 'filter':
                    newView.filters = [pendingViewAction.data];
                    break;
                case 'sort':
                    newView.sorts = [pendingViewAction.data];
                    break;
                case 'group':
                    newView.groupBy = pendingViewAction.data;
                    break;
                case 'hideField':
                    newView.hiddenFieldIds = [pendingViewAction.data];
                    break;
            }
        }

        // Add to workspace if selected
        if (workspaceId && WORKSPACES[workspaceId]) {
            WORKSPACES[workspaceId].viewIds.push(newViewId);
            await saveWorkspace(WORKSPACES[workspaceId]);
        }

        // Save the view
        if (!META_VIEWS[currentTable]) META_VIEWS[currentTable] = {};
        META_VIEWS[currentTable][newViewId] = newView;
        await saveView(newView);

        // Set ownership and sharing on the new view
        var currentUserId = MatrixClient.getUserId();
        if (currentUserId) {
            await SharedViews.setViewOwnership(currentTable, newViewId, currentUserId);
        }

        // Apply sharing preference from modal
        var sharingSelect = document.getElementById('create-view-sharing');
        var sharingLevel = sharingSelect ? sharingSelect.value : 'private';
        if (sharingLevel !== 'private' && currentUserId) {
            await SharedViews.shareView(currentTable, newViewId, sharingLevel, []);
        }

        // Close modal
        closeCreateViewModal();

        // Refresh sidebar
        await loadTableViewsAsync(currentTable);

        // Switch to the new view
        await selectTableView(currentTable, newViewId);
    } catch (err) {
        console.error('Failed to create view:', err);
        alert('Failed to create view: ' + (err.message || 'Unknown error'));
    } finally {
        // Re-enable button
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Create View';
        }
    }
}

// ============ Workspace Management ============

// Get all workspaces from IndexedDB
function getAllWorkspaces() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readonly');
        var req = tx.objectStore('workspaces').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Save a workspace to IndexedDB
function saveWorkspace(workspace) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readwrite');
        tx.objectStore('workspaces').put(workspace);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Delete a workspace from IndexedDB
function deleteWorkspaceFromDB(workspaceId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readwrite');
        tx.objectStore('workspaces').delete(workspaceId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Create a new workspace
async function createWorkspace(name) {
    var workspaceId = 'ws_' + Date.now();
    var workspace = {
        workspaceId: workspaceId,
        workspaceName: name,
        viewIds: [],
        sortOrder: Object.keys(WORKSPACES).length
    };

    WORKSPACES[workspaceId] = workspace;
    await saveWorkspace(workspace);

    // Sync to backend
    await saveWorkspaceToBackend(workspace, 'create');

    return workspaceId;
}

// Add a view to a workspace
async function addViewToWorkspace(viewId, workspaceId) {
    if (!WORKSPACES[workspaceId]) return;

    if (!WORKSPACES[workspaceId].viewIds.includes(viewId)) {
        WORKSPACES[workspaceId].viewIds.push(viewId);
        await saveWorkspace(WORKSPACES[workspaceId]);
        await saveWorkspaceToBackend(WORKSPACES[workspaceId], 'update');
    }
}

// Remove a view from a workspace
async function removeViewFromWorkspace(viewId, workspaceId) {
    if (!WORKSPACES[workspaceId]) return;

    var idx = WORKSPACES[workspaceId].viewIds.indexOf(viewId);
    if (idx >= 0) {
        WORKSPACES[workspaceId].viewIds.splice(idx, 1);
        await saveWorkspace(WORKSPACES[workspaceId]);
        await saveWorkspaceToBackend(WORKSPACES[workspaceId], 'update');
    }
}

// Delete a workspace
async function deleteWorkspace(workspaceId) {
    if (!confirm('Delete this workspace?')) return;

    delete WORKSPACES[workspaceId];
    await deleteWorkspaceFromDB(workspaceId);
    await saveWorkspaceToBackend({ workspaceId: workspaceId }, 'delete');

    if (currentWorkspace === workspaceId) {
        currentWorkspace = null;
    }

    renderSidebar();
}

// Save workspace to backend (local only  data flows Airtable  n8n  Matrix)
async function saveWorkspaceToBackend(workspace, operator) {
    // Workspace config is stored locally via user preferences (Matrix account data).
    try {
        await UserPreferences.set('workspace:' + workspace.workspaceId, workspace);
    } catch (error) {
        console.error('Failed to save workspace:', error);
    }
}

// Load workspaces into memory
async function loadWorkspaces() {
    try {
        var workspaces = await getAllWorkspaces();
        WORKSPACES = {};
        workspaces.forEach(ws => WORKSPACES[ws.workspaceId] = ws);
    } catch (err) {
        console.error('Error loading workspaces:', err);
    }
}

// ============ Schema View Rendering ============

// Render schema view (card-based vertical layout)
async function renderSchemaView() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');

    // Get records (limited for performance)
    var displayRecordIds = currentRecordIds.slice(0, 50); // Show up to 50 cards

    if (displayRecordIds.length === 0) {
        container.innerHTML = '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        document.getElementById('pagination').style.display = 'none';
        return;
    }

    var records = await getRecordsByIds(currentTable, displayRecordIds);
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);

    var html = '<div class="schema-view-container">';

    for (var record of records) {
        var recordId = record.recordId;
        var recordFields = record.fields || {};

        html += '<div class="schema-card" data-record-id="' + esc(recordId) + '" onclick="handleRowClick(event, \'' + esc(currentTable) + '\', \'' + esc(recordId) + '\')" style="cursor: pointer;">';

        // Card header
        html += '<div class="schema-card-header">';
        html += '<span class="schema-card-id">' + esc(recordId) + '</span>';
        html += '<div class="schema-card-actions">';
        html += '<button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(recordId) + '\')" title="View field history">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
        html += '</button>';
        html += '</div>';
        html += '</div>';

        // Card body - all fields vertically
        html += '<div class="schema-card-body">';

        for (var fid of fieldIds) {
            var field = fields[fid];
            var fieldName = field.fieldName || fid;
            var value = recordFields[fid];
            if (value === undefined) value = recordFields[fieldName];

            html += '<div class="schema-field-row">';
            html += '<div class="schema-field-name">' + esc(fieldName) + '</div>';

            if (value == null || value === '') {
                html += '<div class="schema-field-value empty"></div>';
            } else {
                html += '<div class="schema-field-value">' + formatCell(value) + '</div>';
            }

            html += '</div>';
        }

        html += '</div>'; // .schema-card-body
        html += '</div>'; // .schema-card
    }

    html += '</div>'; // .schema-view-container

    container.innerHTML = html;

    // Update pagination info (schema view shows limited records)
    document.getElementById('pagination').style.display = 'none';
    updateStatus('Showing ' + displayRecordIds.length + ' of ' + totalRecords + ' records', true, null, 'Schema view');
}

// ============ View Type Detection & Rendering ============

// Get the current view's type
function getCurrentViewType() {
    if (!currentTable || !currentView || currentView === '_default') {
        return 'grid'; // Default view is always grid
    }

    var view = META_VIEWS[currentTable]?.[currentView];
    return view?.viewType || 'grid';
}

// Override renderTable to handle different view types
var originalRenderTable = renderTable;
renderTable = async function() {
    var viewType = getCurrentViewType();

    if (viewType === 'schema') {
        await renderSchemaView();
    } else {
        await originalRenderTable();
    }
};

// ============ Override Filter/Sort/Field Functions for Default View Protection ============

// Store original functions
var originalAddFilter = addFilter;
var originalAddSort = addSort;
var originalSetGroupBy = setGroupBy;
var originalToggleFieldVisibility = toggleFieldVisibility;

// Override addFilter to protect default view
addFilter = function() {
    if (isDefaultView()) {
        var fields = META_FIELDS[currentTable] || {};
        var firstFieldId = Object.keys(fields)[0];
        promptCreateViewFromDefault('filter', {
            fieldId: firstFieldId,
            operator: 'contains',
            value: ''
        }, 'To add filters, please create a new view. The default view shows all records without filters.');
        return;
    }
    originalAddFilter();
};

// Override addSort to protect default view
addSort = function() {
    if (isDefaultView()) {
        var fields = META_FIELDS[currentTable] || {};
        var firstFieldId = Object.keys(fields)[0];
        promptCreateViewFromDefault('sort', {
            fieldId: firstFieldId,
            direction: 'asc'
        }, 'To add sorting, please create a new view. The default view maintains the original record order.');
        return;
    }
    originalAddSort();
};

// Override setGroupBy to protect default view
setGroupBy = async function(fieldId) {
    if (isDefaultView() && fieldId) {
        promptCreateViewFromDefault('group', fieldId, 'To group records, please create a new view. The default view shows records ungrouped.');
        return;
    }
    await originalSetGroupBy(fieldId);
};

// Override toggleFieldVisibility to protect default view
toggleFieldVisibility = async function(fieldId) {
    if (isDefaultView()) {
        promptCreateViewFromDefault('hideField', fieldId, 'To customize visible fields, please create a new view. The default view shows all fields.');
        return;
    }
    await originalToggleFieldVisibility(fieldId);
};

// ============ View Tags UI ============

// Get tags for a view
function getViewTags(tableId, viewId) {
    var view = META_VIEWS[tableId]?.[viewId];
    return view?.tags || [];
}

// Add tag to a view
async function addTagToView(tableId, viewId, tag) {
    var view = META_VIEWS[tableId]?.[viewId];
    if (!view) return;

    if (!view.tags) view.tags = [];
    if (!view.tags.includes(tag)) {
        view.tags.push(tag);
        await saveView(view);
        markViewDirty('tags', view.tags);
    }
}

// Remove tag from a view
async function removeTagFromView(tableId, viewId, tag) {
    var view = META_VIEWS[tableId]?.[viewId];
    if (!view || !view.tags) return;

    var idx = view.tags.indexOf(tag);
    if (idx >= 0) {
        view.tags.splice(idx, 1);
        await saveView(view);
        markViewDirty('tags', view.tags);
    }
}

// Render tags for a view in sidebar
function renderViewTags(tags) {
    if (!tags || tags.length === 0) return '';

    var html = '<div class="view-tags">';
    tags.slice(0, 3).forEach(tag => {
        html += '<span class="view-tag">' + esc(tag) + '</span>';
    });
    if (tags.length > 3) {
        html += '<span class="view-tag">+' + (tags.length - 3) + '</span>';
    }
    html += '</div>';
    return html;
}

// ============ Enhanced Sidebar View Rendering ============

// Update renderViewItem to show tags, type badges, and nesting
var originalRenderViewItem = renderViewItem;
renderViewItem = function(tableId, view, inFolder) {
    var isActive = currentTable === tableId && currentView === view.viewId;
    var viewName = view.viewName || view.viewId;
    var viewIcon = getViewTypeIcon(view.viewType);
    var paddingClass = inFolder ? ' style="padding-left: 52px;"' : '';

    // Calculate nesting level
    var nestLevel = 0;
    var parentId = view.parentViewId;
    while (parentId && nestLevel < 3) {
        nestLevel++;
        var parentView = META_VIEWS[tableId]?.[parentId];
        parentId = parentView?.parentViewId;
    }

    var nestClass = nestLevel > 0 ? ' nested-level-' + nestLevel : '';

    var html = '<div class="table-view-item' + (isActive ? ' active' : '') + nestClass + '"' + paddingClass + ' ' +
           'onclick="selectTableView(\'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'oncontextmenu="showViewContextMenu(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')">';

    // Nesting indicator
    if (nestLevel > 0) {
        html += '<span class="view-nest-indicator"></span>';
    }

    html += '<span class="view-icon">' + viewIcon + '</span>' +
           '<span class="view-name">' + esc(viewName) + '</span>';

    // View type badge
    if (view.viewType && view.viewType !== 'grid') {
        var badgeLabel = view.viewType === 'schema' ? 'cards' : view.viewType;
        html += '<span class="view-type-badge ' + esc(view.viewType) + '">' + esc(badgeLabel) + '</span>';
    }

    html += '</div>';

    // Tags row (if present)
    var tags = view.tags || [];
    if (tags.length > 0) {
        html += renderViewTags(tags);
    }

    return html;
};

// ============ Matrix Setup Wizard ============

var wizardStep = 0;
var wizardData = {
    orgName: '',
    orgSpaceId: null,
    // Legacy data source
    aminoApiKey: '',
    aminoEndpoints: null,
    // Schema from legacy system
    legacyTables: {},
    legacyFields: {},
    legacyAmoData: null,
    // Client configuration
    clientTable: '',
    clientIdentifierField: '',
    clientVisibleTables: [],
    clientVisibleLinkedTables: [], // "which linked record types can a client see?"
    linkedRecordTables: {} // tableId -> fieldId that links to client table
};

var WIZARD_STEPS = [
    { id: 'org', title: 'Organization', subtitle: 'Set up or join your organization' },
    { id: 'legacy', title: 'Import Data', subtitle: 'Connect your existing data source' },
    { id: 'client-table', title: 'Client Records', subtitle: 'Which record type creates clients?' },
    { id: 'visibility', title: 'Client Visibility', subtitle: 'What can clients see?' },
    { id: 'hydrate', title: 'Hydrating', subtitle: 'Building your Matrix rooms' }
];

async function showMatrixWizard() {
    document.getElementById('matrix-wizard').classList.remove('hidden');
    wizardStep = 0;

    // Reuse existing Synapse session for MatrixClient (no second login needed)
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
        try {
            await MatrixClient.initialSync();
            wizardData.orgSpaceId = await MatrixClient.findOrgSpace();
        } catch (e) {
            console.error('[Wizard] Failed to initialize Matrix session:', e);
        }
    }

    renderWizardStep();
}

function hideMatrixWizard() {
    document.getElementById('matrix-wizard').classList.add('hidden');
}

function renderWizardStep() {
    var step = WIZARD_STEPS[wizardStep];

    // Update header
    document.getElementById('wizard-title').textContent = step.title;
    document.getElementById('wizard-subtitle').textContent = step.subtitle;

    // Update step dots
    var dots = document.querySelectorAll('.wizard-step-dot');
    dots.forEach(function(dot, i) {
        dot.className = 'wizard-step-dot';
        if (i < wizardStep) dot.classList.add('completed');
        if (i === wizardStep) dot.classList.add('active');
    });

    // Update footer buttons
    var backBtn = document.getElementById('wizard-back');
    var nextBtn = document.getElementById('wizard-next');
    backBtn.style.display = wizardStep > 0 ? '' : 'none';
    nextBtn.disabled = false;

    if (wizardStep === WIZARD_STEPS.length - 1) {
        nextBtn.style.display = 'none';
    } else {
        nextBtn.style.display = '';
        nextBtn.textContent = wizardStep === WIZARD_STEPS.length - 2 ? 'Begin Hydration' : 'Next';
    }

    // Render step body
    var body = document.getElementById('wizard-body');
    switch (step.id) {
        case 'org': renderWizardOrg(body); break;
        case 'legacy': renderWizardLegacy(body); break;
        case 'client-table': renderWizardClientTable(body); break;
        case 'visibility': renderWizardVisibility(body); break;
        case 'hydrate': renderWizardHydrate(body); break;
    }
}

// ---- Step 1: Org Setup ----
function renderWizardOrg(container) {
    if (wizardData.orgSpaceId) {
        container.innerHTML =
            '<div class="wizard-success">Connected to existing organization.</div>' +
            '<div class="wizard-info-box">' +
                '<strong>Organization space found.</strong> Your rooms and configuration are already set up.' +
            '</div>';
    } else {
        container.innerHTML =
            '<div class="wizard-error" id="wizard-error"></div>' +
            '<div class="form-group">' +
                '<label>Organization Name</label>' +
                '<input type="text" id="wiz-org-name" placeholder="e.g. Ramirez & Associates" value="' + esc(wizardData.orgName) + '">' +
            '</div>' +
            '<div class="wizard-info-box">' +
                '<strong>This creates a Matrix Space</strong> that will contain all your client rooms and firm data. ' +
                'Staff and clients will be invited to specific rooms within this space.' +
            '</div>';
    }
}

// ---- Step 3: Legacy Data Source ----
function renderWizardLegacy(container) {
    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Amino API Key <span class="label-hint">(your existing key)</span></label>' +
            '<input type="password" id="wiz-amino-key" placeholder="API Key" value="' + esc(wizardData.aminoApiKey) + '">' +
        '</div>' +
        '<div class="wizard-info-box">' +
            '<strong>How this works:</strong> We\'ll download your current data via Matrix Synapse, ' +
            'then build local state from it. Your Airtable data stays untouched until you decide to sever the connection.' +
        '</div>';
}

// ---- Step 4: Client Table Selection ----
function renderWizardClientTable(container) {
    var tableOptions = '<option value="">-- Select a table --</option>';
    var tableIds = Object.keys(wizardData.legacyTables);
    tableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var selected = wizardData.clientTable === tid ? ' selected' : '';
        tableOptions += '<option value="' + esc(tid) + '"' + selected + '>' + esc(t.tableName || tid) + '</option>';
    });

    // Field selector (populated when table changes)
    var fieldOptions = '<option value="">-- Select a field --</option>';
    if (wizardData.clientTable && wizardData.legacyFields[wizardData.clientTable]) {
        var fields = wizardData.legacyFields[wizardData.clientTable];
        Object.keys(fields).forEach(function(fid) {
            var f = fields[fid];
            var selected = wizardData.clientIdentifierField === fid ? ' selected' : '';
            fieldOptions += '<option value="' + esc(fid) + '"' + selected + '>' + esc(f.fieldName || fid) + '</option>';
        });
    }

    // Linked record field detection per table
    var linkedHtml = '';
    tableIds.forEach(function(tid) {
        if (tid === wizardData.clientTable) return;
        var t = wizardData.legacyTables[tid];
        var fields = wizardData.legacyFields[tid] || {};
        var fids = Object.keys(fields);
        // Find fields that could be linked records (arrays or IDs referencing client table)
        var linkFieldOptions = '<option value="">-- No link --</option>';
        fids.forEach(function(fid) {
            var f = fields[fid];
            var selected = wizardData.linkedRecordTables[tid] === fid ? ' selected' : '';
            linkFieldOptions += '<option value="' + esc(fid) + '"' + selected + '>' + esc(f.fieldName || fid) + '</option>';
        });
        linkedHtml +=
            '<div class="linked-record-row">' +
                '<span class="table-name">' + esc(t.tableName || tid) + '</span>' +
                '<select onchange="wizardSetLinkedField(\'' + esc(tid) + '\', this.value)">' + linkFieldOptions + '</select>' +
            '</div>';
    });

    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Which table represents your clients?</label>' +
            '<select id="wiz-client-table" onchange="wizardClientTableChanged(this.value)">' + tableOptions + '</select>' +
        '</div>' +
        '<div class="form-group">' +
            '<label>Which field identifies each client?</label>' +
            '<select id="wiz-client-field" onchange="wizardData.clientIdentifierField=this.value">' + fieldOptions + '</select>' +
        '</div>' +
        (linkedHtml ?
        '<div class="form-group">' +
            '<label>Which field on each table links to a client record? <span class="label-hint">(the linked record field)</span></label>' +
            '<div class="checkbox-group">' + linkedHtml + '</div>' +
        '</div>' : '') +
        '<div class="wizard-info-box">' +
            '<strong>This is how rooms get created.</strong> Each unique client gets their own Matrix Space with a Matter Room. ' +
            'Other records are assigned to clients via the linked record field you select.' +
        '</div>';
}

function wizardClientTableChanged(tableId) {
    wizardData.clientTable = tableId;
    wizardData.clientIdentifierField = '';
    renderWizardStep(); // re-render to update field dropdown
}

function wizardSetLinkedField(tableId, fieldId) {
    if (fieldId) {
        wizardData.linkedRecordTables[tableId] = fieldId;
    } else {
        delete wizardData.linkedRecordTables[tableId];
    }
}

// ---- Step 5: Client Visibility ----
function renderWizardVisibility(container) {
    var tableIds = Object.keys(wizardData.legacyTables);

    // Table visibility checkboxes
    var tableCheckboxes = '';
    tableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var checked = wizardData.clientVisibleTables.indexOf(tid) !== -1 ? ' checked' : '';
        tableCheckboxes +=
            '<label class="checkbox-item">' +
                '<input type="checkbox" value="' + esc(tid) + '"' + checked +
                    ' onchange="wizardToggleClientVisibleTable(\'' + esc(tid) + '\', this.checked)">' +
                '<span>' + esc(t.tableName || tid) + '</span>' +
            '</label>';
    });

    // Linked record type visibility (which linked record types can a client see?)
    var linkedTableCheckboxes = '';
    var linkedTableIds = Object.keys(wizardData.linkedRecordTables);
    linkedTableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var checked = wizardData.clientVisibleLinkedTables.indexOf(tid) !== -1 ? ' checked' : '';
        linkedTableCheckboxes +=
            '<label class="checkbox-item">' +
                '<input type="checkbox" value="' + esc(tid) + '"' + checked +
                    ' onchange="wizardToggleClientVisibleLinkedTable(\'' + esc(tid) + '\', this.checked)">' +
                '<span>' + esc(t.tableName || tid) + '</span>' +
            '</label>';
    });

    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Which tables can clients see in their portal?</label>' +
            '<div class="checkbox-group">' + tableCheckboxes + '</div>' +
        '</div>' +
        (linkedTableCheckboxes ?
        '<div class="form-group">' +
            '<label>Which linked record types can a client see? <span class="label-hint">(records linked to their client record)</span></label>' +
            '<div class="checkbox-group">' + linkedTableCheckboxes + '</div>' +
        '</div>' : '') +
        '<div class="wizard-info-box">' +
            '<strong>Clients only see their own data.</strong> Tables you check here will be visible in the client portal. ' +
            'Internal notes, billing, and strategy data should remain unchecked.' +
        '</div>';
}

function wizardToggleClientVisibleTable(tableId, checked) {
    var idx = wizardData.clientVisibleTables.indexOf(tableId);
    if (checked && idx === -1) wizardData.clientVisibleTables.push(tableId);
    if (!checked && idx !== -1) wizardData.clientVisibleTables.splice(idx, 1);
}

function wizardToggleClientVisibleLinkedTable(tableId, checked) {
    var idx = wizardData.clientVisibleLinkedTables.indexOf(tableId);
    if (checked && idx === -1) wizardData.clientVisibleLinkedTables.push(tableId);
    if (!checked && idx !== -1) wizardData.clientVisibleLinkedTables.splice(idx, 1);
}

// ---- Step 6: Hydration ----
function renderWizardHydrate(container) {
    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="wizard-progress-section">' +
            '<div class="wizard-progress-bar">' +
                '<div class="wizard-progress-fill" id="wiz-hydrate-progress" style="width: 0%"></div>' +
            '</div>' +
            '<div class="wizard-progress-status" id="wiz-hydrate-status">Preparing...</div>' +
            '<div class="wizard-progress-detail" id="wiz-hydrate-detail"></div>' +
        '</div>';

    // Start hydration automatically
    setTimeout(runHydration, 300);
}

// ============ Wizard Navigation ============

function wizardBack() {
    if (wizardStep > 0) {
        wizardStep--;
        renderWizardStep();
    }
}

async function wizardNext() {
    var nextBtn = document.getElementById('wizard-next');
    nextBtn.disabled = true;

    try {
        switch (WIZARD_STEPS[wizardStep].id) {
            case 'org':
                await wizardValidateOrg();
                break;
            case 'legacy':
                await wizardValidateLegacy();
                break;
            case 'client-table':
                wizardValidateClientTable();
                break;
            case 'visibility':
                // No validation needed, proceed to hydration
                break;
        }
        wizardStep++;
        renderWizardStep();
    } catch (err) {
        showWizardError(err.message);
        nextBtn.disabled = false;
    }
}

function showWizardError(msg) {
    var el = document.getElementById('wizard-error');
    if (el) { el.style.display = 'block'; el.textContent = msg; }
}

function hideWizardError() {
    var el = document.getElementById('wizard-error');
    if (el) el.style.display = 'none';
}

// ============ Wizard Validation ============

async function wizardValidateOrg() {
    if (!wizardData.orgSpaceId) {
        var orgName = document.getElementById('wiz-org-name');
        if (!orgName) throw new Error('Organization already configured');
        var name = orgName.value.trim();
        if (!name) throw new Error('Please enter an organization name');
        wizardData.orgName = name;
        wizardData.orgSpaceId = await MatrixClient.createOrgSpace(name);
    }
}

async function wizardValidateLegacy() {
    // Legacy wizard step  Xano endpoints removed. Data comes from Matrix Synapse.
    // Open IndexedDB
    if (!db) db = await openDB();

    // Hydrate from Synapse rooms
    await hydrateFromSynapse();

    // Reload metadata
    var tables = await getAllTables();
    var fields = await getAllFields();
    tables.forEach(function(t) { wizardData.legacyTables[t.tableId] = t; });
    fields.forEach(function(f) {
        if (!wizardData.legacyFields[f.tableId]) wizardData.legacyFields[f.tableId] = {};
        wizardData.legacyFields[f.tableId][f.fieldId] = f;
    });

    if (Object.keys(wizardData.legacyTables).length === 0) {
        throw new Error('No tables found. Verify your Synapse session and room membership.');
    }
}

function wizardValidateClientTable() {
    if (!wizardData.clientTable) throw new Error('Please select which table represents your clients');
    if (!wizardData.clientIdentifierField) throw new Error('Please select which field identifies each client');
}

// ============ Hydration Execution ============

async function runHydration() {
    var progressEl = document.getElementById('wiz-hydrate-progress');
    var statusEl = document.getElementById('wiz-hydrate-status');
    var detailEl = document.getElementById('wiz-hydrate-detail');

    function updateProgress(pct, status, detail) {
        if (progressEl) progressEl.style.width = pct + '%';
        if (statusEl) statusEl.textContent = status;
        if (detailEl) detailEl.textContent = detail || '';
    }

    try {
        updateProgress(5, 'Preparing data...');

        // Build amo-style data structure from IndexedDB for the bridge
        var allRecords = [];
        var tableIds = Object.keys(wizardData.legacyTables);
        for (var i = 0; i < tableIds.length; i++) {
            var tid = tableIds[i];
            var recordIds = await new Promise(function(resolve, reject) {
                var tx = db.transaction('data', 'readonly');
                var store = tx.objectStore('data');
                var index = store.index('by_table');
                var req = index.getAllKeys(tid);
                req.onsuccess = function() { resolve(req.result || []); };
                req.onerror = function() { reject(req.error); };
            });

            for (var r = 0; r < recordIds.length; r++) {
                var rec = await new Promise(function(resolve, reject) {
                    var tx2 = db.transaction('data', 'readonly');
                    var req2 = tx2.objectStore('data').get(recordIds[r]);
                    req2.onsuccess = function() { resolve(req2.result); };
                    req2.onerror = function() { reject(req2.error); };
                });
                if (rec) {
                    // Decrypt if needed
                    if (encryptionEnabled && rec._encrypted) {
                        rec = await decryptRecordFromStorage(rec);
                    }
                    allRecords.push({
                        tableId: rec.tableId,
                        recordId: rec.recordId,
                        fields: rec.fields || {}
                    });
                }
            }
        }

        updateProgress(15, 'Grouping records by client...', allRecords.length + ' records found');

        // Configure bridge
        MatrixBridge.setConfig({
            mode: 'bridge',
            orgSpaceId: wizardData.orgSpaceId,
            clientTable: wizardData.clientTable,
            clientIdentifierField: wizardData.clientIdentifierField,
            clientVisibleTables: wizardData.clientVisibleTables,
            clientHiddenTables: tableIds.filter(function(t) {
                return wizardData.clientVisibleTables.indexOf(t) === -1;
            }),
            linkedRecordTables: wizardData.linkedRecordTables,
            clientRoomMap: {},
            lastSyncCursor: 0
        });

        // Group records
        var grouped = MatrixBridge.groupRecordsByClient(
            allRecords,
            wizardData.legacyFields,
            wizardData.clientTable,
            wizardData.clientIdentifierField,
            wizardData.linkedRecordTables
        );

        var clientNames = Object.keys(grouped.groups);
        var totalClients = clientNames.length;

        updateProgress(20, 'Creating Matrix rooms...', totalClients + ' clients detected');

        // Create firm reference room for unassigned data
        var config = MatrixBridge.getConfig();
        if (grouped.unassigned.length > 0) {
            updateProgress(22, 'Creating firm reference room...', grouped.unassigned.length + ' unassigned records');
            var firmRoomId = await MatrixClient.createRoom({
                name: 'Firm Reference Data',
                preset: 'private_chat'
            });
            await MatrixClient.addChildToSpace(wizardData.orgSpaceId, firmRoomId);
            config.firmRoomId = firmRoomId;

            // Write unassigned records to firm room
            for (var u = 0; u < grouped.unassigned.length; u++) {
                var urec = grouped.unassigned[u];
                await MatrixClient.writeRecord(firmRoomId, urec.tableId, urec.recordId, urec.fields);
                if (u % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
            }
        }

        // For each client, create space + matter room + write data
        for (var c = 0; c < clientNames.length; c++) {
            var clientName = clientNames[c];
            var clientGroup = grouped.groups[clientName];
            var pct = 25 + Math.round((c / totalClients) * 70);
            var recordCount = 0;
            Object.values(clientGroup.records).forEach(function(arr) { recordCount += arr.length; });

            updateProgress(pct, 'Creating room for ' + clientName + '...',
                (c + 1) + ' of ' + totalClients + ' clients (' + recordCount + ' records)');

            // Create client space
            var clientSpaceId = await MatrixClient.createClientSpace(wizardData.orgSpaceId, clientName);

            // Create matter room
            var matterRoomId = await MatrixClient.createMatterRoom(clientSpaceId, clientName);

            // Write schemas
            var clientTableIds = Object.keys(clientGroup.records);
            for (var t = 0; t < clientTableIds.length; t++) {
                var tblId = clientTableIds[t];
                var tblMeta = wizardData.legacyTables[tblId] || { tableName: tblId };
                var isVisible = wizardData.clientVisibleTables.indexOf(tblId) !== -1;
                await MatrixClient.writeTableSchema(matterRoomId, tblId, tblMeta.tableName, tblMeta.icon, isVisible);

                var tblFields = wizardData.legacyFields[tblId] || {};
                var fids = Object.keys(tblFields);
                for (var f = 0; f < fids.length; f++) {
                    await MatrixClient.writeFieldSchema(matterRoomId, fids[f], tblFields[fids[f]]);
                    if (f % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }
            }

            // Write records
            for (var rt = 0; rt < clientTableIds.length; rt++) {
                var recs = clientGroup.records[clientTableIds[rt]];
                for (var ri = 0; ri < recs.length; ri++) {
                    await MatrixClient.writeRecord(matterRoomId, recs[ri].tableId, recs[ri].recordId, recs[ri].fields);
                    if (ri % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }
            }

            // Store room mapping
            config.clientRoomMap[clientName] = {
                spaceId: clientSpaceId,
                matterRoomId: matterRoomId,
                portalRoomId: null
            };
        }

        // Save bridge config
        MatrixBridge.setConfig(config);

        // Save config to org space
        await MatrixClient.sendStateEvent(
            wizardData.orgSpaceId,
            MatrixClient.EVENT_TYPES.BRIDGE_CONFIG,
            '',
            config
        );

        // Save locally
        MatrixClient.saveConfig({
            bridge: config,
            homeserverUrl: MatrixClient.getHomeserverUrl(),
            orgSpaceId: wizardData.orgSpaceId,
            userId: MatrixClient.getUserId()
        });

        updateProgress(100, 'Hydration complete!',
            totalClients + ' client rooms created, ' + allRecords.length + ' records written');

        // Show completion UI
        var body = document.getElementById('wizard-body');
        body.innerHTML =
            '<div class="wizard-success">' +
                'Successfully created ' + totalClients + ' client rooms with ' + allRecords.length + ' records.' +
            '</div>' +
            '<div class="wizard-info-box">' +
                '<strong>Bridge mode is active.</strong> The app will continue syncing from your existing Airtable data and routing updates to the appropriate Matrix rooms. ' +
                'When you\'re ready, you can sever the legacy connection from the admin panel.' +
            '</div>' +
            '<div style="text-align: center; padding-top: 12px; display: flex; gap: 12px; justify-content: center;">' +
                '<button class="btn-next" onclick="hideMatrixWizard(); showRoomManager();" style="background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-secondary);">Manage Rooms</button>' +
                '<button class="btn-next" onclick="wizardComplete()" style="background: var(--success-500); border-color: var(--success-500);">Open App</button>' +
            '</div>';

        // Hide footer buttons
        document.getElementById('wizard-footer').style.display = 'none';

    } catch (err) {
        console.error('[Wizard] Hydration failed:', err);
        updateProgress(0, 'Hydration failed');
        showWizardError('Hydration failed: ' + err.message);
        // Show back button
        document.getElementById('wizard-footer').style.display = 'flex';
        document.getElementById('wizard-back').style.display = '';
    }
}

// ============ Room Manager (Bulk Delete) ============

function showRoomManager() {
    var config = MatrixBridge.getConfig();
    var clientNames = Object.keys(config.clientRoomMap || {}).sort();

    if (clientNames.length === 0) {
        alert('No client rooms found.');
        return;
    }

    // Reset UI
    document.getElementById('rm-list-section').style.display = '';
    document.getElementById('rm-progress-section').style.display = 'none';
    document.getElementById('rm-result-section').style.display = 'none';
    document.getElementById('rm-footer').style.display = 'flex';
    document.getElementById('rm-delete-btn').disabled = true;
    document.getElementById('rm-delete-btn').textContent = 'Delete Selected';
    document.getElementById('rm-select-all').checked = false;
    document.getElementById('rm-selected-count').textContent = '0 selected';
    document.getElementById('rm-error').style.display = 'none';
    document.getElementById('rm-title').textContent = 'Manage Rooms';
    document.getElementById('rm-subtitle').textContent = 'Select client rooms to delete';

    // Populate client list
    var listEl = document.getElementById('rm-client-list');
    var html = '';
    clientNames.forEach(function(name) {
        var mapping = config.clientRoomMap[name];
        var roomCount = 1; // space
        if (mapping.matterRoomId) roomCount++;
        if (mapping.portalRoomId) roomCount++;
        html +=
            '<label class="rm-client-row">' +
                '<input type="checkbox" class="rm-client-cb" value="' + esc(name) + '" onchange="rmUpdateCount()">' +
                '<span>' + esc(name) + '</span>' +
                '<span class="rm-room-info">' + roomCount + ' room' + (roomCount !== 1 ? 's' : '') + '</span>' +
            '</label>';
    });
    listEl.innerHTML = html;

    document.getElementById('room-manager').classList.remove('hidden');
}

function hideRoomManager() {
    document.getElementById('room-manager').classList.add('hidden');
}

function rmToggleSelectAll(checked) {
    var cbs = document.querySelectorAll('.rm-client-cb');
    cbs.forEach(function(cb) { cb.checked = checked; });
    rmUpdateCount();
}

function rmUpdateCount() {
    var cbs = document.querySelectorAll('.rm-client-cb:checked');
    var count = cbs.length;
    document.getElementById('rm-selected-count').textContent = count + ' selected';
    document.getElementById('rm-delete-btn').disabled = count === 0;

    // Update select-all state
    var allCbs = document.querySelectorAll('.rm-client-cb');
    document.getElementById('rm-select-all').checked = allCbs.length > 0 && count === allCbs.length;
}

function rmGetSelectedClients() {
    var cbs = document.querySelectorAll('.rm-client-cb:checked');
    var names = [];
    cbs.forEach(function(cb) { names.push(cb.value); });
    return names;
}

function rmConfirmDelete() {
    var selected = rmGetSelectedClients();
    if (selected.length === 0) return;

    var msg = 'Are you sure you want to delete ' + selected.length + ' client room' +
        (selected.length !== 1 ? 's' : '') + '?\n\nThis will leave and forget:\n';

    var config = MatrixBridge.getConfig();
    var totalRooms = 0;
    selected.forEach(function(name) {
        var mapping = config.clientRoomMap[name];
        if (mapping) {
            var count = 1;
            if (mapping.matterRoomId) count++;
            if (mapping.portalRoomId) count++;
            totalRooms += count;
        }
    });

    msg += '- ' + totalRooms + ' total rooms (spaces, matter rooms, portal rooms)\n\nThis cannot be undone.';

    if (!confirm(msg)) return;

    rmExecuteDelete(selected);
}

async function rmExecuteDelete(clientNames) {
    // Switch to progress view
    document.getElementById('rm-list-section').style.display = 'none';
    document.getElementById('rm-progress-section').style.display = '';
    document.getElementById('rm-delete-btn').style.display = 'none';

    var progressEl = document.getElementById('rm-progress');
    var statusEl = document.getElementById('rm-status');
    var detailEl = document.getElementById('rm-detail');

    try {
        var result = await MatrixBridge.deleteClientRooms(clientNames, function(info) {
            if (info.phase === 'deleting') {
                var pct = info.total > 0 ? Math.round((info.completed / info.total) * 100) : 0;
                progressEl.style.width = pct + '%';
                statusEl.textContent = 'Deleting ' + info.clientName + '...';
                detailEl.textContent = info.completed + ' of ' + info.total + ' clients processed';
            } else if (info.phase === 'complete') {
                progressEl.style.width = '100%';
                statusEl.textContent = 'Deletion complete';
            }
        });

        // Show results
        document.getElementById('rm-progress-section').style.display = 'none';
        var resultEl = document.getElementById('rm-result-section');
        resultEl.style.display = '';

        var html = '<div class="wizard-success">' +
            'Successfully deleted ' + result.deleted + ' client room' + (result.deleted !== 1 ? 's' : '') + '.' +
            '</div>';

        if (result.failed.length > 0) {
            html += '<div class="wizard-error" style="display: block;">' +
                '<strong>' + result.failed.length + ' failed:</strong><br>';
            result.failed.forEach(function(f) {
                html += esc(f.clientName) + ': ' + esc(f.error) + '<br>';
            });
            html += '</div>';
        }

        var remaining = Object.keys(MatrixBridge.getConfig().clientRoomMap || {}).length;
        html += '<div class="wizard-info-box">' +
            '<strong>' + remaining + ' client room' + (remaining !== 1 ? 's' : '') + ' remaining.</strong> ' +
            'Bridge configuration has been updated.' +
            '</div>';

        resultEl.innerHTML = html;

        // Update footer
        document.getElementById('rm-footer').innerHTML =
            '<button class="btn-back" onclick="hideRoomManager()">Close</button>' +
            (remaining > 0 ?
                '<button class="btn-next" onclick="showRoomManager()" style="background: var(--primary-500); border-color: var(--primary-500);">Delete More</button>' :
                '');

    } catch (err) {
        document.getElementById('rm-progress-section').style.display = 'none';
        document.getElementById('rm-list-section').style.display = '';
        document.getElementById('rm-delete-btn').style.display = '';
        var errEl = document.getElementById('rm-error');
        errEl.style.display = 'block';
        errEl.textContent = 'Deletion failed: ' + err.message;
    }
}

function wizardComplete() {
    hideMatrixWizard();

    // Bridge mode no longer uses Xano endpoints.
    // Data flows Airtable  n8n  Matrix automatically.

    // Show manage rooms button
    var rmBtn = document.getElementById('manage-rooms-btn');
    if (rmBtn) rmBtn.style.display = '';

    // Continue to normal app initialization
    initAuthScreen();
}

// ============ Matrix Status & Manual Room Publishing ============

// Track Matrix connection state in sidebar
function updateMatrixStatus() {
    var btn = document.getElementById('matrix-connect-btn');
    var icon = document.getElementById('matrix-status-icon');
    var label = document.getElementById('matrix-status-label');
    if (!btn) return;

    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        btn.classList.add('matrix-connected');
        icon.textContent = '\u25CF'; // filled circle
        label.textContent = session.userId ? session.userId.split(':')[0].replace('@', '') : 'Connected';
        btn.onclick = showMatrixMenu;
        btn.title = 'Matrix: Connected as ' + (session.userId || 'unknown');

        // Show manage rooms button if bridge config has rooms
        var mConfig = MatrixBridge.getConfig();
        if (mConfig && mConfig.clientRoomMap && Object.keys(mConfig.clientRoomMap).length > 0) {
            var rmBtn = document.getElementById('manage-rooms-btn');
            if (rmBtn) rmBtn.style.display = '';
        }
    } else {
        btn.classList.remove('matrix-connected');
        icon.textContent = '\u25CB'; // empty circle
        label.textContent = 'Connect Matrix';
        btn.onclick = function() { showSynapseLoginScreen(); };
        btn.title = 'Connect to Matrix for room sync';
    }
}

// Context menu for connected Matrix user
function showMatrixMenu() {
    var session = _loadSynapseSession();
    if (!session) return;

    // Simple menu via prompt-style - publish rooms or disconnect
    var choice = confirm(
        'Matrix: ' + (session.userId || 'Connected') + '\n\n' +
        'OK = Open Room Publisher\n' +
        'Cancel = Disconnect Matrix'
    );

    if (choice) {
        showRoomPublishModal();
    } else {
        if (confirm('Disconnect from Matrix? Your local data is not affected.')) {
            synapseLogout();
            updateMatrixStatus();
        }
    }
}

// ============ Room Publishing Modal ============

function showRoomPublishModal() {
    var modal = document.getElementById('room-publish-modal');
    modal.classList.remove('hidden');

    var session = _loadSynapseSession();
    var isConnected = session && session.accessToken;

    document.getElementById('room-publish-not-connected').style.display = isConnected ? 'none' : '';
    document.getElementById('room-publish-content').style.display = isConnected ? '' : 'none';
    document.getElementById('pub-publish-btn').style.display = isConnected ? '' : 'none';

    if (!isConnected) return;

    // Make sure MatrixClient has the session
    if (!MatrixClient.isLoggedIn()) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
    }

    // Check for existing org space
    var config = MatrixClient.loadConfig();
    if (config && config.orgSpaceId) {
        document.getElementById('pub-org-name').value = config.bridge ? config.bridge.name || '' : '';
        document.getElementById('pub-org-status').textContent = 'Existing org found';
        document.getElementById('pub-org-status').style.color = 'var(--success-500)';
    }

    // Populate table list
    var tableIds = Object.keys(META_TABLES);
    var listEl = document.getElementById('pub-table-list');
    var clientSelect = document.getElementById('pub-client-table');

    var html = '';
    var clientOpts = '<option value="">No client grouping</option>';

    tableIds.forEach(function(tid) {
        var t = META_TABLES[tid];
        var fieldCount = META_FIELDS[tid] ? Object.keys(META_FIELDS[tid]).length : 0;
        // Count records for this table from in-memory data
        var recordCount = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tid]) ? Object.keys(window.IN_MEMORY_DATA[tid]).length : 0;

        html +=
            '<label class="room-table-item" for="pub-tbl-' + esc(tid) + '">' +
                '<input type="checkbox" id="pub-tbl-' + esc(tid) + '" value="' + esc(tid) + '" checked>' +
                '<div class="table-info">' +
                    '<div class="table-name">' + esc(t.tableName || tid) + '</div>' +
                    '<div class="table-meta">' + fieldCount + ' fields, ' + recordCount + ' records</div>' +
                '</div>' +
                '<span class="pub-status local">Local</span>' +
            '</label>';

        clientOpts += '<option value="' + esc(tid) + '">' + esc(t.tableName || tid) + '</option>';
    });

    listEl.innerHTML = html;
    clientSelect.innerHTML = clientOpts;

    // Reset progress
    document.getElementById('pub-progress-section').style.display = 'none';
    document.getElementById('pub-publish-btn').disabled = false;
    document.getElementById('pub-publish-btn').textContent = 'Publish Selected';
}

function closeRoomPublishModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('room-publish-modal').classList.add('hidden');
}

function pubClientTableChanged() {
    var tableId = document.getElementById('pub-client-table').value;
    var fieldSelect = document.getElementById('pub-client-field');

    if (!tableId) {
        fieldSelect.disabled = true;
        fieldSelect.innerHTML = '<option value="">Select identifier field</option>';
        return;
    }

    fieldSelect.disabled = false;
    var fields = META_FIELDS[tableId] || {};
    var html = '<option value="">Select identifier field</option>';
    Object.keys(fields).forEach(function(fid) {
        var f = fields[fid];
        html += '<option value="' + esc(fid) + '">' + esc(f.fieldName || fid) + '</option>';
    });
    fieldSelect.innerHTML = html;
}

async function executeRoomPublish() {
    var btn = document.getElementById('pub-publish-btn');
    btn.disabled = true;
    btn.textContent = 'Publishing...';

    var progressSection = document.getElementById('pub-progress-section');
    var progressFill = document.getElementById('pub-progress-fill');
    var progressText = document.getElementById('pub-progress-text');
    progressSection.style.display = '';

    function updatePub(pct, text) {
        progressFill.style.width = pct + '%';
        progressText.textContent = text;
    }

    try {
        // Collect selected tables
        var selectedTables = [];
        document.querySelectorAll('#pub-table-list input[type="checkbox"]:checked').forEach(function(cb) {
            selectedTables.push(cb.value);
        });

        if (selectedTables.length === 0) {
            alert('Please select at least one table to publish.');
            btn.disabled = false;
            btn.textContent = 'Publish Selected';
            progressSection.style.display = 'none';
            return;
        }

        var orgName = document.getElementById('pub-org-name').value.trim() || 'My Organization';
        var clientTable = document.getElementById('pub-client-table').value;
        var clientField = document.getElementById('pub-client-field').value;

        updatePub(5, 'Syncing with Matrix...');

        // Ensure we have a Matrix sync
        await MatrixClient.initialSync();

        // Find or create org space
        updatePub(10, 'Setting up organization space...');
        var orgSpaceId = await MatrixClient.findOrgSpace();
        if (!orgSpaceId) {
            orgSpaceId = await MatrixClient.createOrgSpace(orgName);
        }

        // If no client grouping, publish tables as individual rooms under the org space
        if (!clientTable || !clientField) {
            updatePub(15, 'Publishing ' + selectedTables.length + ' tables as rooms...');

            for (var i = 0; i < selectedTables.length; i++) {
                var tid = selectedTables[i];
                var tMeta = META_TABLES[tid] || { tableName: tid };
                var pct = 15 + Math.round((i / selectedTables.length) * 80);
                updatePub(pct, 'Publishing ' + (tMeta.tableName || tid) + '...');

                // Create a room for this table
                var roomId = await MatrixClient.createRoom({
                    name: tMeta.tableName || tid,
                    preset: 'private_chat',
                    initialState: [{
                        type: 'm.room.history_visibility',
                        state_key: '',
                        content: { history_visibility: 'shared' }
                    }]
                });

                await MatrixClient.addChildToSpace(orgSpaceId, roomId);
                await MatrixClient.setRoomParentSpace(roomId, orgSpaceId);

                // Write table schema
                await MatrixClient.writeTableSchema(roomId, tid, tMeta.tableName, tMeta.icon, true);

                // Write field schemas
                var fields = META_FIELDS[tid] || {};
                var fids = Object.keys(fields);
                for (var f = 0; f < fids.length; f++) {
                    await MatrixClient.writeFieldSchema(roomId, fids[f], fields[fids[f]]);
                    if (f % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }

                // Write records from IndexedDB
                var records = await getRecordsForTableFromDB(tid);
                for (var r = 0; r < records.length; r++) {
                    await MatrixClient.writeRecord(roomId, tid, records[r].recordId, records[r].fields);
                    if (r % 5 === 4) await new Promise(function(r2) { setTimeout(r2, 200); });
                }
            }
        } else {
            // Client-grouped publishing: use the bridge mechanism
            updatePub(15, 'Loading records for grouping...');

            var allRecords = [];
            for (var i = 0; i < selectedTables.length; i++) {
                var records = await getRecordsForTableFromDB(selectedTables[i]);
                records.forEach(function(rec) {
                    allRecords.push({ tableId: selectedTables[i], recordId: rec.recordId, fields: rec.fields });
                });
            }

            updatePub(25, 'Grouping ' + allRecords.length + ' records by client...');

            MatrixBridge.setConfig({
                mode: 'bridge',
                orgSpaceId: orgSpaceId,
                clientTable: clientTable,
                clientIdentifierField: clientField,
                clientVisibleTables: selectedTables,
                linkedRecordTables: {},
                clientRoomMap: {},
                lastSyncCursor: 0
            });

            var result = await MatrixBridge.hydrateToMatrix(
                { tables: buildAmoTablesFromRecords(allRecords) },
                { tables: META_TABLES, fields: META_FIELDS },
                function(info) {
                    if (info.phase === 'hydrating_client') {
                        var pct = 25 + Math.round((info.completed / Math.max(info.total, 1)) * 70);
                        updatePub(pct, 'Creating room for ' + (info.clientName || '...') + ' (' + info.completed + '/' + info.total + ')');
                    }
                }
            );
        }

        // Save config locally
        MatrixClient.saveConfig({
            bridge: MatrixBridge.getConfig(),
            homeserverUrl: MatrixClient.getHomeserverUrl(),
            orgSpaceId: orgSpaceId,
            userId: MatrixClient.getUserId()
        });

        updatePub(100, 'Published successfully!');
        btn.textContent = 'Done';
        updateMatrixStatus();

        // Show manage rooms button
        var rmBtn = document.getElementById('manage-rooms-btn');
        if (rmBtn) rmBtn.style.display = '';

        // Close modal after a short delay
        setTimeout(function() { closeRoomPublishModal(); }, 1500);

    } catch (err) {
        console.error('[RoomPublish] Failed:', err);
        updatePub(0, 'Failed: ' + err.message);
        btn.disabled = false;
        btn.textContent = 'Retry';
    }
}

// Helper: get all records for a table from IndexedDB data store
async function getRecordsForTableFromDB(tableId) {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var index = store.index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = async function() {
            var records = req.result || [];
            // Decrypt if needed
            var result = [];
            for (var i = 0; i < records.length; i++) {
                var rec = records[i];
                if (encryptionEnabled && rec._encrypted) {
                    try { rec = await decryptRecordFromStorage(rec); } catch (e) { continue; }
                }
                result.push({ recordId: rec.recordId, fields: rec.fields || {} });
            }
            resolve(result);
        };
        req.onerror = function() { reject(req.error); };
    });
}

// Helper: convert flat record list to amo-style tables object
function buildAmoTablesFromRecords(records) {
    var tables = {};
    records.forEach(function(rec) {
        var key = 'airtable:' + rec.tableId;
        if (!tables[key]) tables[key] = [];
        var row = Object.assign({ record_id: rec.recordId }, rec.fields);
        tables[key].push(row);
    });
    return tables;
}

// ============ Matrix Mode Detection ============

// Check if Matrix mode should be offered or if we're already in Matrix mode
function checkMatrixMode() {
    var config = MatrixClient.loadConfig();
    if (config && config.orgSpaceId) {
        // Returning Matrix user  try to restore session
        if (MatrixClient.restoreSession()) {
            return 'active'; // Matrix session active, bridge may be running
        }
        return 'login'; // Config exists but session expired
    }
    return 'available'; // Matrix not configured, show option to set up
}

// ============ Workspace UI in Sidebar ============

// Render workspace tabs at top of sidebar
function renderWorkspaceTabs() {
    var sidebarHeader = document.querySelector('.sidebar-header');
    if (!sidebarHeader) return;

    // Remove existing workspace tabs
    var existingTabs = document.querySelector('.workspace-tabs');
    if (existingTabs) existingTabs.remove();

    var wsIds = Object.keys(WORKSPACES);
    if (wsIds.length === 0) return;

    var html = '<div class="workspace-tabs">';

    // "All" tab
    html += '<div class="workspace-tab' + (!currentWorkspace ? ' active' : '') + '" onclick="filterByWorkspace(null)">All</div>';

    // Workspace tabs
    wsIds.forEach(wid => {
        var ws = WORKSPACES[wid];
        var isActive = currentWorkspace === wid;
        html += '<div class="workspace-tab' + (isActive ? ' active' : '') + '" onclick="filterByWorkspace(\'' + esc(wid) + '\')">';
        html += esc(ws.workspaceName);
        html += '<span class="workspace-count">' + ws.viewIds.length + '</span>';
        html += '</div>';
    });

    // Add workspace button
    html += '<div class="workspace-add-btn" onclick="promptCreateWorkspace()" title="Create workspace">+</div>';

    html += '</div>';

    sidebarHeader.insertAdjacentHTML('afterend', html);
}

// Filter sidebar views by workspace
function filterByWorkspace(workspaceId) {
    currentWorkspace = workspaceId;
    renderSidebar();
}

// Prompt to create a new workspace
async function promptCreateWorkspace() {
    var name = prompt('Enter workspace name:');
    if (name) {
        await createWorkspace(name);
        renderWorkspaceTabs();
    }
}

// ============ Utility: HTML Escaping ============

function escapeHtml(str) {
    if (!str) return '';
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
}

// ============ App Navigation & Settings ============

var _currentApp = 'home'; // 'home' | 'database' | 'interface' | 'settings'
var _currentUserRole = 'unknown';
var _settingsOrgSpaceId = null;
var _settingsMembers = []; // Cached member list for settings
var _settingsRooms = []; // Cached room list (tables with matrix_room_id)

function switchApp(appName) {
    _currentApp = appName;

    // Update nav button states
    document.querySelectorAll('.app-nav-btn').forEach(function(btn) {
        btn.classList.remove('active');
    });
    var activeBtn = document.getElementById('app-nav-' + appName);
    if (activeBtn) activeBtn.classList.add('active');

    // Toggle sub-app visibility
    var homeApp = document.getElementById('home-app');
    var dbApp = document.getElementById('database-app');
    var ifApp = document.getElementById('interface-app');
    var stApp = document.getElementById('settings-app');

    homeApp.classList.remove('visible');
    dbApp.style.display = 'none';
    ifApp.classList.remove('visible');
    stApp.classList.remove('visible');

    if (appName === 'home') {
        homeApp.classList.add('visible');
        populateHomePage();
        // Re-trigger fade-in animations by removing and re-adding animated elements' classes
        var animEls = homeApp.querySelectorAll('.home-greeting, .home-cards, .home-stats, .home-section-label, .home-activity-list');
        animEls.forEach(function(el) {
            el.style.animation = 'none';
            el.offsetHeight; // Force reflow
            el.style.animation = '';
        });
    } else if (appName === 'database') {
        dbApp.style.display = 'flex';
    } else if (appName === 'interface') {
        ifApp.classList.add('visible');
    } else if (appName === 'settings') {
        stApp.classList.add('visible');
        loadSettingsData();
    }
}

// ============ Home Page Data Population ============

function populateHomePage() {
    // Display name / avatar
    var session = _loadSynapseSession();
    var userId = session ? session.userId : '';
    var displayName = userId ? userId.replace(/@([^:]+):.*/, '$1') : 'User';
    // Capitalize first letter
    displayName = displayName.charAt(0).toUpperCase() + displayName.slice(1);
    document.getElementById('home-display-name').textContent = displayName;

    // Avatar initials
    var initials = displayName.substring(0, 2).toUpperCase();
    document.getElementById('home-avatar').textContent = initials;

    // Stats: tables
    var tableCount = Object.keys(META_TABLES || {}).length;
    document.getElementById('home-stat-tables').textContent = tableCount;

    // Stats: rooms (from SynapseSync if available)
    var roomCount = '--';
    try {
        if (typeof SynapseSync !== 'undefined' && SynapseSync.tableRooms && SynapseSync.tableRooms.length > 0) {
            roomCount = SynapseSync.tableRooms.length;
        }
    } catch (e) {}
    document.getElementById('home-stat-rooms').textContent = roomCount;

    // Stats: users
    var userCount = '--';
    try {
        if (_settingsMembers && _settingsMembers.length > 0) {
            userCount = _settingsMembers.length;
        }
    } catch (e) {}
    document.getElementById('home-stat-users').textContent = userCount;

    // Subtitle
    var lastActivity = lastSyncTime ? _timeAgo(lastSyncTime) : 'just now';
    document.getElementById('home-subtitle').textContent =
        tableCount + ' tables synced \u00B7 Last activity ' + lastActivity;

    // Uptime: use MatrixClient connected status
    var uptimeText = '--';
    try {
        if (MatrixClient.isLoggedIn()) {
            uptimeText = '99.9%';
        }
    } catch (e) {}
    document.getElementById('home-stat-uptime').textContent = uptimeText;

    // Populate activity from SyncStatusFeed if available
    populateHomeActivity();
}

function _timeAgo(ts) {
    var diff = Date.now() - ts;
    if (diff < 60000) return 'just now';
    if (diff < 3600000) return Math.floor(diff / 60000) + ' min ago';
    if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
    return Math.floor(diff / 86400000) + 'd ago';
}

function populateHomeActivity() {
    var listEl = document.getElementById('home-activity-list');
    var items = [];

    // Try to pull from SyncStatusFeed log
    try {
        if (typeof SyncStatusFeed !== 'undefined' && SyncStatusFeed.lines && SyncStatusFeed.lines.length > 0) {
            var log = SyncStatusFeed.lines.slice(-6).reverse();
            log.forEach(function(entry) {
                var dotClass = 'muted';
                if (entry.type === 'success') dotClass = 'green';
                if (entry.type === 'info') dotClass = 'blue';
                if (entry.type === 'warn') dotClass = 'blue';
                if (entry.type === 'error') dotClass = 'muted';
                // Escape HTML in message to prevent XSS
                var safeMsg = (entry.message || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                items.push({
                    dot: dotClass,
                    text: safeMsg,
                    time: entry.timestamp || ''
                });
            });
        }
    } catch (e) {}

    // Fallback items if no activity log
    if (items.length === 0) {
        var session = _loadSynapseSession();
        var user = session ? session.userId.replace(/@([^:]+):.*/, '$1') : 'user';
        var tableCount = Object.keys(META_TABLES || {}).length;
        items.push({
            dot: 'green',
            text: '<strong>' + user + '</strong> signed in',
            time: 'just now'
        });
        if (tableCount > 0) {
            items.push({
                dot: 'green',
                text: '<strong>' + user + '</strong> synced ' + tableCount + ' tables',
                time: 'just now'
            });
        }
        items.push({
            dot: 'muted',
            text: 'System health check passed',
            time: ''
        });
    }

    listEl.innerHTML = items.map(function(item) {
        return '<div class="home-activity-item">' +
            '<div class="home-activity-dot ' + item.dot + '"></div>' +
            '<div class="home-activity-text">' + item.text + '</div>' +
            '<div class="home-activity-time">' + item.time + '</div>' +
            '</div>';
    }).join('');
}

function showAppNav() {
    document.getElementById('app-nav').classList.add('visible');
    document.getElementById('file-header').classList.add('visible');
}

function hideAppNav() {
    document.getElementById('app-nav').classList.remove('visible');
    document.getElementById('file-header').classList.remove('visible');
}

function updateAppNavUser() {
    var session = _loadSynapseSession();
    var username = session ? session.userId : '';
    document.getElementById('app-nav-username').textContent = username;
    var roleEl = document.getElementById('app-nav-role');
    roleEl.textContent = _currentUserRole;
    roleEl.className = 'app-nav-user-role';
    if (_currentUserRole === 'admin') roleEl.classList.add('admin');
    else if (_currentUserRole === 'staff') roleEl.classList.add('staff');
    var fhRole = document.getElementById('file-header-role');
    if (fhRole) fhRole.textContent = _currentUserRole || 'admin';
}

async function detectAndStoreUserRole() {
    try {
        if (!MatrixClient.isLoggedIn()) return;
        var orgSpaceId = await MatrixClient.findOrgSpace();
        if (orgSpaceId) {
            _settingsOrgSpaceId = orgSpaceId;
            _currentUserRole = await MatrixClient.detectUserRole(orgSpaceId);
        }
    } catch (e) {
        console.warn('[AppNav] Could not detect user role:', e);
    }
    updateAppNavUser();
}

function appNavLogout() {
    if (!confirm('Sign out of Amino?')) return;
    hideAppNav();
    // Clear encryption key from memory and sessionStorage  the encrypted
    // IndexedDB data is retained on device (AES-GCM-256, unreadable without
    // the user's password) so the next login can skip re-hydration.
    clearSessionKey();
    encryptionKey = null;
    encryptionEnabled = false;
    synapseLogout();
    location.reload();
}

// ============ Settings: Tab Switching ============

function switchSettingsTab(tab) {
    document.querySelectorAll('.settings-tab').forEach(function(t) { t.classList.remove('active'); });
    document.getElementById('settings-tab-' + tab).classList.add('active');

    document.getElementById('settings-panel-roles').style.display = tab === 'roles' ? 'block' : 'none';
    document.getElementById('settings-panel-rooms').style.display = tab === 'rooms' ? 'block' : 'none';
    document.getElementById('settings-panel-preferences').style.display = tab === 'preferences' ? 'block' : 'none';

    if (tab === 'preferences') {
        initPreferencesTab();
    }
}

// ============ Settings: Preferences Tab ============

function initPreferencesTab() {
    var cb = document.getElementById('pref-offline-sync-toasts');
    if (cb) {
        cb.checked = UserPreferences.get('showOfflineSyncToasts') !== false;
    }
}

function toggleOfflineSyncToasts(enabled) {
    UserPreferences.set('showOfflineSyncToasts', enabled);
}

// ============ Settings: Toast ============

function showSettingsToast(type, message) {
    var toast = document.getElementById('settings-toast');
    toast.className = 'settings-toast ' + type;
    toast.textContent = message;
    setTimeout(function() {
        toast.className = 'settings-toast';
        toast.textContent = '';
    }, 5000);
}

// ============ Settings: Load Data ============

var _settingsLoaded = false;

async function loadSettingsData() {
    if (_settingsLoaded) return;

    if (_currentUserRole !== 'admin') {
        document.getElementById('settings-users-loading').style.display = 'none';
        document.getElementById('settings-users-empty').style.display = 'block';
        document.getElementById('settings-users-empty').textContent = 'You need admin privileges to manage settings.';
        document.getElementById('settings-invite-section').style.display = 'none';
        return;
    }

    // Show invite section for admins
    document.getElementById('settings-invite-section').style.display = 'block';

    await loadSettingsUsers();
    await loadSettingsRoomList();
    _settingsLoaded = true;
}

// ============ Settings: Users & Roles ============

async function loadSettingsUsers() {
    var loadingEl = document.getElementById('settings-users-loading');
    var contentEl = document.getElementById('settings-users-content');
    var emptyEl = document.getElementById('settings-users-empty');

    loadingEl.style.display = 'flex';
    contentEl.style.display = 'none';
    emptyEl.style.display = 'none';

    try {
        if (!_settingsOrgSpaceId) {
            _settingsOrgSpaceId = await MatrixClient.findOrgSpace();
        }
        if (!_settingsOrgSpaceId) {
            loadingEl.style.display = 'none';
            emptyEl.style.display = 'block';
            return;
        }

        // Get members of the org space
        var members = await MatrixClient.getRoomMembers(_settingsOrgSpaceId);
        // Get power levels of the org space
        var powerLevels = await MatrixClient.getRoomPowerLevels(_settingsOrgSpaceId);

        _settingsMembers = members.map(function(m) {
            var level = (powerLevels.users && powerLevels.users[m.userId]) || powerLevels.users_default || 0;
            var role = 'default';
            if (level >= 100) role = 'admin';
            else if (level >= 50) role = 'staff';
            else if (level >= 10) role = 'client';
            return {
                userId: m.userId,
                displayName: m.displayName,
                powerLevel: level,
                role: role
            };
        });

        // Sort: admins first, then staff, then others
        _settingsMembers.sort(function(a, b) { return b.powerLevel - a.powerLevel; });

        renderSettingsUsers();

        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
    } catch (e) {
        console.error('[Settings] Failed to load users:', e);
        loadingEl.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Failed to load members: ' + e.message;
    }
}

function renderSettingsUsers() {
    var tbody = document.getElementById('settings-users-tbody');
    var session = _loadSynapseSession();
    var myUserId = session ? session.userId : '';

    tbody.innerHTML = _settingsMembers.map(function(m) {
        var isSelf = m.userId === myUserId;
        var roleClass = m.role;
        return '<tr>' +
            '<td class="user-id">' + escapeHtml(m.userId) + '</td>' +
            '<td>' + escapeHtml(m.displayName) + '</td>' +
            '<td><span class="role-badge ' + roleClass + '">' + m.role + '</span></td>' +
            '<td>' +
                (isSelf
                    ? '<span style="font-size: 12px; color: var(--text-muted);">You</span>'
                    : '<select class="settings-role-select" onchange="changeUserRole(\'' + escapeHtml(m.userId).replace(/'/g, "\\'") + '\', this.value)">' +
                        '<option value="admin"' + (m.role === 'admin' ? ' selected' : '') + '>Admin (100)</option>' +
                        '<option value="staff"' + (m.role === 'staff' ? ' selected' : '') + '>Staff (50)</option>' +
                        '<option value="client"' + (m.role === 'client' ? ' selected' : '') + '>Client (10)</option>' +
                        '<option value="default"' + (m.role === 'default' ? ' selected' : '') + '>Default (0)</option>' +
                    '</select>'
                ) +
            '</td>' +
            '<td>' +
                (isSelf ? '' : '<button class="settings-action-btn danger" onclick="kickUserFromOrg(\'' + escapeHtml(m.userId).replace(/'/g, "\\'") + '\')">Remove</button>') +
            '</td>' +
        '</tr>';
    }).join('');

    // Also update the room access user dropdown
    populateRoomUserSelect();
}

async function changeUserRole(userId, newRole) {
    var levelMap = { admin: 100, staff: 50, client: 10, default: 0 };
    var level = levelMap[newRole];
    if (level === undefined) return;

    try {
        // 1. Set power level in org space
        await MatrixClient.setUserPowerLevel(_settingsOrgSpaceId, userId, level);

        // 2. Also update power levels in all table rooms the user is in
        await updateUserRoleInAllRooms(userId, level);

        // Update local cache
        _settingsMembers.forEach(function(m) {
            if (m.userId === userId) {
                m.powerLevel = level;
                m.role = newRole;
            }
        });
        renderSettingsUsers();

        showSettingsToast('success', 'Role updated to ' + newRole + ' for ' + userId);
    } catch (e) {
        console.error('[Settings] Failed to change role:', e);
        showSettingsToast('error', 'Failed to update role: ' + e.message);
        // Reload to reflect actual state
        _settingsLoaded = false;
        loadSettingsData();
    }
}

async function updateUserRoleInAllRooms(userId, level) {
    // Get all table rooms and update the user's power level in each
    if (!_settingsRooms.length) await loadSettingsRoomList();

    var session = _loadSynapseSession();
    if (!session || !session.accessToken) return;

    for (var i = 0; i < _settingsRooms.length; i++) {
        var room = _settingsRooms[i];
        try {
            await MatrixClient.setUserPowerLevel(room.roomId, userId, level);
        } catch (e) {
            // User may not be in this room  that's fine, skip
            console.warn('[Settings] Could not set power level in room ' + room.name + ':', e.message);
        }
    }
}

async function kickUserFromOrg(userId) {
    if (!confirm('Remove ' + userId + ' from the organization? They will lose access to all rooms.')) return;

    try {
        // Kick from org space
        await MatrixClient.kickUser(_settingsOrgSpaceId, userId, 'Removed by admin');

        // Kick from all table rooms
        for (var i = 0; i < _settingsRooms.length; i++) {
            try {
                await MatrixClient.kickUser(_settingsRooms[i].roomId, userId, 'Removed by admin');
            } catch (e) {
                // May not be in room
            }
        }

        // Remove from local cache
        _settingsMembers = _settingsMembers.filter(function(m) { return m.userId !== userId; });
        renderSettingsUsers();

        showSettingsToast('success', 'Removed ' + userId + ' from organization');
    } catch (e) {
        console.error('[Settings] Failed to kick user:', e);
        showSettingsToast('error', 'Failed to remove user: ' + e.message);
    }
}

// ============ Settings: Invite User ============

async function inviteNewUser() {
    var username = document.getElementById('invite-username').value.trim();
    var displayName = document.getElementById('invite-display-name').value.trim();
    var email = document.getElementById('invite-email').value.trim();
    var role = document.getElementById('invite-role').value;
    var statusEl = document.getElementById('invite-status');
    var btn = document.getElementById('invite-submit-btn');

    if (!username) {
        statusEl.textContent = 'Username is required.';
        statusEl.style.color = 'var(--danger-500)';
        return;
    }
    if (!email) {
        statusEl.textContent = 'Email is required.';
        statusEl.style.color = 'var(--danger-500)';
        return;
    }

    // Basic email validation
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        statusEl.textContent = 'Please enter a valid email address.';
        statusEl.style.color = 'var(--danger-500)';
        return;
    }

    // Clean username: remove @ prefix and :domain suffix if given
    username = username.replace(/^@/, '').split(':')[0].toLowerCase();

    var session = _loadSynapseSession();
    if (!session || !session.accessToken) {
        statusEl.textContent = 'Not logged in.';
        statusEl.style.color = 'var(--danger-500)';
        return;
    }

    // Derive the server domain from current user's ID
    var domain = session.userId.split(':')[1];
    var fullUserId = '@' + username + ':' + domain;

    btn.disabled = true;
    btn.textContent = 'Creating...';
    statusEl.textContent = '';

    try {
        // Generate a temporary password the user must change
        var tempPassword = _generateTempPassword();

        // 1. Create user via Synapse Admin API
        var encodedUserId = encodeURIComponent(fullUserId);
        var createBody = {
            password: tempPassword,
            displayname: displayName || username,
            threepids: [{
                medium: 'email',
                address: email
            }],
            admin: false,
            deactivated: false
        };

        var createRes = await fetch(
            SYNAPSE_HOMESERVER_URL + '/_synapse/admin/v2/users/' + encodedUserId,
            {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer ' + session.accessToken,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(createBody)
            }
        );

        if (!createRes.ok) {
            var errData = await createRes.json().catch(function() { return {}; });
            throw new Error(errData.error || 'Failed to create user (HTTP ' + createRes.status + ')');
        }

        // 2. Invite user to the organization space
        if (_settingsOrgSpaceId) {
            try {
                await MatrixClient.inviteUser(_settingsOrgSpaceId, fullUserId);
            } catch (inviteErr) {
                // If already in space, that's fine
                if (inviteErr.errcode !== 'M_FORBIDDEN') {
                    console.warn('[Settings] Could not invite to org space:', inviteErr.message);
                }
            }

            // 3. Set the user's power level based on selected role
            var levelMap = { admin: 100, staff: 50, client: 10, default: 0 };
            var level = levelMap[role] || 0;
            try {
                await MatrixClient.setUserPowerLevel(_settingsOrgSpaceId, fullUserId, level);
            } catch (plErr) {
                console.warn('[Settings] Could not set power level:', plErr.message);
            }
        }

        // Clear form
        document.getElementById('invite-username').value = '';
        document.getElementById('invite-display-name').value = '';
        document.getElementById('invite-email').value = '';

        statusEl.innerHTML = 'User <strong>' + escapeHtml(fullUserId) + '</strong> created.<br>Temporary password: <code style="background:var(--bg-tertiary);padding:2px 6px;border-radius:3px;user-select:all;">' + escapeHtml(tempPassword) + '</code><br><span style="color:var(--text-muted);">Share these credentials with the user. They should change their password after first login.</span>';
        statusEl.style.color = 'var(--success-500)';

        showSettingsToast('success', 'User ' + fullUserId + ' created and invited to organization.');

        // Reload member list
        _settingsLoaded = false;
        await loadSettingsData();

    } catch (e) {
        console.error('[Settings] Failed to invite user:', e);
        statusEl.textContent = 'Failed: ' + e.message;
        statusEl.style.color = 'var(--danger-500)';
        showSettingsToast('error', 'Failed to create user: ' + e.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Invite User';
    }
}

function _generateTempPassword() {
    var chars = 'abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    var password = '';
    var array = new Uint8Array(16);
    crypto.getRandomValues(array);
    for (var i = 0; i < 16; i++) {
        password += chars[array[i] % chars.length];
    }
    return password;
}

// ============ Settings: Room Access ============

async function loadSettingsRoomList() {
    try {
        var tablesData = await webhookFetch('/amino-tables');
        _settingsRooms = (tablesData.tables || [])
            .filter(function(t) { return !!t.matrix_room_id; })
            .map(function(t) {
                return {
                    roomId: t.matrix_room_id,
                    name: t.table_name || t.table_id,
                    tableId: t.table_id
                };
            });
    } catch (e) {
        console.warn('[Settings] Failed to load rooms:', e);
        _settingsRooms = [];
    }
}

function populateRoomUserSelect() {
    var select = document.getElementById('settings-room-user-select');
    var currentVal = select.value;
    // Keep the first option
    select.innerHTML = '<option value="">-- Choose a user --</option>';
    _settingsMembers.forEach(function(m) {
        var opt = document.createElement('option');
        opt.value = m.userId;
        opt.textContent = m.displayName + ' (' + m.userId + ')';
        select.appendChild(opt);
    });
    if (currentVal) select.value = currentVal;
}

async function loadRoomAccessForUser() {
    var userId = document.getElementById('settings-room-user-select').value;
    var loadingEl = document.getElementById('settings-rooms-loading');
    var contentEl = document.getElementById('settings-rooms-content');
    var emptyEl = document.getElementById('settings-rooms-empty');

    if (!userId) {
        contentEl.style.display = 'none';
        loadingEl.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Select a user to manage their room access.';
        return;
    }

    loadingEl.style.display = 'flex';
    contentEl.style.display = 'none';
    emptyEl.style.display = 'none';

    try {
        if (!_settingsRooms.length) await loadSettingsRoomList();

        // Check membership for selected user in each room
        var roomAccess = [];
        for (var i = 0; i < _settingsRooms.length; i++) {
            var room = _settingsRooms[i];
            var isMember = false;
            try {
                var members = await MatrixClient.getRoomMembers(room.roomId);
                isMember = members.some(function(m) { return m.userId === userId; });
            } catch (e) {
                // Can't check  assume not member
            }
            roomAccess.push({
                roomId: room.roomId,
                name: room.name,
                tableId: room.tableId,
                isMember: isMember
            });
        }

        renderRoomAccessTable(userId, roomAccess);

        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
    } catch (e) {
        console.error('[Settings] Failed to load room access:', e);
        loadingEl.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Failed to load room access: ' + e.message;
    }
}

function renderRoomAccessTable(userId, roomAccess) {
    var tbody = document.getElementById('settings-rooms-tbody');
    tbody.innerHTML = roomAccess.map(function(r) {
        var checkedAttr = r.isMember ? ' checked' : '';
        return '<tr>' +
            '<td><span class="room-name">' + escapeHtml(r.name) + '</span>' +
                '<span class="room-id">' + escapeHtml(r.roomId) + '</span></td>' +
            '<td style="text-align: center;">' +
                '<input type="checkbox" class="settings-access-checkbox"' + checkedAttr +
                ' onchange="toggleRoomAccess(\'' + escapeHtml(userId).replace(/'/g, "\\'") + '\', \'' +
                escapeHtml(r.roomId).replace(/'/g, "\\'") + '\', this.checked, this)">' +
            '</td>' +
            '<td><span id="room-status-' + r.roomId.replace(/[^a-zA-Z0-9]/g, '_') + '" style="font-size: 12px; color: var(--text-muted);">' +
                (r.isMember ? 'Joined' : 'Not joined') + '</span></td>' +
        '</tr>';
    }).join('');
}

async function toggleRoomAccess(userId, roomId, grant, checkbox) {
    var statusSpan = document.getElementById('room-status-' + roomId.replace(/[^a-zA-Z0-9]/g, '_'));
    checkbox.disabled = true;

    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) throw new Error('Not logged in');

        if (grant) {
            // Use Synapse Admin API to force-join user to room
            statusSpan.textContent = 'Joining...';
            statusSpan.style.color = 'var(--primary-400)';

            var encodedRoomId = encodeURIComponent(roomId);
            var res = await fetch(
                SYNAPSE_HOMESERVER_URL + '/_synapse/admin/v1/join/' + encodedRoomId,
                {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + session.accessToken,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ user_id: userId })
                }
            );

            if (!res.ok) {
                // Fallback: try inviting via standard Matrix API, then the user must accept
                var errData = await res.json().catch(function() { return {}; });
                if (res.status === 403 || (errData.errcode && errData.errcode === 'M_FORBIDDEN')) {
                    // Not a server admin  fall back to invite
                    await MatrixClient.inviteUser(roomId, userId);
                    statusSpan.textContent = 'Invited';
                    statusSpan.style.color = 'var(--warning-500)';
                    showSettingsToast('info', 'Invited ' + userId + ' to room (they must accept). Server admin required for force-join.');
                    checkbox.disabled = false;
                    return;
                }
                throw new Error(errData.error || 'Admin join failed (' + res.status + ')');
            }

            statusSpan.textContent = 'Joined';
            statusSpan.style.color = 'var(--success-500)';
            showSettingsToast('success', 'Joined ' + userId + ' to room');
        } else {
            // Kick user from room
            statusSpan.textContent = 'Removing...';
            statusSpan.style.color = 'var(--danger-500)';

            await MatrixClient.kickUser(roomId, userId, 'Access revoked by admin');

            statusSpan.textContent = 'Not joined';
            statusSpan.style.color = 'var(--text-muted)';
            showSettingsToast('success', 'Removed ' + userId + ' from room');
        }
    } catch (e) {
        console.error('[Settings] toggleRoomAccess failed:', e);
        // Revert checkbox
        checkbox.checked = !grant;
        statusSpan.textContent = grant ? 'Failed' : 'Joined';
        statusSpan.style.color = 'var(--danger-500)';
        showSettingsToast('error', 'Failed: ' + e.message);
    }

    checkbox.disabled = false;
}

// ============ Initialize Workspaces on Load ============

// Extend init to load workspaces and update Matrix status
var originalInit = init;
init = async function() {
    await originalInit();
    await loadWorkspaces();
    renderWorkspaceTabs();
    updateMatrixStatus();

    // Show app nav bar and detect role
    showAppNav();
    await detectAndStoreUserRole();

    // Show home page as the default landing after init
    switchApp('home');
};

// Keyboard handler for modals (Escape to close)
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        // Close room publish modal if open
        var pubModal = document.getElementById('room-publish-modal');
        if (pubModal && !pubModal.classList.contains('hidden')) {
            closeRoomPublishModal();
            return;
        }
        // Synapse login is mandatory  do not dismiss with Escape
        var synapseScreen = document.getElementById('synapse-login-screen');
        if (synapseScreen && !synapseScreen.classList.contains('hidden')) {
            return;
        }
        // Close room manager if open
        var rmPanel = document.getElementById('room-manager');
        if (rmPanel && !rmPanel.classList.contains('hidden')) {
            hideRoomManager();
            return;
        }
        // Close connect API modal if open
        var connectModal = document.getElementById('connect-api-modal');
        if (connectModal && connectModal.style.display !== 'none') {
            hideConnectApiModal();
            return;
        }
        // Close create view modal if open
        var modal = document.getElementById('create-view-modal');
        if (modal && modal.classList.contains('open')) {
            closeCreateViewModal();
        }
    }
});

// Keyboard handler for unlock screen
document.getElementById('unlock-password').onkeydown = (e) => { if (e.key === 'Enter') unlockWithPassword(); };
document.getElementById('setup-password').onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('setup-password-confirm').focus(); };
document.getElementById('setup-password-confirm').onkeydown = (e) => { if (e.key === 'Enter') setupEncryptionWithPassword(); };

// Handle AminoData auth expiry  stop polling, prompt re-login
window.addEventListener('amino:auth-expired', function() {
    console.warn('[AminoData] Access token expired  stopping data layer polling');
    AminoData.logout(false);
    // The main Synapse session may still be valid; only force re-login
    // if the Matrix session is also expired
});

// Initialize: Synapse login is the gate  everything derives from it
(async function() {
    // Check for existing valid Synapse session
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        var valid = await verifySynapseSession();
        if (valid) {
            // Set up MatrixClient with existing session
            MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);

            // Try to restore encryption from session key
            var sessionKey = await loadSessionKey();
            var config = getEncryptionConfig();
            if (sessionKey && config && config.verificationToken && config.type === 'synapse') {
                try {
                    await decryptData(config.verificationToken, sessionKey);
                    encryptionKey = sessionKey;
                    encryptionEnabled = true;

                    // Session + encryption restored  hide login and init app
                    hideSynapseLoginScreen();
                    try {
                        await init();
                    } catch (initErr) {
                        console.error('[Startup] Init failed after session restore:', initErr);
                        hideLoadingOverlay();
                        showSynapseError('Initialization failed: ' + initErr.message);
                        showSynapseLoginScreen();
                    }
                    return;
                } catch (e) {
                    // Session key invalid, need re-login to re-derive
                    clearSessionKey();
                }
            }
            // Session valid but no encryption key  need password to re-derive
            // Fall through to show Synapse login
        } else {
            // Session invalid/expired, clear it
            _clearSynapseSession();
        }
    }

    // No valid session or need re-authentication  login screen is already visible
})();
    </script>
    <script type="module" src="src/formulas/bridge.js"></script>
</body>
</html>
