<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DB Viewer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f5f5f5; color: #333; display: flex; height: 100vh; }

        /* Sidebar - Airtable dark style */
        .sidebar { width: 260px; background: #1d1f25; border-right: 1px solid #2d2f36; overflow-y: auto; flex-shrink: 0; }
        .sidebar-header { padding: 16px; border-bottom: 1px solid #2d2f36; }
        .sidebar-header h2 { color: #fff; font-size: 14px; font-weight: 600; }
        .sidebar div.table-item { padding: 8px 16px; cursor: pointer; font-size: 13px; color: #b3b3b3; display: flex; align-items: center; gap: 8px; }
        .sidebar div.table-item:hover { background: #2d2f36; color: #fff; }
        .sidebar div.table-item.active { background: #2d6cdf; color: #fff; }
        .sidebar div.table-item .count { margin-left: auto; font-size: 11px; color: #666; }
        .sidebar div.table-item.active .count { color: rgba(255,255,255,0.7); }
        .table-icon { width: 16px; height: 16px; background: #2d6cdf; border-radius: 3px; flex-shrink: 0; }

        /* Main content - Airtable light style */
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: #fff; }

        /* Toolbar */
        .toolbar { padding: 12px 20px; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; background: #fff; }
        .toolbar h1 { font-size: 18px; font-weight: 600; color: #333; flex: 1; }
        .btn { padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; color: #333; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 4px; }
        .btn:hover { background: #e8e8e8; }
        .btn-primary { background: #2d6cdf; border-color: #2d6cdf; color: #fff; }
        .btn-primary:hover { background: #2560c9; }

        /* Status bar */
        .status-bar { padding: 8px 20px; background: #fafafa; border-bottom: 1px solid #e0e0e0; font-size: 12px; color: #666; display: flex; align-items: center; gap: 12px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.synced { background: #20c933; }
        .status-dot.loading { background: #fcb400; }

        /* Table container */
        .table-container { flex: 1; overflow: auto; }

        /* Airtable-style table */
        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th { background: #f5f5f5; border-bottom: 2px solid #ddd; padding: 8px 12px; text-align: left; font-weight: 500; color: #333; position: sticky; top: 0; z-index: 10; white-space: nowrap; }
        th:first-child { width: 120px; color: #666; }
        td { border-bottom: 1px solid #eee; padding: 8px 12px; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: top; }
        tr:hover td { background: #f8f9fa; }
        tr.selected td { background: #e8f0fe; }

        /* Cell content styling */
        .cell-empty { color: #ccc; }
        .cell-array { color: #333; }
        .cell-array .tag { display: inline-block; background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; font-size: 12px; }
        .cell-link { color: #2d6cdf; text-decoration: none; }
        .cell-link:hover { text-decoration: underline; }
        .cell-number { font-family: "SF Mono", Monaco, monospace; }
        .cell-bool { padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; }
        .cell-bool.true { background: #d4edda; color: #155724; }
        .cell-bool.false { background: #f8d7da; color: #721c24; }

        /* Pagination */
        .pagination { padding: 12px 20px; border-top: 1px solid #e0e0e0; background: #fafafa; display: flex; align-items: center; gap: 12px; font-size: 13px; }
        .pagination button { padding: 6px 12px; background: #fff; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; }
        .pagination button:hover:not(:disabled) { background: #f5f5f5; }
        .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
        .pagination .page-info { color: #666; }

        /* Auth screen */
        #auth-screen { position: fixed; inset: 0; background: #1d1f25; display: flex; align-items: center; justify-content: center; z-index: 100; }
        .auth-box { background: #fff; border-radius: 8px; padding: 32px; width: 360px; box-shadow: 0 4px 24px rgba(0,0,0,0.3); }
        .auth-box h2 { font-size: 20px; margin-bottom: 8px; color: #333; }
        .auth-box p { font-size: 13px; color: #666; margin-bottom: 24px; }
        .auth-box input { width: 100%; padding: 10px 12px; background: #fff; border: 1px solid #ddd; border-radius: 6px; color: #333; font-size: 14px; margin-bottom: 12px; }
        .auth-box input:focus { outline: none; border-color: #2d6cdf; box-shadow: 0 0 0 3px rgba(45,108,223,0.1); }
        .auth-box button { width: 100%; padding: 10px; background: #2d6cdf; border: none; border-radius: 6px; color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; }
        .auth-box button:hover { background: #2560c9; }
        .auth-box button:disabled { background: #ccc; cursor: not-allowed; }
        .auth-box button.secondary { background: #f5f5f5; color: #333; }
        .auth-box button.secondary:hover { background: #e8e8e8; }
        .auth-error { color: #dc3545; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: #f8d7da; border-radius: 4px; display: none; }
        .auth-info { color: #666; font-size: 12px; margin-top: 16px; text-align: center; }
        .hidden { display: none !important; }

        /* Empty state */
        .empty-state { padding: 60px 20px; text-align: center; color: #666; }
        .empty-state h3 { font-size: 16px; margin-bottom: 8px; color: #333; }

        /* Loading states */
        .loading-state { padding: 60px 20px; text-align: center; color: #666; }
        .loading-state h3 { font-size: 16px; margin-bottom: 8px; color: #333; }
        .loading-spinner { display: inline-block; width: 24px; height: 24px; border: 3px solid #e0e0e0; border-top-color: #2d6cdf; border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Skeleton loading for table */
        .skeleton-row td { background: linear-gradient(90deg, #f0f0f0 25%, #e8e8e8 50%, #f0f0f0 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .skeleton-cell { height: 16px; background: #e0e0e0; border-radius: 4px; }

        /* Progress bar */
        .progress-bar { height: 3px; background: #e0e0e0; border-radius: 2px; overflow: hidden; margin-top: 4px; }
        .progress-fill { height: 100%; background: #2d6cdf; transition: width 0.3s ease; }

        /* Table loading indicator */
        .table-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .table-container { position: relative; }
    </style>
</head>
<body>
    <div id="auth-screen">
        <div class="auth-box">
            <h2>Amino Viewer</h2>
            <p>Connect to your Amino event stream</p>
            <div id="auth-error" class="auth-error"></div>
            <input type="password" id="api-key-input" placeholder="API Key" autocomplete="off">
            <input type="text" id="set-filter-input" placeholder="Filter by set (optional)" autocomplete="off">
            <button id="auth-submit">Connect</button>
            <button id="auth-clear" class="secondary hidden">Clear Local Data</button>
            <div id="auth-info" class="auth-info"></div>
        </div>
    </div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2>Tables</h2>
        </div>
        <div id="table-list"></div>
    </div>

    <div class="main">
        <div class="toolbar">
            <h1 id="title">Select a table</h1>
            <button class="btn" onclick="manualSync()">Sync</button>
            <button class="btn" onclick="logout()">Logout</button>
        </div>
        <div class="status-bar">
            <span class="status-dot" id="status-dot"></span>
            <span id="status-text">Ready</span>
            <div class="progress-bar" id="progress-bar" style="display: none; flex: 1; max-width: 200px;">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
            <span id="status-detail" style="color: #999; font-size: 11px;"></span>
        </div>
        <div class="table-container" id="table-container">
            <table id="table"></table>
        </div>
        <div class="pagination" id="pagination">
            <button id="prev-btn" onclick="prevPage()">Previous</button>
            <span class="page-info" id="page-info">Page 1</span>
            <button id="next-btn" onclick="nextPage()">Next</button>
        </div>
    </div>

    <script>
var API = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:nrIL-Oi-/aminostream';
var DB_NAME = 'aminostream';
var DB_VERSION = 2;
var PAGE_SIZE = 100;

var API_KEY = null;
var SET_FILTER = null;
var db = null;

// Only keep lightweight metadata in memory
var META_TABLES = {};
var META_FIELDS = {};

var currentTable = null;
var currentPage = 0;
var currentRecordIds = [];
var totalRecords = 0;
var lastEventId = 0;
var pollInterval = null;

// ============ IndexedDB ============

function openDB() {
    return new Promise((resolve, reject) => {
        var req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve(req.result);
        req.onupgradeneeded = (e) => {
            var db = e.target.result;

            // Delete old stores if they exist
            if (db.objectStoreNames.contains('records')) {
                db.deleteObjectStore('records');
            }
            if (db.objectStoreNames.contains('meta')) {
                db.deleteObjectStore('meta');
            }

            // Data records: keyed by [tableId, recordId]
            var dataStore = db.createObjectStore('data', { keyPath: ['tableId', 'recordId'] });
            dataStore.createIndex('by_table', 'tableId');

            // Table metadata
            db.createObjectStore('tables', { keyPath: 'tableId' });

            // Field metadata: keyed by [tableId, fieldId]
            var fieldStore = db.createObjectStore('fields', { keyPath: ['tableId', 'fieldId'] });
            fieldStore.createIndex('by_table', 'tableId');

            // Sync state
            db.createObjectStore('sync', { keyPath: 'key' });
        };
    });
}

function getSyncMeta(key) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readonly');
        var req = tx.objectStore('sync').get(key);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
        req.onerror = () => reject(req.error);
    });
}

function setSyncMeta(key, value) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readwrite');
        tx.objectStore('sync').put({ key, value });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getAllTables() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readonly');
        var req = tx.objectStore('tables').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getFieldsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var index = tx.objectStore('fields').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getRecordIdsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var index = tx.objectStore('data').index('by_table');
        var req = index.getAllKeys(tableId);
        req.onsuccess = () => {
            // Keys are [tableId, recordId], extract recordIds
            var recordIds = (req.result || []).map(k => k[1]);
            resolve(recordIds);
        };
        req.onerror = () => reject(req.error);
    });
}

function getRecordsByIds(tableId, recordIds) {
    return new Promise((resolve, reject) => {
        if (!recordIds.length) return resolve([]);
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var results = [];
        var pending = recordIds.length;

        recordIds.forEach(rid => {
            var req = store.get([tableId, rid]);
            req.onsuccess = () => {
                if (req.result) results.push(req.result);
                if (--pending === 0) resolve(results);
            };
            req.onerror = () => {
                if (--pending === 0) resolve(results);
            };
        });
    });
}

function saveTable(table) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readwrite');
        tx.objectStore('tables').put(table);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveField(field) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readwrite');
        tx.objectStore('fields').put(field);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveDataRecord(record) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readwrite');
        tx.objectStore('data').put(record);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveBatch(tables, fields, dataRecords) {
    return new Promise((resolve, reject) => {
        var stores = [];
        if (tables.length) stores.push('tables');
        if (fields.length) stores.push('fields');
        if (dataRecords.length) stores.push('data');
        if (!stores.length) return resolve();

        var tx = db.transaction(stores, 'readwrite');

        tables.forEach(t => tx.objectStore('tables').put(t));
        fields.forEach(f => tx.objectStore('fields').put(f));
        dataRecords.forEach(d => tx.objectStore('data').put(d));

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function clearAllData() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction(['data', 'tables', 'fields', 'sync'], 'readwrite');
        tx.objectStore('data').clear();
        tx.objectStore('tables').clear();
        tx.objectStore('fields').clear();
        tx.objectStore('sync').clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getLocalStats() {
    return new Promise(async (resolve) => {
        try {
            var tempDb = await openDB();
            var count = await new Promise((res, rej) => {
                var tx = tempDb.transaction('data', 'readonly');
                var req = tx.objectStore('data').count();
                req.onsuccess = () => res(req.result);
                req.onerror = () => res(0);
            });
            var lastId = await new Promise((res, rej) => {
                var tx = tempDb.transaction('sync', 'readonly');
                var req = tx.objectStore('sync').get('lastEventId');
                req.onsuccess = () => res(req.result ? req.result.value : 0);
                req.onerror = () => res(0);
            });
            tempDb.close();
            resolve({ count, lastId });
        } catch (e) {
            resolve({ count: 0, lastId: 0 });
        }
    });
}

// ============ Auth ============

document.getElementById('auth-submit').onclick = tryAuth;
document.getElementById('api-key-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('set-filter-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('auth-clear').onclick = clearLocalAndReset;

async function initAuthScreen() {
    var stats = await getLocalStats();
    var infoEl = document.getElementById('auth-info');
    var clearBtn = document.getElementById('auth-clear');

    if (stats.count > 0) {
        infoEl.textContent = 'Local cache: ' + stats.count.toLocaleString() + ' records';
        clearBtn.classList.remove('hidden');
    } else {
        infoEl.textContent = 'No local data';
        clearBtn.classList.add('hidden');
    }
}

async function clearLocalAndReset() {
    if (!confirm('Clear all local data?')) return;
    try {
        db = await openDB();
        await clearAllData();
        db.close();
        db = null;
    } catch (e) {
        console.error('Clear error:', e);
    }
    initAuthScreen();
}

async function tryAuth() {
    var key = document.getElementById('api-key-input').value.trim();
    if (!key) {
        showAuthError('Please enter an API key');
        return;
    }

    var btn = document.getElementById('auth-submit');
    btn.textContent = 'Connecting...';
    btn.disabled = true;
    document.getElementById('auth-error').style.display = 'none';

    API_KEY = key;
    SET_FILTER = document.getElementById('set-filter-input').value.trim() || null;

    try {
        await init();
    } catch (err) {
        console.error('Init error:', err);
        showAuthError('Connection failed: ' + err.message);
        btn.textContent = 'Connect';
        btn.disabled = false;
        return;
    }

    btn.textContent = 'Connect';
    btn.disabled = false;
}

function showAuthError(msg) {
    var el = document.getElementById('auth-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function hideAuthScreen() {
    document.getElementById('auth-screen').classList.add('hidden');
}

function showAuthScreen() {
    document.getElementById('auth-screen').classList.remove('hidden');
    if (pollInterval) clearInterval(pollInterval);
    initAuthScreen();
}

function logout() {
    if (pollInterval) clearInterval(pollInterval);
    API_KEY = null;
    SET_FILTER = null;
    showAuthScreen();
}

async function manualSync() {
    if (!API_KEY) return;
    await incrementalSync();
}

// ============ Data Processing ============

function parsePayload(payload) {
    if (typeof payload === 'string') {
        try { return JSON.parse(payload); } catch { return null; }
    }
    return payload;
}

async function processEvents(events) {
    if (!events || !Array.isArray(events)) return;

    var tables = [];
    var fields = [];
    var dataRecords = [];
    var tableDataMap = {}; // tableId -> { recordId -> fields }

    for (var e of events) {
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;

        if (recordType === 'table') {
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            tables.push(tableData);
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            var tableId = setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            fields.push(fieldData);
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            // Skip views for now

        } else {
            // Data record
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) {
                // Try to get existing record from db
                tableDataMap[tableId][recordId] = {};
            }

            var state = tableDataMap[tableId][recordId];

            if (pfields.INS) Object.assign(state, pfields.INS);
            if (pfields.ALT) Object.assign(state, pfields.ALT);
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(k => delete state[k]);
            }
        }

        if (e.id && e.id > lastEventId) {
            lastEventId = e.id;
        }
    }

    // Convert tableDataMap to dataRecords array
    for (var tableId in tableDataMap) {
        for (var recordId in tableDataMap[tableId]) {
            dataRecords.push({
                tableId,
                recordId,
                fields: tableDataMap[tableId][recordId]
            });
        }
    }

    // Save batch
    if (tables.length || fields.length || dataRecords.length) {
        await saveBatch(tables, fields, dataRecords);
    }
}

function applyPayloadFields(target, payload) {
    if (!payload.fields) return;
    var fields = payload.fields;
    if (fields.INS) Object.assign(target, fields.INS);
    if (fields.ALT) Object.assign(target, fields.ALT);
    if (fields.NUL && Array.isArray(fields.NUL)) {
        fields.NUL.forEach(k => delete target[k]);
    }
}

// ============ UI ============

async function renderSidebar() {
    var tableList = document.getElementById('table-list');
    tableList.innerHTML = '';

    var tables = await getAllTables();

    // Also get tables from META_TABLES (in-memory from current session)
    for (var tid in META_TABLES) {
        if (!tables.find(t => t.tableId === tid)) {
            tables.push(META_TABLES[tid]);
        }
    }

    tables.sort((a, b) => (a.tableName || a.tableId).localeCompare(b.tableName || b.tableId));

    for (var table of tables) {
        var tableId = table.tableId;
        var tableName = table.tableName || tableId;

        var div = document.createElement('div');
        div.className = 'table-item' + (tableId === currentTable ? ' active' : '');
        div.innerHTML = '<span class="table-icon"></span>' + esc(tableName) + '<span class="count" id="count-' + tableId + '"></span>';
        div.onclick = ((t) => () => showTable(t))(tableId);
        tableList.appendChild(div);
    }

    // Update counts asynchronously
    for (var table of tables) {
        getRecordIdsForTable(table.tableId).then(((tid) => (ids) => {
            var el = document.getElementById('count-' + tid);
            if (el) el.textContent = ids.length.toLocaleString();
        })(table.tableId));
    }
}

function updateStatus(msg, isSynced, progress, detail) {
    var dot = document.getElementById('status-dot');
    var text = document.getElementById('status-text');
    var progressBar = document.getElementById('progress-bar');
    var progressFill = document.getElementById('progress-fill');
    var statusDetail = document.getElementById('status-detail');

    dot.className = 'status-dot ' + (isSynced ? 'synced' : 'loading');
    text.textContent = msg;

    if (typeof progress === 'number' && progress >= 0) {
        progressBar.style.display = 'block';
        progressFill.style.width = Math.min(100, progress) + '%';
    } else {
        progressBar.style.display = 'none';
    }

    statusDetail.textContent = detail || '';
}

async function showTable(tableId) {
    currentTable = tableId;
    currentPage = 0;

    var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
    var tableName = table.tableName || tableId;

    document.getElementById('title').textContent = tableName;

    // Update sidebar
    document.querySelectorAll('.table-item').forEach(el => el.classList.remove('active'));
    var activeItem = [...document.querySelectorAll('.table-item')].find(el => el.textContent.includes(tableName));
    if (activeItem) activeItem.classList.add('active');

    // Show loading state immediately
    showTableLoading('Loading table structure...');

    // Load fields first (table structure)
    var fields = await getFieldsForTable(tableId);
    META_FIELDS[tableId] = {};
    fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

    // Show table headers immediately with skeleton rows (even before data loads)
    renderTableHeaders();

    // Update status (don't overwrite table headers with loading spinner)
    updateStatus('Loading records...', false, null, null);

    // Load record IDs
    currentRecordIds = await getRecordIdsForTable(tableId);
    totalRecords = currentRecordIds.length;

    // Now render full table with data
    await renderTable();
}

function showTableLoading(message) {
    var container = document.getElementById('table-container');
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>' + esc(message) + '</h3></div>';
    document.getElementById('pagination').style.display = 'none';
}

function renderTableHeaders() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);

    if (fieldIds.length === 0) {
        // No fields yet, show loading
        return;
    }

    var colList = [];
    var colNames = {};
    fieldIds.forEach(fid => {
        colList.push(fid);
        colNames[fid] = fields[fid].fieldName || fid;
    });

    // Build table with headers and skeleton rows
    var html = '<table id="table"><thead><tr><th>ID</th>';
    colList.forEach(col => {
        html += '<th title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    // Add skeleton loading rows
    for (var i = 0; i < 5; i++) {
        html += '<tr class="skeleton-row"><td><div class="skeleton-cell" style="width: 60px;"></div></td>';
        colList.forEach(() => {
            html += '<td><div class="skeleton-cell" style="width: ' + (60 + Math.random() * 80) + 'px;"></div></td>';
        });
        html += '</tr>';
    }

    html += '</tbody></table>';
    container.innerHTML = html;
}

async function renderTable() {
    if (!currentTable) return;

    var tableEl = document.getElementById('table');
    var pageRecordIds = currentRecordIds.slice(currentPage * PAGE_SIZE, (currentPage + 1) * PAGE_SIZE);

    if (pageRecordIds.length === 0) {
        tableEl.innerHTML = '';
        document.getElementById('table-container').innerHTML = '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        document.getElementById('pagination').style.display = 'none';
        return;
    }

    document.getElementById('table-container').innerHTML = '<table id="table"></table>';
    tableEl = document.getElementById('table');

    // Get records for current page
    var records = await getRecordsByIds(currentTable, pageRecordIds);
    var recordMap = {};
    records.forEach(r => recordMap[r.recordId] = r.fields || {});

    // Get columns
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);

    var colList = [];
    var colNames = {};

    if (fieldIds.length > 0) {
        fieldIds.forEach(fid => {
            colList.push(fid);
            colNames[fid] = fields[fid].fieldName || fid;
        });
    } else {
        // Discover from data
        var colSet = {};
        records.forEach(r => {
            if (r.fields) Object.keys(r.fields).forEach(k => colSet[k] = true);
        });
        colList = Object.keys(colSet).sort();
        colList.forEach(c => colNames[c] = c);
    }

    // Build table
    var html = '<thead><tr><th>ID</th>';
    colList.forEach(col => {
        html += '<th title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    pageRecordIds.forEach(rid => {
        var row = recordMap[rid] || {};
        html += '<tr><td>' + esc(rid.slice(-8)) + '</td>';
        colList.forEach(col => {
            var value = row[col];
            if (value === undefined) value = row[colNames[col]];
            html += '<td>' + formatCell(value) + '</td>';
        });
        html += '</tr>';
    });

    html += '</tbody>';
    tableEl.innerHTML = html;

    // Update pagination
    updatePagination();
}

function formatCell(v) {
    if (v == null || v === '') {
        return '<span class="cell-empty">—</span>';
    }

    if (Array.isArray(v)) {
        if (v.length === 0) return '<span class="cell-empty">—</span>';

        // Check if it's an array of objects (linked records, attachments, etc.)
        if (typeof v[0] === 'object' && v[0] !== null) {
            var items = v.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return '<span class="cell-array">' + items.map(i => '<span class="tag">' + esc(i) + '</span>').join('') + '</span>';
        }

        // Simple array - join with commas
        return '<span class="cell-array">' + v.map(i => '<span class="tag">' + esc(String(i)) + '</span>').join('') + '</span>';
    }

    if (typeof v === 'object') {
        // Single object
        if (v.name) return esc(v.name);
        if (v.filename) return esc(v.filename);
        if (v.email) return esc(v.email);
        if (v.url) return '<a class="cell-link" href="' + esc(v.url) + '" target="_blank">' + esc(v.url.slice(0, 40)) + '</a>';
        return esc(JSON.stringify(v).slice(0, 50));
    }

    if (typeof v === 'boolean') {
        return '<span class="cell-bool ' + v + '">' + (v ? 'Yes' : 'No') + '</span>';
    }

    if (typeof v === 'number') {
        return '<span class="cell-number">' + v.toLocaleString() + '</span>';
    }

    // String - check for URLs
    var str = String(v);
    if (str.startsWith('http://') || str.startsWith('https://')) {
        return '<a class="cell-link" href="' + esc(str) + '" target="_blank">' + esc(str.slice(0, 50)) + '</a>';
    }

    return esc(str);
}

function updatePagination() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    var start = currentPage * PAGE_SIZE + 1;
    var end = Math.min((currentPage + 1) * PAGE_SIZE, totalRecords);

    document.getElementById('page-info').textContent = start + '-' + end + ' of ' + totalRecords.toLocaleString();
    document.getElementById('prev-btn').disabled = currentPage === 0;
    document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
    document.getElementById('pagination').style.display = totalRecords > PAGE_SIZE ? 'flex' : 'none';
}

function prevPage() {
    if (currentPage > 0) {
        currentPage--;
        renderTable();
    }
}

function nextPage() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    if (currentPage < totalPages - 1) {
        currentPage++;
        renderTable();
    }
}

// ============ API ============

async function fetchPage(page, afterId) {
    var url = API + '?page=' + page + '&per_page=500';
    if (API_KEY) url += '&apiKey=' + encodeURIComponent(API_KEY);
    if (afterId) url += '&id=' + afterId;
    if (SET_FILTER) url += '&set=' + encodeURIComponent(SET_FILTER);

    var res = await fetch(url);

    if (res.status === 401 || res.status === 403) {
        throw new Error('Invalid API key');
    }

    var data = await res.json();

    if (!res.ok) {
        throw new Error(data.message || data.error || 'HTTP ' + res.status);
    }

    var events = Array.isArray(data) ? data : (data.items || data.data || []);
    var hasMore = Array.isArray(data) ? events.length >= 500 : !!data.nextPage;
    var nextPage = Array.isArray(data) ? page + 1 : data.nextPage;

    return { events, hasMore, nextPage };
}

async function fullSync() {
    var page = 1;
    var eventsLoaded = 0;
    var tablesFound = 0;
    var fieldsFound = 0;
    var recordsFound = 0;

    while (true) {
        // Show progress with estimates (assume ~50 pages max for progress bar)
        var progressPct = Math.min(95, (page / 50) * 100);
        var detail = tablesFound + ' tables, ' + fieldsFound + ' fields, ' + recordsFound.toLocaleString() + ' records';
        updateStatus('Syncing page ' + page + '...', false, progressPct, detail);

        var result = await fetchPage(page, null);
        if (!result.events || result.events.length === 0) break;

        eventsLoaded += result.events.length;
        result.events.sort((a, b) => (a.id || 0) - (b.id || 0));

        // Count what we're processing for feedback
        for (var e of result.events) {
            var payload = parsePayload(e.payload);
            if (payload && payload._set === 'table') tablesFound++;
            else if (payload && payload._set === 'field') fieldsFound++;
            else if (payload && payload._set !== 'view') recordsFound++;
        }

        await processEvents(result.events);

        // Update sidebar after EVERY page to show tables/fields as they arrive
        await renderSidebar();

        // If no table is selected but we have tables, show the first one
        if (!currentTable && Object.keys(META_TABLES).length > 0) {
            var firstTable = Object.keys(META_TABLES)[0];
            await showTable(firstTable);
        } else if (currentTable) {
            // Refresh current table view to show new data
            currentRecordIds = await getRecordIdsForTable(currentTable);
            totalRecords = currentRecordIds.length;
            await renderTable();
        }

        if (!result.hasMore) break;
        page = result.nextPage || page + 1;
        if (page > 500) break;
    }

    await setSyncMeta('lastEventId', lastEventId);
    var finalDetail = tablesFound + ' tables, ' + fieldsFound + ' fields, ' + recordsFound.toLocaleString() + ' records';
    updateStatus('Synced ' + eventsLoaded.toLocaleString() + ' events', true, null, finalDetail);
}

async function incrementalSync() {
    try {
        updateStatus('Checking for updates...', false, null, null);

        var result = await fetchPage(1, lastEventId);

        if (result.events && result.events.length > 0) {
            updateStatus('Processing ' + result.events.length + ' new events...', false, null, null);
            result.events.sort((a, b) => (a.id || 0) - (b.id || 0));
            await processEvents(result.events);
            await setSyncMeta('lastEventId', lastEventId);

            updateStatus('Updating views...', false, null, null);
            await renderSidebar();
            if (currentTable) {
                currentRecordIds = await getRecordIdsForTable(currentTable);
                totalRecords = currentRecordIds.length;
                await renderTable();
            }
            updateStatus('Up to date', true, null, result.events.length + ' events synced');
        } else {
            updateStatus('Up to date', true, null, null);
        }
    } catch (err) {
        console.error('Sync error:', err);
        updateStatus('Sync error: ' + err.message, false, null, null);
    }
}

// ============ Init ============

async function init() {
    META_TABLES = {};
    META_FIELDS = {};
    currentTable = null;
    currentPage = 0;
    currentRecordIds = [];
    totalRecords = 0;
    lastEventId = 0;

    db = await openDB();

    updateStatus('Loading local data...', false, null, null);

    var storedLastId = await getSyncMeta('lastEventId');
    var tables = await getAllTables();

    // Load table metadata into memory
    tables.forEach(t => META_TABLES[t.tableId] = t);

    hideAuthScreen();

    if (tables.length > 0) {
        updateStatus('Found ' + tables.length + ' tables', false, null, 'Loading table list...');
        await renderSidebar();

        lastEventId = storedLastId || 0;
        await showTable(tables[0].tableId);
        await incrementalSync();
    } else {
        updateStatus('Starting initial sync...', false, 0, 'Fetching data from server...');
        await renderSidebar();
        await fullSync();
        await renderSidebar();
        var newTables = await getAllTables();
        if (newTables.length > 0) {
            await showTable(newTables[0].tableId);
        }
    }

    updateStatus('Up to date', true, null, null);

    if (pollInterval) clearInterval(pollInterval);
    pollInterval = setInterval(incrementalSync, 60000);
}

function esc(s) {
    if (s == null) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

initAuthScreen();
    </script>
</body>
</html>
