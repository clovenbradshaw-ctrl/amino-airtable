<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CaseTrack</title>
  <link href="https://unpkg.com/tabulator-tables@6.2.1/dist/css/tabulator_simple.min.css" rel="stylesheet">
  <script src="https://unpkg.com/@phosphor-icons/web"></script>
  <style>
    * { box-sizing: border-box; }

    :root {
      /* Light theme - main content */
      --bg-main: #ffffff;
      --bg-surface: #f9fafb;
      --bg-surface-100: #f3f4f6;
      --bg-surface-200: #e5e7eb;
      --bg-surface-300: #d1d5db;
      --border: #e5e7eb;
      --border-light: #f3f4f6;
      --text: #374151;
      --text-dark: #111827;
      --text-muted: #6b7280;
      --text-light: #9ca3af;

      /* Sidebar - dark theme */
      --sidebar-bg: #111827;
      --sidebar-hover: #1f2937;
      --sidebar-active: #374151;
      --sidebar-border: #374151;
      --sidebar-text: #9ca3af;
      --sidebar-text-hover: #f3f4f6;

      /* Accent colors */
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --accent-light: #dbeafe;
      --accent-dark: #1d4ed8;

      /* Status colors */
      --success: #22c55e;
      --success-light: #dcfce7;
      --success-dark: #15803d;
      --warning: #f59e0b;
      --warning-light: #fef3c7;
      --warning-dark: #b45309;
      --danger: #ef4444;
      --danger-light: #fee2e2;
      --danger-dark: #dc2626;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: var(--bg-surface);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: var(--bg-surface-300);
      border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-light);
    }

    /* ==================== HEADER ==================== */
    .header {
      height: 56px;
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 0 16px;
      background: var(--bg-main);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .header-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: var(--accent-light);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-size: 16px;
    }

    .header-title h1 {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-dark);
      margin: 0;
    }

    .header-count {
      font-size: 14px;
      color: var(--text-muted);
    }

    .header-actions {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-toolbar {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      font-size: 13px;
      color: var(--text);
      background: var(--bg-main);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-toolbar:hover {
      background: var(--bg-surface);
      border-color: var(--bg-surface-300);
    }

    .btn-primary {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      color: white;
      background: var(--accent);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-primary:hover {
      background: var(--accent-hover);
    }

    .btn-secondary {
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      background: var(--bg-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-secondary:hover {
      background: var(--bg-surface-100);
    }

    .btn-danger {
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      color: white;
      background: var(--danger);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-danger:hover {
      background: var(--danger-dark);
    }

    /* Sync indicators in header */
    .sync-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 6px;
      background: var(--bg-surface);
      font-size: 13px;
      color: var(--text-muted);
    }

    .sync-indicator.syncing { color: var(--warning); }
    .sync-indicator.synced { color: var(--success); }
    .sync-indicator.offline { color: var(--text-muted); }
    .sync-indicator.error { color: var(--danger); }

    .sync-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    .sync-indicator.syncing .sync-dot {
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .pending-badge {
      background: var(--warning-light);
      color: var(--warning-dark);
      padding: 4px 10px;
      border-radius: 9999px;
      font-size: 12px;
      font-weight: 500;
    }

    .conflict-badge {
      background: var(--danger-light);
      color: var(--danger-dark);
      padding: 4px 10px;
      border-radius: 9999px;
      font-size: 12px;
      font-weight: 500;
    }

    .live-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-main);
      color: var(--text-muted);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.15s;
    }

    .live-toggle:hover {
      border-color: var(--bg-surface-300);
    }

    .live-toggle.active {
      background: var(--success-light);
      border-color: var(--success);
      color: var(--success-dark);
    }

    .live-toggle .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
      transition: all 0.2s;
    }

    .live-toggle.active .live-dot {
      background: var(--success);
      box-shadow: 0 0 8px var(--success);
      animation: live-pulse 2s infinite;
    }

    @keyframes live-pulse {
      0%, 100% { box-shadow: 0 0 4px var(--success); }
      50% { box-shadow: 0 0 12px var(--success); }
    }

    .live-toggle.flash .live-dot {
      animation: live-flash 0.3s ease-out;
    }

    @keyframes live-flash {
      0% { transform: scale(1); }
      50% { transform: scale(1.5); background: white; }
      100% { transform: scale(1); }
    }

    /* Legacy nav class support */
    .nav {
      display: none;
    }

    .nav-tabs {
      display: flex;
      gap: 4px;
    }

    .nav-tab {
      padding: 8px 16px;
      border-radius: 6px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 13px;
    }

    .nav-tab:hover { background: var(--bg-surface); }
    .nav-tab.active { background: var(--accent); color: white; }

    /* ==================== PAGES ==================== */
    .page { display: none; padding: 20px; }
    .page.active { display: block; }

    /* ==================== CONNECT PAGE ==================== */
    .connect-card {
      max-width: 400px;
      margin: 60px auto;
      padding: 32px;
      background: var(--bg-main);
      border-radius: 12px;
      border: 1px solid var(--border);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .connect-card h2 { margin-top: 0; font-size: 20px; color: var(--text-dark); }
    .connect-card .form-group { margin-bottom: 16px; }
    .connect-card label { display: block; margin-bottom: 6px; color: var(--text-muted); font-size: 13px; }

    .connect-card input {
      width: 100%;
      padding: 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-main);
      color: var(--text);
      font-size: 14px;
    }

    .connect-card input:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-light); }

    .connect-card button {
      width: 100%;
      padding: 12px;
      border-radius: 6px;
      border: none;
      background: var(--accent);
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }

    .connect-card button:hover { background: var(--accent-hover); }
    .connect-card .hint { margin-top: 16px; font-size: 12px; color: var(--text-muted); }

    /* ==================== TOOLBAR ==================== */
    .toolbar {
      height: 48px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 16px;
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .toolbar-search {
      position: relative;
    }

    .toolbar-search i {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-light);
      font-size: 14px;
    }

    .toolbar-search input {
      width: 220px;
      padding: 6px 12px 6px 36px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-main);
      color: var(--text);
      font-size: 13px;
    }

    .toolbar-search input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-light);
    }

    .toolbar-divider {
      width: 1px;
      height: 20px;
      background: var(--border);
    }

    .toolbar-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      font-size: 13px;
      color: var(--text);
      background: var(--bg-main);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .toolbar-btn:hover {
      background: var(--bg-surface);
      border-color: var(--bg-surface-300);
    }

    .toolbar-btn i {
      font-size: 14px;
      color: var(--text-muted);
    }

    .toolbar-spacer { flex: 1; }

    .toolbar-icon-btn {
      padding: 8px;
      color: var(--text-muted);
      background: transparent;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .toolbar-icon-btn:hover {
      background: var(--bg-surface-100);
      color: var(--text);
    }

    /* ==================== DATA PAGE ==================== */
    .data-controls {
      display: none; /* Hide old controls */
    }

    .table-status {
      font-size: 13px;
      color: var(--text-muted);
    }

    #grid {
      border-radius: 0;
      overflow: auto;
      flex: 1;
      min-height: 0;
    }

    /* Tabulator overrides - Light theme */
    .tabulator {
      background: var(--bg-main);
      border: none;
      font-size: 13px;
    }
    .tabulator .tabulator-header {
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      height: 36px !important;
      min-height: 36px !important;
    }
    .tabulator .tabulator-col {
      background: var(--bg-surface);
      border-right: 1px solid var(--border);
      height: 36px !important;
    }
    .tabulator .tabulator-col-title {
      color: var(--text-muted);
      font-weight: 600;
      font-size: 12px;
    }
    .tabulator .tabulator-col-content {
      padding: 0 12px;
      height: 36px !important;
      display: flex;
      align-items: center;
    }
    .tabulator .tabulator-row {
      border-bottom: 1px solid var(--border-light);
      min-height: 36px !important;
      max-height: 36px !important;
      height: 36px !important;
    }
    .tabulator .tabulator-row:hover {
      background: var(--bg-surface) !important;
    }
    .tabulator .tabulator-row.tabulator-selected {
      background: #eff6ff !important;
    }
    .tabulator .tabulator-cell {
      border-right: 1px solid var(--border-light);
      color: var(--text);
      padding: 0 12px;
      display: flex;
      align-items: center;
      height: 36px !important;
      min-height: 36px !important;
      max-height: 36px !important;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .tabulator .tabulator-col {
      min-width: 120px;
    }
    .tabulator .tabulator-cell.tabulator-editing {
      background: var(--bg-main);
      border: 2px solid var(--accent);
    }
    .tabulator .tabulator-cell.tabulator-editing input {
      background: var(--bg-main);
      color: var(--text);
      border: none;
    }
    .tabulator .tabulator-group {
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      color: var(--accent-dark);
      font-weight: 600;
    }
    .tabulator .tabulator-footer {
      background: var(--bg-main);
      border-top: 1px solid var(--border);
      color: var(--text-muted);
      padding: 8px 16px;
    }
    .tabulator .tabulator-footer .tabulator-page {
      background: var(--bg-main);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 6px;
      padding: 4px 12px;
    }
    .tabulator .tabulator-footer .tabulator-page:hover {
      background: var(--bg-surface);
    }
    .tabulator .tabulator-footer .tabulator-page.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    /* Row status indicators */
    .tabulator .tabulator-row.row-pending { border-left: 3px solid var(--warning); }
    .tabulator .tabulator-row.row-conflict { border-left: 3px solid var(--danger); }
    .tabulator .tabulator-row.row-new { border-left: 3px solid var(--success); }

    /* Formula cell indicators */
    .tabulator .tabulator-cell.formula-cell {
      background: rgba(99, 102, 241, 0.05);
      font-style: italic;
    }
    .formula-calculated {
      color: var(--accent);
    }
    .formula-calculated::after {
      content: ' âš¡';
      font-size: 10px;
      opacity: 0.7;
    }

    /* Error cells */
    .cell-error {
      color: var(--danger);
      font-weight: 500;
      font-size: 11px;
    }

    /* Number cells - right align */
    .tabulator .tabulator-cell.number-cell {
      justify-content: flex-end;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    /* Link cells */
    .cell-link {
      color: var(--accent);
      text-decoration: none;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .cell-link:hover {
      text-decoration: underline;
    }

    /* Timestamp cells */
    .cell-timestamp {
      color: var(--text-muted);
      font-size: 12px;
    }

    /* Attachment indicator */
    .attachment-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: var(--text-muted);
      font-size: 12px;
    }
    .attachment-indicator i {
      font-size: 14px;
    }

    /* Select tags (single and multi) */
    .select-tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
      margin-right: 4px;
      white-space: nowrap;
    }
    .select-blueLight, .select-blue { background: #dbeafe; color: #1e40af; }
    .select-greenLight, .select-green { background: #dcfce7; color: #166534; }
    .select-yellowLight, .select-yellow { background: #fef9c3; color: #854d0e; }
    .select-redLight, .select-red { background: #fee2e2; color: #991b1b; }
    .select-grayLight, .select-gray { background: #f3f4f6; color: #374151; }
    .select-tealLight, .select-teal { background: #ccfbf1; color: #115e59; }
    .select-cyanLight, .select-cyan { background: #cffafe; color: #155e75; }
    .select-orangeLight, .select-orange { background: #ffedd5; color: #9a3412; }
    .select-pinkLight, .select-pink { background: #fce7f3; color: #9d174d; }
    .select-purpleLight, .select-purple { background: #f3e8ff; color: #6b21a8; }

    /* Status badges in cells */
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 9999px;
      font-size: 12px;
      font-weight: 500;
    }
    .badge-blue { background: var(--accent-light); color: var(--accent-dark); }
    .badge-green { background: var(--success-light); color: var(--success-dark); }
    .badge-yellow { background: var(--warning-light); color: var(--warning-dark); }
    .badge-red { background: var(--danger-light); color: var(--danger-dark); }
    .badge-gray { background: var(--bg-surface-100); color: var(--text-muted); }

    /* ==================== SYNC PAGE ==================== */
    .sync-page { max-width: 900px; margin: 0 auto; }

    .sync-header {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }

    .sync-header h2 { margin: 0; color: var(--text-dark); }

    .sync-actions {
      margin-left: auto;
      display: flex;
      gap: 8px;
    }

    .sync-actions button {
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    .sync-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .stat-card {
      background: var(--bg-main);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .stat-card .stat-value {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--text-dark);
    }

    .stat-card .stat-label {
      font-size: 13px;
      color: var(--text-muted);
    }

    .stat-card.pending .stat-value { color: var(--warning); }
    .stat-card.conflicts .stat-value { color: var(--danger); }
    .stat-card.synced .stat-value { color: var(--success); }

    .sync-section {
      background: var(--bg-main);
      border-radius: 8px;
      border: 1px solid var(--border);
      margin-bottom: 16px;
    }

    .sync-section-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-dark);
    }

    .sync-section-content {
      padding: 16px;
      max-height: 300px;
      overflow-y: auto;
    }

    .sync-table-row {
      display: flex;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid var(--border-light);
    }

    .sync-table-row:last-child { border-bottom: none; }

    .sync-table-name { flex: 1; font-weight: 500; color: var(--text); }

    .sync-table-stats {
      display: flex;
      gap: 16px;
      font-size: 13px;
      color: var(--text-muted);
    }

    .sync-table-time { font-size: 12px; color: var(--text-muted); }

    .sync-table-actions {
      margin-left: 16px;
      display: flex;
      gap: 8px;
    }

    .sync-table-actions button {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-surface);
      color: var(--text);
      cursor: pointer;
    }

    .sync-table-actions button:hover { background: var(--bg-surface-100); }

    .queue-item, .conflict-item {
      padding: 12px;
      background: var(--bg-surface);
      border-radius: 6px;
      margin-bottom: 8px;
      border: 1px solid var(--border-light);
    }

    .queue-item:last-child, .conflict-item:last-child { margin-bottom: 0; }

    .queue-item-header, .conflict-item-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .queue-item-op {
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .queue-item-op.update { background: var(--warning-light); color: var(--warning-dark); }
    .queue-item-op.create { background: var(--success-light); color: var(--success-dark); }
    .queue-item-op.delete { background: var(--danger-light); color: var(--danger-dark); }

    .queue-item-record { font-weight: 500; color: var(--text); }
    .queue-item-time { margin-left: auto; font-size: 12px; color: var(--text-muted); }

    .queue-item-fields {
      font-size: 13px;
      color: var(--text-muted);
    }

    .conflict-versions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin: 12px 0;
    }

    .conflict-version {
      padding: 10px;
      background: var(--bg-surface-100);
      border-radius: 4px;
      font-size: 13px;
    }

    .conflict-version-label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .conflict-version.given .conflict-version-label { color: var(--accent); }
    .conflict-version.meant .conflict-version-label { color: var(--warning); }

    .conflict-actions {
      display: flex;
      gap: 8px;
    }

    .empty-state {
      text-align: center;
      padding: 24px;
      color: var(--text-muted);
    }

    /* ==================== MODAL ==================== */
    .modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal.hidden { display: none; }

    .modal-content {
      background: var(--bg-main);
      padding: 24px;
      border-radius: 12px;
      min-width: 400px;
      max-width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid var(--border);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    .modal-content h3 { margin-top: 0; color: var(--text-dark); }
    .modal-content .form-group { margin-bottom: 16px; }
    .modal-content label { display: block; margin-bottom: 6px; color: var(--text-muted); font-size: 13px; }

    .modal-content input,
    .modal-content select,
    .modal-content textarea {
      width: 100%;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-main);
      color: var(--text);
      font-size: 14px;
    }

    .modal-content input:focus,
    .modal-content select:focus,
    .modal-content textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-light);
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 20px;
    }

    /* ==================== LOADING ==================== */
    .loading-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      gap: 16px;
    }

    .loading-overlay.hidden { display: none; }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--bg-surface-200);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loading-text {
      font-size: 14px;
      color: var(--text-muted);
    }

    .progress-bar {
      width: 300px;
      height: 6px;
      background: var(--bg-surface-200);
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s;
    }

    /* ==================== MAIN LAYOUT ==================== */
    .app-layout {
      display: flex;
      height: 100vh;
    }

    /* ==================== LEFT PANEL (DARK SIDEBAR) ==================== */
    .left-panel {
      width: 240px;
      min-width: 240px;
      background: var(--sidebar-bg);
      border-right: 1px solid var(--sidebar-border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .left-panel-logo {
      height: 56px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 16px;
      border-bottom: 1px solid var(--sidebar-border);
    }

    .left-panel-logo-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
    }

    .left-panel-logo-text {
      font-weight: 600;
      font-size: 15px;
      color: white;
    }

    .left-panel-search {
      padding: 12px;
    }

    .left-panel-search input {
      width: 100%;
      padding: 8px 12px 8px 36px;
      background: var(--sidebar-hover);
      border: 1px solid var(--sidebar-border);
      border-radius: 8px;
      color: white;
      font-size: 13px;
    }

    .left-panel-search input::placeholder {
      color: var(--text-muted);
    }

    .left-panel-search input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .left-panel-header {
      padding: 16px 20px 8px;
      font-weight: 600;
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: none;
    }

    .left-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 8px 0;
    }

    .left-panel-section {
      margin-bottom: 8px;
    }

    .left-panel-section-title {
      padding: 16px 20px 8px;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* Sidebar Items */
    .sidebar-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      margin: 2px 8px;
      border-radius: 6px;
      font-size: 13px;
      color: var(--sidebar-text);
      cursor: pointer;
      transition: all 0.15s;
    }

    .sidebar-item:hover {
      background: var(--sidebar-hover);
      color: var(--sidebar-text-hover);
    }

    .sidebar-item.active {
      background: var(--accent);
      color: white;
    }

    .sidebar-item i {
      font-size: 18px;
    }

    .sidebar-item-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sidebar-item-count {
      font-size: 12px;
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 8px;
      border-radius: 9999px;
    }

    .sidebar-item-expand {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--sidebar-text);
      font-size: 10px;
      transition: transform 0.2s;
      flex-shrink: 0;
    }

    .sidebar-item-expand.expanded {
      transform: rotate(90deg);
    }

    /* Table Item (legacy support) */
    .table-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      margin: 2px 8px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      user-select: none;
      color: var(--sidebar-text);
      font-size: 13px;
    }

    .table-item:hover {
      background: var(--sidebar-hover);
      color: var(--sidebar-text-hover);
    }

    .table-item.active {
      background: var(--accent);
      color: white;
    }

    .table-item-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: inherit;
      font-size: 16px;
      flex-shrink: 0;
    }

    .table-item-name {
      flex: 1;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .table-item-count {
      font-size: 12px;
      padding: 2px 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 9999px;
    }

    .table-item-expand {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: inherit;
      font-size: 10px;
      transition: transform 0.2s;
      flex-shrink: 0;
    }

    .table-item-expand.expanded {
      transform: rotate(90deg);
    }

    /* Views List */
    .views-list {
      display: none;
      padding-left: 20px;
    }

    .views-list.expanded {
      display: block;
    }

    .view-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      margin: 2px 8px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      font-size: 13px;
      color: var(--sidebar-text);
    }

    .view-item:hover {
      background: var(--sidebar-hover);
      color: var(--sidebar-text-hover);
    }

    .view-item.active {
      color: white;
      background: rgba(59, 130, 246, 0.3);
    }

    .view-item-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .view-item-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* View sections/folders */
    .view-section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      margin: 4px 8px 2px 8px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      font-size: 12px;
      color: var(--sidebar-text);
      opacity: 0.8;
      font-weight: 500;
    }

    .view-section-header:hover {
      background: var(--sidebar-hover);
      color: var(--sidebar-text-hover);
      opacity: 1;
    }

    .view-section-header.expanded {
      opacity: 1;
    }

    .view-section-icon {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: var(--primary);
    }

    .view-section-header.expanded .view-section-icon i {
      transform: rotate(0deg);
    }

    .view-section-header .view-section-icon i.ph-folder::before {
      content: "\e9a9"; /* folder icon */
    }

    .view-section-header.expanded .view-section-icon i.ph-folder::before {
      content: "\e9a7"; /* folder-open icon */
    }

    .view-section-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .view-section-expand {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      transition: transform 0.2s;
    }

    .view-section-header.expanded .view-section-expand {
      transform: rotate(90deg);
    }

    .view-section-views {
      display: none;
      padding-left: 8px;
    }

    .view-section-views.expanded {
      display: block;
    }

    .view-section-views .view-item {
      padding-left: 16px;
      font-size: 12px;
    }

    /* Sidebar footer */
    .left-panel-footer {
      padding: 12px;
      border-top: 1px solid var(--sidebar-border);
    }

    .sync-footer {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--sidebar-text);
    }

    .sync-footer .sync-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
    }

    .sync-footer button {
      margin-left: auto;
      padding: 4px;
      background: transparent;
      border: none;
      color: var(--sidebar-text);
      cursor: pointer;
      border-radius: 4px;
    }

    .sync-footer button:hover {
      background: var(--sidebar-hover);
      color: var(--sidebar-text-hover);
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      background: var(--bg-main);
      min-width: 0;
    }

    .main-content .page {
      flex: 1;
      overflow: auto;
    }

    .main-content .page.active {
      display: flex;
      flex-direction: column;
    }

    .main-content #page-data.active {
      padding: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      flex: 1;
    }

    .main-content #page-sync.active {
      padding: 24px;
      justify-content: flex-start;
      align-items: stretch;
    }

    .main-content #page-sync .sync-page {
      width: 100%;
    }

    .main-content #page-data .data-controls {
      flex-shrink: 0;
    }

    .main-content #grid {
      flex: 1;
      min-height: 0;
      overflow: auto;
    }

    /* Left panel scrollbar styling */
    .left-panel-content::-webkit-scrollbar {
      width: 6px;
    }

    .left-panel-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .left-panel-content::-webkit-scrollbar-thumb {
      background: var(--sidebar-border);
      border-radius: 3px;
    }

    .left-panel-content::-webkit-scrollbar-thumb:hover {
      background: var(--sidebar-text);
    }

    /* Footer bar */
    .footer-bar {
      height: 48px;
      display: flex;
      align-items: center;
      padding: 0 16px;
      background: var(--bg-main);
      border-top: 1px solid var(--border);
      flex-shrink: 0;
      gap: 16px;
    }

    .footer-bar .record-count {
      font-size: 13px;
      color: var(--text-muted);
    }

    .footer-bar .record-count strong {
      color: var(--text);
    }

    .footer-bar .pagination {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .footer-bar .rows-per-page {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-muted);
    }

    .footer-bar .rows-per-page select {
      padding: 4px 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-main);
      color: var(--text);
      font-size: 13px;
    }

    .footer-bar .page-btn {
      padding: 6px 12px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }

    .footer-bar .page-btn:hover {
      background: var(--bg-surface);
      color: var(--text);
    }

    .footer-bar .page-btn.active {
      background: var(--accent);
      color: white;
    }

    .footer-bar .page-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ==================== TOOLBAR BUTTON ACTIVE STATES ==================== */
    .toolbar-btn.active {
      background: var(--accent-light);
      border-color: var(--accent);
      color: var(--accent-dark);
    }

    .toolbar-btn .filter-count,
    .toolbar-btn .sort-count,
    .toolbar-btn .hidden-count {
      background: var(--accent);
      color: white;
      padding: 2px 6px;
      border-radius: 9999px;
      font-size: 11px;
      margin-left: 4px;
    }

    /* ==================== FILTER/SORT/HIDE MODAL STYLES ==================== */
    .modal-content.modal-wide {
      min-width: 500px;
      max-width: 600px;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .modal-header h3 {
      margin: 0;
    }

    .modal-header .modal-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: var(--text-muted);
      padding: 4px;
    }

    .modal-header .modal-close:hover {
      color: var(--text);
    }

    /* Filter conditions */
    .filter-conditions {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
      max-height: 300px;
      overflow-y: auto;
    }

    .filter-condition {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-surface);
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .filter-condition select,
    .filter-condition input {
      flex: 1;
      min-width: 0;
    }

    .filter-condition .filter-conjunction {
      width: 60px;
      flex: none;
      text-align: center;
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 500;
    }

    .filter-condition .remove-condition {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      font-size: 16px;
    }

    .filter-condition .remove-condition:hover {
      color: var(--danger);
    }

    .add-condition-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: var(--bg-surface);
      border: 1px dashed var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 13px;
      width: 100%;
      justify-content: center;
    }

    .add-condition-btn:hover {
      background: var(--bg-surface-100);
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Sort rules */
    .sort-rules {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
      max-height: 300px;
      overflow-y: auto;
    }

    .sort-rule {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-surface);
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .sort-rule select {
      flex: 1;
      min-width: 0;
    }

    .sort-rule .sort-direction {
      width: 130px;
      flex: none;
    }

    .sort-rule .sort-label {
      font-size: 12px;
      color: var(--text-muted);
      width: 50px;
      flex: none;
    }

    .sort-rule .remove-sort {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      font-size: 16px;
    }

    .sort-rule .remove-sort:hover {
      color: var(--danger);
    }

    /* Hide fields */
    .hide-fields-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 16px;
      max-height: 400px;
      overflow-y: auto;
    }

    .hide-field-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: var(--bg-surface);
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .hide-field-item:hover {
      background: var(--bg-surface-100);
    }

    .hide-field-item input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .hide-field-item .field-name {
      flex: 1;
      font-size: 14px;
    }

    .hide-field-item .field-type {
      font-size: 12px;
      color: var(--text-muted);
      padding: 2px 8px;
      background: var(--bg-surface-200);
      border-radius: 4px;
    }

    .hide-fields-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .hide-fields-actions button {
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-main);
      color: var(--text);
      cursor: pointer;
    }

    .hide-fields-actions button:hover {
      background: var(--bg-surface);
    }

    /* Search clear button */
    .toolbar-search {
      position: relative;
    }

    .toolbar-search .search-clear {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--text-light);
      cursor: pointer;
      padding: 2px;
      font-size: 14px;
      display: none;
    }

    .toolbar-search .search-clear:hover {
      color: var(--text);
    }

    .toolbar-search.has-value .search-clear {
      display: block;
    }

    .toolbar-search.has-value input {
      padding-right: 30px;
    }
  </style>
</head>
<body>

<!-- Loading Overlay -->
<div class="loading-overlay hidden" id="loading">
  <div class="spinner"></div>
  <div class="loading-text" id="loading-text">Loading...</div>
  <div class="progress-bar" id="progress-bar" style="display: none;">
    <div class="progress-bar-fill" id="progress-fill"></div>
  </div>
</div>

<!-- Navigation -->
<nav class="nav" id="nav" style="display: none;">
  <span class="nav-brand">Airtable Grid</span>

  <div class="nav-tabs">
    <button class="nav-tab active" data-page="data">Data</button>
    <button class="nav-tab" data-page="sync">Sync</button>
  </div>

  <div class="nav-status">
    <button class="live-toggle" id="live-toggle" title="Toggle Live Sync">
      <span class="live-dot"></span>
      <span id="live-toggle-text">Live</span>
    </button>
    <div class="sync-indicator synced" id="sync-indicator">
      <span class="sync-dot"></span>
      <span id="sync-status-text">Synced</span>
    </div>
    <span class="pending-badge" id="pending-badge" style="display: none;">0 pending</span>
    <span class="conflict-badge" id="conflict-badge" style="display: none;">0 conflicts</span>
    <button class="nav-tab" id="disconnect-btn">Disconnect</button>
  </div>
</nav>

<!-- Connect Page -->
<div class="page active" id="page-connect">
  <div class="connect-card">
    <h2>Connect to Airtable</h2>
    <div class="form-group">
      <label>Personal Access Token</label>
      <input type="password" id="api-key" placeholder="patXXXXXXXX.XXXXXXXX...">
    </div>
    <div class="form-group">
      <label>Base ID</label>
      <input type="text" id="base-id" placeholder="appXXXXXXXXXXXXXX">
    </div>
    <button id="connect-btn">Connect</button>
    <p class="hint">Find your Base ID in the Airtable URL: airtable.com/<strong>appXXXXX</strong>/...</p>
  </div>
</div>

<!-- App Layout (Left Panel + Main Content) -->
<div class="app-layout" id="app-layout" style="display: none;">

  <!-- Left Panel (Dark Sidebar) -->
  <aside class="left-panel" id="left-panel">
    <!-- Logo -->
    <div class="left-panel-logo">
      <div class="left-panel-logo-icon">
        <i class="ph-fill ph-table"></i>
      </div>
      <span class="left-panel-logo-text">CaseTrack</span>
    </div>

    <!-- Search -->
    <div class="left-panel-search">
      <div style="position: relative;">
        <i class="ph ph-magnifying-glass" style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #6b7280;"></i>
        <input type="text" placeholder="Search..." id="sidebar-search">
      </div>
    </div>

    <!-- Tables List -->
    <div class="left-panel-header">Tables</div>
    <div class="left-panel-content" id="tables-list">
      <!-- Tables will be populated here -->
    </div>

    <!-- Test Page Link -->
    <div class="left-panel-header" style="margin-top: 16px;">Debug</div>
    <div class="left-panel-content">
      <div class="table-item" id="nav-test-page" style="cursor: pointer;">
        <span class="table-item-icon">
          <i class="ph ph-flask"></i>
        </span>
        <span class="table-item-name">Data Test</span>
      </div>
    </div>

    <!-- Footer with Sync Status -->
    <div class="left-panel-footer">
      <div class="sync-footer">
        <span class="sync-dot"></span>
        <span id="sidebar-sync-text">Synced just now</span>
        <button id="sidebar-refresh-btn" title="Refresh">
          <i class="ph ph-arrows-clockwise"></i>
        </button>
        <button id="sidebar-disconnect-btn" title="Disconnect">
          <i class="ph ph-sign-out"></i>
        </button>
      </div>
    </div>
  </aside>

  <!-- Main Content -->
  <main class="main-content">
    <!-- Data Page -->
    <div class="page" id="page-data">
      <!-- Header -->
      <header class="header" id="data-header">
        <div class="header-title">
          <div class="header-icon">
            <i class="ph ph-users"></i>
          </div>
          <h1 id="current-table-name">Select a table</h1>
          <span class="header-count" id="header-record-count"></span>
        </div>
        <div class="header-actions">
          <button class="live-toggle" id="live-toggle" title="Toggle Live Sync">
            <span class="live-dot"></span>
            <span id="live-toggle-text">Live</span>
          </button>
          <div class="sync-indicator synced" id="sync-indicator">
            <span class="sync-dot"></span>
            <span id="sync-status-text">Synced</span>
          </div>
          <span class="pending-badge" id="pending-badge" style="display: none;">0 pending</span>
          <span class="conflict-badge" id="conflict-badge" style="display: none;">0 conflicts</span>
          <button class="btn-toolbar" id="share-btn">
            <i class="ph ph-share-network"></i>
            Share
          </button>
          <button class="btn-primary" id="add-row-btn">
            <i class="ph ph-plus"></i>
            Add record
          </button>
        </div>
      </header>

      <!-- Toolbar -->
      <div class="toolbar" id="data-toolbar">
        <div class="toolbar-search" id="toolbar-search-container">
          <i class="ph ph-magnifying-glass"></i>
          <input type="text" id="search" placeholder="Search records...">
          <button class="search-clear" id="search-clear" title="Clear search"><i class="ph ph-x"></i></button>
        </div>
        <div class="toolbar-divider"></div>
        <button class="toolbar-btn" id="filter-btn">
          <i class="ph ph-funnel"></i>
          Filter
        </button>
        <button class="toolbar-btn" id="sort-btn">
          <i class="ph ph-sort-ascending"></i>
          Sort
        </button>
        <select id="group-by" class="toolbar-btn" style="appearance: none; padding-right: 28px; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%236b7280%22 stroke-width=%222%22%3e%3cpolyline points=%226 9 12 15 18 9%22%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 8px center; background-size: 14px;">
          <option value="">Group</option>
        </select>
        <button class="toolbar-btn" id="hide-fields-btn">
          <i class="ph ph-eye-slash"></i>
          Hide fields
        </button>
        <div class="toolbar-spacer"></div>
        <button class="toolbar-icon-btn" id="download-btn" title="Download">
          <i class="ph ph-download-simple"></i>
        </button>
        <button class="toolbar-icon-btn" id="more-btn" title="More options">
          <i class="ph ph-dots-three"></i>
        </button>
      </div>

      <!-- Grid -->
      <div id="grid"></div>

      <!-- Hidden status for compatibility -->
      <span class="table-status" id="table-status" style="display: none;"></span>
    </div>

    <!-- Sync Page -->
<div class="page" id="page-sync">
  <div class="sync-page">
    <div class="sync-header">
      <h2>Sync Manager</h2>
      <div class="sync-actions">
        <button class="btn-secondary" id="sync-delta-btn">Delta Sync</button>
        <button class="btn-primary" id="sync-full-btn">Full Sync</button>
        <button class="btn-danger" id="clear-cache-btn">Clear Cache</button>
      </div>
    </div>

    <div class="sync-stats">
      <div class="stat-card">
        <div class="stat-value" id="stat-total">0</div>
        <div class="stat-label">Total Records</div>
      </div>
      <div class="stat-card synced">
        <div class="stat-value" id="stat-synced">0</div>
        <div class="stat-label">Synced</div>
      </div>
      <div class="stat-card pending">
        <div class="stat-value" id="stat-pending">0</div>
        <div class="stat-label">Pending</div>
      </div>
      <div class="stat-card conflicts">
        <div class="stat-value" id="stat-conflicts">0</div>
        <div class="stat-label">Conflicts</div>
      </div>
    </div>

    <!-- Tables Section -->
    <div class="sync-section">
      <div class="sync-section-header">
        Tables
      </div>
      <div class="sync-section-content" id="sync-tables-list">
        <div class="empty-state">Loading tables...</div>
      </div>
    </div>

    <!-- Pending Queue Section -->
    <div class="sync-section">
      <div class="sync-section-header">
        Pending Changes
        <button class="btn-primary" style="margin-left: auto; padding: 4px 12px; font-size: 12px;" id="flush-queue-btn">Push All</button>
      </div>
      <div class="sync-section-content" id="sync-queue-list">
        <div class="empty-state">No pending changes</div>
      </div>
    </div>

    <!-- Conflicts Section -->
    <div class="sync-section">
      <div class="sync-section-header">
        Conflicts
      </div>
      <div class="sync-section-content" id="sync-conflicts-list">
        <div class="empty-state">No conflicts</div>
      </div>
    </div>
  </div>
</div>

    <!-- Test Page - Sanity Check for Table Rendering -->
    <div class="page" id="page-test">
      <header class="header">
        <div class="header-title">
          <div class="header-icon">
            <i class="ph ph-flask"></i>
          </div>
          <h1>Test Table Rendering</h1>
          <span class="header-count" id="test-record-count"></span>
        </div>
        <div class="header-actions">
          <button class="btn-secondary" id="test-refresh-btn">
            <i class="ph ph-arrows-clockwise"></i>
            Refresh
          </button>
        </div>
      </header>
      <div class="toolbar">
        <span style="font-size: 13px; color: var(--text-muted);">
          Single table source: <strong>tblgynOzESGvAXAsK</strong>
        </span>
      </div>
      <div id="test-grid"></div>
      <div id="test-debug" style="padding: 16px; font-family: monospace; font-size: 12px; background: var(--bg-surface-100); border-top: 1px solid var(--border); max-height: 200px; overflow: auto;"></div>
    </div>

  </main><!-- /main-content -->
</div><!-- /app-layout -->

<!-- Add Row Modal -->
<div class="modal hidden" id="add-modal">
  <div class="modal-content">
    <h3>Add New Record</h3>
    <div id="modal-fields"></div>
    <div class="modal-actions">
      <button class="btn-secondary" id="modal-cancel">Cancel</button>
      <button class="btn-primary" id="modal-save">Save</button>
    </div>
  </div>
</div>

<!-- Filter Modal -->
<div class="modal hidden" id="filter-modal">
  <div class="modal-content modal-wide">
    <div class="modal-header">
      <h3>Filter records</h3>
      <button class="modal-close" id="filter-modal-close"><i class="ph ph-x"></i></button>
    </div>
    <div class="filter-conditions" id="filter-conditions">
      <!-- Filter conditions will be added here -->
    </div>
    <button class="add-condition-btn" id="add-filter-condition">
      <i class="ph ph-plus"></i>
      Add condition
    </button>
    <div class="modal-actions">
      <button class="btn-secondary" id="filter-clear">Clear all</button>
      <button class="btn-primary" id="filter-apply">Apply filters</button>
    </div>
  </div>
</div>

<!-- Sort Modal -->
<div class="modal hidden" id="sort-modal">
  <div class="modal-content modal-wide">
    <div class="modal-header">
      <h3>Sort records</h3>
      <button class="modal-close" id="sort-modal-close"><i class="ph ph-x"></i></button>
    </div>
    <div class="sort-rules" id="sort-rules">
      <!-- Sort rules will be added here -->
    </div>
    <button class="add-condition-btn" id="add-sort-rule">
      <i class="ph ph-plus"></i>
      Add sort
    </button>
    <div class="modal-actions">
      <button class="btn-secondary" id="sort-clear">Clear all</button>
      <button class="btn-primary" id="sort-apply">Apply sort</button>
    </div>
  </div>
</div>

<!-- Hide Fields Modal -->
<div class="modal hidden" id="hide-fields-modal">
  <div class="modal-content modal-wide">
    <div class="modal-header">
      <h3>Hide fields</h3>
      <button class="modal-close" id="hide-fields-modal-close"><i class="ph ph-x"></i></button>
    </div>
    <div class="hide-fields-actions">
      <button id="hide-fields-show-all">Show all</button>
      <button id="hide-fields-hide-all">Hide all</button>
    </div>
    <div class="hide-fields-list" id="hide-fields-list">
      <!-- Field checkboxes will be added here -->
    </div>
    <div class="modal-actions">
      <button class="btn-primary" id="hide-fields-apply">Done</button>
    </div>
  </div>
</div>

<!-- Tabulator -->
<script src="https://unpkg.com/tabulator-tables@6.2.1/dist/js/tabulator.min.js"></script>

<script>
// ============================================================
// CONFIG
// ============================================================
const CONFIG = {
  API_KEY: '',
  BASE_ID: '',
  // Live sync settings
  LIVE_SYNC_URL: '', // e.g., 'https://your-n8n.com/webhook/airtable-changes'
  LIVE_POLL_INTERVAL: 5000 // 5 seconds
};

// ============================================================
// EXPERIENCE ENGINE - IndexedDB Store
// ============================================================
const ExperienceEngine = {
  db: null,
  DB_NAME: 'experience-engine',
  DB_VERSION: 1, // NEVER change this without migration logic

  // ========== INITIALIZATION ==========
  async init() {
    if (this.db) return this.db;

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

      request.onerror = () => {
        console.error('IndexedDB open failed:', request.error);
        reject(request.error);
      };

      request.onsuccess = () => {
        this.db = request.result;
        console.log('IndexedDB opened, stores:', [...this.db.objectStoreNames]);
        resolve(this.db);
      };

      request.onupgradeneeded = (e) => {
        console.log('IndexedDB upgrade needed:', e.oldVersion, '->', e.newVersion);
        const db = e.target.result;

        // Records store - the main cache
        if (!db.objectStoreNames.contains('records')) {
          const records = db.createObjectStore('records', { keyPath: '_id' });
          records.createIndex('byTable', ['baseId', 'tableId']);
          records.createIndex('byStatus', '_status');
        }

        // Sync queue - pending operations
        if (!db.objectStoreNames.contains('syncQueue')) {
          db.createObjectStore('syncQueue', { keyPath: 'id', autoIncrement: true });
        }

        // Conflicts - diverged records
        if (!db.objectStoreNames.contains('conflicts')) {
          db.createObjectStore('conflicts', { keyPath: 'id', autoIncrement: true });
        }

        // Metadata - sync times, schema cache
        if (!db.objectStoreNames.contains('meta')) {
          db.createObjectStore('meta', { keyPath: 'key' });
        }
      };
    });
  },

  // ========== RECORD OPERATIONS ==========

  // Create composite ID
  _recordId(baseId, tableId, recordId) {
    return `${baseId}:${tableId}:${recordId}`;
  },

  // Store a record from Airtable (the "Given")
  async storeGiven(baseId, tableId, airtableRecord) {
    await this.init();

    const id = this._recordId(baseId, tableId, airtableRecord.id);
    const now = Date.now();

    // Check if we have local changes
    const existing = await this.getRecord(id);

    const record = {
      _id: id,
      baseId,
      tableId,
      recordId: airtableRecord.id,

      // Provenance (Rule 7)
      _provenance: {
        source: 'airtable',
        recordId: airtableRecord.id,
        baseId,
        tableId,
        witnessedAt: existing?._provenance?.witnessedAt || now
      },

      // The Given - what server said (Rule 3: ineliminable)
      _given: {
        fields: airtableRecord.fields || {},
        createdTime: airtableRecord.createdTime
      },

      // Server's modification time
      _serverModifiedAt: airtableRecord.fields?.['Last Modified']
        ? new Date(airtableRecord.fields['Last Modified']).getTime()
        : now,

      // When we synced
      _syncedAt: now,

      // The Meant - our local interpretation
      _meant: existing?._meant || { fields: {}, modifiedAt: null },

      // Status
      _status: existing?._status === 'pending' ? 'pending' : 'synced'
    };

    // Check for conflict: we have pending changes AND server changed
    if (existing?._status === 'pending' &&
        existing._syncedAt < record._serverModifiedAt) {
      record._status = 'conflict';
      await this.createConflict(id, existing._meant, record._given);
    }

    return this._put('records', record);
  },

  // Store a locally created record (starts as "Meant" only)
  async storeLocal(baseId, tableId, fields) {
    await this.init();

    const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const id = this._recordId(baseId, tableId, tempId);
    const now = Date.now();

    const record = {
      _id: id,
      baseId,
      tableId,
      recordId: tempId,

      _provenance: {
        source: 'local',
        tempId,
        baseId,
        tableId,
        createdAt: now
      },

      _given: null, // No server truth yet
      _serverModifiedAt: null,
      _syncedAt: null,

      _meant: {
        fields,
        modifiedAt: now
      },

      _status: 'new'
    };

    await this._put('records', record);
    await this.queueOperation(baseId, tableId, tempId, 'create', fields);

    return record;
  },

  // Update a record locally
  async updateLocal(recordId, fieldChanges) {
    await this.init();

    const record = await this.getRecord(recordId);
    if (!record) throw new Error('Record not found');

    const now = Date.now();

    // Merge changes into meant
    record._meant.fields = { ...record._meant.fields, ...fieldChanges };
    record._meant.modifiedAt = now;
    record._status = record._status === 'new' ? 'new' : 'pending';

    await this._put('records', record);

    // Queue the update
    if (record._status !== 'new') { // New records already have a create queued
      await this.queueOperation(
        record.baseId,
        record.tableId,
        record.recordId,
        'update',
        fieldChanges
      );
    }

    return record;
  },

  // Get a record
  async getRecord(id) {
    await this.init();
    return this._get('records', id);
  },

  // Get all records for a table
  async getTableRecords(baseId, tableId) {
    await this.init();

    return new Promise((resolve, reject) => {
      try {
        const tx = this.db.transaction('records', 'readonly');
        const store = tx.objectStore('records');
        const index = store.index('byTable');
        const request = index.getAll([baseId, tableId]);

        request.onsuccess = () => {
          const results = request.result || [];
          console.log(`getTableRecords(${tableId}): found ${results.length} records`);
          resolve(results);
        };
        request.onerror = () => {
          console.error('getTableRecords error:', request.error);
          reject(request.error);
        };
      } catch (e) {
        console.error('getTableRecords exception:', e);
        resolve([]); // Return empty on error, don't block
      }
    });
  },

  // Get merged view (Given + Meant) for display
  getMergedFields(record) {
    if (!record) return {};
    const given = record._given?.fields || {};
    const meant = record._meant?.fields || {};
    return { ...given, ...meant };
  },

  // ========== SYNC QUEUE ==========

  async queueOperation(baseId, tableId, recordId, operation, fields) {
    await this.init();

    const item = {
      baseId,
      tableId,
      recordId,
      operation,
      fields,
      createdAt: Date.now(),
      attempts: 0,
      lastError: null
    };

    return this._add('syncQueue', item);
  },

  async getQueue() {
    await this.init();
    return this._getAll('syncQueue');
  },

  async removeFromQueue(id) {
    await this.init();
    return this._delete('syncQueue', id);
  },

  async clearQueue() {
    await this.init();
    return this._clear('syncQueue');
  },

  // ========== CONFLICTS ==========

  async createConflict(recordId, meant, given) {
    await this.init();

    const conflict = {
      recordId,
      meant,
      given,
      detectedAt: Date.now(),
      resolution: null
    };

    return this._add('conflicts', conflict);
  },

  async getConflicts() {
    await this.init();
    return this._getAll('conflicts');
  },

  async resolveConflict(id, resolution, record) {
    await this.init();

    // Update conflict record
    const conflict = await this._get('conflicts', id);
    if (conflict) {
      conflict.resolution = resolution;
      conflict.resolvedAt = Date.now();
      await this._put('conflicts', conflict);
    }

    // Update the record based on resolution
    if (record) {
      if (resolution === 'keep_given') {
        record._meant = { fields: {}, modifiedAt: null };
        record._status = 'synced';
      } else if (resolution === 'keep_meant') {
        // Re-queue the push
        await this.queueOperation(
          record.baseId,
          record.tableId,
          record.recordId,
          'update',
          record._meant.fields
        );
        record._status = 'pending';
      }
      await this._put('records', record);
    }

    // Remove resolved conflict
    await this._delete('conflicts', id);
  },

  // ========== METADATA ==========

  async getMeta(key) {
    await this.init();
    const item = await this._get('meta', key);
    return item?.value;
  },

  async setMeta(key, value) {
    await this.init();
    return this._put('meta', { key, value, updatedAt: Date.now() });
  },

  async getTableSyncTime(tableId) {
    return this.getMeta(`sync:${CONFIG.BASE_ID}:${tableId}`);
  },

  async setTableSyncTime(tableId, time) {
    return this.setMeta(`sync:${CONFIG.BASE_ID}:${tableId}`, time);
  },

  // ========== STATS ==========

  async getStats() {
    await this.init();

    const records = await this._getAll('records');
    const queue = await this.getQueue();
    const conflicts = await this.getConflicts();

    const byStatus = { synced: 0, pending: 0, new: 0, conflict: 0 };
    const byTable = {};

    for (const r of records) {
      byStatus[r._status] = (byStatus[r._status] || 0) + 1;

      const tableKey = `${r.baseId}:${r.tableId}`;
      if (!byTable[tableKey]) {
        byTable[tableKey] = { total: 0, synced: 0, pending: 0 };
      }
      byTable[tableKey].total++;
      byTable[tableKey][r._status] = (byTable[tableKey][r._status] || 0) + 1;
    }

    return {
      total: records.length,
      synced: byStatus.synced,
      pending: byStatus.pending + byStatus.new,
      conflicts: conflicts.length,
      queueLength: queue.length,
      byTable
    };
  },

  // ========== CLEAR ==========

  async clearAll() {
    await this.init();
    await this._clear('records');
    await this._clear('syncQueue');
    await this._clear('conflicts');
    await this._clear('meta');
    console.log('Cache cleared');
  },

  async clearTable(baseId, tableId) {
    await this.init();

    // Get all records for this table and delete them
    const records = await this.getTableRecords(baseId, tableId);
    for (const record of records) {
      await this._delete('records', record._id);
    }

    // Clear sync time
    await this._delete('meta', `sync:${baseId}:${tableId}`);

    console.log(`Cleared table ${tableId}: ${records.length} records`);
  },

  // ========== LOW-LEVEL HELPERS ==========

  _get(storeName, key) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readonly');
      const request = tx.objectStore(storeName).get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },

  _getAll(storeName) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readonly');
      const request = tx.objectStore(storeName).getAll();
      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  },

  _put(storeName, item) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readwrite');
      const request = tx.objectStore(storeName).put(item);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },

  _add(storeName, item) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readwrite');
      const request = tx.objectStore(storeName).add(item);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },

  _delete(storeName, key) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readwrite');
      const request = tx.objectStore(storeName).delete(key);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  },

  _clear(storeName) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readwrite');
      const request = tx.objectStore(storeName).clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
};

// ============================================================
// FORMULA ENGINE - Local formula calculation
// ============================================================
const FormulaEngine = {
  // Cache parsed formulas for performance
  _cache: new Map(),

  // Evaluate a formula string with record data
  evaluate(formulaStr, record, fields) {
    if (!formulaStr || typeof formulaStr !== 'string') return null;

    try {
      // Get or create parsed formula
      let parsed = this._cache.get(formulaStr);
      if (!parsed) {
        parsed = this.parse(formulaStr);
        this._cache.set(formulaStr, parsed);
      }

      // Create field lookup map (name -> value)
      const fieldValues = {};
      const fieldMap = new Map(fields.map(f => [f.id, f.name]));

      for (const [key, value] of Object.entries(record)) {
        fieldValues[key] = value;
      }

      return this.exec(parsed, fieldValues);
    } catch (e) {
      console.warn('Formula evaluation error:', e.message, formulaStr);
      return '#ERROR';
    }
  },

  // Parse formula string into AST
  parse(formula) {
    const tokens = this.tokenize(formula);
    return this.parseExpression(tokens, 0).node;
  },

  // Tokenize formula string
  tokenize(formula) {
    const tokens = [];
    let i = 0;

    while (i < formula.length) {
      const ch = formula[i];

      // Whitespace
      if (/\s/.test(ch)) {
        i++;
        continue;
      }

      // Field reference: {Field Name}
      if (ch === '{') {
        const end = formula.indexOf('}', i);
        if (end === -1) throw new Error('Unclosed field reference');
        tokens.push({ type: 'field', value: formula.slice(i + 1, end) });
        i = end + 1;
        continue;
      }

      // String literal: "text" or 'text'
      if (ch === '"' || ch === "'") {
        const quote = ch;
        let str = '';
        i++;
        while (i < formula.length && formula[i] !== quote) {
          if (formula[i] === '\\' && i + 1 < formula.length) {
            i++;
            str += formula[i];
          } else {
            str += formula[i];
          }
          i++;
        }
        if (i >= formula.length) throw new Error('Unclosed string');
        tokens.push({ type: 'string', value: str });
        i++;
        continue;
      }

      // Number
      if (/[0-9.]/.test(ch)) {
        let num = '';
        while (i < formula.length && /[0-9.]/.test(formula[i])) {
          num += formula[i];
          i++;
        }
        tokens.push({ type: 'number', value: parseFloat(num) });
        continue;
      }

      // Operators
      if (ch === '+') { tokens.push({ type: 'op', value: '+' }); i++; continue; }
      if (ch === '-') { tokens.push({ type: 'op', value: '-' }); i++; continue; }
      if (ch === '*') { tokens.push({ type: 'op', value: '*' }); i++; continue; }
      if (ch === '/') { tokens.push({ type: 'op', value: '/' }); i++; continue; }
      if (ch === '&') { tokens.push({ type: 'op', value: '&' }); i++; continue; }
      if (ch === '(') { tokens.push({ type: 'lparen' }); i++; continue; }
      if (ch === ')') { tokens.push({ type: 'rparen' }); i++; continue; }
      if (ch === ',') { tokens.push({ type: 'comma' }); i++; continue; }

      // Comparison operators
      if (ch === '=' && formula[i + 1] !== '=') {
        tokens.push({ type: 'op', value: '=' }); i++; continue;
      }
      if (ch === '!' && formula[i + 1] === '=') {
        tokens.push({ type: 'op', value: '!=' }); i += 2; continue;
      }
      if (ch === '<' && formula[i + 1] === '=') {
        tokens.push({ type: 'op', value: '<=' }); i += 2; continue;
      }
      if (ch === '>' && formula[i + 1] === '=') {
        tokens.push({ type: 'op', value: '>=' }); i += 2; continue;
      }
      if (ch === '<') { tokens.push({ type: 'op', value: '<' }); i++; continue; }
      if (ch === '>') { tokens.push({ type: 'op', value: '>' }); i++; continue; }

      // Function or identifier
      if (/[a-zA-Z_]/.test(ch)) {
        let name = '';
        while (i < formula.length && /[a-zA-Z0-9_]/.test(formula[i])) {
          name += formula[i];
          i++;
        }
        // Check for TRUE/FALSE literals
        if (name.toUpperCase() === 'TRUE') {
          tokens.push({ type: 'boolean', value: true });
        } else if (name.toUpperCase() === 'FALSE') {
          tokens.push({ type: 'boolean', value: false });
        } else {
          tokens.push({ type: 'func', value: name.toUpperCase() });
        }
        continue;
      }

      // Unknown character - skip
      i++;
    }

    return tokens;
  },

  // Parse expression with precedence
  parseExpression(tokens, pos) {
    return this.parseComparison(tokens, pos);
  },

  // Parse comparison (lowest precedence)
  parseComparison(tokens, pos) {
    let { node: left, pos: newPos } = this.parseAddSub(tokens, pos);

    while (newPos < tokens.length &&
           tokens[newPos].type === 'op' &&
           ['=', '!=', '<', '>', '<=', '>='].includes(tokens[newPos].value)) {
      const op = tokens[newPos].value;
      const { node: right, pos: nextPos } = this.parseAddSub(tokens, newPos + 1);
      left = { type: 'binary', op, left, right };
      newPos = nextPos;
    }

    return { node: left, pos: newPos };
  },

  // Parse addition/subtraction and string concat
  parseAddSub(tokens, pos) {
    let { node: left, pos: newPos } = this.parseMulDiv(tokens, pos);

    while (newPos < tokens.length &&
           tokens[newPos].type === 'op' &&
           ['+', '-', '&'].includes(tokens[newPos].value)) {
      const op = tokens[newPos].value;
      const { node: right, pos: nextPos } = this.parseMulDiv(tokens, newPos + 1);
      left = { type: 'binary', op, left, right };
      newPos = nextPos;
    }

    return { node: left, pos: newPos };
  },

  // Parse multiplication/division
  parseMulDiv(tokens, pos) {
    let { node: left, pos: newPos } = this.parseUnary(tokens, pos);

    while (newPos < tokens.length &&
           tokens[newPos].type === 'op' &&
           ['*', '/'].includes(tokens[newPos].value)) {
      const op = tokens[newPos].value;
      const { node: right, pos: nextPos } = this.parseUnary(tokens, newPos + 1);
      left = { type: 'binary', op, left, right };
      newPos = nextPos;
    }

    return { node: left, pos: newPos };
  },

  // Parse unary (negative numbers)
  parseUnary(tokens, pos) {
    if (pos < tokens.length && tokens[pos].type === 'op' && tokens[pos].value === '-') {
      const { node, pos: newPos } = this.parsePrimary(tokens, pos + 1);
      return { node: { type: 'unary', op: '-', operand: node }, pos: newPos };
    }
    return this.parsePrimary(tokens, pos);
  },

  // Parse primary (literals, fields, functions, parentheses)
  parsePrimary(tokens, pos) {
    if (pos >= tokens.length) {
      return { node: { type: 'literal', value: null }, pos };
    }

    const token = tokens[pos];

    // Literals
    if (token.type === 'number' || token.type === 'string' || token.type === 'boolean') {
      return { node: { type: 'literal', value: token.value }, pos: pos + 1 };
    }

    // Field reference
    if (token.type === 'field') {
      return { node: { type: 'field', name: token.value }, pos: pos + 1 };
    }

    // Function call
    if (token.type === 'func') {
      const funcName = token.value;
      if (pos + 1 < tokens.length && tokens[pos + 1].type === 'lparen') {
        // Parse arguments
        const args = [];
        let argPos = pos + 2;

        while (argPos < tokens.length && tokens[argPos].type !== 'rparen') {
          const { node: arg, pos: newPos } = this.parseExpression(tokens, argPos);
          args.push(arg);
          argPos = newPos;

          if (argPos < tokens.length && tokens[argPos].type === 'comma') {
            argPos++;
          }
        }

        // Skip closing paren
        if (argPos < tokens.length && tokens[argPos].type === 'rparen') {
          argPos++;
        }

        return { node: { type: 'call', func: funcName, args }, pos: argPos };
      }
      // Bare function name (shouldn't happen but handle it)
      return { node: { type: 'call', func: funcName, args: [] }, pos: pos + 1 };
    }

    // Parenthesized expression
    if (token.type === 'lparen') {
      const { node, pos: newPos } = this.parseExpression(tokens, pos + 1);
      // Skip closing paren
      const closePos = newPos < tokens.length && tokens[newPos].type === 'rparen' ? newPos + 1 : newPos;
      return { node, pos: closePos };
    }

    // Unknown - return null
    return { node: { type: 'literal', value: null }, pos: pos + 1 };
  },

  // Execute AST node
  exec(node, fields) {
    if (!node) return null;

    switch (node.type) {
      case 'literal':
        return node.value;

      case 'field':
        const val = fields[node.name];
        // Handle undefined/null
        if (val === undefined || val === null) return null;
        // Handle linked records/attachments (return count or first value)
        if (Array.isArray(val)) {
          if (val.length === 0) return null;
          if (typeof val[0] === 'object') return val.length; // Count for linked records
          return val[0]; // First value for simple arrays
        }
        return val;

      case 'unary':
        const operand = this.exec(node.operand, fields);
        if (node.op === '-') return -this.toNumber(operand);
        return operand;

      case 'binary':
        const left = this.exec(node.left, fields);
        const right = this.exec(node.right, fields);
        return this.execBinary(node.op, left, right);

      case 'call':
        const args = node.args.map(a => this.exec(a, fields));
        return this.execFunction(node.func, args);

      default:
        return null;
    }
  },

  // Execute binary operation
  execBinary(op, left, right) {
    switch (op) {
      case '+': return this.toNumber(left) + this.toNumber(right);
      case '-': return this.toNumber(left) - this.toNumber(right);
      case '*': return this.toNumber(left) * this.toNumber(right);
      case '/':
        const divisor = this.toNumber(right);
        return divisor === 0 ? '#DIV/0' : this.toNumber(left) / divisor;
      case '&': return this.toString(left) + this.toString(right);
      case '=': return this.isEqual(left, right);
      case '!=': return !this.isEqual(left, right);
      case '<': return this.toNumber(left) < this.toNumber(right);
      case '>': return this.toNumber(left) > this.toNumber(right);
      case '<=': return this.toNumber(left) <= this.toNumber(right);
      case '>=': return this.toNumber(left) >= this.toNumber(right);
      default: return null;
    }
  },

  // Execute function call
  execFunction(name, args) {
    switch (name) {
      // Logical
      case 'IF':
        return args[0] ? args[1] : (args[2] ?? null);
      case 'AND':
        return args.every(a => this.toBool(a));
      case 'OR':
        return args.some(a => this.toBool(a));
      case 'NOT':
        return !this.toBool(args[0]);
      case 'BLANK':
        return null;
      case 'ERROR':
        return '#ERROR';
      case 'ISERROR':
        return typeof args[0] === 'string' && args[0].startsWith('#');

      // Math
      case 'SUM':
        return args.flat().reduce((a, b) => this.toNumber(a) + this.toNumber(b), 0);
      case 'AVERAGE':
        const nums = args.flat().filter(n => n !== null && n !== '');
        return nums.length ? nums.reduce((a, b) => this.toNumber(a) + this.toNumber(b), 0) / nums.length : null;
      case 'MAX':
        return Math.max(...args.flat().map(n => this.toNumber(n)));
      case 'MIN':
        return Math.min(...args.flat().map(n => this.toNumber(n)));
      case 'ABS':
        return Math.abs(this.toNumber(args[0]));
      case 'ROUND':
        const places = args[1] ?? 0;
        const factor = Math.pow(10, this.toNumber(places));
        return Math.round(this.toNumber(args[0]) * factor) / factor;
      case 'ROUNDUP':
        const upFactor = Math.pow(10, this.toNumber(args[1] ?? 0));
        return Math.ceil(this.toNumber(args[0]) * upFactor) / upFactor;
      case 'ROUNDDOWN':
        const downFactor = Math.pow(10, this.toNumber(args[1] ?? 0));
        return Math.floor(this.toNumber(args[0]) * downFactor) / downFactor;
      case 'CEILING':
        return Math.ceil(this.toNumber(args[0]));
      case 'FLOOR':
        return Math.floor(this.toNumber(args[0]));
      case 'MOD':
        return this.toNumber(args[0]) % this.toNumber(args[1]);
      case 'POWER':
        return Math.pow(this.toNumber(args[0]), this.toNumber(args[1]));
      case 'SQRT':
        return Math.sqrt(this.toNumber(args[0]));
      case 'LOG':
        return args[1] ? Math.log(this.toNumber(args[0])) / Math.log(this.toNumber(args[1])) : Math.log10(this.toNumber(args[0]));
      case 'EXP':
        return Math.exp(this.toNumber(args[0]));
      case 'INT':
        return Math.trunc(this.toNumber(args[0]));
      case 'EVEN':
        const n = Math.ceil(Math.abs(this.toNumber(args[0])));
        return (n % 2 === 0 ? n : n + 1) * Math.sign(this.toNumber(args[0]) || 1);
      case 'ODD':
        const o = Math.ceil(Math.abs(this.toNumber(args[0])));
        return (o % 2 === 1 ? o : o + 1) * Math.sign(this.toNumber(args[0]) || 1);
      case 'VALUE':
        return this.toNumber(args[0]);

      // Text
      case 'CONCATENATE':
        return args.map(a => this.toString(a)).join('');
      case 'LEN':
        return this.toString(args[0]).length;
      case 'UPPER':
        return this.toString(args[0]).toUpperCase();
      case 'LOWER':
        return this.toString(args[0]).toLowerCase();
      case 'TRIM':
        return this.toString(args[0]).trim();
      case 'LEFT':
        return this.toString(args[0]).slice(0, this.toNumber(args[1]) || 1);
      case 'RIGHT':
        const str = this.toString(args[0]);
        const len = this.toNumber(args[1]) || 1;
        return str.slice(-len);
      case 'MID':
        return this.toString(args[0]).slice(this.toNumber(args[1]) - 1, this.toNumber(args[1]) - 1 + this.toNumber(args[2]));
      case 'SUBSTITUTE':
        return this.toString(args[0]).split(this.toString(args[1])).join(this.toString(args[2] ?? ''));
      case 'REPLACE': {
        const orig = this.toString(args[0]);
        const start = this.toNumber(args[1]) - 1;
        const count = this.toNumber(args[2]);
        const replacement = this.toString(args[3] ?? '');
        return orig.slice(0, start) + replacement + orig.slice(start + count);
      }
      case 'REPT':
        return this.toString(args[0]).repeat(Math.max(0, this.toNumber(args[1])));
      case 'T':
        return typeof args[0] === 'string' ? args[0] : '';
      case 'FIND':
        const idx = this.toString(args[1]).indexOf(this.toString(args[0]), this.toNumber(args[2] ?? 1) - 1);
        return idx === -1 ? 0 : idx + 1;
      case 'SEARCH':
        const sIdx = this.toString(args[1]).toLowerCase().indexOf(this.toString(args[0]).toLowerCase(), this.toNumber(args[2] ?? 1) - 1);
        return sIdx === -1 ? 0 : sIdx + 1;
      case 'ENCODE_URL_COMPONENT':
        return encodeURIComponent(this.toString(args[0]));

      // Date/Time
      case 'TODAY':
        return new Date().toISOString().split('T')[0];
      case 'NOW':
        return new Date().toISOString();
      case 'YEAR':
        return new Date(args[0]).getFullYear();
      case 'MONTH':
        return new Date(args[0]).getMonth() + 1;
      case 'DAY':
        return new Date(args[0]).getDate();
      case 'HOUR':
        return new Date(args[0]).getHours();
      case 'MINUTE':
        return new Date(args[0]).getMinutes();
      case 'SECOND':
        return new Date(args[0]).getSeconds();
      case 'WEEKDAY':
        return new Date(args[0]).getDay();
      case 'WEEKNUM': {
        const d = new Date(args[0]);
        const yearStart = new Date(d.getFullYear(), 0, 1);
        return Math.ceil((((d - yearStart) / 86400000) + yearStart.getDay() + 1) / 7);
      }
      case 'DATEADD':
        const date = new Date(args[0]);
        const amount = this.toNumber(args[1]);
        const unit = this.toString(args[2]).toLowerCase();
        if (unit === 'days' || unit === 'day') date.setDate(date.getDate() + amount);
        else if (unit === 'months' || unit === 'month') date.setMonth(date.getMonth() + amount);
        else if (unit === 'years' || unit === 'year') date.setFullYear(date.getFullYear() + amount);
        else if (unit === 'hours' || unit === 'hour') date.setHours(date.getHours() + amount);
        else if (unit === 'minutes' || unit === 'minute') date.setMinutes(date.getMinutes() + amount);
        return date.toISOString();
      case 'DATETIME_DIFF':
        const d1 = new Date(args[0]);
        const d2 = new Date(args[1]);
        const diffUnit = this.toString(args[2]).toLowerCase();
        const diffMs = d1 - d2;
        if (diffUnit === 'days' || diffUnit === 'day') return Math.floor(diffMs / 86400000);
        if (diffUnit === 'hours' || diffUnit === 'hour') return Math.floor(diffMs / 3600000);
        if (diffUnit === 'minutes' || diffUnit === 'minute') return Math.floor(diffMs / 60000);
        if (diffUnit === 'seconds' || diffUnit === 'second') return Math.floor(diffMs / 1000);
        if (diffUnit === 'months' || diffUnit === 'month') return (d1.getFullYear() - d2.getFullYear()) * 12 + (d1.getMonth() - d2.getMonth());
        if (diffUnit === 'years' || diffUnit === 'year') return d1.getFullYear() - d2.getFullYear();
        return diffMs;
      case 'DATETIME_FORMAT':
        return new Date(args[0]).toLocaleString();
      case 'DATETIME_PARSE':
        return new Date(args[0]).toISOString();
      case 'IS_AFTER':
        return new Date(args[0]) > new Date(args[1]);
      case 'IS_BEFORE':
        return new Date(args[0]) < new Date(args[1]);
      case 'IS_SAME':
        const unit1 = this.toString(args[2] ?? 'day').toLowerCase();
        const da = new Date(args[0]), db = new Date(args[1]);
        if (unit1.startsWith('year')) return da.getFullYear() === db.getFullYear();
        if (unit1.startsWith('month')) return da.getFullYear() === db.getFullYear() && da.getMonth() === db.getMonth();
        return da.toDateString() === db.toDateString();

      // Record info
      case 'RECORD_ID':
        return args[0]?._recordId || '';
      case 'CREATED_TIME':
        return args[0]?._createdTime || '';

      // Array/counting
      case 'COUNT':
        return args.flat().filter(v => v !== null && v !== '' && v !== undefined).length;
      case 'COUNTA':
        return args.flat().filter(v => v !== null && v !== '' && v !== undefined).length;
      case 'COUNTALL':
        return args.flat().length;

      default:
        console.warn('Unknown formula function:', name);
        return null;
    }
  },

  // Type coercion helpers
  toNumber(val) {
    if (val === null || val === undefined || val === '') return 0;
    if (typeof val === 'number') return isNaN(val) ? 0 : val;
    if (typeof val === 'boolean') return val ? 1 : 0;
    const n = parseFloat(val);
    return isNaN(n) ? 0 : n;
  },

  toString(val) {
    if (val === null || val === undefined) return '';
    if (typeof val === 'object') return JSON.stringify(val);
    return String(val);
  },

  toBool(val) {
    if (val === null || val === undefined || val === '' || val === 0 || val === false) return false;
    return true;
  },

  isEqual(a, b) {
    if (a === b) return true;
    if (a === null || a === undefined) return b === null || b === undefined;
    if (typeof a === 'string' && typeof b === 'string') return a.toLowerCase() === b.toLowerCase();
    return this.toNumber(a) === this.toNumber(b);
  }
};

// ============================================================
// AIRTABLE API
// ============================================================
const Airtable = {
  baseUrl: 'https://api.airtable.com/v0',

  headers() {
    return {
      'Authorization': `Bearer ${CONFIG.API_KEY}`,
      'Content-Type': 'application/json'
    };
  },

  async getSchema() {
    const res = await fetch(`https://api.airtable.com/v0/meta/bases/${CONFIG.BASE_ID}/tables`, {
      headers: this.headers()
    });
    if (!res.ok) throw new Error(`Schema fetch failed: ${res.status}`);
    return res.json();
  },

  async getPage(tableId, { offset = null, pageSize = 100, filterFormula = null, view = null } = {}) {
    const params = new URLSearchParams();
    params.set('pageSize', pageSize);
    if (offset) params.set('offset', offset);
    if (filterFormula) params.set('filterByFormula', filterFormula);
    if (view) params.set('view', view);

    const url = `${this.baseUrl}/${CONFIG.BASE_ID}/${encodeURIComponent(tableId)}?${params}`;
    const res = await fetch(url, { headers: this.headers() });
    if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
    return res.json();
  },

  async getAllRecords(tableId, { filterFormula = null, view = null, onProgress = null } = {}) {
    const allRecords = [];
    let offset = null;
    let page = 0;

    do {
      const data = await this.getPage(tableId, { offset, filterFormula, view });
      allRecords.push(...data.records);
      offset = data.offset;
      page++;

      if (onProgress) onProgress(allRecords.length, page, !!offset);
      if (offset) await new Promise(r => setTimeout(r, 200));
    } while (offset);

    return allRecords;
  },

  async createRecord(tableId, fields) {
    const res = await fetch(`${this.baseUrl}/${CONFIG.BASE_ID}/${encodeURIComponent(tableId)}`, {
      method: 'POST',
      headers: this.headers(),
      body: JSON.stringify({ fields, typecast: true })
    });
    if (!res.ok) throw new Error(`Create failed: ${res.status}`);
    return res.json();
  },

  async updateRecord(tableId, recordId, fields) {
    const res = await fetch(`${this.baseUrl}/${CONFIG.BASE_ID}/${encodeURIComponent(tableId)}/${recordId}`, {
      method: 'PATCH',
      headers: this.headers(),
      body: JSON.stringify({ fields, typecast: true })
    });
    if (!res.ok) throw new Error(`Update failed: ${res.status}`);
    return res.json();
  },

  async deleteRecord(tableId, recordId) {
    const res = await fetch(`${this.baseUrl}/${CONFIG.BASE_ID}/${encodeURIComponent(tableId)}/${recordId}`, {
      method: 'DELETE',
      headers: this.headers()
    });
    if (!res.ok) throw new Error(`Delete failed: ${res.status}`);
    return res.json();
  },

  // Fetch detailed view metadata including sections/folders
  async getViews(tableId) {
    const res = await fetch(`https://api.airtable.com/v0/meta/bases/${CONFIG.BASE_ID}/tables/${tableId}/views`, {
      headers: this.headers()
    });
    if (!res.ok) {
      console.warn(`Views fetch failed for ${tableId}: ${res.status}`);
      return null;
    }
    return res.json();
  }
};

// Enrich schema with detailed view data including sections/folders
async function enrichSchemaWithViewDetails(schema) {
  if (!schema || !schema.tables) return schema;

  // Fetch detailed view info for each table in parallel
  const viewPromises = schema.tables.map(async (tableSchema) => {
    try {
      const viewsData = await Airtable.getViews(tableSchema.id);
      if (viewsData && viewsData.views) {
        // Store the enriched view data
        tableSchema.viewsDetailed = viewsData.views;
        // Log to see what we get back
        console.log(`Views for ${tableSchema.name}:`, viewsData);
      }
    } catch (e) {
      console.warn(`Failed to fetch views for ${tableSchema.name}:`, e);
    }
  });

  await Promise.all(viewPromises);
  return schema;
}

// ============================================================
// SYNC MANAGER
// ============================================================
const SyncManager = {
  isSyncing: false,

  // Full sync - download everything
  async fullSync(tableId) {
    if (this.isSyncing) return 0;
    this.isSyncing = true;
    updateSyncIndicator('syncing', 'Syncing...');

    try {
      const records = await Airtable.getAllRecords(tableId);

      // Store all as Given
      for (const record of records) {
        await ExperienceEngine.storeGiven(CONFIG.BASE_ID, tableId, record);
      }

      await ExperienceEngine.setTableSyncTime(tableId, Date.now());

      updateSyncIndicator('synced', 'Synced');
      await updateBadges();

      return records.length;
    } catch (e) {
      console.error('Full sync failed:', e);
      updateSyncIndicator('error', 'Sync failed');
      return 0;
    } finally {
      this.isSyncing = false;
    }
  },

  // Delta sync - only fetch changed records
  async deltaSync(tableId) {
    if (this.isSyncing) return;
    this.isSyncing = true;
    updateSyncIndicator('syncing', 'Syncing...');

    try {
      const lastSync = await ExperienceEngine.getTableSyncTime(tableId);

      if (!lastSync) {
        // No previous sync - do full
        return this.fullSync(tableId);
      }

      // Fetch records modified since last sync
      const lastSyncDate = new Date(lastSync).toISOString();
      const filterFormula = `LAST_MODIFIED_TIME() > '${lastSyncDate}'`;

      let records = [];
      try {
        records = await Airtable.getAllRecords(tableId, { filterFormula });
      } catch (e) {
        // If LAST_MODIFIED_TIME doesn't exist, fall back to full sync
        console.warn('Delta sync failed, falling back to full sync:', e);
        return this.fullSync(tableId);
      }

      // Store updated records
      for (const record of records) {
        await ExperienceEngine.storeGiven(CONFIG.BASE_ID, tableId, record);
      }

      await ExperienceEngine.setTableSyncTime(tableId, Date.now());

      updateSyncIndicator('synced', `Synced (${records.length} updated)`);
      await updateBadges();

      return records.length;
    } finally {
      this.isSyncing = false;
    }
  },

  // Push local changes to server
  async flushQueue() {
    const queue = await ExperienceEngine.getQueue();
    if (queue.length === 0) return;

    updateSyncIndicator('syncing', 'Pushing changes...');

    let success = 0;
    let failed = 0;

    for (const item of queue) {
      try {
        if (item.operation === 'create') {
          const newRecord = await Airtable.createRecord(item.tableId, item.fields);

          // Update local record with real ID
          const oldId = ExperienceEngine._recordId(item.baseId, item.tableId, item.recordId);
          const oldRecord = await ExperienceEngine.getRecord(oldId);

          if (oldRecord) {
            // Delete temp record
            await ExperienceEngine._delete('records', oldId);

            // Store with real ID
            await ExperienceEngine.storeGiven(item.baseId, item.tableId, newRecord);
          }

        } else if (item.operation === 'update') {
          await Airtable.updateRecord(item.tableId, item.recordId, item.fields);

          // Update local record status
          const id = ExperienceEngine._recordId(item.baseId, item.tableId, item.recordId);
          const record = await ExperienceEngine.getRecord(id);
          if (record) {
            record._status = 'synced';
            record._meant = { fields: {}, modifiedAt: null };
            await ExperienceEngine._put('records', record);
          }
        }

        await ExperienceEngine.removeFromQueue(item.id);
        success++;

      } catch (e) {
        console.error('Queue item failed:', e);
        failed++;
      }
    }

    updateSyncIndicator('synced', `Pushed ${success} changes`);
    await updateBadges();

    return { success, failed };
  }
};

// ============================================================
// LIVE SYNC MANAGER (Real-time via n8n relay)
// ============================================================
const LiveSync = {
  isEnabled: false,
  pollInterval: null,
  lastCheck: 0,

  async start() {
    if (this.isEnabled || !CONFIG.LIVE_SYNC_URL) return;

    this.isEnabled = true;
    this.lastCheck = Date.now();

    console.log('LiveSync started');
    updateLiveSyncIndicator(true);

    // Start polling
    this.poll();
    this.pollInterval = setInterval(() => this.poll(), CONFIG.LIVE_POLL_INTERVAL);
  },

  stop() {
    this.isEnabled = false;
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }
    console.log('LiveSync stopped');
    updateLiveSyncIndicator(false);
  },

  async poll() {
    if (!this.isEnabled || !CONFIG.LIVE_SYNC_URL) return;

    try {
      const url = `${CONFIG.LIVE_SYNC_URL}?since=${this.lastCheck}`;
      const res = await fetch(url);

      if (!res.ok) {
        console.warn('LiveSync poll failed:', res.status);
        return;
      }

      const data = await res.json();

      if (data.hasChanges) {
        console.log('LiveSync detected changes:', data.changes.length);

        // Update last check time
        this.lastCheck = data.serverTime || Date.now();

        // Trigger delta sync for current table
        if (currentTableId) {
          await SyncManager.deltaSync(currentTableId);

          // Refresh grid - apply view filter if a view is selected
          if (currentViewId) {
            // Fetch view-filtered records from server
            const records = await Airtable.getAllRecords(currentTableId, { view: currentViewId });
            const gridData = records.map(transformRecordForGrid).filter(Boolean);
            if (table) {
              table.replaceData(gridData);
            }
          } else {
            // No view selected - show all cached records
            const records = await ExperienceEngine.getTableRecords(CONFIG.BASE_ID, currentTableId);
            const gridData = records.map(transformRecordForGrid).filter(Boolean);
            if (table) {
              table.replaceData(gridData);
            }
          }
        }

        // Flash indicator
        flashLiveSyncIndicator();
      }

    } catch (e) {
      console.warn('LiveSync poll error:', e);
    }
  },

  toggle() {
    if (this.isEnabled) {
      this.stop();
    } else {
      this.start();
    }
    return this.isEnabled;
  }
};

// ============================================================
// DIRECT POLLING (No n8n required - polls Airtable directly)
// ============================================================
const DirectPoll = {
  isEnabled: false,
  pollInterval: null,

  async start() {
    if (this.isEnabled) return;

    this.isEnabled = true;
    console.log('DirectPoll started');
    updateLiveSyncIndicator(true, 'polling');

    // Poll every 15 seconds
    this.pollInterval = setInterval(() => this.poll(), 15000);
  },

  stop() {
    this.isEnabled = false;
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }
    console.log('DirectPoll stopped');
    updateLiveSyncIndicator(false);
  },

  async poll() {
    if (!this.isEnabled || !currentTableId) return;

    try {
      const updated = await SyncManager.deltaSync(currentTableId);

      if (updated > 0) {
        // Refresh grid - apply view filter if a view is selected
        let gridData;
        if (currentViewId) {
          const records = await Airtable.getAllRecords(currentTableId, { view: currentViewId });
          gridData = records.map(transformRecordForGrid).filter(Boolean);
        } else {
          const records = await ExperienceEngine.getTableRecords(CONFIG.BASE_ID, currentTableId);
          gridData = records.map(transformRecordForGrid).filter(Boolean);
        }
        if (table) {
          table.replaceData(gridData);
        }
        flashLiveSyncIndicator();
      }
    } catch (e) {
      console.warn('DirectPoll error:', e);
    }
  },

  toggle() {
    if (this.isEnabled) {
      this.stop();
    } else {
      this.start();
    }
    return this.isEnabled;
  }
};

// ============================================================
// LIVE SYNC UI HELPERS
// ============================================================
function updateLiveSyncIndicator(active, mode = 'live') {
  const toggle = document.getElementById('live-toggle');
  const text = document.getElementById('live-toggle-text');

  if (active) {
    toggle.classList.add('active');
    text.textContent = mode === 'polling' ? 'Polling' : 'Live';
  } else {
    toggle.classList.remove('active');
    text.textContent = 'Live';
  }
}

function flashLiveSyncIndicator() {
  const toggle = document.getElementById('live-toggle');
  toggle.classList.add('flash');
  setTimeout(() => toggle.classList.remove('flash'), 300);
}

// Live toggle click handler
document.getElementById('live-toggle').addEventListener('click', () => {
  // Use DirectPoll if no LIVE_SYNC_URL configured
  if (CONFIG.LIVE_SYNC_URL) {
    LiveSync.toggle();
  } else {
    DirectPoll.toggle();
  }
});

let schema = null;
let currentTableId = null;
let currentViewId = null;
let currentViewName = null;
let currentFields = [];
let table = null;

// DOM Elements
const loadingEl = document.getElementById('loading');
const loadingTextEl = document.getElementById('loading-text');
const progressBarEl = document.getElementById('progress-bar');
const progressFillEl = document.getElementById('progress-fill');
const navEl = document.getElementById('nav');
const syncIndicatorEl = document.getElementById('sync-indicator');
const syncStatusTextEl = document.getElementById('sync-status-text');
const pendingBadgeEl = document.getElementById('pending-badge');
const conflictBadgeEl = document.getElementById('conflict-badge');

// ============================================================
// UI HELPERS
// ============================================================

function setLoading(show, text = 'Loading...', showProgress = false) {
  loadingEl.classList.toggle('hidden', !show);
  loadingTextEl.textContent = text;
  progressBarEl.style.display = showProgress ? 'block' : 'none';
}

function setProgress(percent) {
  progressFillEl.style.width = `${percent}%`;
}

function updateSyncIndicator(state, text) {
  syncIndicatorEl.className = `sync-indicator ${state}`;
  syncStatusTextEl.textContent = text;
}

async function updateBadges() {
  const stats = await ExperienceEngine.getStats();

  if (stats.pending > 0) {
    pendingBadgeEl.textContent = `${stats.pending} pending`;
    pendingBadgeEl.style.display = 'inline';
  } else {
    pendingBadgeEl.style.display = 'none';
  }

  if (stats.conflicts > 0) {
    conflictBadgeEl.textContent = `${stats.conflicts} conflicts`;
    conflictBadgeEl.style.display = 'inline';
  } else {
    conflictBadgeEl.style.display = 'none';
  }

  // Update sync page stats
  document.getElementById('stat-total').textContent = stats.total;
  document.getElementById('stat-synced').textContent = stats.synced;
  document.getElementById('stat-pending').textContent = stats.pending;
  document.getElementById('stat-conflicts').textContent = stats.conflicts;
}

function showPage(pageName) {
  const connectPage = document.getElementById('page-connect');
  const appLayout = document.getElementById('app-layout');

  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));

  if (pageName === 'connect') {
    connectPage.classList.add('active');
    appLayout.style.display = 'none';
  } else {
    connectPage.classList.remove('active');
    appLayout.style.display = 'flex';
    document.getElementById(`page-${pageName}`).classList.add('active');
    document.querySelector(`.nav-tab[data-page="${pageName}"]`)?.classList.add('active');
  }

  if (pageName === 'sync') {
    renderSyncPage();
  }

  if (pageName === 'test') {
    loadTestPage();
  }
}

function formatTimeAgo(timestamp) {
  if (!timestamp) return 'Never';
  const diff = Date.now() - timestamp;
  const mins = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);

  if (mins < 1) return 'Just now';
  if (mins < 60) return `${mins}m ago`;
  if (hours < 24) return `${hours}h ago`;
  return `${days}d ago`;
}

// Update record count display in header
function updateRecordCount(count, syncInfo = null) {
  const headerCountEl = document.getElementById('header-record-count');
  const sidebarSyncEl = document.getElementById('sidebar-sync-text');

  if (headerCountEl) {
    headerCountEl.textContent = count !== null ? `${count.toLocaleString()} records` : '';
  }

  if (sidebarSyncEl && syncInfo) {
    sidebarSyncEl.textContent = `Synced ${syncInfo}`;
  }
}

// ============================================================
// DATA PAGE
// ============================================================

function transformRecordForGrid(record, fields = currentFields) {
  if (!record) return null;
  if (!fields || !Array.isArray(fields)) fields = [];

  const merged = ExperienceEngine.getMergedFields(record);

  // Note: We use Airtable's computed values for formula/rollup/lookup/count fields
  // rather than recalculating locally. Airtable already provides these values
  // in the API response, and our local FormulaEngine doesn't support all functions.
  // Local formula calculation only happens in cellEdited for optimistic updates.

  return {
    _id: record._id,
    _status: record._status,
    _recordId: record.recordId,
    ...merged
  };
}

// Format a single value (non-array) for display
function formatSingleValue(value) {
  if (value === null || value === undefined) return '';

  // Handle primitive types
  if (typeof value !== 'object') {
    return String(value);
  }

  // Handle Airtable error objects like {error: "#ERROR!"} or {specialValue: "NaN"}
  if (value.error) {
    return `#ERROR`;
  }
  if (value.specialValue) {
    return value.specialValue === 'NaN' ? '' : value.specialValue;
  }

  // Handle linked record objects
  if (value.id && value.name) {
    return value.name;
  }

  // Handle collaborator/user objects
  if (value.email) {
    return value.name || value.email;
  }

  // Handle attachment objects
  if (value.filename || value.url) {
    return value.filename || 'Attachment';
  }

  // Handle barcode objects
  if (value.text !== undefined) {
    return value.text;
  }

  // Handle button objects
  if (value.label) {
    return value.label;
  }

  // Fallback: try common properties, then empty string
  // Avoid JSON.stringify which produces ugly output like {"error":"#ERROR!"}
  return value.name || value.id || '';
}

// Format any value (including arrays) for display
function formatValue(value) {
  if (value === null || value === undefined) return '';

  // Handle string "#ERROR" from FormulaEngine
  if (value === '#ERROR') return '#ERROR';

  // Handle arrays (linked records, attachments, multi-select, etc.)
  if (Array.isArray(value)) {
    if (value.length === 0) return '';
    return value.map(formatSingleValue).filter(v => v !== '').join(', ');
  }

  return formatSingleValue(value);
}

function getEditor(field) {
  if (!field || !field.type) return false;
  const readonlyTypes = ['formula', 'rollup', 'count', 'lookup', 'autoNumber', 'createdTime', 'lastModifiedTime', 'createdBy', 'lastModifiedBy', 'multipleAttachments', 'multipleRecordLinks'];
  if (readonlyTypes.includes(field.type)) return false;

  switch (field.type) {
    case 'singleLineText':
    case 'email':
    case 'url':
    case 'phoneNumber':
      return 'input';
    case 'multilineText':
      return 'textarea';
    case 'number':
    case 'currency':
    case 'percent':
      return 'number';
    case 'date':
    case 'dateTime':
      return 'date';
    case 'checkbox':
      return 'tickCross';
    case 'singleSelect':
    case 'multipleSelects':
      return 'list';
    default:
      return false;
  }
}

function getEditorParams(field) {
  if (!field || !field.options) return {};
  if (field.type === 'singleSelect' && field.options.choices) {
    return { values: field.options.choices.map(c => c?.name || '').filter(Boolean), clearable: true };
  }
  if (field.type === 'multipleSelects' && field.options.choices) {
    return { values: field.options.choices.map(c => c?.name || '').filter(Boolean), multiselect: true };
  }
  return {};
}

// Get type-specific formatter for a field
function getFormatterForField(field) {
  const fieldType = field.type;
  const fieldName = field.name;

  return function(cell) {
    try {
      const rawValue = cell.getValue();

      // Handle null/undefined
      if (rawValue === null || rawValue === undefined) {
        return '';
      }

      // Handle error values from Airtable
      if (typeof rawValue === 'object' && !Array.isArray(rawValue)) {
        if (rawValue.error) {
          return `<span class="cell-error" title="${rawValue.error}">#ERROR</span>`;
        }
        if (rawValue.specialValue) {
          return rawValue.specialValue === 'NaN' ? '' : rawValue.specialValue;
        }
      }

      // Handle FormulaEngine errors
      if (rawValue === '#ERROR') {
        return `<span class="cell-error">#ERROR</span>`;
      }

      // Type-specific formatting
      switch (fieldType) {
        case 'checkbox':
          return rawValue ? '<i class="ph ph-check-square" style="color: var(--success);"></i>' : '<i class="ph ph-square" style="color: var(--text-muted);"></i>';

        case 'number':
        case 'currency':
        case 'percent':
          if (typeof rawValue === 'number') {
            if (fieldType === 'currency') {
              return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(rawValue);
            }
            if (fieldType === 'percent') {
              return `${(rawValue * 100).toFixed(1)}%`;
            }
            return rawValue.toLocaleString();
          }
          return formatValue(rawValue);

        case 'date':
        case 'dateTime':
          if (rawValue) {
            const date = new Date(rawValue);
            if (!isNaN(date.getTime())) {
              return fieldType === 'dateTime'
                ? date.toLocaleString()
                : date.toLocaleDateString();
            }
          }
          return formatValue(rawValue);

        case 'singleSelect':
          if (rawValue) {
            const color = field.options?.choices?.find(c => c.name === rawValue)?.color || 'gray';
            return `<span class="select-tag select-${color}">${rawValue}</span>`;
          }
          return '';

        case 'multipleSelects':
          if (Array.isArray(rawValue) && rawValue.length > 0) {
            return rawValue.map(v => {
              const color = field.options?.choices?.find(c => c.name === v)?.color || 'gray';
              return `<span class="select-tag select-${color}">${v}</span>`;
            }).join(' ');
          }
          return '';

        case 'multipleRecordLinks':
          if (Array.isArray(rawValue)) {
            return rawValue.map(v => formatSingleValue(v)).filter(Boolean).join(', ');
          }
          return formatValue(rawValue);

        case 'multipleAttachments':
          if (Array.isArray(rawValue) && rawValue.length > 0) {
            const count = rawValue.length;
            return `<span class="attachment-indicator"><i class="ph ph-paperclip"></i> ${count} file${count > 1 ? 's' : ''}</span>`;
          }
          return '';

        case 'url':
          if (rawValue) {
            const displayUrl = String(rawValue).replace(/^https?:\/\//, '').substring(0, 40);
            return `<a href="${rawValue}" target="_blank" class="cell-link" onclick="event.stopPropagation()">${displayUrl}${rawValue.length > 40 ? '...' : ''}</a>`;
          }
          return '';

        case 'email':
          if (rawValue) {
            return `<a href="mailto:${rawValue}" class="cell-link" onclick="event.stopPropagation()">${rawValue}</a>`;
          }
          return '';

        case 'phoneNumber':
          if (rawValue) {
            return `<a href="tel:${rawValue}" class="cell-link" onclick="event.stopPropagation()">${rawValue}</a>`;
          }
          return '';

        case 'formula':
        case 'rollup':
        case 'lookup':
        case 'count':
          // Check if locally calculated
          const rowData = cell.getRow().getData();
          const isCalculated = rowData[`_calc_${fieldName}`];
          const displayValue = formatValue(rawValue);

          if (isCalculated) {
            return `<span class="formula-calculated" title="Calculated locally">${displayValue}</span>`;
          }
          return displayValue;

        case 'createdTime':
        case 'lastModifiedTime':
          if (rawValue) {
            const date = new Date(rawValue);
            if (!isNaN(date.getTime())) {
              return `<span class="cell-timestamp">${date.toLocaleString()}</span>`;
            }
          }
          return '';

        case 'createdBy':
        case 'lastModifiedBy':
          if (rawValue && typeof rawValue === 'object') {
            return rawValue.name || rawValue.email || '';
          }
          return formatValue(rawValue);

        default:
          return formatValue(rawValue);
      }
    } catch (e) {
      console.warn('Cell formatter error:', e, fieldName);
      return '';
    }
  };
}

// Get CSS class for a field type
function getCssClassForField(field) {
  const classes = [];
  switch (field.type) {
    case 'formula':
    case 'rollup':
    case 'lookup':
    case 'count':
      classes.push('formula-cell');
      break;
    case 'number':
    case 'currency':
    case 'percent':
      classes.push('number-cell');
      break;
  }
  return classes.join(' ');
}

// Build table columns from field definitions
function buildColumns(fields) {
  return fields.map(field => {
    const isComputedField = ['formula', 'rollup', 'lookup', 'count'].includes(field.type);

    // Determine column width based on field type
    let width = 180;
    switch (field.type) {
      case 'checkbox':
        width = 80;
        break;
      case 'number':
      case 'currency':
      case 'percent':
        width = 120;
        break;
      case 'date':
        width = 120;
        break;
      case 'dateTime':
      case 'createdTime':
      case 'lastModifiedTime':
        width = 180;
        break;
      case 'multilineText':
        width = 250;
        break;
      case 'url':
        width = 220;
        break;
      case 'multipleAttachments':
        width = 120;
        break;
    }

    return {
      title: isComputedField ? `${field.name} Æ’` : field.name,
      field: field.name,
      editor: getEditor(field),
      editorParams: getEditorParams(field),
      formatter: getFormatterForField(field),
      cssClass: getCssClassForField(field),
      width: width,
      minWidth: 80,
      headerTooltip: `${field.name} (${field.type})`,
    };
  });
}

async function loadTable(tableId, viewId = null, viewName = null) {
  if (table) {
    table.destroy();
    table = null;
  }

  // Reset filters, sorts, and hidden fields when switching tables
  activeFilters = [];
  activeSorts = [];
  hiddenFields.clear();
  searchInput.value = '';
  searchContainer.classList.remove('has-value');

  // Reset toolbar button states
  document.getElementById('filter-btn').classList.remove('active');
  document.getElementById('filter-btn').innerHTML = '<i class="ph ph-funnel"></i> Filter';
  document.getElementById('sort-btn').classList.remove('active');
  document.getElementById('sort-btn').innerHTML = '<i class="ph ph-sort-ascending"></i> Sort';
  document.getElementById('hide-fields-btn').classList.remove('active');
  document.getElementById('hide-fields-btn').innerHTML = '<i class="ph ph-eye-slash"></i> Hide fields';
  document.getElementById('group-by').value = '';

  currentTableId = tableId;
  currentViewId = viewId;
  currentViewName = viewName;
  const tableSchema = schema.tables.find(t => t.id === tableId);
  if (!tableSchema) {
    console.error('Table schema not found for tableId:', tableId);
    currentFields = [];
    return;
  }
  currentFields = tableSchema.fields || [];

  // Debug: Log formula fields to verify API returns formula expressions
  const formulaFields = currentFields.filter(f => f.type === 'formula');
  if (formulaFields.length > 0) {
    console.log('Formula fields found:', formulaFields.map(f => ({
      name: f.name,
      formula: f.options?.formula || '(no formula in options)',
      result: f.options?.result?.type
    })));
  }

  // Update left panel counts
  updateTableCounts();

  // Update group-by dropdown
  const groupByEl = document.getElementById('group-by');
  groupByEl.innerHTML = '<option value="">Group by...</option>';
  currentFields.forEach(f => {
    if (['singleSelect', 'singleLineText', 'checkbox'].includes(f.type)) {
      const opt = document.createElement('option');
      opt.value = f.name;
      opt.textContent = f.name;
      groupByEl.appendChild(opt);
    }
  });

  // Build columns first
  const columns = buildColumns(currentFields);

  // Try to load from cache FIRST - never block on network
  let records = [];
  let cacheHit = false;

  try {
    records = await ExperienceEngine.getTableRecords(CONFIG.BASE_ID, tableId);
    cacheHit = records.length > 0;
    console.log(`Cache ${cacheHit ? 'HIT' : 'MISS'}: ${records.length} records for ${tableId}`);
  } catch (e) {
    console.error('Cache read failed:', e);
  }

  // Show whatever we have immediately (even if empty)
  const gridData = records.map(transformRecordForGrid).filter(Boolean);

  table = new Tabulator('#grid', {
    data: gridData,
    columns: columns,
    layout: 'fitDataStretch',  // Columns stretch to fill available width
    height: '100%',
    rowHeight: 36,
    pagination: true,
    paginationSize: 50,
    paginationSizeSelector: [25, 50, 100],
    movableColumns: true,
    resizableColumns: true,
    columnDefaults: {
      minWidth: 80,
      resizable: true,
    },
    placeholder: cacheHit ? 'No records found' : 'Loading from server...',
    groupBy: false,
    groupStartOpen: true,
    groupHeader: (value, count) => `${value || '(empty)'} <span style="color:var(--accent)">(${count})</span>`,

    rowFormatter: (row) => {
      try {
        const data = row.getData();
        const el = row.getElement();
        if (!el) return;
        el.classList.remove('row-pending', 'row-conflict', 'row-new');
        if (data._status === 'pending') el.classList.add('row-pending');
        if (data._status === 'conflict') el.classList.add('row-conflict');
        if (data._status === 'new') el.classList.add('row-new');
      } catch (e) {
        console.warn('Row formatter error:', e);
      }
    },

    cellEdited: async (cell) => {
      const rowData = cell.getRow().getData();
      const fieldName = cell.getField();
      const newValue = cell.getValue();

      try {
        await ExperienceEngine.updateLocal(rowData._id, { [fieldName]: newValue });
        cell.getRow().getElement().classList.add('row-pending');

        // Recalculate dependent formula fields
        const row = cell.getRow();
        const currentData = { ...row.getData(), [fieldName]: newValue };

        for (const field of currentFields) {
          if (field.type === 'formula' && field.options?.formula) {
            // Check if this formula depends on the edited field
            const formulaStr = field.options.formula;
            if (formulaStr.includes(`{${fieldName}}`)) {
              const calculated = FormulaEngine.evaluate(formulaStr, currentData, currentFields);
              if (calculated !== null && calculated !== undefined) {
                currentData[field.name] = calculated;
                currentData[`_calc_${field.name}`] = true;
              }
            }
          }
        }

        // Update the row with recalculated values
        row.update(currentData);
        await updateBadges();
      } catch (e) {
        console.error('Edit failed:', e);
        cell.restoreOldValue();
      }
    }
  });

  // Update status with cache info
  const syncTime = await ExperienceEngine.getTableSyncTime(tableId);

  if (cacheHit && !viewId) {
    // Cache hit with no specific view - show all cached records
    document.getElementById('table-status').textContent =
      `${gridData.length} records | Synced ${formatTimeAgo(syncTime)}`;
    updateRecordCount(gridData.length, formatTimeAgo(syncTime));

    // Background delta sync
    syncInBackground(tableId);
  } else if (cacheHit && viewId) {
    // Cache hit with a view selected - show cache immediately, then fetch view-filtered data
    document.getElementById('table-status').textContent =
      `${gridData.length} records | Loading view...`;
    updateRecordCount(gridData.length, 'loading view...');

    // Fetch view-filtered records from server
    syncAndUpdateTable(tableId, viewId);
  } else {
    document.getElementById('table-status').textContent = 'Loading from server...';
    updateRecordCount(null, 'loading...');

    // No cache - need to fetch, but do it async and update table
    syncAndUpdateTable(tableId, viewId);
  }
}

// Background sync - doesn't block UI
async function syncInBackground(tableId) {
  try {
    const count = await SyncManager.deltaSync(tableId);

    // Reload data if we got updates
    if (count > 0 && currentTableId === tableId) {
      const records = await ExperienceEngine.getTableRecords(CONFIG.BASE_ID, tableId);
      const gridData = records.map(transformRecordForGrid).filter(Boolean);
      table.replaceData(gridData);

      const syncTime = await ExperienceEngine.getTableSyncTime(tableId);
      document.getElementById('table-status').textContent =
        `${gridData.length} records | Synced ${formatTimeAgo(syncTime)} (${count} updated)`;
      updateRecordCount(gridData.length, formatTimeAgo(syncTime));
    }
  } catch (e) {
    console.error('Background sync failed:', e);
  }
}

// Initial sync with progress - updates table as data arrives
async function syncAndUpdateTable(tableId, viewId = null) {
  updateSyncIndicator('syncing', 'Downloading...');

  let totalCount = 0;

  try {
    const records = await Airtable.getAllRecords(tableId, {
      view: viewId,
      onProgress: async (count, page, hasMore) => {
        totalCount = count;
        document.getElementById('table-status').textContent =
          `Downloading... ${count} records (page ${page})`;
      }
    });

    // Store all records
    for (const record of records) {
      await ExperienceEngine.storeGiven(CONFIG.BASE_ID, tableId, record);
    }

    await ExperienceEngine.setTableSyncTime(tableId, Date.now());

    // Update table with all data
    if (currentTableId === tableId) {
      const cachedRecords = await ExperienceEngine.getTableRecords(CONFIG.BASE_ID, tableId);
      const gridData = cachedRecords.map(transformRecordForGrid).filter(Boolean);
      table.replaceData(gridData);
      table.options.placeholder = 'No records found';

      document.getElementById('table-status').textContent =
        `${gridData.length} records | Synced just now`;
      updateRecordCount(gridData.length, 'just now');
    }

    updateSyncIndicator('synced', 'Synced');
    await updateBadges();

  } catch (e) {
    console.error('Initial sync failed:', e);
    updateSyncIndicator('error', 'Sync failed');
    document.getElementById('table-status').textContent = 'Failed to load - check connection';
    updateRecordCount(null, 'error');
  }
}

// ============================================================
// SYNC PAGE
// ============================================================

async function renderSyncPage() {
  await updateBadges();

  // Render tables list
  const tablesListEl = document.getElementById('sync-tables-list');
  tablesListEl.innerHTML = '';

  if (!schema) {
    tablesListEl.innerHTML = '<div class="empty-state">Not connected</div>';
    return;
  }

  const stats = await ExperienceEngine.getStats();

  for (const t of schema.tables) {
    const tableKey = `${CONFIG.BASE_ID}:${t.id}`;
    const tableStats = stats.byTable[tableKey] || { total: 0, synced: 0, pending: 0 };
    const syncTime = await ExperienceEngine.getTableSyncTime(t.id);

    const row = document.createElement('div');
    row.className = 'sync-table-row';
    row.innerHTML = `
      <span class="sync-table-name">${t.name}</span>
      <span class="sync-table-stats">
        <span>${tableStats.total} records</span>
        ${tableStats.pending > 0 ? `<span style="color: var(--warning)">${tableStats.pending} pending</span>` : ''}
      </span>
      <span class="sync-table-time">${formatTimeAgo(syncTime)}</span>
      <div class="sync-table-actions">
        <button data-action="delta" data-table="${t.id}">Delta</button>
        <button data-action="full" data-table="${t.id}">Full</button>
      </div>
    `;
    tablesListEl.appendChild(row);
  }

  // Add click handlers
  tablesListEl.querySelectorAll('button[data-action]').forEach(btn => {
    btn.addEventListener('click', async () => {
      const action = btn.dataset.action;
      const tableId = btn.dataset.table;

      setLoading(true, `Syncing ${action}...`);
      try {
        if (action === 'delta') {
          await SyncManager.deltaSync(tableId);
        } else {
          await SyncManager.fullSync(tableId);
        }
        renderSyncPage();
      } finally {
        setLoading(false);
      }
    });
  });

  // Render queue
  const queueListEl = document.getElementById('sync-queue-list');
  const queue = await ExperienceEngine.getQueue();

  if (queue.length === 0) {
    queueListEl.innerHTML = '<div class="empty-state">No pending changes</div>';
  } else {
    queueListEl.innerHTML = queue.map(item => `
      <div class="queue-item">
        <div class="queue-item-header">
          <span class="queue-item-op ${item.operation}">${item.operation}</span>
          <span class="queue-item-record">${item.recordId}</span>
          <span class="queue-item-time">${formatTimeAgo(item.createdAt)}</span>
        </div>
        <div class="queue-item-fields">
          ${Object.keys(item.fields || {}).join(', ')}
        </div>
      </div>
    `).join('');
  }

  // Render conflicts
  const conflictsListEl = document.getElementById('sync-conflicts-list');
  const conflicts = await ExperienceEngine.getConflicts();

  if (conflicts.length === 0) {
    conflictsListEl.innerHTML = '<div class="empty-state">No conflicts</div>';
  } else {
    conflictsListEl.innerHTML = conflicts.map(conflict => `
      <div class="conflict-item" data-conflict-id="${conflict.id}">
        <div class="conflict-item-header">
          <strong>${conflict.recordId}</strong>
          <span class="queue-item-time">${formatTimeAgo(conflict.detectedAt)}</span>
        </div>
        <div class="conflict-versions">
          <div class="conflict-version given">
            <div class="conflict-version-label">Server (Given)</div>
            <div>${JSON.stringify(conflict.given?.fields || {}, null, 2).slice(0, 200)}...</div>
          </div>
          <div class="conflict-version meant">
            <div class="conflict-version-label">Local (Meant)</div>
            <div>${JSON.stringify(conflict.meant?.fields || {}, null, 2).slice(0, 200)}...</div>
          </div>
        </div>
        <div class="conflict-actions">
          <button class="btn-secondary" data-resolve="keep_given">Keep Server</button>
          <button class="btn-primary" data-resolve="keep_meant">Keep Local</button>
        </div>
      </div>
    `).join('');

    // Add conflict resolution handlers
    conflictsListEl.querySelectorAll('button[data-resolve]').forEach(btn => {
      btn.addEventListener('click', async () => {
        const conflictEl = btn.closest('.conflict-item');
        const conflictId = parseInt(conflictEl.dataset.conflictId);
        const resolution = btn.dataset.resolve;

        const conflict = conflicts.find(c => c.id === conflictId);
        if (conflict) {
          const record = await ExperienceEngine.getRecord(conflict.recordId);
          await ExperienceEngine.resolveConflict(conflictId, resolution, record);
          renderSyncPage();
        }
      });
    });
  }
}

// ============================================================
// INITIALIZATION
// ============================================================

// Nav tab clicks
document.querySelectorAll('.nav-tab[data-page]').forEach(tab => {
  tab.addEventListener('click', () => showPage(tab.dataset.page));
});


// ============================================================
// SEARCH - Real-time with debounce
// ============================================================
let searchDebounceTimer = null;
const searchInput = document.getElementById('search');
const searchContainer = document.getElementById('toolbar-search-container');
const searchClearBtn = document.getElementById('search-clear');

function performSearch(term) {
  if (!table) return;

  if (term) {
    searchContainer.classList.add('has-value');
    table.setFilter((data) => {
      return Object.values(data).some(v =>
        v !== null && v !== undefined && String(v).toLowerCase().includes(term)
      );
    });
  } else {
    searchContainer.classList.remove('has-value');
    table.clearFilter();
  }
}

searchInput.addEventListener('input', (e) => {
  clearTimeout(searchDebounceTimer);
  const term = e.target.value.trim().toLowerCase();

  // Debounce: wait 200ms after user stops typing
  searchDebounceTimer = setTimeout(() => {
    performSearch(term);
  }, 200);
});

searchInput.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    searchInput.value = '';
    performSearch('');
    searchInput.blur();
  }
});

searchClearBtn.addEventListener('click', () => {
  searchInput.value = '';
  performSearch('');
  searchInput.focus();
});

// ============================================================
// FILTER FUNCTIONALITY
// ============================================================
let activeFilters = [];

const filterOperators = {
  text: [
    { value: 'contains', label: 'contains' },
    { value: 'not_contains', label: 'does not contain' },
    { value: 'equals', label: 'is' },
    { value: 'not_equals', label: 'is not' },
    { value: 'empty', label: 'is empty' },
    { value: 'not_empty', label: 'is not empty' },
    { value: 'starts_with', label: 'starts with' },
    { value: 'ends_with', label: 'ends with' }
  ],
  number: [
    { value: 'equals', label: '=' },
    { value: 'not_equals', label: '!=' },
    { value: 'greater', label: '>' },
    { value: 'greater_equal', label: '>=' },
    { value: 'less', label: '<' },
    { value: 'less_equal', label: '<=' },
    { value: 'empty', label: 'is empty' },
    { value: 'not_empty', label: 'is not empty' }
  ],
  select: [
    { value: 'equals', label: 'is' },
    { value: 'not_equals', label: 'is not' },
    { value: 'empty', label: 'is empty' },
    { value: 'not_empty', label: 'is not empty' }
  ],
  checkbox: [
    { value: 'checked', label: 'is checked' },
    { value: 'unchecked', label: 'is unchecked' }
  ],
  date: [
    { value: 'equals', label: 'is' },
    { value: 'before', label: 'is before' },
    { value: 'after', label: 'is after' },
    { value: 'empty', label: 'is empty' },
    { value: 'not_empty', label: 'is not empty' }
  ]
};

function getFieldOperatorType(fieldType) {
  if (['number', 'currency', 'percent', 'rating', 'duration'].includes(fieldType)) return 'number';
  if (['singleSelect', 'multipleSelects'].includes(fieldType)) return 'select';
  if (fieldType === 'checkbox') return 'checkbox';
  if (['date', 'dateTime', 'createdTime', 'lastModifiedTime'].includes(fieldType)) return 'date';
  return 'text';
}

function renderFilterConditions() {
  const container = document.getElementById('filter-conditions');
  container.innerHTML = '';

  activeFilters.forEach((filter, index) => {
    const field = currentFields.find(f => f.name === filter.field);
    const opType = field ? getFieldOperatorType(field.type) : 'text';
    const operators = filterOperators[opType];
    const needsValue = !['empty', 'not_empty', 'checked', 'unchecked'].includes(filter.operator);

    const div = document.createElement('div');
    div.className = 'filter-condition';
    div.innerHTML = `
      ${index > 0 ? '<span class="filter-conjunction">AND</span>' : '<span class="filter-conjunction">Where</span>'}
      <select class="filter-field" data-index="${index}">
        <option value="">Select field...</option>
        ${currentFields.map(f => `<option value="${f.name}" ${f.name === filter.field ? 'selected' : ''}>${f.name}</option>`).join('')}
      </select>
      <select class="filter-operator" data-index="${index}">
        ${operators.map(op => `<option value="${op.value}" ${op.value === filter.operator ? 'selected' : ''}>${op.label}</option>`).join('')}
      </select>
      ${needsValue ? `<input type="text" class="filter-value" data-index="${index}" value="${filter.value || ''}" placeholder="Enter value...">` : ''}
      <button class="remove-condition" data-index="${index}"><i class="ph ph-x"></i></button>
    `;
    container.appendChild(div);
  });

  // Add event listeners
  container.querySelectorAll('.filter-field').forEach(select => {
    select.addEventListener('change', (e) => {
      const index = parseInt(e.target.dataset.index);
      const fieldName = e.target.value;
      const field = currentFields.find(f => f.name === fieldName);
      const opType = field ? getFieldOperatorType(field.type) : 'text';
      activeFilters[index].field = fieldName;
      activeFilters[index].operator = filterOperators[opType][0].value;
      activeFilters[index].value = '';
      renderFilterConditions();
    });
  });

  container.querySelectorAll('.filter-operator').forEach(select => {
    select.addEventListener('change', (e) => {
      const index = parseInt(e.target.dataset.index);
      activeFilters[index].operator = e.target.value;
      renderFilterConditions();
    });
  });

  container.querySelectorAll('.filter-value').forEach(input => {
    input.addEventListener('input', (e) => {
      const index = parseInt(e.target.dataset.index);
      activeFilters[index].value = e.target.value;
    });
  });

  container.querySelectorAll('.remove-condition').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const index = parseInt(e.currentTarget.dataset.index);
      activeFilters.splice(index, 1);
      renderFilterConditions();
    });
  });
}

function applyFilters() {
  if (!table) return;

  const validFilters = activeFilters.filter(f => f.field && f.operator);

  if (validFilters.length === 0) {
    table.clearFilter();
    document.getElementById('filter-btn').classList.remove('active');
    document.getElementById('filter-btn').innerHTML = '<i class="ph ph-funnel"></i> Filter';
    return;
  }

  table.setFilter((data) => {
    return validFilters.every(filter => {
      const value = data[filter.field];
      const filterValue = filter.value?.toLowerCase() || '';
      const cellValue = value !== null && value !== undefined ? String(value).toLowerCase() : '';

      switch (filter.operator) {
        case 'contains': return cellValue.includes(filterValue);
        case 'not_contains': return !cellValue.includes(filterValue);
        case 'equals': return cellValue === filterValue;
        case 'not_equals': return cellValue !== filterValue;
        case 'empty': return value === null || value === undefined || value === '';
        case 'not_empty': return value !== null && value !== undefined && value !== '';
        case 'starts_with': return cellValue.startsWith(filterValue);
        case 'ends_with': return cellValue.endsWith(filterValue);
        case 'greater': return parseFloat(value) > parseFloat(filter.value);
        case 'greater_equal': return parseFloat(value) >= parseFloat(filter.value);
        case 'less': return parseFloat(value) < parseFloat(filter.value);
        case 'less_equal': return parseFloat(value) <= parseFloat(filter.value);
        case 'checked': return value === true;
        case 'unchecked': return value !== true;
        case 'before': return new Date(value) < new Date(filter.value);
        case 'after': return new Date(value) > new Date(filter.value);
        default: return true;
      }
    });
  });

  // Update button state
  document.getElementById('filter-btn').classList.add('active');
  document.getElementById('filter-btn').innerHTML = `<i class="ph ph-funnel"></i> Filter <span class="filter-count">${validFilters.length}</span>`;
}

// Filter modal handlers
document.getElementById('filter-btn').addEventListener('click', () => {
  if (activeFilters.length === 0) {
    activeFilters.push({ field: '', operator: 'contains', value: '' });
  }
  renderFilterConditions();
  document.getElementById('filter-modal').classList.remove('hidden');
});

document.getElementById('filter-modal-close').addEventListener('click', () => {
  document.getElementById('filter-modal').classList.add('hidden');
});

document.getElementById('filter-modal').addEventListener('click', (e) => {
  if (e.target.id === 'filter-modal') {
    document.getElementById('filter-modal').classList.add('hidden');
  }
});

document.getElementById('add-filter-condition').addEventListener('click', () => {
  activeFilters.push({ field: '', operator: 'contains', value: '' });
  renderFilterConditions();
});

document.getElementById('filter-clear').addEventListener('click', () => {
  activeFilters = [];
  renderFilterConditions();
  applyFilters();
  document.getElementById('filter-modal').classList.add('hidden');
});

document.getElementById('filter-apply').addEventListener('click', () => {
  applyFilters();
  document.getElementById('filter-modal').classList.add('hidden');
});

// ============================================================
// SORT FUNCTIONALITY
// ============================================================
let activeSorts = [];

function renderSortRules() {
  const container = document.getElementById('sort-rules');
  container.innerHTML = '';

  activeSorts.forEach((sort, index) => {
    const div = document.createElement('div');
    div.className = 'sort-rule';
    div.innerHTML = `
      <span class="sort-label">${index === 0 ? 'Sort by' : 'Then by'}</span>
      <select class="sort-field" data-index="${index}">
        <option value="">Select field...</option>
        ${currentFields.map(f => `<option value="${f.name}" ${f.name === sort.field ? 'selected' : ''}>${f.name}</option>`).join('')}
      </select>
      <select class="sort-direction" data-index="${index}">
        <option value="asc" ${sort.direction === 'asc' ? 'selected' : ''}>A â†’ Z (Ascending)</option>
        <option value="desc" ${sort.direction === 'desc' ? 'selected' : ''}>Z â†’ A (Descending)</option>
      </select>
      <button class="remove-sort" data-index="${index}"><i class="ph ph-x"></i></button>
    `;
    container.appendChild(div);
  });

  // Add event listeners
  container.querySelectorAll('.sort-field').forEach(select => {
    select.addEventListener('change', (e) => {
      const index = parseInt(e.target.dataset.index);
      activeSorts[index].field = e.target.value;
    });
  });

  container.querySelectorAll('.sort-direction').forEach(select => {
    select.addEventListener('change', (e) => {
      const index = parseInt(e.target.dataset.index);
      activeSorts[index].direction = e.target.value;
    });
  });

  container.querySelectorAll('.remove-sort').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const index = parseInt(e.currentTarget.dataset.index);
      activeSorts.splice(index, 1);
      renderSortRules();
    });
  });
}

function applySorts() {
  if (!table) return;

  const validSorts = activeSorts.filter(s => s.field);

  if (validSorts.length === 0) {
    table.clearSort();
    document.getElementById('sort-btn').classList.remove('active');
    document.getElementById('sort-btn').innerHTML = '<i class="ph ph-sort-ascending"></i> Sort';
    return;
  }

  const sorters = validSorts.map(s => ({
    column: s.field,
    dir: s.direction
  }));

  table.setSort(sorters);

  // Update button state
  document.getElementById('sort-btn').classList.add('active');
  document.getElementById('sort-btn').innerHTML = `<i class="ph ph-sort-ascending"></i> Sort <span class="sort-count">${validSorts.length}</span>`;
}

// Sort modal handlers
document.getElementById('sort-btn').addEventListener('click', () => {
  if (activeSorts.length === 0) {
    activeSorts.push({ field: '', direction: 'asc' });
  }
  renderSortRules();
  document.getElementById('sort-modal').classList.remove('hidden');
});

document.getElementById('sort-modal-close').addEventListener('click', () => {
  document.getElementById('sort-modal').classList.add('hidden');
});

document.getElementById('sort-modal').addEventListener('click', (e) => {
  if (e.target.id === 'sort-modal') {
    document.getElementById('sort-modal').classList.add('hidden');
  }
});

document.getElementById('add-sort-rule').addEventListener('click', () => {
  activeSorts.push({ field: '', direction: 'asc' });
  renderSortRules();
});

document.getElementById('sort-clear').addEventListener('click', () => {
  activeSorts = [];
  renderSortRules();
  applySorts();
  document.getElementById('sort-modal').classList.add('hidden');
});

document.getElementById('sort-apply').addEventListener('click', () => {
  applySorts();
  document.getElementById('sort-modal').classList.add('hidden');
});

// ============================================================
// HIDE FIELDS FUNCTIONALITY
// ============================================================
let hiddenFields = new Set();

function renderHideFieldsList() {
  const container = document.getElementById('hide-fields-list');
  container.innerHTML = '';

  currentFields.forEach(field => {
    const isHidden = hiddenFields.has(field.name);
    const div = document.createElement('div');
    div.className = 'hide-field-item';
    div.innerHTML = `
      <input type="checkbox" data-field="${field.name}" ${!isHidden ? 'checked' : ''}>
      <span class="field-name">${field.name}</span>
      <span class="field-type">${field.type}</span>
    `;

    // Make the whole row clickable
    div.addEventListener('click', (e) => {
      if (e.target.tagName !== 'INPUT') {
        const checkbox = div.querySelector('input');
        checkbox.checked = !checkbox.checked;
        updateFieldVisibility(field.name, checkbox.checked);
      }
    });

    div.querySelector('input').addEventListener('change', (e) => {
      updateFieldVisibility(field.name, e.target.checked);
    });

    container.appendChild(div);
  });
}

function updateFieldVisibility(fieldName, isVisible) {
  if (isVisible) {
    hiddenFields.delete(fieldName);
  } else {
    hiddenFields.add(fieldName);
  }
  applyHiddenFields();
}

function applyHiddenFields() {
  if (!table) return;

  currentFields.forEach(field => {
    if (hiddenFields.has(field.name)) {
      table.hideColumn(field.name);
    } else {
      table.showColumn(field.name);
    }
  });

  // Update button state
  if (hiddenFields.size > 0) {
    document.getElementById('hide-fields-btn').classList.add('active');
    document.getElementById('hide-fields-btn').innerHTML = `<i class="ph ph-eye-slash"></i> Hide fields <span class="hidden-count">${hiddenFields.size}</span>`;
  } else {
    document.getElementById('hide-fields-btn').classList.remove('active');
    document.getElementById('hide-fields-btn').innerHTML = '<i class="ph ph-eye-slash"></i> Hide fields';
  }
}

// Hide fields modal handlers
document.getElementById('hide-fields-btn').addEventListener('click', () => {
  renderHideFieldsList();
  document.getElementById('hide-fields-modal').classList.remove('hidden');
});

document.getElementById('hide-fields-modal-close').addEventListener('click', () => {
  document.getElementById('hide-fields-modal').classList.add('hidden');
});

document.getElementById('hide-fields-modal').addEventListener('click', (e) => {
  if (e.target.id === 'hide-fields-modal') {
    document.getElementById('hide-fields-modal').classList.add('hidden');
  }
});

document.getElementById('hide-fields-show-all').addEventListener('click', () => {
  hiddenFields.clear();
  renderHideFieldsList();
  applyHiddenFields();
});

document.getElementById('hide-fields-hide-all').addEventListener('click', () => {
  currentFields.forEach(f => hiddenFields.add(f.name));
  renderHideFieldsList();
  applyHiddenFields();
});

document.getElementById('hide-fields-apply').addEventListener('click', () => {
  document.getElementById('hide-fields-modal').classList.add('hidden');
});

// ============================================================
// DOWNLOAD/EXPORT FUNCTIONALITY
// ============================================================
document.getElementById('download-btn').addEventListener('click', () => {
  if (!table) return;

  const tableName = schema?.tables.find(t => t.id === currentTableId)?.name || 'data';
  const filename = `${tableName}_${new Date().toISOString().split('T')[0]}.csv`;

  // Get visible columns only
  const visibleColumns = currentFields
    .filter(f => !hiddenFields.has(f.name))
    .map(f => f.name);

  table.download('csv', filename, {
    delimiter: ',',
    columns: visibleColumns
  });
});

// Group by
document.getElementById('group-by').addEventListener('change', (e) => {
  if (table) {
    table.setGroupBy(e.target.value || false);
  }
});

// Add row
document.getElementById('add-row-btn').addEventListener('click', () => {
  if (!currentFields.length) return;

  const modalFieldsEl = document.getElementById('modal-fields');
  modalFieldsEl.innerHTML = '';

  const editableFields = currentFields.filter(f =>
    !['formula', 'rollup', 'count', 'lookup', 'autoNumber', 'createdTime', 'lastModifiedTime', 'createdBy', 'lastModifiedBy'].includes(f.type)
  );

  for (const field of editableFields) {
    const div = document.createElement('div');
    div.className = 'form-group';
    div.innerHTML = `<label>${field.name}</label>`;

    let input;
    if (field.type === 'singleSelect' && field.options?.choices) {
      input = document.createElement('select');
      input.innerHTML = '<option value="">Select...</option>' +
        field.options.choices.map(c => `<option value="${c.name}">${c.name}</option>`).join('');
    } else if (field.type === 'multilineText') {
      input = document.createElement('textarea');
      input.rows = 3;
    } else if (field.type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
    } else if (['number', 'currency', 'percent'].includes(field.type)) {
      input = document.createElement('input');
      input.type = 'number';
    } else {
      input = document.createElement('input');
      input.type = 'text';
    }

    input.dataset.field = field.name;
    input.dataset.type = field.type;
    div.appendChild(input);
    modalFieldsEl.appendChild(div);
  }

  document.getElementById('add-modal').classList.remove('hidden');
});

// Modal cancel
document.getElementById('modal-cancel').addEventListener('click', () => {
  document.getElementById('add-modal').classList.add('hidden');
});

// Modal save
document.getElementById('modal-save').addEventListener('click', async () => {
  const inputs = document.querySelectorAll('#modal-fields input, #modal-fields select, #modal-fields textarea');
  const fields = {};

  inputs.forEach(input => {
    const fieldName = input.dataset.field;
    const fieldType = input.dataset.type;
    let value = fieldType === 'checkbox' ? input.checked :
                ['number', 'currency', 'percent'].includes(fieldType) ? (input.value ? parseFloat(input.value) : null) :
                input.value || null;
    if (value !== null && value !== '') fields[fieldName] = value;
  });

  document.getElementById('add-modal').classList.add('hidden');

  try {
    const record = await ExperienceEngine.storeLocal(CONFIG.BASE_ID, currentTableId, fields);
    const gridRow = transformRecordForGrid(record);
    table.addRow(gridRow, true);
    await updateBadges();
  } catch (e) {
    console.error('Create failed:', e);
  }
});

// Modal outside click
document.getElementById('add-modal').addEventListener('click', (e) => {
  if (e.target.id === 'add-modal') {
    e.target.classList.add('hidden');
  }
});

// Flush queue button
document.getElementById('flush-queue-btn').addEventListener('click', async () => {
  setLoading(true, 'Pushing changes...');
  try {
    await SyncManager.flushQueue();
    renderSyncPage();
    if (currentTableId) loadTable(currentTableId);
  } finally {
    setLoading(false);
  }
});

// Delta sync button
document.getElementById('sync-delta-btn').addEventListener('click', async () => {
  if (!schema) return;
  setLoading(true, 'Delta syncing all tables...');
  try {
    for (const t of schema.tables) {
      await SyncManager.deltaSync(t.id);
    }
    renderSyncPage();
  } finally {
    setLoading(false);
  }
});

// Full sync button
document.getElementById('sync-full-btn').addEventListener('click', async () => {
  if (!schema) return;
  if (!confirm('Full sync will re-download all tables. This may take a while. Continue?')) return;

  setLoading(true, 'Full sync...', true);
  try {
    const total = schema.tables.length;
    for (let i = 0; i < total; i++) {
      const t = schema.tables[i];
      setProgress(((i + 0.5) / total) * 100);
      loadingTextEl.textContent = `Syncing ${t.name} (${i + 1}/${total})...`;
      await SyncManager.fullSync(t.id);
    }
    setProgress(100);
    loadingTextEl.textContent = 'Done!';
    await new Promise(r => setTimeout(r, 500));
    renderSyncPage();

    // Reload current table if any
    if (currentTableId) {
      const records = await ExperienceEngine.getTableRecords(CONFIG.BASE_ID, currentTableId);
      const gridData = records.map(transformRecordForGrid).filter(Boolean);
      if (table) table.replaceData(gridData);
    }
  } finally {
    setLoading(false);
  }
});

// Clear cache button
document.getElementById('clear-cache-btn').addEventListener('click', async () => {
  if (!confirm('This will delete ALL cached data. You will need to re-download everything. Continue?')) return;

  setLoading(true, 'Clearing cache...');
  try {
    await ExperienceEngine.clearAll();

    if (table) {
      table.clearData();
    }

    renderSyncPage();
    document.getElementById('table-status').textContent = 'Cache cleared';
    updateSyncIndicator('synced', 'Cache cleared');
  } finally {
    setLoading(false);
  }
});

// Connect
document.getElementById('connect-btn').addEventListener('click', async () => {
  const apiKey = document.getElementById('api-key').value.trim();
  const baseId = document.getElementById('base-id').value.trim();

  if (!apiKey || !baseId) {
    alert('Please enter both API Key and Base ID');
    return;
  }

  CONFIG.API_KEY = apiKey;
  CONFIG.BASE_ID = baseId;

  try {
    await ExperienceEngine.init();

    // Try to load cached schema first
    const cachedSchema = await ExperienceEngine.getMeta(`schema:${baseId}`);

    if (cachedSchema) {
      console.log('Using cached schema');
      schema = cachedSchema;

      // Populate table dropdown
      populateTableDropdown();

      // Show main UI immediately
      localStorage.setItem('airtable_api_key', apiKey);
      localStorage.setItem('airtable_base_id', baseId);
      // Nav bar hidden - functionality exists in header
      showPage('data');
      await updateBadges();

      // Refresh schema in background with view details
      Airtable.getSchema().then(async freshSchema => {
        // Enrich with detailed view info (including sections/folders)
        await enrichSchemaWithViewDetails(freshSchema);
        schema = freshSchema;
        await ExperienceEngine.setMeta(`schema:${baseId}`, freshSchema);
        populateTableDropdown();
      }).catch(e => console.warn('Schema refresh failed:', e));

    } else {
      // No cached schema - must fetch
      setLoading(true, 'Connecting...');

      schema = await Airtable.getSchema();
      // Enrich with detailed view info (including sections/folders)
      await enrichSchemaWithViewDetails(schema);
      await ExperienceEngine.setMeta(`schema:${baseId}`, schema);

      localStorage.setItem('airtable_api_key', apiKey);
      localStorage.setItem('airtable_base_id', baseId);

      populateTableDropdown();

      // Nav bar hidden - functionality exists in header
      showPage('data');
      await updateBadges();

      setLoading(false);
    }

  } catch (e) {
    console.error('Connect failed:', e);
    setLoading(false);
    alert('Failed to connect. Check your API key and Base ID.');
  }
});

function populateLeftPanel() {
  const tablesListEl = document.getElementById('tables-list');
  tablesListEl.innerHTML = '';

  schema.tables.forEach(tableSchema => {
    // Table item container
    const tableContainer = document.createElement('div');
    tableContainer.className = 'left-panel-section';
    tableContainer.dataset.tableId = tableSchema.id;

    // Table row (clickable)
    const tableRow = document.createElement('div');
    tableRow.className = 'table-item';
    tableRow.dataset.tableId = tableSchema.id;

    // Use detailed views if available, otherwise fallback to basic views
    const views = tableSchema.viewsDetailed || tableSchema.views || [];
    const hasViews = views.length > 0;

    // Get appropriate icon based on table name
    const tableIcon = getTableIcon(tableSchema.name);

    tableRow.innerHTML = `
      <span class="table-item-icon">
        <i class="ph ${tableIcon}"></i>
      </span>
      <span class="table-item-name">${tableSchema.name}</span>
      <span class="table-item-count" id="count-${tableSchema.id}">-</span>
      ${hasViews ? '<span class="table-item-expand"><i class="ph ph-caret-right"></i></span>' : ''}
    `;

    // Views list (hidden by default)
    const viewsList = document.createElement('div');
    viewsList.className = 'views-list';
    viewsList.dataset.tableId = tableSchema.id;

    // Organize views by section if section info is available
    const viewsBySection = organizeViewsBySection(views);

    if (viewsBySection.hasSections) {
      // Render views organized by sections/folders
      viewsBySection.sections.forEach(section => {
        // Section header (folder)
        const sectionHeader = document.createElement('div');
        sectionHeader.className = 'view-section-header';
        sectionHeader.innerHTML = `
          <span class="view-section-icon"><i class="ph ph-folder"></i></span>
          <span class="view-section-name">${section.name}</span>
          <span class="view-section-expand"><i class="ph ph-caret-right"></i></span>
        `;

        const sectionViews = document.createElement('div');
        sectionViews.className = 'view-section-views';

        section.views.forEach(view => {
          const viewItem = createViewItem(view, tableSchema.id);
          sectionViews.appendChild(viewItem);
        });

        viewsList.appendChild(sectionHeader);
        viewsList.appendChild(sectionViews);

        // Add click handler for section expand/collapse
        sectionHeader.addEventListener('click', (e) => {
          e.stopPropagation();
          sectionHeader.classList.toggle('expanded');
          sectionViews.classList.toggle('expanded');
        });
      });

      // Render unsectioned views (if any)
      viewsBySection.unsectioned.forEach(view => {
        const viewItem = createViewItem(view, tableSchema.id);
        viewsList.appendChild(viewItem);
      });
    } else {
      // No sections - render flat list
      views.forEach(view => {
        const viewItem = createViewItem(view, tableSchema.id);
        viewsList.appendChild(viewItem);
      });
    }

    tableContainer.appendChild(tableRow);
    if (hasViews) {
      tableContainer.appendChild(viewsList);
    }
    tablesListEl.appendChild(tableContainer);
  });

  // Helper function to create a view item element
  function createViewItem(view, tableId) {
    const viewItem = document.createElement('div');
    viewItem.className = 'view-item';
    viewItem.dataset.tableId = tableId;
    viewItem.dataset.viewId = view.id;
    viewItem.dataset.viewName = view.name;

    const viewIcon = getViewIcon(view.type);
    viewItem.innerHTML = `
      <span class="view-item-icon"><i class="ph ${viewIcon}"></i></span>
      <span class="view-item-name">${view.name}</span>
    `;

    return viewItem;
  }

  // Helper function to organize views by section
  function organizeViewsBySection(views) {
    const sections = new Map();
    const unsectioned = [];
    let hasSections = false;

    views.forEach(view => {
      // Check for section info - Airtable may use 'sectionId' and 'sectionName'
      // or the view might have a 'personalForUserId' for personal views
      const sectionId = view.sectionId || view.viewSectionId;
      const sectionName = view.sectionName || view.viewSectionName;

      if (sectionId && sectionName) {
        hasSections = true;
        if (!sections.has(sectionId)) {
          sections.set(sectionId, { id: sectionId, name: sectionName, views: [] });
        }
        sections.get(sectionId).views.push(view);
      } else if (view.personalForUserId) {
        // Personal view - group under "Personal Views"
        hasSections = true;
        const personalKey = 'personal';
        if (!sections.has(personalKey)) {
          sections.set(personalKey, { id: personalKey, name: 'Personal Views', views: [] });
        }
        sections.get(personalKey).views.push(view);
      } else {
        unsectioned.push(view);
      }
    });

    return {
      hasSections,
      sections: Array.from(sections.values()),
      unsectioned
    };
  }

  // Add click handlers for tables
  tablesListEl.querySelectorAll('.table-item').forEach(item => {
    item.addEventListener('click', async (e) => {
      const tableId = item.dataset.tableId;
      const expandBtn = item.querySelector('.table-item-expand');
      const viewsList = item.nextElementSibling;

      // Toggle views list if clicking on expand button area
      if (e.target.closest('.table-item-expand') && viewsList) {
        expandBtn.classList.toggle('expanded');
        viewsList.classList.toggle('expanded');
        return;
      }

      // Select table
      selectTable(tableId);

      // Expand views if present
      if (expandBtn && viewsList && !viewsList.classList.contains('expanded')) {
        expandBtn.classList.add('expanded');
        viewsList.classList.add('expanded');
      }
    });
  });

  // Add click handlers for views
  tablesListEl.querySelectorAll('.view-item').forEach(item => {
    item.addEventListener('click', (e) => {
      e.stopPropagation();
      const tableId = item.dataset.tableId;
      const viewId = item.dataset.viewId;
      const viewName = item.dataset.viewName;

      selectTable(tableId, viewId, viewName);
    });
  });

  // Update record counts
  updateTableCounts();
}

// Get appropriate icon for table based on name
function getTableIcon(tableName) {
  const name = tableName.toLowerCase();
  if (name.includes('client') || name.includes('user') || name.includes('person') || name.includes('contact')) {
    return 'ph-users';
  } else if (name.includes('event') || name.includes('calendar')) {
    return 'ph-calendar-check';
  } else if (name.includes('deadline') || name.includes('due')) {
    return 'ph-clock-countdown';
  } else if (name.includes('fee') || name.includes('payment') || name.includes('invoice') || name.includes('money')) {
    return 'ph-currency-dollar';
  } else if (name.includes('case') || name.includes('matter')) {
    return 'ph-eye';
  } else if (name.includes('tracker') || name.includes('update')) {
    return 'ph-clipboard-text';
  } else if (name.includes('intake') || name.includes('onboard')) {
    return 'ph-user-plus';
  } else if (name.includes('test') || name.includes('uscis')) {
    return 'ph-identification-card';
  } else if (name.includes('setting') || name.includes('config')) {
    return 'ph-gear';
  } else if (name.includes('sync') || name.includes('status')) {
    return 'ph-arrows-clockwise';
  } else {
    return 'ph-table';
  }
}

function getViewIcon(viewType) {
  switch (viewType) {
    case 'grid':
      return 'ph-table';
    case 'kanban':
      return 'ph-kanban';
    case 'calendar':
      return 'ph-calendar-blank';
    case 'gallery':
      return 'ph-squares-four';
    case 'form':
      return 'ph-note-pencil';
    case 'timeline':
      return 'ph-chart-line';
    default:
      return 'ph-list';
  }
}

async function updateTableCounts() {
  if (!schema) return;

  const stats = await ExperienceEngine.getStats();

  for (const tableSchema of schema.tables) {
    const tableKey = `${CONFIG.BASE_ID}:${tableSchema.id}`;
    const tableStats = stats.byTable[tableKey] || { total: 0 };
    const countEl = document.getElementById(`count-${tableSchema.id}`);
    if (countEl) {
      countEl.textContent = tableStats.total > 0 ? tableStats.total : '-';
    }
  }
}

function selectTable(tableId, viewId = null, viewName = null) {
  // Update active state in left panel
  document.querySelectorAll('.table-item').forEach(item => {
    item.classList.toggle('active', item.dataset.tableId === tableId);
  });

  document.querySelectorAll('.view-item').forEach(item => {
    item.classList.toggle('active', item.dataset.tableId === tableId && item.dataset.viewId === viewId);
  });

  // Update header with table name
  const tableSchema = schema.tables.find(t => t.id === tableId);
  if (tableSchema) {
    const tableNameEl = document.getElementById('current-table-name');
    const headerIconEl = document.querySelector('.header-icon i');
    if (tableNameEl) {
      tableNameEl.textContent = tableSchema.name;
    }
    if (headerIconEl) {
      headerIconEl.className = `ph ${getTableIcon(tableSchema.name)}`;
    }
  }

  // Load table
  loadTable(tableId, viewId, viewName);

  // Make sure we're on the data page
  showPage('data');
}

// Keep backwards compatibility
function populateTableDropdown() {
  populateLeftPanel();
}

// Disconnect function
async function handleDisconnect() {
  if (!confirm('Disconnect? Your cached data will be preserved for next time.')) return;

  CONFIG.API_KEY = '';
  CONFIG.BASE_ID = '';
  localStorage.removeItem('airtable_api_key');
  localStorage.removeItem('airtable_base_id');

  // Don't clear cache - user might reconnect
  // await ExperienceEngine.clearAll();

  if (table) {
    table.destroy();
    table = null;
  }
  schema = null;
  currentTableId = null;
  currentViewId = null;
  currentViewName = null;

  navEl.style.display = 'none';
  document.getElementById('tables-list').innerHTML = '';
  showPage('connect');
}

// Disconnect buttons (nav and sidebar)
document.getElementById('disconnect-btn')?.addEventListener('click', handleDisconnect);
document.getElementById('sidebar-disconnect-btn')?.addEventListener('click', handleDisconnect);

// ============================================================
// TEST PAGE - Isolated Tabulator test
// ============================================================
const TEST_TABLE_ID = 'tblgynOzESGvAXAsK';
let testTable = null;

async function loadTestPage() {
  const gridEl = document.getElementById('test-grid');
  const debugEl = document.getElementById('test-debug');
  const countEl = document.getElementById('test-record-count');

  debugEl.innerHTML = 'Loading...';
  if (testTable) { testTable.destroy(); testTable = null; }

  // Inject CSS to make ALL column headers visible
  let styleEl = document.getElementById('test-grid-reset-css');
  if (!styleEl) {
    styleEl = document.createElement('style');
    styleEl.id = 'test-grid-reset-css';
    styleEl.textContent = `
      #test-grid-inner .tabulator-col {
        background: #e0e0e0 !important;
        border: 1px solid #333 !important;
        min-width: 150px !important;
      }
      #test-grid-inner .tabulator-col-title {
        color: #000 !important;
        font-weight: bold !important;
        font-size: 14px !important;
      }
      #test-grid-inner .tabulator-cell {
        border: 1px solid #ccc !important;
        min-width: 150px !important;
        background: #fff !important;
      }
    `;
    document.head.appendChild(styleEl);
  }

  // Create fresh container
  gridEl.innerHTML = '<div id="test-grid-inner" style="width:100%;overflow:auto;"></div>';

  // 1. Fetch directly from Airtable
  const res = await fetch(
    `https://api.airtable.com/v0/${CONFIG.BASE_ID}/${TEST_TABLE_ID}?pageSize=10`,
    { headers: { 'Authorization': `Bearer ${CONFIG.API_KEY}` } }
  );
  const json = await res.json();
  const records = json.records || [];

  if (!records.length) {
    debugEl.innerHTML = 'No records found';
    return;
  }

  // 2. Use just 4 fields for simplicity
  const fieldNames = Object.keys(records[0].fields).slice(0, 4);

  // 3. Simple data - just strings
  const data = records.map(rec => {
    const row = { id: rec.id };
    fieldNames.forEach(name => {
      let val = rec.fields[name] ?? '';
      if (typeof val !== 'string') val = JSON.stringify(val);
      row[name] = val;
    });
    return row;
  });

  // 4. Explicit columns with widths
  const columns = fieldNames.map(name => ({
    title: name,
    field: name,
    width: 200,
    minWidth: 100,
  }));

  debugEl.innerHTML = `Columns: ${columns.map(c => c.field).join(', ')}<br>Data[0]: ${JSON.stringify(data[0])}`;
  countEl.textContent = `${data.length} records`;

  // 5. Create Tabulator on fresh inner div
  testTable = new Tabulator('#test-grid-inner', {
    data: data,
    columns: columns,
  });

  // Debug: inspect DOM after render
  setTimeout(() => {
    const cols = document.querySelectorAll('#test-grid-inner .tabulator-col');
    const cells = document.querySelectorAll('#test-grid-inner .tabulator-row:first-child .tabulator-cell');
    debugEl.innerHTML += `<br>DOM: ${cols.length} cols, ${cells.length} cells in first row`;

    // Log column widths
    cols.forEach((col, i) => {
      const rect = col.getBoundingClientRect();
      debugEl.innerHTML += `<br>Col ${i}: ${rect.width}px wide`;
    });
  }, 500);
}

// Test page refresh button
document.getElementById('test-refresh-btn')?.addEventListener('click', loadTestPage);

// Test page sidebar navigation
document.getElementById('nav-test-page')?.addEventListener('click', () => {
  // Remove active from all table items
  document.querySelectorAll('.table-item').forEach(item => item.classList.remove('active'));
  // Add active to test page link
  document.getElementById('nav-test-page')?.classList.add('active');
  showPage('test');
});

// Auto-connect
async function init() {
  try {
    const savedApiKey = localStorage.getItem('airtable_api_key');
    const savedBaseId = localStorage.getItem('airtable_base_id');

    if (savedApiKey && savedBaseId) {
      document.getElementById('api-key').value = savedApiKey;
      document.getElementById('base-id').value = savedBaseId;
      document.getElementById('connect-btn').click();
    }
  } catch (e) {
    console.error('Auto-connect failed:', e);
  }
}

// Online/offline handlers
window.addEventListener('online', () => {
  updateSyncIndicator('synced', 'Online');
  SyncManager.flushQueue();
});

window.addEventListener('offline', () => {
  updateSyncIndicator('offline', 'Offline');
});

// Visibility change - delta sync when tab becomes visible
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && currentTableId && navigator.onLine) {
    SyncManager.deltaSync(currentTableId);
  }
});

init();
</script>

</body>
</html>
