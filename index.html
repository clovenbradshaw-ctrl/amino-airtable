<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DB Viewer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #0d1117; color: #e6edf3; display: flex; height: 100vh; }
        .sidebar { width: 220px; background: #161b22; border-right: 1px solid #30363d; overflow-y: auto; }
        .sidebar div { padding: 10px 15px; cursor: pointer; font-size: 13px; border-bottom: 1px solid #30363d; }
        .sidebar div:hover { background: #21262d; }
        .sidebar div.active { background: #1f6feb; }
        .sidebar div.table-header { font-weight: bold; background: #21262d; }
        .sidebar div.view-item { padding-left: 25px; font-size: 12px; color: #8b949e; }
        .sidebar div.view-item:hover { color: #e6edf3; }
        .main { flex: 1; overflow: auto; padding: 20px; }
        h1 { font-size: 18px; margin-bottom: 10px; }
        #status { color: #8b949e; font-size: 12px; margin-bottom: 15px; }
        .loading { color: #f0883e; }
        .synced { color: #3fb950; }
        table { border-collapse: collapse; font-size: 12px; }
        th, td { border: 1px solid #30363d; padding: 6px 10px; text-align: left; max-width: 500px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        th { background: #21262d; position: sticky; top: 0; }
        tr:hover td { background: #161b22; }

        /* Header controls */
        .header-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .header-row h1 {
            margin-bottom: 0;
            flex: 1;
        }
        .btn-small {
            padding: 4px 10px;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 4px;
            color: #8b949e;
            font-size: 11px;
            cursor: pointer;
        }
        .btn-small:hover {
            background: #30363d;
            color: #e6edf3;
        }

        /* Auth screen */
        #auth-screen {
            position: fixed;
            inset: 0;
            background: #0d1117;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .auth-box {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 30px;
            width: 340px;
        }
        .auth-box h2 {
            font-size: 16px;
            margin-bottom: 20px;
            color: #e6edf3;
        }
        .auth-box input {
            width: 100%;
            padding: 10px 12px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #e6edf3;
            font-size: 14px;
            margin-bottom: 15px;
        }
        .auth-box input:focus {
            outline: none;
            border-color: #1f6feb;
        }
        .auth-box button {
            width: 100%;
            padding: 10px;
            background: #238636;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .auth-box button:hover {
            background: #2ea043;
        }
        .auth-box button:disabled {
            background: #21262d;
            cursor: not-allowed;
        }
        .auth-box button.secondary {
            background: #21262d;
        }
        .auth-box button.secondary:hover {
            background: #30363d;
        }
        .auth-error {
            color: #f85149;
            font-size: 13px;
            margin-bottom: 15px;
            display: none;
        }
        .auth-info {
            color: #8b949e;
            font-size: 12px;
            margin-top: 10px;
            text-align: center;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="auth-screen">
        <div class="auth-box">
            <h2>Amino Viewer</h2>
            <div id="auth-error" class="auth-error"></div>
            <input type="password" id="api-key-input" placeholder="API Key (UUID)" autocomplete="off">
            <input type="text" id="set-filter-input" placeholder="Filter by set (optional)" autocomplete="off">
            <input type="text" id="record-filter-input" placeholder="Filter by recordId (optional)" autocomplete="off">
            <button id="auth-submit">Connect</button>
            <button id="auth-debug" class="secondary" onclick="debugFetch()">Debug Fetch</button>
            <button id="auth-clear" class="secondary hidden">Clear Local Data</button>
            <div id="auth-info" class="auth-info"></div>
        </div>
    </div>

    <div class="sidebar" id="sidebar"></div>
    <div class="main">
        <div class="header-row">
            <h1 id="title">Select a table</h1>
            <button class="btn-small" onclick="manualSync()">↻ Sync</button>
            <button class="btn-small" onclick="logout()">Logout</button>
        </div>
        <div id="status"></div>
        <table id="table"></table>
    </div>
    <script>
var API = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:nrIL-Oi-/aminostream';
var DB_NAME = 'aminostream';
var DB_VERSION = 1;

var API_KEY = null;
var SET_FILTER = null;
var RECORD_FILTER = null;
var db = null;

// Metadata from event stream
var META_TABLES = {};  // tableId -> { tableName, primaryFieldId, ... }
var META_FIELDS = {};  // tableId -> { fieldId -> { fieldName, fieldType, options, ... } }
var META_VIEWS = {};   // tableId -> { viewId -> { viewName, viewType, ... } }

// Actual data records
var DATA = {};         // tableId -> { recordId -> { field values } }

var currentTable = null;
var currentView = null;
var totalEvents = 0;
var lastEventId = 0;
var pollInterval = null;
var syncStartTime = null;
var syncItemsTotal = 0;

// ============ IndexedDB ============

function openDB() {
    return new Promise((resolve, reject) => {
        var req = indexedDB.open(DB_NAME, DB_VERSION);

        req.onerror = () => reject(req.error);

        req.onsuccess = () => resolve(req.result);

        req.onupgradeneeded = (e) => {
            var db = e.target.result;

            // Store materialized table state: { set, recordId, data }
            if (!db.objectStoreNames.contains('records')) {
                var store = db.createObjectStore('records', { keyPath: ['set', 'recordId'] });
                store.createIndex('by_set', 'set');
            }

            // Store sync metadata
            if (!db.objectStoreNames.contains('meta')) {
                db.createObjectStore('meta', { keyPath: 'key' });
            }
        };
    });
}

function getMeta(key) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('meta', 'readonly');
        var req = tx.objectStore('meta').get(key);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
        req.onerror = () => reject(req.error);
    });
}

function setMeta(key, value) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('meta', 'readwrite');
        tx.objectStore('meta').put({ key, value });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getAllRecords() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('records', 'readonly');
        var req = tx.objectStore('records').getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

function saveRecords(changed) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('records', 'readwrite');
        var store = tx.objectStore('records');

        for (var r of changed) {
            // Create a unique key based on type
            var key, record;

            if (r.type === 'table') {
                key = ['_meta_table', r.tableId];
                record = { set: '_meta_table', recordId: r.tableId, data: r.data, recType: 'table' };
            } else if (r.type === 'field') {
                key = ['_meta_field:' + r.tableId, r.fieldId];
                record = { set: '_meta_field:' + r.tableId, recordId: r.fieldId, data: r.data, recType: 'field', tableId: r.tableId };
            } else if (r.type === 'view') {
                key = ['_meta_view:' + r.tableId, r.viewId];
                record = { set: '_meta_view:' + r.tableId, recordId: r.viewId, data: r.data, recType: 'view', tableId: r.tableId };
            } else {
                // data record
                key = ['data:' + r.tableId, r.recordId];
                record = { set: 'data:' + r.tableId, recordId: r.recordId, data: r.data, recType: 'data', tableId: r.tableId };
            }

            store.put(record);
        }

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function deleteRecord(set, recordId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('records', 'readwrite');
        tx.objectStore('records').delete([set, recordId]);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function clearAllData() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction(['records', 'meta'], 'readwrite');
        tx.objectStore('records').clear();
        tx.objectStore('meta').clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getLocalStats() {
    return new Promise(async (resolve) => {
        try {
            var tempDb = await openDB();
            var records = await new Promise((res, rej) => {
                var tx = tempDb.transaction('records', 'readonly');
                var req = tx.objectStore('records').count();
                req.onsuccess = () => res(req.result);
                req.onerror = () => rej(req.error);
            });
            var lastId = await new Promise((res, rej) => {
                var tx = tempDb.transaction('meta', 'readonly');
                var req = tx.objectStore('meta').get('lastEventId');
                req.onsuccess = () => res(req.result ? req.result.value : 0);
                req.onerror = () => rej(req.error);
            });
            tempDb.close();
            resolve({ records, lastId });
        } catch (e) {
            resolve({ records: 0, lastId: 0 });
        }
    });
}

// ============ Auth ============

document.getElementById('auth-submit').onclick = tryAuth;
document.getElementById('api-key-input').onkeydown = function(e) {
    if (e.key === 'Enter') tryAuth();
};
document.getElementById('set-filter-input').onkeydown = function(e) {
    if (e.key === 'Enter') tryAuth();
};
document.getElementById('record-filter-input').onkeydown = function(e) {
    if (e.key === 'Enter') tryAuth();
};
document.getElementById('auth-clear').onclick = clearLocalAndReset;

async function initAuthScreen() {
    var stats = await getLocalStats();
    var infoEl = document.getElementById('auth-info');
    var clearBtn = document.getElementById('auth-clear');

    if (stats.records > 0) {
        infoEl.textContent = 'Local: ' + stats.records + ' records, synced to event #' + stats.lastId;
        clearBtn.classList.remove('hidden');
    } else {
        infoEl.textContent = 'No local data — full sync required';
        clearBtn.classList.add('hidden');
    }
}

async function clearLocalAndReset() {
    if (!confirm('Clear all local data? Next connect will do a full sync.')) return;
    try {
        db = await openDB();
        await clearAllData();
        db.close();
        db = null;
    } catch (e) {
        console.error('Clear error:', e);
    }
    initAuthScreen();
}

async function tryAuth() {
    var key = document.getElementById('api-key-input').value.trim();
    if (!key) {
        showAuthError('Please enter an API key');
        return;
    }

    var btn = document.getElementById('auth-submit');
    btn.textContent = 'Connecting...';
    btn.disabled = true;
    document.getElementById('auth-error').style.display = 'none';

    API_KEY = key;
    SET_FILTER = document.getElementById('set-filter-input').value.trim() || null;
    RECORD_FILTER = document.getElementById('record-filter-input').value.trim() || null;

    try {
        await init();
    } catch (err) {
        console.error('Init error:', err);
    }

    btn.textContent = 'Connect';
    btn.disabled = false;
}

function showAuthError(msg) {
    var el = document.getElementById('auth-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function hideAuthScreen() {
    document.getElementById('auth-screen').classList.add('hidden');
}

function showAuthScreen() {
    document.getElementById('auth-screen').classList.remove('hidden');
    if (pollInterval) clearInterval(pollInterval);
    document.getElementById('auth-submit').textContent = 'Connect';
    document.getElementById('auth-submit').disabled = false;
    initAuthScreen();
}

function logout() {
    if (pollInterval) clearInterval(pollInterval);
    API_KEY = null;
    SET_FILTER = null;
    RECORD_FILTER = null;
    showAuthScreen();
}

async function manualSync() {
    if (!API_KEY) return;
    await incrementalSync();
}

// ============ Data Processing ============

function parsePayload(payload) {
    if (typeof payload === 'string') {
        try { payload = JSON.parse(payload); } catch { return null; }
    }
    return payload;
}

function processEvents(events) {
    if (!events || !Array.isArray(events)) return [];

    var changed = [];
    var debugged = false;

    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (!e) continue;

        var setName = e.set;
        var recordId = e.recordId;

        if (!setName || !recordId || recordId === '') continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;  // 'table', 'field', 'view', or human-readable name

        // Debug first few events
        if (!debugged && (recordType === 'table' || recordType === 'field' || recordType === 'view')) {
            console.log('=== META EVENT ===', recordType);
            console.log('set:', setName, 'recordId:', recordId);
            console.log('payload:', payload);
            debugged = true;
        }

        if (recordType === 'table') {
            // TABLE definition - lives in airtable:{baseId}, recordId is tableId
            var tableId = recordId;
            if (!META_TABLES[tableId]) META_TABLES[tableId] = {};

            applyPayloadFields(META_TABLES[tableId], payload);

            // Also store direct payload fields
            META_TABLES[tableId].tableId = payload.tableId || tableId;
            META_TABLES[tableId].tableName = payload.tableName;
            META_TABLES[tableId].primaryFieldId = payload.primaryFieldId;

            changed.push({ type: 'table', tableId, data: META_TABLES[tableId] });

        } else if (recordType === 'field') {
            // FIELD definition - lives in airtable:{tableId}, recordId is fieldId
            var tableId = setName.replace('airtable:', '');
            var fieldId = recordId;

            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            if (!META_FIELDS[tableId][fieldId]) META_FIELDS[tableId][fieldId] = {};

            applyPayloadFields(META_FIELDS[tableId][fieldId], payload);

            // Also store direct payload fields
            META_FIELDS[tableId][fieldId].fieldId = payload.fieldId || fieldId;
            META_FIELDS[tableId][fieldId].fieldName = payload.fieldName;
            META_FIELDS[tableId][fieldId].fieldType = payload.fieldType;
            META_FIELDS[tableId][fieldId].options = payload.options;

            changed.push({ type: 'field', tableId, fieldId, data: META_FIELDS[tableId][fieldId] });

        } else if (recordType === 'view') {
            // VIEW definition - lives in airtable:{tableId}, recordId is viewId
            var tableId = setName.replace('airtable:', '');
            var viewId = recordId;

            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) META_VIEWS[tableId][viewId] = {};

            applyPayloadFields(META_VIEWS[tableId][viewId], payload);

            // Also store direct payload fields
            META_VIEWS[tableId][viewId].viewId = payload.viewId || viewId;
            META_VIEWS[tableId][viewId].viewName = payload.viewName;
            META_VIEWS[tableId][viewId].viewType = payload.viewType;
            META_VIEWS[tableId][viewId].tableId = payload.tableId;
            META_VIEWS[tableId][viewId].tableName = payload.tableName;

            changed.push({ type: 'view', tableId, viewId, data: META_VIEWS[tableId][viewId] });

        } else {
            // DATA record - lives in airtable:{tableId}
            // recordType here is the human-readable table name like "Client Info"
            var tableId = setName.replace('airtable:', '');

            var fields = payload.fields;
            if (!fields || typeof fields !== 'object') {
                console.log('=== DATA RECORD SKIPPED (no fields) ===');
                console.log('set:', setName, 'recordId:', recordId);
                console.log('payload keys:', Object.keys(payload));
                continue;
            }

            if (!DATA[tableId]) DATA[tableId] = {};
            if (!DATA[tableId][recordId]) DATA[tableId][recordId] = {};

            var state = DATA[tableId][recordId];

            if (fields.INS && typeof fields.INS === 'object') {
                for (var key in fields.INS) {
                    state[key] = fields.INS[key];
                }
            }

            if (fields.ALT && typeof fields.ALT === 'object') {
                for (var key in fields.ALT) {
                    state[key] = fields.ALT[key];
                }
            }

            if (fields.NUL && Array.isArray(fields.NUL)) {
                for (var j = 0; j < fields.NUL.length; j++) {
                    delete state[fields.NUL[j]];
                }
            }

            changed.push({ type: 'data', tableId, recordId, data: state });
        }

        if (e.id && e.id > lastEventId) {
            lastEventId = e.id;
        }
    }

    totalEvents += events.length;
    return changed;
}

// Helper to apply INS/ALT/NUL from payload.fields if present
function applyPayloadFields(target, payload) {
    if (!payload.fields) return;
    var fields = payload.fields;

    if (fields.INS && typeof fields.INS === 'object') {
        for (var key in fields.INS) {
            target[key] = fields.INS[key];
        }
    }
    if (fields.ALT && typeof fields.ALT === 'object') {
        for (var key in fields.ALT) {
            target[key] = fields.ALT[key];
        }
    }
    if (fields.NUL && Array.isArray(fields.NUL)) {
        for (var j = 0; j < fields.NUL.length; j++) {
            delete target[fields.NUL[j]];
        }
    }
}

function loadFromLocal(records) {
    for (var r of records) {
        var recType = r.recType;

        if (recType === 'table') {
            META_TABLES[r.recordId] = r.data;
        } else if (recType === 'field') {
            var tableId = r.tableId;
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][r.recordId] = r.data;
        } else if (recType === 'view') {
            var tableId = r.tableId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][r.recordId] = r.data;
        } else if (recType === 'data') {
            var tableId = r.tableId;
            if (!DATA[tableId]) DATA[tableId] = {};
            DATA[tableId][r.recordId] = r.data;
        } else {
            // Legacy format fallback
            if (r.isView) {
                var tableId = r.set.replace('airtable:', '');
                if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
                META_VIEWS[tableId][r.recordId] = r.data;
            } else {
                var tableId = r.set.replace('airtable:', '');
                if (!DATA[tableId]) DATA[tableId] = {};
                DATA[tableId][r.recordId] = r.data;
            }
        }
    }
}

// ============ UI ============

function renderSidebar() {
    var sidebar = document.getElementById('sidebar');
    sidebar.innerHTML = '';

    // Get all tables - from META_TABLES or inferred from DATA/META_FIELDS/META_VIEWS
    var allTableIds = new Set([
        ...Object.keys(META_TABLES),
        ...Object.keys(DATA),
        ...Object.keys(META_FIELDS),
        ...Object.keys(META_VIEWS)
    ]);
    var tableIds = Array.from(allTableIds).sort();

    for (var i = 0; i < tableIds.length; i++) {
        var tableId = tableIds[i];
        var tableMeta = META_TABLES[tableId] || {};
        var tableName = tableMeta.tableName || tableId;
        var recordCount = DATA[tableId] ? Object.keys(DATA[tableId]).length : 0;
        var views = META_VIEWS[tableId] || {};
        var viewIds = Object.keys(views);

        // Table header
        var tableDiv = document.createElement('div');
        tableDiv.className = 'table-header' + (tableId === currentTable && !currentView ? ' active' : '');
        tableDiv.textContent = tableName + ' (' + recordCount + ')';
        tableDiv.onclick = (function(t) {
            return function() { showTable(t, null); };
        })(tableId);
        sidebar.appendChild(tableDiv);

        // Views under this table
        for (var j = 0; j < viewIds.length; j++) {
            var viewId = viewIds[j];
            var view = views[viewId];
            var viewDiv = document.createElement('div');
            viewDiv.className = 'view-item' + (tableId === currentTable && viewId === currentView ? ' active' : '');
            viewDiv.textContent = '↳ ' + (view.viewName || viewId);
            viewDiv.onclick = (function(t, v) {
                return function() { showTable(t, v); };
            })(tableId, viewId);
            sidebar.appendChild(viewDiv);
        }
    }

    return tableIds;
}

function updateStatus(msg, synced) {
    var recordCount = 0;
    for (var t in DATA) recordCount += Object.keys(DATA[t]).length;

    var tableCount = Object.keys(META_TABLES).length || Object.keys(DATA).length;
    var base = tableCount + ' tables, ' + recordCount + ' records';
    if (synced) {
        base = '<span class="synced">●</span> ' + base + ' — synced to #' + lastEventId;
    }
    if (msg) {
        base = '<span class="loading">' + msg + '</span> ' + base;
    }
    document.getElementById('status').innerHTML = base;
}

function formatDuration(ms) {
    var secs = Math.floor(ms / 1000);
    if (secs < 60) return secs + 's';
    var mins = Math.floor(secs / 60);
    secs = secs % 60;
    return mins + 'm ' + secs + 's';
}

function updateSyncProgress(page, eventsLoaded) {
    var recordCount = 0;
    for (var t in DATA) recordCount += Object.keys(DATA[t]).length;

    var elapsed = Date.now() - syncStartTime;
    var rate = eventsLoaded > 0 ? Math.round(eventsLoaded / (elapsed / 1000)) : 0;

    var status = '<span class="loading">Syncing...</span> ';
    if (syncItemsTotal > 0) {
        var pct = Math.round(eventsLoaded / syncItemsTotal * 100);
        status += pct + '% · ';
    }
    status += 'Page ' + page + ' · ';
    status += eventsLoaded.toLocaleString();
    if (syncItemsTotal > 0) {
        status += ' / ' + syncItemsTotal.toLocaleString();
    }
    status += ' events · ';
    status += recordCount.toLocaleString() + ' records · ';
    status += rate.toLocaleString() + ' evt/s · ';
    status += formatDuration(elapsed);

    document.getElementById('status').innerHTML = status;
}

function showTable(tableId, viewId) {
    currentTable = tableId;
    currentView = viewId;

    var tableMeta = META_TABLES[tableId] || {};
    var tableName = tableMeta.tableName || tableId;
    var title = tableName;

    if (viewId && META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        title += ' → ' + META_VIEWS[tableId][viewId].viewName;
    }

    document.getElementById('title').textContent = title;

    // Update sidebar active states
    renderSidebar();

    var records = DATA[tableId] || {};
    var rids = Object.keys(records);

    // Get columns from field definitions if available
    var fields = META_FIELDS[tableId] || {};
    var fieldIds = Object.keys(fields);

    // Build column list: use field definitions for names, fall back to discovering from data
    var colList = [];
    var colNames = {};  // fieldId/key -> display name

    if (fieldIds.length > 0) {
        // Use field definitions
        for (var i = 0; i < fieldIds.length; i++) {
            var fieldId = fieldIds[i];
            var field = fields[fieldId];
            colList.push(fieldId);
            colNames[fieldId] = field.fieldName || fieldId;
        }
    } else {
        // Discover columns from data
        var colSet = {};
        for (var i = 0; i < rids.length; i++) {
            var keys = Object.keys(records[rids[i]]);
            for (var j = 0; j < keys.length; j++) {
                colSet[keys[j]] = true;
            }
        }
        colList = Object.keys(colSet).sort();
        for (var i = 0; i < colList.length; i++) {
            colNames[colList[i]] = colList[i];
        }
    }

    // Build table
    var html = '<tr><th>recordId</th>';
    for (var i = 0; i < colList.length; i++) {
        html += '<th title="' + esc(colList[i]) + '">' + esc(colNames[colList[i]]) + '</th>';
    }
    html += '</tr>';

    for (var i = 0; i < rids.length; i++) {
        var rid = rids[i];
        var row = records[rid];
        html += '<tr><td>' + esc(rid) + '</td>';
        for (var j = 0; j < colList.length; j++) {
            var colKey = colList[j];
            // Data might be keyed by fieldId or fieldName, try both
            var value = row[colKey];
            if (value === undefined && colNames[colKey]) {
                value = row[colNames[colKey]];
            }
            html += '<td>' + fmt(value) + '</td>';
        }
        html += '</tr>';
    }

    if (rids.length === 0) {
        html += '<tr><td colspan="' + (colList.length + 1) + '" style="color:#8b949e;text-align:center;">No records</td></tr>';
    }

    document.getElementById('table').innerHTML = html;
}

// ============ API ============

async function fetchPage(page, afterId) {
    var url = API + '?page=' + page + '&per_page=500';
    if (API_KEY) {
        url += '&apiKey=' + encodeURIComponent(API_KEY);
    }
    if (afterId) {
        url += '&id=' + afterId;
    }
    if (SET_FILTER) {
        url += '&set=' + encodeURIComponent(SET_FILTER);
    }
    if (RECORD_FILTER) {
        url += '&recordId=' + encodeURIComponent(RECORD_FILTER);
    }
    console.log('Fetching page', page, afterId ? '(after id #' + afterId + ')' : '');

    var res = await fetch(url);

    console.log('Response status:', res.status);

    if (res.status === 401 || res.status === 403) {
        throw new Error('AUTH');
    }

    var text = await res.text();
    console.log('Response length:', text.length, 'chars');

    if (!text || text.length === 0) {
        throw new Error('Empty response from server');
    }

    var data;
    try {
        data = JSON.parse(text);
    } catch (e) {
        console.error('JSON parse failed:', text.slice(0, 500));
        throw new Error('Invalid JSON: ' + e.message);
    }

    if (!res.ok) {
        throw new Error(data.message || data.error || 'HTTP ' + res.status);
    }

    if (data && data.error) {
        throw new Error(data.error);
    }

    // Handle both array and paginated response formats
    var events = Array.isArray(data) ? data : (data.items || data.data || []);
    var hasMore = Array.isArray(data) ? events.length >= 500 : !!data.nextPage;
    var nextPage = Array.isArray(data) ? page + 1 : data.nextPage;

    console.log('Got', events.length, 'events, hasMore:', hasMore);

    return { events, hasMore, nextPage };
}

async function fullSync() {
    syncStartTime = Date.now();
    var eventsLoaded = 0;
    var page = 1;

    while (true) {
        updateSyncProgress(page, eventsLoaded);

        var result = await fetchPage(page, null);
        var events = result.events;

        if (!events || events.length === 0) break;

        eventsLoaded += events.length;

        // Sort by id ascending
        events.sort((a, b) => (a.id || 0) - (b.id || 0));

        var changed = processEvents(events);
        if (changed.length > 0) {
            await saveRecords(changed);
        }

        renderSidebar();
        if (currentTable) showTable(currentTable, currentView);

        updateSyncProgress(page, eventsLoaded);

        if (!result.hasMore) break;
        page = result.nextPage || page + 1;

        if (page > 500) break; // Safety limit
    }

    await setMeta('lastEventId', lastEventId);

    var elapsed = formatDuration(Date.now() - syncStartTime);
    console.log('Full sync complete:', eventsLoaded, 'events in', elapsed);
}

async function incrementalSync() {
    try {
        updateStatus('Checking for updates... ', true);

        // Fetch events where id > lastEventId
        var result = await fetchPage(1, lastEventId);
        var events = result.events;

        if (events && events.length > 0) {
            events.sort((a, b) => (a.id || 0) - (b.id || 0));

            var changed = processEvents(events);
            if (changed.length > 0) {
                await saveRecords(changed);
                await setMeta('lastEventId', lastEventId);

                renderSidebar();
                if (currentTable) showTable(currentTable, currentView);

                console.log('Synced', events.length, 'new events, now at id #' + lastEventId);
            }

            // Fetch more pages if available
            while (result.hasMore) {
                result = await fetchPage(result.nextPage, lastEventId);
                events = result.events;
                if (events && events.length > 0) {
                    events.sort((a, b) => (a.id || 0) - (b.id || 0));
                    changed = processEvents(events);
                    if (changed.length > 0) {
                        await saveRecords(changed);
                        await setMeta('lastEventId', lastEventId);
                        renderSidebar();
                        if (currentTable) showTable(currentTable, currentView);
                    }
                }
            }
        }

        updateStatus(null, true);
    } catch (err) {
        console.error('Sync error:', err);
        updateStatus('Sync error: ' + err.message, false);
    }
}

// ============ Init ============

async function init() {
    META_TABLES = {};
    META_FIELDS = {};
    META_VIEWS = {};
    DATA = {};
    currentTable = null;
    currentView = null;
    totalEvents = 0;
    lastEventId = 0;
    syncItemsTotal = 0;
    document.getElementById('sidebar').innerHTML = '';
    document.getElementById('table').innerHTML = '';
    document.getElementById('title').textContent = 'Select a table';

    try {
        db = await openDB();

        // Load local state
        var localRecords = await getAllRecords();
        var storedLastId = await getMeta('lastEventId');

        if (localRecords.length > 0) {
            updateStatus('Loading from cache... ', false);
            loadFromLocal(localRecords);
            lastEventId = storedLastId || 0;

            var names = renderSidebar();
            if (names.length > 0) showTable(names[0], null);

            hideAuthScreen();

            // Incremental sync
            await incrementalSync();
        } else {
            // First load — do full sync
            hideAuthScreen();
            await fullSync();
        }

        updateStatus(null, true);

        // Start polling
        if (pollInterval) clearInterval(pollInterval);
        pollInterval = setInterval(incrementalSync, 60000);

    } catch (err) {
        console.error('Init error:', err);
        showAuthScreen();
        showAuthError('Error: ' + err.message);
    }
}

function esc(s) {
    if (s == null) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function fmt(v) {
    if (v == null) return '<span style="color:#6e7681">—</span>';
    if (typeof v === 'object') return esc(JSON.stringify(v).slice(0,200));
    return esc(String(v));
}

// Show auth screen on load
initAuthScreen();

// Debug: test specific recordIds
var DEBUG_RECORDS = [
    'rec00ORjAj01dmUyW',
    'rec00TJLBT06tDdn4',
    'rec00VYwwhAwgX6cO',
    'rec00ydJe0zXIL8Kd',
    'rec01F5KmIcbKfnlv',
    'rec01gXPN7CkqjBQO',
    'rec028b2iBjFqDMvZ',
    'rec02fFCwBn3Qr1Ut',
    'rec02gBtgOTB6dS0B',
    'rec02jHerKlqdxVMO',
    'rec02zqECdi0QAcDd',
    'rec039Y5fw0GJYNsv',
    'rec03G8q4tTQ9Ztnp'
];

async function debugFetch() {
    API_KEY = document.getElementById('api-key-input').value.trim() || null;
    SET_FILTER = document.getElementById('set-filter-input').value.trim() || null;
    RECORD_FILTER = document.getElementById('record-filter-input').value.trim() || null;

    console.log('=== DEBUG FETCH ===');
    console.log('API:', API);
    console.log('API Key:', API_KEY ? API_KEY.slice(0,8) + '...' : '(none)');
    console.log('Set filter:', SET_FILTER || '(none)');
    console.log('RecordId filter:', RECORD_FILTER || '(none)');

    try {
        var url = API + '?page=1&per_page=10';
        if (API_KEY) {
            url += '&apiKey=' + encodeURIComponent(API_KEY);
        }
        if (SET_FILTER) {
            url += '&set=' + encodeURIComponent(SET_FILTER);
        }
        if (RECORD_FILTER) {
            url += '&recordId=' + encodeURIComponent(RECORD_FILTER);
        }
        console.log('Fetching:', url.replace(API_KEY || '', '***'));

        var res = await fetch(url);
        console.log('Status:', res.status);

        var text = await res.text();
        console.log('Response length:', text.length, 'chars');
        console.log('Raw response:', text.slice(0, 2000));

        var data;
        try {
            data = JSON.parse(text);
        } catch (e) {
            console.error('JSON parse error:', e);
            return;
        }

        console.log('Response type:', Array.isArray(data) ? 'array' : 'object');
        console.log('Keys:', Object.keys(data));

        var events = Array.isArray(data) ? data : (data.items || data.data || []);
        console.log('Events count:', events.length);

        if (events.length > 0) {
            console.log('First event:', events[0]);
            console.log('Last event:', events[events.length - 1]);
        }

        // Look for debug records
        var found = events.filter(e => DEBUG_RECORDS.includes(e.recordId));
        console.log('Found debug records:', found.length);
        if (found.length > 0) {
            console.log('Found:', found);
        }

    } catch (err) {
        console.error('Debug fetch error:', err);
    }
}

// Run debug on load after a short delay
// Or call debugFetch() from console
console.log('Call debugFetch() to test API');
    </script>
</body>
</html>
