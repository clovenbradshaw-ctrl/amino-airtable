<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Amino — Rooms Sanity Check</title>
<style>
    :root {
        --bg: #0d1117;
        --surface: #161b22;
        --surface2: #1c2128;
        --border: #30363d;
        --text: #e6edf3;
        --text-muted: #8b949e;
        --accent: #58a6ff;
        --green: #3fb950;
        --yellow: #d29922;
        --red: #f85149;
        --purple: #bc8cff;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
        font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
        background: var(--bg);
        color: var(--text);
        padding: 24px;
        line-height: 1.5;
    }
    h1 { font-size: 20px; margin-bottom: 4px; }
    h2 { font-size: 16px; color: var(--accent); margin: 20px 0 10px; }
    h3 { font-size: 14px; color: var(--purple); margin: 12px 0 6px; }
    .subtitle { color: var(--text-muted); font-size: 12px; margin-bottom: 20px; }
    .panel {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
    }
    label { display: block; font-size: 12px; color: var(--text-muted); margin-bottom: 4px; }
    input[type="text"], input[type="password"] {
        width: 100%;
        background: var(--surface2);
        border: 1px solid var(--border);
        border-radius: 4px;
        padding: 8px 10px;
        color: var(--text);
        font-family: inherit;
        font-size: 13px;
        margin-bottom: 10px;
    }
    input:focus { outline: none; border-color: var(--accent); }
    button {
        background: var(--accent);
        color: var(--bg);
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        font-family: inherit;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
    }
    button:hover { opacity: 0.9; }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    button.secondary {
        background: var(--surface2);
        color: var(--text);
        border: 1px solid var(--border);
    }
    .btn-row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .status {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 11px;
        font-weight: 600;
    }
    .status-ok { background: rgba(63, 185, 80, 0.15); color: var(--green); }
    .status-warn { background: rgba(210, 153, 34, 0.15); color: var(--yellow); }
    .status-err { background: rgba(248, 81, 73, 0.15); color: var(--red); }
    .status-info { background: rgba(88, 166, 255, 0.15); color: var(--accent); }
    table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
        margin-top: 8px;
    }
    th {
        text-align: left;
        padding: 6px 10px;
        border-bottom: 1px solid var(--border);
        color: var(--text-muted);
        font-weight: 600;
        white-space: nowrap;
    }
    td {
        padding: 6px 10px;
        border-bottom: 1px solid var(--border);
        max-width: 300px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    tr:hover td { background: var(--surface2); }
    .mono { font-family: inherit; font-size: 11px; color: var(--text-muted); }
    .room-card {
        background: var(--surface2);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 10px;
    }
    .room-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }
    .room-card-title { font-weight: 600; font-size: 13px; }
    .room-card-id { font-size: 11px; color: var(--text-muted); }
    .room-card-stats {
        display: flex;
        gap: 16px;
        font-size: 12px;
        color: var(--text-muted);
        flex-wrap: wrap;
    }
    .room-card-stats span strong { color: var(--text); }
    .collapsible { cursor: pointer; user-select: none; }
    .collapsible::before { content: '\25B6 '; font-size: 10px; }
    .collapsible.open::before { content: '\25BC '; }
    .collapse-content { display: none; margin-top: 8px; }
    .collapse-content.show { display: block; }
    pre.json {
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 4px;
        padding: 10px;
        font-size: 11px;
        overflow-x: auto;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-break: break-all;
    }
    .log-area {
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 4px;
        padding: 10px;
        font-size: 11px;
        max-height: 200px;
        overflow-y: auto;
    }
    .log-line { margin-bottom: 2px; }
    .log-line.info { color: var(--accent); }
    .log-line.ok { color: var(--green); }
    .log-line.warn { color: var(--yellow); }
    .log-line.err { color: var(--red); }
    .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: 10px;
        margin-top: 10px;
    }
    .summary-card {
        background: var(--surface2);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 12px;
        text-align: center;
    }
    .summary-card .number {
        font-size: 28px;
        font-weight: 700;
        color: var(--accent);
    }
    .summary-card .label {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: 2px;
    }
    #results { display: none; }
    .spinner {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid var(--border);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 0.6s linear infinite;
        vertical-align: middle;
        margin-right: 6px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .hidden { display: none !important; }
    .tab-bar { display: flex; gap: 4px; margin-bottom: 12px; flex-wrap: wrap; }
    .tab {
        padding: 6px 14px;
        font-size: 12px;
        font-family: inherit;
        border: 1px solid var(--border);
        border-radius: 4px;
        background: var(--surface);
        color: var(--text-muted);
        cursor: pointer;
    }
    .tab.active {
        background: var(--accent);
        color: var(--bg);
        border-color: var(--accent);
        font-weight: 600;
    }
</style>
</head>
<body>

<h1>Rooms Sanity Check</h1>
<p class="subtitle">Inspect Matrix rooms, table mappings, and locally stored data for the Amino system.</p>

<!-- Login Panel -->
<div class="panel" id="login-panel">
    <h2>Connect</h2>
    <label for="hs-url">Homeserver URL</label>
    <input type="text" id="hs-url" value="https://app.aminoimmigration.com" placeholder="https://matrix.example.com">
    <label for="username">Username</label>
    <input type="text" id="username" placeholder="admin">
    <label for="password">Password</label>
    <input type="password" id="password" placeholder="Matrix login password">
    <label for="enc-password">Encryption Password <span class="mono">(local unlock password — leave blank to try session key)</span></label>
    <input type="password" id="enc-password" placeholder="Local encryption password (if different from Matrix password)">
    <div class="btn-row">
        <button id="btn-login" onclick="doLogin()">Login &amp; Run Check</button>
        <button class="secondary" id="btn-restore" onclick="doRestore()">Restore Session</button>
    </div>
    <div class="log-area" id="login-log" style="margin-top: 10px;"></div>
</div>

<!-- Results -->
<div id="results">
    <div class="panel" id="session-info"></div>

    <!-- Tabs -->
    <div class="tab-bar">
        <div class="tab active" onclick="showTab('overview')">Overview</div>
        <div class="tab" onclick="showTab('rooms')">All Rooms</div>
        <div class="tab" onclick="showTab('table-rooms')">Table Rooms</div>
        <div class="tab" onclick="showTab('data')">Stored Data</div>
    </div>

    <!-- Overview Tab -->
    <div id="tab-overview" class="tab-content">
        <div class="panel">
            <h2>Summary</h2>
            <div class="summary-grid" id="summary-grid"></div>
        </div>
        <div class="panel">
            <h2>Table-Room Mapping</h2>
            <p class="subtitle" style="margin-bottom: 8px;">Derived from <code>law.firm.vault.metadata</code> state events in each room.</p>
            <div id="table-room-map"></div>
        </div>
    </div>

    <!-- All Rooms Tab -->
    <div id="tab-rooms" class="tab-content hidden">
        <div class="panel">
            <h2>Joined Rooms</h2>
            <div id="rooms-list"></div>
        </div>
    </div>

    <!-- Table Rooms Tab -->
    <div id="tab-table-rooms" class="tab-content hidden">
        <div class="panel">
            <h2>Table Rooms Detail</h2>
            <p class="subtitle" style="margin-bottom: 12px;">Rooms mapped to Airtable tables with state and recent timeline events.</p>
            <div id="table-rooms-detail"></div>
        </div>
    </div>

    <!-- Stored Data Tab -->
    <div id="tab-data" class="tab-content hidden">
        <div class="panel">
            <h2>IndexedDB Records</h2>
            <p class="subtitle" style="margin-bottom: 12px;">Records stored locally in the <code>amino</code> database (v8 schema).</p>
            <div id="idb-data"></div>
        </div>
    </div>
</div>

<!-- Only load matrix.js — we access IndexedDB directly -->
<script src="matrix.js"></script>

<script>
(function() {
    'use strict';

    // ============ Constants ============
    var DB_NAME = 'amino';
    var ENCRYPTION_CONFIG_KEY = 'amino_encryption_config';
    var SESSION_KEY_STORAGE = 'amino_session_key';

    // ============ State ============
    var _db = null;           // IndexedDB handle
    var _encKey = null;       // CryptoKey for decrypting stored data
    var _encEnabled = false;  // Whether data in IDB is encrypted

    // ============ Logging ============
    var logEl = null;
    function log(msg, level) {
        level = level || 'info';
        if (!logEl) logEl = document.getElementById('login-log');
        var line = document.createElement('div');
        line.className = 'log-line ' + level;
        line.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg;
        logEl.appendChild(line);
        logEl.scrollTop = logEl.scrollHeight;
    }

    // ============ Crypto Helpers (match main app) ============

    function arrayBufferToBase64(buffer) {
        var bytes = new Uint8Array(buffer);
        var binary = '';
        for (var i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
    }

    function base64ToArrayBuffer(base64) {
        var binary = atob(base64);
        var bytes = new Uint8Array(binary.length);
        for (var i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        return bytes;
    }

    async function deriveKeyFromPassword(password, salt) {
        var enc = new TextEncoder();
        var keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveBits', 'deriveKey']);
        return crypto.subtle.deriveKey(
            { name: 'PBKDF2', salt: salt, iterations: 100000, hash: 'SHA-256' },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    }

    async function decryptData(encryptedBase64, key) {
        var combined = base64ToArrayBuffer(encryptedBase64);
        var iv = combined.slice(0, 12);
        var encryptedData = combined.slice(12);
        var decryptedBuffer = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, key, encryptedData);
        return JSON.parse(new TextDecoder().decode(decryptedBuffer));
    }

    // Try to load session key from sessionStorage (survives refresh within same tab)
    async function loadSessionKey() {
        var stored = sessionStorage.getItem(SESSION_KEY_STORAGE);
        if (!stored) return null;
        try {
            var raw = base64ToArrayBuffer(stored);
            return await crypto.subtle.importKey('raw', raw, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
        } catch (e) { return null; }
    }

    // Initialize encryption: try session key, then password-derived key
    async function initEncryption(encPassword) {
        var config = null;
        try {
            var cfgStr = localStorage.getItem(ENCRYPTION_CONFIG_KEY);
            if (cfgStr) config = JSON.parse(cfgStr);
        } catch (e) {}

        if (!config) {
            log('No encryption config found in localStorage — data may be unencrypted.', 'warn');
            _encEnabled = false;
            return;
        }

        // Try session key first (fastest — no password needed)
        var sessionKey = await loadSessionKey();
        if (sessionKey) {
            try {
                await decryptData(config.verificationToken, sessionKey);
                _encKey = sessionKey;
                _encEnabled = true;
                log('Encryption key restored from session.', 'ok');
                return;
            } catch (e) {
                log('Session key did not verify — trying password.', 'warn');
            }
        }

        // Derive from password
        if (!encPassword) {
            log('No encryption password provided and no valid session key. Data will show as encrypted blobs.', 'warn');
            _encEnabled = false;
            return;
        }

        try {
            var salt = base64ToArrayBuffer(config.salt);
            _encKey = await deriveKeyFromPassword(encPassword, salt);
            // Verify
            await decryptData(config.verificationToken, _encKey);
            _encEnabled = true;
            log('Encryption key derived from password.', 'ok');
        } catch (e) {
            log('Encryption password did not verify: ' + e.message, 'err');
            _encEnabled = false;
            _encKey = null;
        }
    }

    // Decrypt a stored data record (has _encryptedFields instead of fields)
    async function decryptRecord(record) {
        if (!record) return record;
        if (!record._encryptedFields) return record; // not encrypted
        if (!_encEnabled || !_encKey) return record;  // can't decrypt
        try {
            var decrypted = Object.assign({}, record);
            decrypted.fields = await decryptData(record._encryptedFields, _encKey);
            delete decrypted._encryptedFields;
            return decrypted;
        } catch (e) {
            return record; // return as-is
        }
    }

    // Decrypt a stored event (has _encryptedPayload instead of payload)
    async function decryptEvent(event) {
        if (!event) return event;
        if (!event._encryptedPayload) return event;
        if (!_encEnabled || !_encKey) return event;
        try {
            var decrypted = Object.assign({}, event);
            decrypted.payload = await decryptData(event._encryptedPayload, _encKey);
            delete decrypted._encryptedPayload;
            return decrypted;
        } catch (e) {
            return event;
        }
    }

    // ============ IndexedDB Helpers ============

    function openDB() {
        return new Promise(function(resolve, reject) {
            // Open WITHOUT specifying version — opens whatever version exists
            var req = indexedDB.open(DB_NAME);
            req.onsuccess = function() { resolve(req.result); };
            req.onerror = function() { reject(req.error); };
            // If onupgradeneeded fires it means the DB doesn't exist yet — that's fine
            req.onupgradeneeded = function(e) {
                // Don't create stores — just let it open at version 1 empty
            };
        });
    }

    function idbGetAll(store) {
        return new Promise(function(resolve, reject) {
            var req = store.getAll();
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });
    }

    function idbGetAllFromIndex(store, indexName, query) {
        return new Promise(function(resolve, reject) {
            var index = store.index(indexName);
            var req = query !== undefined ? index.getAll(query) : index.getAll();
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });
    }

    function idbCount(store) {
        return new Promise(function(resolve, reject) {
            var req = store.count();
            req.onsuccess = function() { resolve(req.result); };
            req.onerror = function() { reject(req.error); };
        });
    }

    function hasStore(db, name) {
        return db.objectStoreNames.contains(name);
    }

    // ============ Tab Navigation ============
    window.showTab = function(tabName) {
        document.querySelectorAll('.tab-content').forEach(function(el) { el.classList.add('hidden'); });
        document.querySelectorAll('.tab').forEach(function(el) { el.classList.remove('active'); });
        document.getElementById('tab-' + tabName).classList.remove('hidden');
        var tabs = document.querySelectorAll('.tab');
        var tabNames = ['overview', 'rooms', 'table-rooms', 'data'];
        for (var i = 0; i < tabNames.length; i++) {
            if (tabNames[i] === tabName) tabs[i].classList.add('active');
        }
    };

    // ============ Collapsible Sections ============
    window.toggleCollapse = function(id) {
        var el = document.getElementById(id);
        var trigger = el.previousElementSibling;
        el.classList.toggle('show');
        trigger.classList.toggle('open');
    };

    // ============ Login ============
    window.doLogin = async function() {
        var hsUrl = document.getElementById('hs-url').value.trim().replace(/\/$/, '');
        var username = document.getElementById('username').value.trim();
        var password = document.getElementById('password').value;

        if (!hsUrl || !username || !password) {
            log('Homeserver URL, username, and password are required.', 'err');
            return;
        }

        var btn = document.getElementById('btn-login');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span>Connecting...';

        try {
            log('Logging into Matrix at ' + hsUrl + '...');
            var session = await MatrixClient.login(hsUrl, username, password);
            log('Logged in as ' + session.userId, 'ok');

            log('Running initial sync to populate room cache...');
            await MatrixClient.initialSync();
            log('Sync complete. Joined rooms: ' + MatrixClient.getJoinedRooms().length, 'ok');

            await prepareAndRun();
        } catch (err) {
            log('Error: ' + err.message, 'err');
            console.error(err);
        } finally {
            btn.disabled = false;
            btn.textContent = 'Login & Run Check';
        }
    };

    window.doRestore = async function() {
        var btn = document.getElementById('btn-restore');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span>Restoring...';

        try {
            var restored = MatrixClient.restoreSession();
            if (!restored) {
                log('No saved Matrix session found. Please log in.', 'warn');
                return;
            }
            log('Session restored for ' + MatrixClient.getUserId(), 'ok');

            log('Running initial sync...');
            await MatrixClient.initialSync();
            log('Sync complete. Joined rooms: ' + MatrixClient.getJoinedRooms().length, 'ok');

            await prepareAndRun();
        } catch (err) {
            log('Error: ' + err.message, 'err');
            console.error(err);
        } finally {
            btn.disabled = false;
            btn.textContent = 'Restore Session';
        }
    };

    async function prepareAndRun() {
        // Open IndexedDB
        log('Opening IndexedDB "amino"...');
        try {
            _db = await openDB();
            var storeNames = Array.from(_db.objectStoreNames);
            log('DB v' + _db.version + ' opened. Stores: ' + storeNames.join(', '), 'ok');
        } catch (e) {
            log('Could not open IndexedDB: ' + e.message + ' — continuing without local data.', 'warn');
            _db = null;
        }

        // Init encryption
        var encPassword = document.getElementById('enc-password').value || document.getElementById('password').value;
        await initEncryption(encPassword);

        log('Running sanity check...');
        await runSanityCheck();
    }

    // ============ Sanity Check ============
    async function runSanityCheck() {
        document.getElementById('results').style.display = 'block';

        var userId = MatrixClient.getUserId();
        var hsUrl = MatrixClient.getHomeserverUrl();
        var joinedRoomIds = MatrixClient.getJoinedRooms();

        // ---- Session Info ----
        document.getElementById('session-info').innerHTML =
            '<strong>Session:</strong> ' + esc(userId) +
            ' &nbsp; <span class="status status-ok">Connected</span>' +
            ' &nbsp; <span class="mono">' + esc(hsUrl) + '</span>' +
            (_db ? ' &nbsp; <span class="status status-info">IDB v' + _db.version + '</span>' : ' &nbsp; <span class="status status-warn">No IDB</span>') +
            (_encEnabled ? ' &nbsp; <span class="status status-ok">Decryption OK</span>' : ' &nbsp; <span class="status status-warn">No Decryption</span>');

        // ---- Build table-room map from IDB tables store ----
        var tableRoomMap = {};  // tableId -> roomId
        var roomTableMap = {};  // roomId -> tableId
        var tablesFromIDB = [];

        if (_db && hasStore(_db, 'tables')) {
            try {
                var tx = _db.transaction('tables', 'readonly');
                tablesFromIDB = await idbGetAll(tx.objectStore('tables'));
                log('Found ' + tablesFromIDB.length + ' tables in IDB.', 'ok');
            } catch (e) {
                log('Could not read tables store: ' + e.message, 'warn');
            }
        }

        // Also probe rooms for vault.metadata state to build the mapping
        log('Probing rooms for vault.metadata state events...');
        var vaultRooms = [];
        for (var vi = 0; vi < joinedRoomIds.length; vi++) {
            var rId = joinedRoomIds[vi];
            if (MatrixClient.isSpace(rId)) continue;
            var vaultMeta = MatrixClient.getCachedStateEvent(rId, 'law.firm.vault.metadata', '');
            if (vaultMeta && vaultMeta.content && vaultMeta.content.airtable_table_id) {
                var tableId = vaultMeta.content.airtable_table_id;
                tableRoomMap[tableId] = rId;
                roomTableMap[rId] = tableId;
                vaultRooms.push({
                    roomId: rId,
                    tableId: tableId,
                    tableName: vaultMeta.content.table_name || tableId,
                    meta: vaultMeta.content
                });
            }
        }

        // Supplement from IDB tables that have matrix_room_id
        for (var ti = 0; ti < tablesFromIDB.length; ti++) {
            var tbl = tablesFromIDB[ti];
            var tId = tbl.tableId || tbl.table_id;
            var tRoom = tbl.matrixRoomId || tbl.matrix_room_id;
            if (tId && tRoom && !tableRoomMap[tId]) {
                tableRoomMap[tId] = tRoom;
                roomTableMap[tRoom] = tId;
            }
        }
        log('Table-room mappings: ' + Object.keys(tableRoomMap).length, 'ok');

        // ---- Classify rooms ----
        var spaces = [];
        var tableRooms = [];
        var otherRooms = [];

        for (var i = 0; i < joinedRoomIds.length; i++) {
            var rid = joinedRoomIds[i];
            var rName = MatrixClient.getRoomName(rid);
            var isSp = MatrixClient.isSpace(rid);
            var mappedTable = roomTableMap[rid] || null;
            var mappedTableName = null;

            // Try to get table name from vault rooms or IDB
            if (mappedTable) {
                for (var vr = 0; vr < vaultRooms.length; vr++) {
                    if (vaultRooms[vr].tableId === mappedTable) {
                        mappedTableName = vaultRooms[vr].tableName;
                        break;
                    }
                }
                if (!mappedTableName) {
                    for (var ti2 = 0; ti2 < tablesFromIDB.length; ti2++) {
                        var t = tablesFromIDB[ti2];
                        if ((t.tableId || t.table_id) === mappedTable) {
                            mappedTableName = t.tableName || t.table_name || mappedTable;
                            break;
                        }
                    }
                }
            }

            var info = {
                roomId: rid,
                name: rName,
                isSpace: isSp,
                mappedTableId: mappedTable,
                mappedTableName: mappedTableName
            };

            if (isSp) spaces.push(info);
            else if (mappedTable) tableRooms.push(info);
            else otherRooms.push(info);
        }

        // ---- IDB store counts ----
        var storeCounts = {};
        if (_db) {
            var storeNames = ['data', 'tables', 'fields', 'views', 'events', 'snapshot', 'fieldHistory'];
            for (var si = 0; si < storeNames.length; si++) {
                var sn = storeNames[si];
                if (hasStore(_db, sn)) {
                    try {
                        var ctx = _db.transaction(sn, 'readonly');
                        storeCounts[sn] = await idbCount(ctx.objectStore(sn));
                    } catch (e) { storeCounts[sn] = '?'; }
                }
            }
        }

        // ---- Summary Grid ----
        var summaryHtml = '';
        summaryHtml += summaryCard(joinedRoomIds.length, 'Total Rooms');
        summaryHtml += summaryCard(spaces.length, 'Spaces');
        summaryHtml += summaryCard(tableRooms.length, 'Table Rooms');
        summaryHtml += summaryCard(otherRooms.length, 'Other Rooms');
        summaryHtml += summaryCard(Object.keys(tableRoomMap).length, 'Table Mappings');
        if (storeCounts.data !== undefined) summaryHtml += summaryCard(storeCounts.data, 'IDB Data Records');
        if (storeCounts.events !== undefined) summaryHtml += summaryCard(storeCounts.events, 'IDB Events');
        if (storeCounts.fields !== undefined) summaryHtml += summaryCard(storeCounts.fields, 'IDB Fields');
        if (storeCounts.snapshot !== undefined) summaryHtml += summaryCard(storeCounts.snapshot, 'IDB Snapshots');
        document.getElementById('summary-grid').innerHTML = summaryHtml;

        // ---- Table-Room Mapping ----
        var allTableIds = Object.keys(tableRoomMap);
        // Also include IDB tables that might not have a room
        for (var idbti = 0; idbti < tablesFromIDB.length; idbti++) {
            var idbTid = tablesFromIDB[idbti].tableId || tablesFromIDB[idbti].table_id;
            if (idbTid && allTableIds.indexOf(idbTid) === -1) allTableIds.push(idbTid);
        }

        var mapHtml = '<table><tr><th>Table Name</th><th>Table ID</th><th>Room ID</th><th>Status</th></tr>';
        for (var m = 0; m < allTableIds.length; m++) {
            var mTid = allTableIds[m];
            var mRoomId = tableRoomMap[mTid] || null;
            var mName = mTid;
            // Resolve name
            for (var vr2 = 0; vr2 < vaultRooms.length; vr2++) {
                if (vaultRooms[vr2].tableId === mTid) { mName = vaultRooms[vr2].tableName; break; }
            }
            for (var idbti2 = 0; idbti2 < tablesFromIDB.length; idbti2++) {
                var it = tablesFromIDB[idbti2];
                if ((it.tableId || it.table_id) === mTid) { mName = it.tableName || it.table_name || mName; break; }
            }
            var inJoined = mRoomId ? joinedRoomIds.indexOf(mRoomId) !== -1 : false;
            var statusHtml = '';
            if (!mRoomId) statusHtml = '<span class="status status-err">No Room</span>';
            else if (inJoined) statusHtml = '<span class="status status-ok">Joined</span>';
            else statusHtml = '<span class="status status-warn">Not Joined</span>';

            mapHtml += '<tr><td>' + esc(mName) + '</td>' +
                '<td class="mono">' + esc(mTid) + '</td>' +
                '<td class="mono">' + esc(mRoomId || '—') + '</td>' +
                '<td>' + statusHtml + '</td></tr>';
        }
        mapHtml += '</table>';
        document.getElementById('table-room-map').innerHTML = mapHtml;

        // ---- All Rooms List ----
        var roomsHtml = '';
        var allRooms = spaces.concat(tableRooms).concat(otherRooms);
        for (var r = 0; r < allRooms.length; r++) {
            var rm = allRooms[r];
            var typeLabel = rm.isSpace ? '<span class="status status-info">Space</span>' :
                rm.mappedTableId ? '<span class="status status-ok">Table</span>' :
                '<span class="status status-warn">Other</span>';
            var extra = rm.mappedTableName ? ' &rarr; ' + esc(rm.mappedTableName) : '';
            roomsHtml += '<div class="room-card">' +
                '<div class="room-card-header">' +
                '<span class="room-card-title">' + esc(rm.name) + ' ' + typeLabel + extra + '</span>' +
                '</div>' +
                '<div class="room-card-id">' + esc(rm.roomId) + '</div>' +
                '</div>';
        }
        document.getElementById('rooms-list').innerHTML = roomsHtml || '<p class="mono">No rooms found.</p>';

        // ---- Table Rooms Detail ----
        log('Fetching room data for ' + tableRooms.length + ' table rooms...');
        var detailHtml = '';
        for (var d = 0; d < tableRooms.length; d++) {
            detailHtml += await buildTableRoomDetail(tableRooms[d], d);
        }
        document.getElementById('table-rooms-detail').innerHTML = detailHtml || '<p class="mono">No table rooms found.</p>';
        log('Table room details loaded.', 'ok');

        // ---- IndexedDB Stored Data ----
        log('Reading stored data from IndexedDB...');
        var dataHtml = '';

        if (_db && hasStore(_db, 'data')) {
            // Get unique tableIds from the data store
            var dataTableIds = [];
            try {
                var dtx = _db.transaction('data', 'readonly');
                var allData = await idbGetAll(dtx.objectStore('data'));
                log('Read ' + allData.length + ' records from IDB data store.', 'ok');

                // Group by tableId
                var byTable = {};
                for (var di = 0; di < allData.length; di++) {
                    var rec = allData[di];
                    var tKey = rec.tableId || 'unknown';
                    if (!byTable[tKey]) byTable[tKey] = [];
                    byTable[tKey].push(rec);
                }

                var tableKeys = Object.keys(byTable);
                for (var tk = 0; tk < tableKeys.length; tk++) {
                    var tkId = tableKeys[tk];
                    var recs = byTable[tkId];
                    var tName = tkId;
                    // Resolve name
                    for (var vr3 = 0; vr3 < vaultRooms.length; vr3++) {
                        if (vaultRooms[vr3].tableId === tkId) { tName = vaultRooms[vr3].tableName; break; }
                    }
                    for (var idbti3 = 0; idbti3 < tablesFromIDB.length; idbti3++) {
                        var it2 = tablesFromIDB[idbti3];
                        if ((it2.tableId || it2.table_id) === tkId) { tName = it2.tableName || it2.table_name || tName; break; }
                    }

                    var collapseId = 'idb-' + tk;
                    dataHtml += '<div class="room-card">';
                    dataHtml += '<div class="room-card-header">';
                    dataHtml += '<span class="room-card-title">' + esc(tName) + '</span>';
                    dataHtml += '<span class="status status-info">' + recs.length + ' records</span>';
                    if (recs[0] && recs[0]._encryptedFields) {
                        dataHtml += _encEnabled ?
                            ' <span class="status status-ok">Decryptable</span>' :
                            ' <span class="status status-warn">Encrypted</span>';
                    }
                    dataHtml += '</div>';
                    dataHtml += '<div class="room-card-id">' + esc(tkId) + '</div>';

                    if (recs.length > 0) {
                        dataHtml += '<h3 class="collapsible" onclick="toggleCollapse(\'' + collapseId + '\')">Sample Records (first 5)</h3>';
                        dataHtml += '<div class="collapse-content" id="' + collapseId + '">';
                        var sample = recs.slice(0, 5);
                        for (var sr = 0; sr < sample.length; sr++) {
                            var decRec = await decryptRecord(sample[sr]);
                            dataHtml += '<div style="margin-bottom: 8px;">';
                            dataHtml += '<strong class="mono">' + esc(decRec.recordId || decRec.id || '?') + '</strong>';
                            if (decRec.fields) {
                                dataHtml += '<pre class="json">' + esc(JSON.stringify(decRec.fields, null, 2)) + '</pre>';
                            } else if (decRec._encryptedFields) {
                                dataHtml += '<pre class="json" style="color:var(--yellow);">[Encrypted — provide encryption password to decrypt]</pre>';
                            } else {
                                dataHtml += '<pre class="json">' + esc(JSON.stringify(decRec, null, 2)) + '</pre>';
                            }
                            dataHtml += '</div>';
                        }
                        if (recs.length > 5) {
                            dataHtml += '<p class="mono" style="color:var(--text-muted);">... and ' + (recs.length - 5) + ' more records</p>';
                        }
                        dataHtml += '</div>';
                    }
                    dataHtml += '</div>';
                }
            } catch (e) {
                dataHtml += '<p class="mono" style="color:var(--red);">Error reading data store: ' + esc(e.message) + '</p>';
                log('Error reading data store: ' + e.message, 'err');
            }
        } else if (_db) {
            dataHtml = '<p class="mono">No "data" store found in this database version.</p>';
        } else {
            dataHtml = '<p class="mono">IndexedDB not available.</p>';
        }

        // Also show IDB tables metadata
        if (tablesFromIDB.length > 0) {
            dataHtml += '<h2 style="margin-top: 16px;">IDB Tables Metadata</h2>';
            dataHtml += '<pre class="json">' + esc(JSON.stringify(tablesFromIDB, null, 2)) + '</pre>';
        }

        document.getElementById('idb-data').innerHTML = dataHtml;
        log('Sanity check complete.', 'ok');
    }

    // ---- Build detail card for a single table room ----
    async function buildTableRoomDetail(roomInfo, idx) {
        var html = '<div class="room-card">';
        html += '<div class="room-card-header">';
        html += '<span class="room-card-title">' + esc(roomInfo.name) + '</span>';
        html += '<span class="status status-ok">' + esc(roomInfo.mappedTableName || roomInfo.mappedTableId) + '</span>';
        html += '</div>';
        html += '<div class="room-card-id">' + esc(roomInfo.roomId) + '</div>';

        // Fetch state events for the room
        try {
            var state = await MatrixClient.getRoomState(roomInfo.roomId);

            // Classify state events by type
            var stateByType = {};
            for (var i = 0; i < state.length; i++) {
                var evtType = state[i].type;
                if (!stateByType[evtType]) stateByType[evtType] = [];
                stateByType[evtType].push(state[i]);
            }

            html += '<div class="room-card-stats" style="margin-top: 8px;">';
            html += '<span>State events: <strong>' + state.length + '</strong></span>';
            var types = Object.keys(stateByType);
            for (var t = 0; t < types.length; t++) {
                html += '<span>' + esc(types[t].replace('law.firm.', '')) + ': <strong>' + stateByType[types[t]].length + '</strong></span>';
            }
            html += '</div>';

            var stateCollapseId = 'state-' + idx;
            html += '<h3 class="collapsible" onclick="toggleCollapse(\'' + stateCollapseId + '\')">State Events</h3>';
            html += '<div class="collapse-content" id="' + stateCollapseId + '">';
            html += '<table><tr><th>Type</th><th>State Key</th><th>Content (truncated)</th></tr>';
            for (var s = 0; s < state.length; s++) {
                var evt = state[s];
                var contentStr = JSON.stringify(evt.content);
                if (contentStr.length > 120) contentStr = contentStr.substring(0, 120) + '...';
                html += '<tr><td class="mono">' + esc(evt.type) + '</td>' +
                    '<td class="mono">' + esc(evt.state_key || '—') + '</td>' +
                    '<td class="mono">' + esc(contentStr) + '</td></tr>';
            }
            html += '</table></div>';
        } catch (err) {
            html += '<p class="mono" style="color:var(--yellow); margin-top: 8px;">Could not fetch state: ' + esc(err.message) + '</p>';
        }

        // Fetch recent timeline events (last 20 mutations)
        try {
            var messages = await MatrixClient.getRoomMessages(roomInfo.roomId, {
                dir: 'b',
                limit: 20,
                filter: { types: ['law.firm.record.mutate', 'law.firm.schema.object'] }
            });

            var chunk = (messages && messages.chunk) || [];
            var timelineCollapseId = 'timeline-' + idx;
            html += '<h3 class="collapsible" onclick="toggleCollapse(\'' + timelineCollapseId + '\')">Recent Events (' + chunk.length + ')</h3>';
            html += '<div class="collapse-content" id="' + timelineCollapseId + '">';

            if (chunk.length > 0) {
                html += '<table><tr><th>Time</th><th>Type</th><th>Record ID</th><th>Encrypted</th><th>Sender</th></tr>';
                for (var e = 0; e < chunk.length; e++) {
                    var ev = chunk[e];
                    var ts = ev.origin_server_ts ? new Date(ev.origin_server_ts).toLocaleString() : '—';
                    var recId = (ev.content && ev.content.recordId) || '—';
                    var isEnc = (ev.content && ev.content._encrypted) ? 'Yes' : 'No';
                    html += '<tr><td class="mono">' + esc(ts) + '</td>' +
                        '<td class="mono">' + esc(ev.type.replace('law.firm.', '')) + '</td>' +
                        '<td class="mono">' + esc(recId) + '</td>' +
                        '<td>' + (isEnc === 'Yes' ? '<span class="status status-info">Encrypted</span>' : '<span class="status status-warn">Plain</span>') + '</td>' +
                        '<td class="mono">' + esc(ev.sender || '—') + '</td></tr>';
                }
                html += '</table>';
            } else {
                html += '<p class="mono" style="color:var(--text-muted);">No mutation events found in this room.</p>';
            }
            html += '</div>';
        } catch (err) {
            html += '<p class="mono" style="color:var(--yellow); margin-top: 8px;">Could not fetch timeline: ' + esc(err.message) + '</p>';
        }

        html += '</div>';
        return html;
    }

    // ---- Helpers ----
    function summaryCard(number, label) {
        return '<div class="summary-card"><div class="number">' + number + '</div><div class="label">' + esc(label) + '</div></div>';
    }

    function esc(str) {
        if (str === null || str === undefined) return '';
        var div = document.createElement('div');
        div.textContent = String(str);
        return div.innerHTML;
    }
})();
</script>

</body>
</html>
