<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DB Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ===== Noema Design System - CSS Variables ===== */
        :root {
            /* Color Palette */
            --primary-50: #eff6ff;
            --primary-100: #dbeafe;
            --primary-200: #bfdbfe;
            --primary-300: #93c5fd;
            --primary-400: #60a5fa;
            --primary-500: #3b82f6;
            --primary-600: #2563eb;
            --primary-700: #1d4ed8;
            --primary-800: #1e40af;

            --gray-50: #f8fafc;
            --gray-100: #f1f5f9;
            --gray-200: #e2e8f0;
            --gray-300: #cbd5e1;
            --gray-400: #94a3b8;
            --gray-500: #64748b;
            --gray-600: #475569;
            --gray-700: #334155;
            --gray-800: #1e293b;
            --gray-900: #0f172a;
            --gray-950: #020617;

            --success-500: #22c55e;
            --success-600: #16a34a;
            --warning-500: #f59e0b;
            --warning-600: #d97706;
            --danger-500: #ef4444;
            --danger-600: #dc2626;

            /* Semantic Colors - Dark Theme Default */
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --bg-elevated: #1e293b;
            --bg-hover: rgba(255, 255, 255, 0.06);
            --bg-active: rgba(255, 255, 255, 0.1);

            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --text-disabled: #475569;

            --border-primary: #334155;
            --border-secondary: #475569;

            /* Sizing */
            --sidebar-width: 288px;
            --header-height: 52px;
            --tab-bar-height: 38px;
            --status-bar-height: 28px;

            /* Typography */
            --font-sans: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Consolas', monospace;

            /* Transitions */
            --transition-fast: 0.1s ease;
            --transition-normal: 0.2s ease;
            --transition-slow: 0.3s ease;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            --shadow-xl: 0 20px 60px rgba(0, 0, 0, 0.6);

            /* Radii */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --radius-xl: 12px;
        }

        /* Light Theme Override */
        html.light-theme {
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --bg-elevated: #ffffff;
            --bg-hover: rgba(0, 0, 0, 0.04);
            --bg-active: rgba(0, 0, 0, 0.08);

            --text-primary: #0f172a;
            --text-secondary: #334155;
            --text-muted: #64748b;
            --text-disabled: #94a3b8;

            --border-primary: #e2e8f0;
            --border-secondary: #cbd5e1;

            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.15);
            --shadow-xl: 0 20px 60px rgba(0, 0, 0, 0.2);
        }

        /* ===== Base Reset & Layout ===== */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ===== Custom Scrollbars ===== */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border-secondary); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        * { scrollbar-width: thin; scrollbar-color: var(--border-secondary) transparent; }

        /* ===== Sidebar ===== */
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-track { background: transparent; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border-primary); border-radius: 3px; }
        .sidebar::-webkit-scrollbar-thumb:hover { background: var(--border-secondary); }

        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            overflow-y: auto;
            flex-shrink: 0;
            font-family: var(--font-sans);
            display: flex;
            flex-direction: column;
        }
        .sidebar-header { padding: 16px; border-bottom: 1px solid var(--border-primary); }
        .sidebar-header-top { display: flex; align-items: center; gap: 10px; margin-bottom: 14px; }
        .sidebar-logo {
            width: 28px; height: 28px; border-radius: 8px;
            background: linear-gradient(135deg, var(--primary-500) 0%, #8b5cf6 100%);
            display: flex; align-items: center; justify-content: center;
        }
        .sidebar-logo svg { width: 14px; height: 14px; color: #fff; }
        .sidebar-header h2 { color: var(--text-primary); font-size: 15px; font-weight: 600; letter-spacing: -0.01em; }

        /* Sidebar Search */
        .sidebar-search { position: relative; }
        .sidebar-search-icon { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: var(--text-muted); pointer-events: none; }
        .sidebar-search-icon svg { width: 14px; height: 14px; }
        .sidebar-search input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: 9px 44px 9px 36px;
            font-size: 13px;
            color: var(--text-primary);
            transition: all var(--transition-fast);
        }
        .sidebar-search input::placeholder { color: var(--text-muted); }
        .sidebar-search input:focus {
            outline: none;
            border-color: var(--primary-500);
            background: var(--bg-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
        }
        .sidebar-search-shortcut {
            position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
            font-size: 10px; color: var(--text-muted);
            background: var(--bg-tertiary); padding: 3px 6px;
            border-radius: var(--radius-sm); border: 1px solid var(--border-primary);
            font-family: system-ui, sans-serif;
        }

        /* Section Headers */
        .sidebar-section-header {
            display: flex; align-items: center; gap: 8px;
            padding: 10px 16px; font-size: 11px; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.05em;
            color: var(--text-muted); cursor: pointer;
            transition: color var(--transition-fast); user-select: none;
        }
        .sidebar-section-header:hover { color: var(--text-secondary); }
        .sidebar-section-header:active { color: var(--text-primary); background: var(--bg-hover); transition: background-color 0.05s, color 0.05s; border-radius: var(--radius-sm); }
        .sidebar-section-header svg { width: 12px; height: 12px; transition: transform 0.2s; }
        .sidebar-section-header.collapsed svg { transform: rotate(-90deg); }
        .sidebar-section-header .section-icon { opacity: 0.8; }
        .sidebar-section-header .section-count { margin-left: auto; font-weight: 400; color: var(--text-muted); }

        .sidebar-divider { height: 1px; background: var(--border-primary); margin: 8px 16px; }

        /* Table Items */
        .sidebar div.table-item {
            padding: 9px 12px; margin: 2px 8px; border-radius: var(--radius-lg);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
            display: flex; align-items: center; gap: 10px;
            transition: all var(--transition-fast); position: relative;
        }
        .sidebar div.table-item:hover { background: var(--bg-hover); color: var(--text-primary); }
        .sidebar div.table-item:active { background: var(--bg-active); color: var(--text-primary); transition: background-color 0.05s, color 0.05s; }
        .sidebar div.table-item.active {
            background: var(--bg-tertiary); color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }
        .sidebar div.table-item.active::before {
            content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%);
            width: 3px; height: 20px; border-radius: 0 2px 2px 0;
        }
        .sidebar div.table-item .table-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .sidebar div.table-item .count { font-size: 11px; color: var(--text-muted); font-variant-numeric: tabular-nums; }
        .sidebar div.table-item.active .count { color: var(--text-secondary); }
        .sidebar div.table-item:hover .count { color: var(--text-secondary); }

        /* Table Type Icons */
        .table-icon {
            width: 20px; height: 20px; border-radius: 5px; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
        }
        .table-icon svg { width: 12px; height: 12px; }
        .table-icon.type-events { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .table-icon.type-operational { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
        .table-icon.type-collection { background: rgba(139, 92, 246, 0.2); color: #8b5cf6; }
        .table-icon.type-reference { background: rgba(16, 185, 129, 0.2); color: #10b981; }
        .table-icon.type-dev { background: rgba(107, 114, 128, 0.2); color: #9ca3af; }

        /* Count Bar */
        .count-bar-wrapper { display: flex; align-items: center; gap: 6px; min-width: 54px; justify-content: flex-end; }
        .count-bar { height: 4px; border-radius: 2px; transition: all var(--transition-fast); opacity: 0.6; }
        .count-value { font-size: 11px; font-variant-numeric: tabular-nums; min-width: 28px; text-align: right; }

        /* Pin Button */
        .pin-btn {
            padding: 4px; border-radius: var(--radius-sm); background: transparent;
            border: none; cursor: pointer; opacity: 0;
            transition: all var(--transition-fast);
            display: flex; align-items: center; justify-content: center;
        }
        .pin-btn svg { width: 12px; height: 12px; color: var(--text-muted); }
        .pin-btn:hover svg { color: #f59e0b; }
        .pin-btn.pinned { opacity: 1; }
        .pin-btn.pinned svg { color: #f59e0b; fill: #f59e0b; }
        .sidebar div.table-item:hover .pin-btn { opacity: 1; }

        /* Expand Arrow */
        .sidebar div.table-item .expand-arrow {
            font-size: 10px; color: var(--text-muted);
            transition: transform 0.2s; padding: 4px;
        }
        .sidebar div.table-item.expanded .expand-arrow { transform: rotate(90deg); }
        .sidebar div.table-item:hover .expand-arrow { color: var(--text-secondary); }

        /* Table Views List */
        .table-views-list {
            max-height: 0; overflow: hidden;
            transition: max-height 0.25s ease-out;
            background: var(--bg-primary);
            margin: 0 8px; border-radius: 0 0 var(--radius-lg) var(--radius-lg);
        }
        .table-views-list.expanded { max-height: 500px; }
        .table-view-item {
            padding: 7px 12px 7px 40px; cursor: pointer;
            font-size: 12px; color: var(--text-muted);
            display: flex; align-items: center; gap: 8px;
            transition: all var(--transition-fast);
            margin: 1px 4px; border-radius: var(--radius-md);
        }
        .table-view-item:hover { background: var(--bg-hover); color: var(--text-primary); }
        .table-view-item:active { background: var(--bg-active); color: var(--text-primary); transition: background-color 0.05s, color 0.05s; }
        .table-view-item.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .table-view-item.active:active { background: rgba(59, 130, 246, 0.25); }
        .table-view-item .view-icon { font-size: 12px; width: 16px; text-align: center; color: var(--text-muted); }
        .table-view-item:hover .view-icon, .table-view-item.active .view-icon { color: inherit; }
        .table-view-item .view-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .table-view-item .view-name-input {
            flex: 1; background: var(--bg-primary); border: 1px solid var(--primary-500);
            border-radius: var(--radius-sm); color: var(--text-primary);
            font-size: 12px; padding: 3px 8px; outline: none; min-width: 0;
        }
        .table-view-item .view-name-input:focus { border-color: var(--primary-400); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }
        .table-view-default { color: var(--text-muted); font-style: italic; }

        /* Sidebar Footer - Theme Toggle */
        .sidebar-footer {
            margin-top: auto; padding: 12px 16px;
            border-top: 1px solid var(--border-primary);
            display: flex; flex-wrap: wrap; align-items: center; gap: 8px;
        }
        .theme-toggle-btn {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 10px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            color: var(--text-secondary); font-size: 12px; cursor: pointer;
            transition: all var(--transition-fast); flex: 1;
        }
        .theme-toggle-btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--border-secondary); }

        /* Matrix connection status */
        .theme-toggle-btn.matrix-connected { border-color: var(--success-500); color: var(--success-500); }
        .theme-toggle-btn.matrix-connected:hover { background: rgba(34,197,94,0.1); }

        /* ===== Room Publishing Modal ===== */
        .room-publish-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; display: flex; align-items: center; justify-content: center; }
        .room-publish-modal.hidden { display: none !important; }
        .room-publish-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 24px; width: 480px; max-height: 80vh; overflow-y: auto; box-shadow: var(--shadow-xl); }
        .room-publish-box h2 { font-size: 18px; margin-bottom: 4px; color: var(--text-primary); }
        .room-publish-box .pub-subtitle { font-size: 13px; color: var(--text-muted); margin-bottom: 20px; }
        .room-publish-section { margin-bottom: 16px; }
        .room-publish-section h3 { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .room-table-item { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); margin-bottom: 6px; cursor: pointer; transition: all var(--transition-fast); }
        .room-table-item:hover { border-color: var(--primary-500); background: var(--bg-hover); }
        .room-table-item input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--primary-500); flex-shrink: 0; }
        .room-table-item .table-info { flex: 1; }
        .room-table-item .table-info .table-name { font-size: 13px; font-weight: 500; color: var(--text-primary); }
        .room-table-item .table-info .table-meta { font-size: 11px; color: var(--text-muted); }
        .room-table-item .pub-status { font-size: 11px; padding: 2px 8px; border-radius: 10px; font-weight: 500; }
        .room-table-item .pub-status.local { background: var(--bg-tertiary); color: var(--text-muted); border: 1px solid var(--border-primary); }
        .room-table-item .pub-status.published { background: rgba(34,197,94,0.15); color: var(--success-500); }
        .pub-actions { display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end; }
        .pub-actions button { padding: 8px 16px; border-radius: var(--radius-md); font-size: 13px; font-weight: 500; cursor: pointer; transition: all var(--transition-fast); }
        .pub-btn-cancel { background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-secondary); }
        .pub-btn-cancel:hover { background: var(--bg-hover); }
        .pub-btn-publish { background: var(--primary-500); border: none; color: #fff; }
        .pub-btn-publish:hover { background: var(--primary-600); }
        .pub-btn-publish:disabled { background: var(--gray-600); cursor: not-allowed; }
        .pub-progress { margin-top: 12px; }
        .pub-progress-bar { height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; }
        .pub-progress-fill { height: 100%; background: var(--primary-500); transition: width 0.3s ease; }
        .pub-progress-text { font-size: 12px; color: var(--text-muted); margin-top: 6px; }
        /* ===== Main Content Area ===== */
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: var(--bg-primary); }

        /* ===== Browser Tab Bar ===== */
        .tab-bar {
            display: flex; align-items: stretch;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-primary);
            height: var(--tab-bar-height); padding: 0 4px;
            gap: 2px; position: relative; user-select: none;
            flex-shrink: 0;
        }
        .tab-bar::before {
            content: ''; position: absolute; bottom: 0; left: 0; right: 0;
            height: 1px; background: var(--border-primary);
        }
        .tab-bar-tabs {
            display: flex; align-items: flex-end; flex: 1;
            overflow-x: auto; overflow-y: hidden;
            scrollbar-width: none; gap: 1px; padding-top: 6px;
        }
        .tab-bar-tabs::-webkit-scrollbar { display: none; }

        .browser-tab {
            display: flex; align-items: center; gap: 8px;
            min-width: 120px; max-width: 240px; height: 32px;
            padding: 0 12px; background: var(--bg-secondary);
            border: 1px solid var(--border-primary); border-bottom: none;
            border-radius: var(--radius-md) var(--radius-md) 0 0;
            color: var(--text-secondary); font-size: 13px;
            cursor: pointer; position: relative;
            transition: var(--transition-fast); flex-shrink: 0;
        }
        .browser-tab:hover { background: var(--bg-elevated); color: var(--text-primary); }
        .browser-tab:hover .tab-close { opacity: 1; }
        .browser-tab.active {
            background: var(--bg-primary); color: var(--text-primary);
            border-color: var(--primary-500); border-top-width: 2px;
            z-index: 1; font-weight: 600;
            box-shadow: inset 0 2px 0 0 var(--primary-500);
        }
        .browser-tab.active::after {
            content: ''; position: absolute; bottom: -1px; left: 0; right: 0;
            height: 2px; background: var(--bg-primary);
        }

        .tab-icon {
            display: flex; align-items: center; justify-content: center;
            width: 16px; height: 16px; font-size: 14px;
            flex-shrink: 0; color: var(--text-muted);
        }
        .browser-tab.active .tab-icon { color: var(--primary-400); }

        .tab-title {
            flex: 1; white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis; font-weight: 500;
        }

        .tab-close {
            display: flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; border-radius: var(--radius-sm);
            color: var(--text-muted); opacity: 0;
            transition: var(--transition-fast); flex-shrink: 0; cursor: pointer;
            background: none; border: none; font-size: 14px;
        }
        .tab-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .tab-close:active { background: var(--danger-500); color: white; }
        .browser-tab.active .tab-close { opacity: 0.7; }
        .browser-tab.active .tab-close:hover { opacity: 1; color: var(--text-primary); }

        .tab-count {
            font-size: 11px; color: var(--text-muted);
            background: var(--bg-tertiary); padding: 1px 6px;
            border-radius: var(--radius-sm); margin-left: 4px; flex-shrink: 0;
        }
        .browser-tab.active .tab-count { background: var(--bg-secondary); color: var(--text-secondary); }

        .tab-bar-new-tab {
            display: flex; align-items: center; justify-content: center;
            width: 28px; height: 28px; margin: auto 4px;
            background: transparent; border: none;
            border-radius: var(--radius-md); color: var(--text-muted);
            cursor: pointer; transition: var(--transition-fast); flex-shrink: 0;
            font-size: 18px;
        }
        .tab-bar-new-tab:hover { background: var(--bg-hover); color: var(--text-primary); }
        .tab-bar-new-tab:active { background: var(--bg-active); }

        /* ===== Toolbar ===== */
        .toolbar {
            padding: 12px 20px; border-bottom: 1px solid var(--border-primary);
            display: flex; align-items: center; gap: 12px;
            background: var(--bg-secondary);
        }
        .toolbar h1 { font-size: 18px; font-weight: 600; color: var(--text-primary); flex: 1; }
        .btn {
            padding: 6px 12px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            color: var(--text-secondary); font-size: 12px; cursor: pointer;
            display: flex; align-items: center; gap: 4px;
            transition: all var(--transition-fast);
        }
        .btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--border-secondary); }
        .btn-primary { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .btn-primary:hover { background: var(--primary-600); }

        /* ===== Status Bar ===== */
        .status-bar {
            padding: 8px 20px; background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            font-size: 12px; color: var(--text-muted);
            display: flex; align-items: center; gap: 12px;
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.synced { background: var(--success-500); }
        .status-dot.loading { background: var(--warning-500); }

        /* Sync Toggle */
        .sync-toggle-wrapper { display: flex; align-items: center; gap: 6px; margin-left: 8px; padding-left: 12px; border-left: 1px solid var(--border-primary); }
        .sync-toggle-label { font-size: 11px; color: var(--text-muted); white-space: nowrap; }
        .sync-toggle { position: relative; width: 32px; height: 18px; background: var(--border-secondary); border-radius: 9px; cursor: pointer; transition: background 0.2s; }
        .sync-toggle.active { background: var(--success-500); }
        .sync-toggle-knob { position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: left 0.2s; box-shadow: var(--shadow-sm); }
        .sync-toggle.active .sync-toggle-knob { left: 16px; }

        /* Sync Feed */
        .sync-feed-btn { background: none; border: none; padding: 2px 6px; cursor: pointer; font-size: 11px; color: var(--text-muted); border-radius: 3px; margin-left: 4px; }
        .sync-feed-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .sync-feed-btn.has-activity { color: var(--primary-500); }
        .sync-feed-panel {
            position: fixed; bottom: 60px; right: 20px; width: 420px; max-height: 300px;
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg); box-shadow: var(--shadow-lg);
            z-index: 1000; display: none; flex-direction: column;
            font-family: var(--font-mono);
        }
        .sync-feed-panel.visible { display: flex; }
        .sync-feed-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid var(--border-primary); color: var(--text-primary); font-size: 12px; font-weight: 500; }
        .sync-feed-header-left { display: flex; align-items: center; gap: 8px; }
        .sync-feed-status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-muted); }
        .sync-feed-status-dot.active { background: var(--success-500); animation: pulse 2s infinite; }
        .sync-feed-status-dot.error { background: var(--danger-500); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .sync-feed-close { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 16px; padding: 0 4px; }
        .sync-feed-close:hover { color: var(--text-primary); }
        .sync-feed-body { flex: 1; overflow-y: auto; padding: 8px 0; max-height: 240px; }
        .sync-feed-line { padding: 2px 12px; font-size: 11px; line-height: 1.6; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .sync-feed-line.info { color: #7ec8e3; }
        .sync-feed-line.success { color: var(--success-500); }
        .sync-feed-line.error { color: var(--danger-500); }
        .sync-feed-line.warn { color: var(--warning-500); }
        .sync-feed-line .timestamp { color: var(--text-disabled); margin-right: 8px; }
        .sync-feed-line .prefix { color: var(--text-muted); }
        .sync-feed-empty { padding: 20px; text-align: center; color: var(--text-disabled); font-size: 11px; }
        .sync-feed-footer { padding: 8px 12px; border-top: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; font-size: 10px; color: var(--text-disabled); }
        .sync-feed-footer button { background: var(--bg-tertiary); border: none; color: var(--text-muted); font-size: 10px; padding: 4px 8px; border-radius: 3px; cursor: pointer; }
        .sync-feed-footer button:hover { background: var(--bg-hover); color: var(--text-primary); }

        /* ===== Table Container ===== */
        .table-container { flex: 1; overflow: auto; }

        /* ===== Table ===== */
        table { min-width: 100%; border-collapse: collapse; font-size: 13px; }
        th {
            background: var(--bg-secondary); border-bottom: 2px solid var(--border-primary);
            padding: 8px 12px; text-align: left; font-weight: 500;
            color: var(--text-secondary); position: sticky; top: 0; z-index: 10; white-space: nowrap;
        }
        th:first-child { width: 120px; color: var(--text-muted); }
        td {
            border-bottom: 1px solid var(--border-primary);
            padding: 8px 12px; max-width: 300px; overflow: hidden;
            text-overflow: ellipsis; white-space: nowrap; vertical-align: top;
            color: var(--text-secondary);
        }
        tr:hover td { background: var(--bg-hover); }
        tr.selected td { background: rgba(59, 130, 246, 0.15); }

        /* Cell Styling */
        .cell-empty { color: var(--text-disabled); }
        .cell-array { color: var(--text-secondary); }
        .cell-array .tag { display: inline-block; background: rgba(59, 130, 246, 0.15); color: var(--primary-400); padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; font-size: 12px; }
        .cell-link { color: var(--primary-400); text-decoration: none; }
        .cell-link:hover { text-decoration: underline; }
        .cell-number { font-family: var(--font-mono); }
        .cell-bool { padding: 2px 8px; border-radius: var(--radius-sm); font-size: 11px; font-weight: 500; }
        .cell-bool.true { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .cell-bool.false { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Pagination */
        .pagination {
            padding: 12px 20px; border-top: 1px solid var(--border-primary);
            background: var(--bg-secondary); display: flex; align-items: center;
            gap: 12px; font-size: 13px;
        }
        .pagination button {
            padding: 6px 12px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            cursor: pointer; color: var(--text-secondary);
            transition: all var(--transition-fast);
        }
        .pagination button:hover:not(:disabled) { background: var(--bg-hover); color: var(--text-primary); }
        .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
        .pagination .page-info { color: var(--text-muted); }
        /* ===== Auth Screen ===== */
        #auth-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 100; }
        #auth-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .auth-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 360px; box-shadow: var(--shadow-xl); }
        .auth-box h2 { font-size: 20px; margin-bottom: 8px; color: var(--text-primary); }
        .auth-box p { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .auth-box input { width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .auth-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .auth-box button { width: 100%; padding: 10px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; transition: background var(--transition-fast); }
        .auth-box button:hover { background: var(--primary-600); }
        .auth-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .auth-box button.secondary { background: var(--bg-tertiary); color: var(--text-secondary); }
        .auth-box button.secondary:hover { background: var(--bg-hover); }
        .auth-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-sm); display: none; }
        .auth-info { color: var(--text-muted); font-size: 12px; margin-top: 16px; text-align: center; }

        /* Synapse Login Screen */
        #synapse-login-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 105; }
        #synapse-login-screen.hidden { display: none !important; }
        #synapse-login-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .synapse-login-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 360px; box-shadow: var(--shadow-xl); }
        .synapse-login-box h2 { font-size: 20px; margin-bottom: 8px; color: var(--text-primary); }
        .synapse-login-box p { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .synapse-login-box input { width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .synapse-login-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .synapse-login-box button { width: 100%; padding: 10px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; font-weight: 500; transition: background var(--transition-fast); }
        .synapse-login-box button:hover { background: var(--primary-600); }
        .synapse-login-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .synapse-login-box .synapse-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-sm); display: none; }
        .synapse-login-box label { display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 4px; font-weight: 500; }

        .hidden { display: none !important; }

        /* Unlock Screen */
        #unlock-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 110; }
        #unlock-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .unlock-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); padding: 32px; width: 400px; box-shadow: var(--shadow-xl); }
        .unlock-box h2 { font-size: 22px; margin-bottom: 8px; color: var(--text-primary); display: flex; align-items: center; gap: 10px; }
        .unlock-box h2 .lock-icon { font-size: 24px; }
        .unlock-box .subtitle { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .unlock-box input { width: 100%; padding: 12px 14px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .unlock-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
        .unlock-box button { width: 100%; padding: 12px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; transition: background var(--transition-fast); }
        .unlock-box button:hover { background: var(--primary-600); }
        .unlock-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .unlock-box button.secondary { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-primary); }
        .unlock-box button.secondary:hover { background: var(--bg-hover); }
        .unlock-box button.passkey-btn { background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; gap: 8px; }
        .unlock-box button.passkey-btn:hover { background: var(--bg-hover); }
        .unlock-box button.passkey-btn .passkey-icon { font-size: 18px; }
        .unlock-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 10px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-md); display: none; }
        .unlock-divider { display: flex; align-items: center; gap: 12px; margin: 16px 0; color: var(--text-muted); font-size: 12px; }
        .unlock-divider::before, .unlock-divider::after { content: ''; flex: 1; height: 1px; background: var(--border-primary); }
        .unlock-info { color: var(--text-muted); font-size: 12px; margin-top: 16px; text-align: center; line-height: 1.5; }
        .unlock-info a { color: var(--primary-400); text-decoration: none; }
        .unlock-info a:hover { text-decoration: underline; }
        .setup-section { margin-bottom: 20px; }
        .setup-section label { display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500; }
        .password-strength { height: 4px; background: var(--bg-tertiary); border-radius: 2px; margin-top: -8px; margin-bottom: 12px; overflow: hidden; }
        .password-strength-fill { height: 100%; transition: width 0.2s, background 0.2s; width: 0%; }
        .password-strength-fill.weak { background: var(--danger-500); width: 33%; }
        .password-strength-fill.medium { background: var(--warning-500); width: 66%; }
        .password-strength-fill.strong { background: var(--success-500); width: 100%; }
        .security-note { background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 12px; margin-bottom: 16px; font-size: 12px; color: var(--text-secondary); line-height: 1.5; }
        .security-note strong { color: var(--text-primary); }

        /* Empty & Loading States */
        .empty-state { padding: 60px 20px; text-align: center; color: var(--text-muted); }
        .empty-state h3 { font-size: 16px; margin-bottom: 8px; color: var(--text-primary); }
        .loading-state { padding: 60px 20px; text-align: center; color: var(--text-muted); animation: fadeIn 0.15s ease-out; }
        .loading-state h3 { font-size: 16px; margin-bottom: 8px; color: var(--text-primary); }
        .loading-spinner { display: inline-block; width: 24px; height: 24px; border: 3px solid var(--border-primary); border-top-color: var(--primary-500); border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Skeleton Loading */
        .skeleton-row td { background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .skeleton-cell { height: 16px; background: var(--border-primary); border-radius: var(--radius-sm); }

        /* Progress Bar */
        .progress-bar { height: 3px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; margin-top: 4px; }
        .progress-fill { height: 100%; background: var(--primary-500); transition: width 0.3s ease; }
        .table-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .table-container { position: relative; }

        /* ===== View Controls Bar ===== */
        .view-controls-bar { display: flex; align-items: center; gap: 4px; padding: 8px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); }
        .view-control-wrapper { position: relative; }
        .view-control-btn {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 10px; background: transparent; border: none;
            border-radius: var(--radius-sm); cursor: pointer; font-size: 13px;
            color: var(--text-secondary); transition: all var(--transition-fast);
        }
        .view-control-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .view-control-btn.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-control-btn svg { flex-shrink: 0; }
        .control-count { background: var(--primary-500); color: #fff; font-size: 10px; font-weight: 600; padding: 1px 5px; border-radius: 8px; min-width: 16px; text-align: center; }
        .view-controls-spacer { flex: 1; }

        /* View Search */
        .view-search-wrapper { position: relative; display: flex; align-items: center; }
        .view-search-wrapper .search-icon { position: absolute; left: 10px; color: var(--text-muted); pointer-events: none; }
        .view-search-input {
            padding: 6px 10px 6px 32px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); font-size: 13px; width: 180px;
            background: var(--bg-tertiary); color: var(--text-primary);
            transition: all var(--transition-fast);
        }
        .view-search-input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15); width: 220px; }
        .view-search-input::placeholder { color: var(--text-muted); }

        /* View Control Dropdowns */
        .view-control-dropdown {
            position: absolute; top: 100%; left: 0; margin-top: 4px;
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg); box-shadow: var(--shadow-lg);
            z-index: 100; min-width: 280px; display: none;
        }
        .view-control-dropdown.open { display: block; }
        .dropdown-section { padding: 0; }
        .dropdown-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid var(--border-primary); background: var(--bg-tertiary); border-radius: var(--radius-lg) var(--radius-lg) 0 0; }
        .dropdown-header span { font-size: 13px; font-weight: 600; color: var(--text-primary); }
        .dropdown-action-btn { background: transparent; border: none; color: var(--primary-400); font-size: 12px; cursor: pointer; padding: 4px 8px; border-radius: var(--radius-sm); }
        .dropdown-action-btn:hover { background: rgba(59, 130, 246, 0.15); }

        /* Filter Dropdown */
        .filter-list { padding: 12px 16px; max-height: 300px; overflow-y: auto; }
        .empty-filters, .empty-sorts { color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px 0; }
        .filter-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .filter-row:last-child { border-bottom: none; }
        .filter-row select, .filter-row input { padding: 6px 8px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; background: var(--bg-tertiary); color: var(--text-primary); }
        .filter-row select { min-width: 100px; }
        .filter-row input { flex: 1; min-width: 80px; }
        .filter-remove-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 4px; border-radius: var(--radius-sm); }
        .filter-remove-btn:hover { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Sort Dropdown */
        .sort-list { padding: 12px 16px; max-height: 300px; overflow-y: auto; }
        .sort-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .sort-row:last-child { border-bottom: none; }
        .sort-row select { padding: 6px 8px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; flex: 1; background: var(--bg-tertiary); color: var(--text-primary); }
        .sort-direction-btns { display: flex; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); overflow: hidden; }
        .sort-direction-btn { padding: 6px 10px; background: var(--bg-tertiary); border: none; cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .sort-direction-btn.active { background: var(--primary-500); color: #fff; }
        .sort-direction-btn:first-child { border-right: 1px solid var(--border-primary); }
        .sort-remove-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 4px; border-radius: var(--radius-sm); }
        .sort-remove-btn:hover { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Group & Color Dropdown */
        .group-options, .color-options { padding: 8px 0; max-height: 400px; overflow-y: auto; }
        .group-option, .color-option { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; font-size: 13px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .group-option:hover, .color-option:hover { background: var(--bg-hover); }
        .group-option .check-mark, .color-option .check-mark { color: var(--primary-400); font-size: 14px; width: 16px; visibility: hidden; }
        .group-option.selected .check-mark, .color-option.selected .check-mark, .group-option.none-selected .check-mark, .color-option.none-selected .check-mark { visibility: visible; }

        /* Dropdown Search */
        .dropdown-search-wrapper { padding: 8px 12px; border-bottom: 1px solid var(--border-primary); }
        .dropdown-search-input { width: 100%; padding: 8px 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 13px; box-sizing: border-box; background: var(--bg-tertiary); color: var(--text-primary); }
        .dropdown-search-input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15); }
        .dropdown-search-input::placeholder { color: var(--text-muted); }

        /* Grouped Table */
        .group-header-row td { background: var(--bg-secondary); font-weight: 600; padding: 10px 12px !important; border-top: 1px solid var(--border-primary); cursor: pointer; user-select: none; }
        .group-header-row:hover td { background: var(--bg-hover); }
        .group-header-row .group-toggle { display: inline-flex; align-items: center; gap: 8px; color: var(--text-primary); }
        .group-header-row .group-toggle svg { width: 16px; height: 16px; transition: transform 0.2s; color: var(--text-muted); }
        .group-header-row.collapsed .group-toggle svg { transform: rotate(-90deg); }
        .group-header-row .group-name { font-size: 13px; }
        .group-header-row .group-count { font-size: 12px; color: var(--text-muted); font-weight: 400; margin-left: 8px; }
        .group-row.hidden { display: none; }

        /* Row Height */
        .row-height-option { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; font-size: 13px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .row-height-option:hover { background: var(--bg-hover); }
        .row-height-option.selected { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .row-height-option svg { color: var(--text-muted); }
        .row-height-option.selected svg { color: var(--primary-400); }
        table.row-height-short td { padding: 4px 12px; }
        table.row-height-medium td { padding: 8px 12px; }
        table.row-height-tall td { padding: 14px 12px; }
        table.row-height-extra-tall td { padding: 20px 12px; white-space: normal; }
        /* ===== Modals ===== */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .modal-overlay.open { opacity: 1; visibility: visible; }
        .modal { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 90%; max-width: 700px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: var(--shadow-xl); transform: translateY(20px); transition: transform 0.2s; }
        .modal-overlay.open .modal { transform: translateY(0); }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .modal-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); flex: 1; margin: 0; }
        .modal-header .record-id { font-size: 12px; color: var(--text-muted); font-family: var(--font-mono); }
        .modal-close { width: 32px; height: 32px; border: none; background: var(--bg-tertiary); border-radius: var(--radius-md); cursor: pointer; font-size: 18px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .modal-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .modal-body { flex: 1; overflow-y: auto; padding: 0; }
        .modal-empty { padding: 60px 20px; text-align: center; color: var(--text-muted); }
        .modal-empty h3 { font-size: 16px; color: var(--text-primary); margin-bottom: 8px; }

        /* History Timeline */
        .history-timeline { padding: 16px 0; }
        .history-item { padding: 16px 24px; border-bottom: 1px solid var(--border-primary); transition: background var(--transition-fast); }
        .history-item:hover { background: var(--bg-hover); }
        .history-item:last-child { border-bottom: none; }
        .history-item-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
        .history-field-name { font-weight: 600; color: var(--text-primary); font-size: 14px; }
        .history-change-type { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: var(--radius-sm); text-transform: uppercase; letter-spacing: 0.3px; }
        .history-change-type.created { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .history-change-type.updated { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .history-change-type.deleted { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .history-timestamp { font-size: 12px; color: var(--text-muted); margin-left: auto; }
        .history-event-id { font-size: 11px; color: var(--text-disabled); font-family: var(--font-mono); }
        .history-values { display: flex; gap: 12px; align-items: flex-start; flex-wrap: wrap; }
        .history-value-box { flex: 1; min-width: 200px; padding: 10px 12px; border-radius: var(--radius-md); font-size: 13px; }
        .history-value-box.old { background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); }
        .history-value-box.new { background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); }
        .history-value-box.null { background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-muted); font-style: italic; }
        .history-value-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin-bottom: 4px; }
        .history-value-content { word-break: break-word; color: var(--text-secondary); }
        .history-arrow { color: var(--text-muted); font-size: 16px; flex-shrink: 0; align-self: center; }
        .history-btn { padding: 4px 8px; background: transparent; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: inline-flex; align-items: center; gap: 4px; transition: all var(--transition-fast); }
        .history-btn:hover { background: var(--bg-hover); border-color: var(--primary-500); color: var(--primary-400); }
        .history-btn svg { width: 12px; height: 12px; }

        /* Modal Toolbar */
        .modal-toolbar { padding: 12px 24px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .modal-toolbar select { padding: 6px 10px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 13px; background: var(--bg-secondary); color: var(--text-primary); }
        .modal-toolbar .history-count { font-size: 12px; color: var(--text-muted); margin-left: auto; }

        /* View Selector */
        .view-selector { position: relative; display: flex; align-items: center; gap: 8px; }
        .view-selector-btn { padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 8px; min-width: 140px; transition: border-color var(--transition-fast); color: var(--text-secondary); }
        .view-selector-btn:hover { border-color: var(--primary-500); }
        .view-selector-btn .view-icon { font-size: 14px; }
        .view-selector-btn .view-name { flex: 1; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .view-selector-btn .dropdown-arrow { font-size: 10px; color: var(--text-muted); }
        .view-selector-dropdown { position: absolute; top: 100%; left: 0; margin-top: 4px; min-width: 200px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 100; max-height: 300px; overflow-y: auto; display: none; }
        .view-selector-dropdown.open { display: block; }
        .view-selector-dropdown-header { padding: 10px 12px; font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border-primary); background: var(--bg-tertiary); }
        .view-selector-option { padding: 10px 12px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 10px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .view-selector-option:hover { background: var(--bg-hover); }
        .view-selector-option.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-selector-option .view-type-icon { width: 20px; text-align: center; }
        .view-selector-option .view-option-name { flex: 1; }
        .view-selector-option .view-check { color: var(--primary-400); font-size: 14px; }

        /* Fields Button & Dropdown */
        .fields-btn { padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 6px; transition: all var(--transition-fast); color: var(--text-secondary); }
        .fields-btn:hover { border-color: var(--primary-500); color: var(--text-primary); }
        .fields-btn .fields-icon { font-size: 14px; }
        .fields-btn .fields-count { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); padding: 2px 6px; border-radius: 10px; font-size: 11px; font-weight: 600; }
        .fields-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; width: 340px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 100; display: none; }
        .fields-dropdown.open { display: block; }
        .fields-dropdown-header { padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; }
        .fields-dropdown-header h3 { font-size: 14px; font-weight: 600; color: var(--text-primary); margin: 0; }
        .fields-dropdown-actions { display: flex; gap: 8px; }
        .fields-dropdown-actions button { padding: 4px 8px; font-size: 11px; background: transparent; border: none; color: var(--primary-400); cursor: pointer; border-radius: var(--radius-sm); }
        .fields-dropdown-actions button:hover { background: rgba(59, 130, 246, 0.15); }
        .fields-search-container { padding: 8px 12px; border-bottom: 1px solid var(--border-primary); }
        .fields-search-input { width: 100%; padding: 6px 10px; font-size: 13px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); outline: none; box-sizing: border-box; }
        .fields-search-input::placeholder { color: var(--text-muted); }
        .fields-search-input:focus { border-color: var(--primary-500); }
        .fields-dropdown-list { max-height: 450px; overflow-y: auto; padding: 8px 0; }
        .fields-dropdown-item.drag-over-above { box-shadow: inset 0 2px 0 0 var(--primary-500); }
        .fields-dropdown-item.drag-over-below { box-shadow: inset 0 -2px 0 0 var(--primary-500); }
        .fields-dropdown-item { padding: 8px 16px; display: flex; align-items: center; gap: 10px; cursor: pointer; transition: background var(--transition-fast); user-select: none; }
        .fields-dropdown-item:hover { background: var(--bg-hover); }
        .fields-dropdown-item.dragging { background: rgba(59, 130, 246, 0.15); opacity: 0.8; }
        .fields-dropdown-item .field-drag-handle { cursor: grab; color: var(--text-disabled); font-size: 12px; padding: 2px; }
        .fields-dropdown-item .field-drag-handle:hover { color: var(--text-muted); }
        .fields-dropdown-item .field-checkbox { width: 18px; height: 18px; border: 2px solid var(--border-secondary); border-radius: var(--radius-sm); display: flex; align-items: center; justify-content: center; transition: all var(--transition-fast); flex-shrink: 0; }
        .fields-dropdown-item .field-checkbox.checked { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .fields-dropdown-item .field-checkbox .check-icon { font-size: 12px; display: none; }
        .fields-dropdown-item .field-checkbox.checked .check-icon { display: block; }
        .fields-dropdown-item .field-info { flex: 1; min-width: 0; }
        .fields-dropdown-item .field-name { font-size: 13px; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .fields-dropdown-item .field-type { font-size: 11px; color: var(--text-muted); }
        .fields-dropdown-item .field-move-btns { display: flex; flex-direction: column; gap: 2px; opacity: 0; transition: opacity var(--transition-fast); }
        .fields-dropdown-item:hover .field-move-btns { opacity: 1; }
        .fields-dropdown-item .field-move-btn { width: 18px; height: 14px; border: none; background: var(--bg-tertiary); border-radius: 3px; cursor: pointer; font-size: 10px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .fields-dropdown-item .field-move-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .fields-dropdown-footer { padding: 10px 16px; border-top: 1px solid var(--border-primary); background: var(--bg-tertiary); font-size: 11px; color: var(--text-muted); }
        .toolbar-views { display: flex; align-items: center; gap: 8px; position: relative; }
        /* ===== Loading Overlay ===== */
        #loading-overlay {
            position: fixed; inset: 0;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            display: flex; align-items: center; justify-content: center; z-index: 200;
        }
        #loading-overlay.fading-out { opacity: 0; transition: opacity 0.4s ease; pointer-events: none; }
        .loading-content { text-align: center; max-width: 400px; padding: 40px; }
        .loading-logo { width: 80px; height: 80px; margin: 0 auto 24px; position: relative; }
        .loading-logo-inner {
            width: 100%; height: 100%; border-radius: 20px;
            background: linear-gradient(135deg, var(--primary-500) 0%, #7c3aed 100%);
            animation: pulse-glow 2s ease-in-out infinite;
            display: flex; align-items: center; justify-content: center;
            font-size: 36px; color: white;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.4); transform: scale(1); }
            50% { box-shadow: 0 0 40px rgba(124, 58, 237, 0.6); transform: scale(1.05); }
        }
        .loading-title { font-size: 24px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; }
        .loading-subtitle { font-size: 14px; color: var(--text-muted); margin-bottom: 32px; line-height: 1.5; }
        .loading-progress-container { background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 20px; margin-bottom: 24px; }
        .loading-progress-bar { height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden; margin-bottom: 16px; position: relative; }
        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-500), #7c3aed, var(--primary-500));
            background-size: 200% 100%; border-radius: 3px;
            transition: width 0.3s ease; animation: shimmer-progress 1.5s linear infinite;
        }
        @keyframes shimmer-progress { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .loading-status { font-size: 13px; color: var(--text-secondary); margin-bottom: 4px; }
        .loading-detail { font-size: 12px; color: var(--text-muted); font-family: var(--font-mono); }
        .loading-time-estimate { font-size: 11px; color: var(--text-muted); margin-top: 8px; min-height: 16px; }
        .loading-progress-activity { position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; border-radius: 3px; }
        .loading-progress-activity::after {
            content: ''; position: absolute; top: 0; left: -100%; height: 100%; width: 50%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: activity-sweep 1.2s ease-in-out infinite;
        }
        @keyframes activity-sweep { 0% { left: -50%; } 100% { left: 100%; } }
        .loading-facts { display: flex; justify-content: center; gap: 24px; margin-bottom: 24px; }
        .loading-fact { text-align: center; }
        .loading-fact-value { font-size: 28px; font-weight: 700; color: var(--text-primary); line-height: 1; }
        .loading-fact-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }
        .loading-note { font-size: 12px; color: var(--text-muted); background: rgba(255, 255, 255, 0.03); border: 1px solid var(--border-primary); padding: 12px 16px; border-radius: var(--radius-lg); border-left: 3px solid var(--primary-500); }
        .loading-note strong { color: var(--text-secondary); }
        .loading-skip-section { margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border-primary); }
        .loading-skip-text { font-size: 12px; color: var(--text-muted); margin-bottom: 12px; }
        .loading-skip-btn { background: transparent; border: 1px solid var(--border-secondary); color: var(--text-secondary); padding: 10px 20px; border-radius: var(--radius-md); font-size: 13px; cursor: pointer; transition: all 0.2s; }
        .loading-skip-btn:hover { background: var(--bg-hover); border-color: var(--text-muted); color: var(--text-primary); }
        .loading-skip-btn:active { transform: scale(0.98); }
        .loading-particles { position: absolute; inset: 0; overflow: hidden; pointer-events: none; }
        .particle { position: absolute; width: 4px; height: 4px; background: rgba(59, 130, 246, 0.3); border-radius: 50%; animation: float-up 8s ease-in-out infinite; }
        .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
        .particle:nth-child(2) { left: 20%; animation-delay: 1s; }
        .particle:nth-child(3) { left: 30%; animation-delay: 2s; }
        .particle:nth-child(4) { left: 40%; animation-delay: 3s; }
        .particle:nth-child(5) { left: 50%; animation-delay: 4s; }
        .particle:nth-child(6) { left: 60%; animation-delay: 5s; }
        .particle:nth-child(7) { left: 70%; animation-delay: 6s; }
        .particle:nth-child(8) { left: 80%; animation-delay: 7s; }
        .particle:nth-child(9) { left: 90%; animation-delay: 0.5s; }
        .particle:nth-child(10) { left: 15%; animation-delay: 2.5s; }
        @keyframes float-up {
            0%, 100% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(90vh) scale(1); }
            90% { opacity: 1; transform: translateY(10vh) scale(1); }
            100% { transform: translateY(0) scale(0); opacity: 0; }
        }

        /* Refresh & Save Indicators */
        .refresh-indicator { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text-muted); padding: 2px 8px; border-radius: var(--radius-sm); transition: all 0.3s; }
        .refresh-indicator.syncing { color: var(--primary-400); background: rgba(59, 130, 246, 0.1); }
        .refresh-indicator .refresh-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); transition: all 0.3s; }
        .refresh-indicator.syncing .refresh-dot { background: var(--primary-500); animation: pulse-dot 1s ease-in-out infinite; }
        @keyframes pulse-dot { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.5); opacity: 0.5; } }

        .view-save-indicator { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text-muted); padding: 4px 10px; border-radius: var(--radius-sm); transition: all 0.3s; margin-left: 8px; }
        .view-save-indicator.dirty { color: var(--warning-500); background: rgba(245, 158, 11, 0.1); }
        .view-save-indicator.saving { color: var(--primary-400); background: rgba(59, 130, 246, 0.1); }
        .view-save-indicator.saved { color: var(--success-500); background: rgba(34, 197, 94, 0.1); }
        .view-save-indicator .save-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }
        .view-save-indicator.saving .save-dot { animation: pulse-dot 1s ease-in-out infinite; }
        .view-save-btn { padding: 4px 10px; background: var(--primary-500); color: #fff; border: none; border-radius: var(--radius-sm); font-size: 11px; cursor: pointer; margin-left: 4px; transition: all var(--transition-fast); }
        .view-save-btn:hover { background: var(--primary-600); }
        .view-save-btn:disabled { background: var(--gray-600); cursor: not-allowed; }

        /* View Folders */
        .table-view-folder { padding: 6px 16px 6px 36px; cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 8px; transition: all var(--transition-fast); user-select: none; }
        .table-view-folder:hover { background: var(--bg-hover); color: var(--text-primary); }
        .table-view-folder .folder-icon { font-size: 12px; transition: transform 0.2s; }
        .table-view-folder.expanded .folder-icon { transform: rotate(90deg); }
        .table-view-folder .folder-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .table-view-folder .folder-actions { display: none; gap: 4px; }
        .table-view-folder:hover .folder-actions { display: flex; }
        .table-view-folder .folder-action-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 2px 4px; font-size: 10px; border-radius: 3px; }
        .table-view-folder .folder-action-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .folder-views-list { max-height: 0; overflow: hidden; transition: max-height 0.25s ease-out; }
        .folder-views-list.expanded { max-height: 500px; }
        .folder-views-list .table-view-item { padding-left: 52px; }
        .table-view-add-btn { padding: 6px 16px 6px 44px; cursor: pointer; font-size: 12px; color: var(--text-disabled); display: flex; align-items: center; gap: 8px; transition: all var(--transition-fast); }
        .table-view-add-btn:hover { background: var(--bg-hover); color: var(--primary-400); }
        .table-view-add-btn .add-icon { font-size: 14px; color: var(--primary-400); }
        .folder-name-input { background: var(--bg-tertiary); border: 1px solid var(--primary-500); color: var(--text-primary); padding: 4px 8px; font-size: 12px; border-radius: var(--radius-sm); width: 120px; }
        .folder-name-input:focus { outline: none; border-color: var(--primary-400); }

        /* Context Menu */
        .view-context-menu { position: fixed; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 1000; min-width: 160px; padding: 4px 0; display: none; }
        .view-context-menu.open { display: block; }
        .view-context-menu-item { padding: 8px 16px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 8px; color: var(--text-secondary); }
        .view-context-menu-item:hover { background: var(--bg-hover); }
        .view-context-menu-item.danger { color: #f87171; }
        .view-context-menu-item.danger:hover { background: rgba(239, 68, 68, 0.15); }
        .view-context-menu-separator { height: 1px; background: var(--border-primary); margin: 4px 0; }

        /* Column Drag */
        th.dragging { opacity: 0.5; background: rgba(59, 130, 246, 0.15) !important; }
        th.drag-over { border-left: 3px solid var(--primary-500); }
        th { cursor: grab; }
        th:active { cursor: grabbing; }
        th:first-child { cursor: default; }

        /* Schema View */
        .schema-view-container { padding: 20px; display: flex; flex-wrap: wrap; gap: 16px; overflow-y: auto; }
        .schema-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 320px; max-height: 500px; overflow: hidden; box-shadow: var(--shadow-sm); transition: box-shadow 0.2s, transform 0.2s; display: flex; flex-direction: column; }
        .schema-card:hover { box-shadow: var(--shadow-md); transform: translateY(-2px); }
        .schema-card-header { padding: 16px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; }
        .schema-card-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); background: var(--bg-primary); padding: 4px 8px; border-radius: var(--radius-sm); }
        .schema-card-actions { display: flex; gap: 8px; }
        .schema-card-body { padding: 0; overflow-y: auto; flex: 1; }
        .schema-field-row { padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; flex-direction: column; gap: 4px; }
        .schema-field-row:last-child { border-bottom: none; }
        .schema-field-name { font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.3px; }
        .schema-field-value { font-size: 13px; color: var(--text-primary); word-break: break-word; }
        .schema-field-value.empty { color: var(--text-disabled); font-style: italic; }
        /* ===== Create View Modal ===== */
        .create-view-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1001; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .create-view-modal.open { opacity: 1; visibility: visible; }
        .create-view-modal-content { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 400px; max-width: 90%; box-shadow: var(--shadow-xl); transform: translateY(20px); transition: transform 0.2s; }
        .create-view-modal.open .create-view-modal-content { transform: translateY(0); }
        .create-view-modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border-primary); }
        .create-view-modal-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); margin: 0 0 4px 0; }
        .create-view-modal-header p { font-size: 13px; color: var(--text-muted); margin: 0; }
        .create-view-modal-body { padding: 24px; }
        .create-view-field { margin-bottom: 16px; }
        .create-view-field label { display: block; font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 6px; }
        .create-view-field input, .create-view-field select { width: 100%; padding: 10px 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); font-size: 14px; background: var(--bg-tertiary); color: var(--text-primary); }
        .create-view-field input:focus, .create-view-field select:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .create-view-modal-footer { padding: 16px 24px; border-top: 1px solid var(--border-primary); display: flex; justify-content: flex-end; gap: 12px; background: var(--bg-tertiary); border-radius: 0 0 var(--radius-xl) var(--radius-xl); }
        .create-view-modal-footer button { padding: 10px 20px; border-radius: var(--radius-md); font-size: 14px; font-weight: 500; cursor: pointer; transition: all var(--transition-fast); }
        .create-view-modal-footer .btn-cancel { background: var(--bg-secondary); border: 1px solid var(--border-primary); color: var(--text-muted); }
        .create-view-modal-footer .btn-cancel:hover { background: var(--bg-hover); }
        .create-view-modal-footer .btn-create { background: var(--primary-500); border: 1px solid var(--primary-500); color: #fff; }
        .create-view-modal-footer .btn-create:hover { background: var(--primary-600); }

        /* View Tags */
        .view-tags { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; }
        .view-tag { font-size: 10px; padding: 2px 6px; border-radius: 10px; background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-tag.workspace { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .table-view-item .view-tags { padding-left: 24px; }

        /* Workspace Tabs */
        .workspace-tabs { display: flex; gap: 4px; padding: 8px 16px; background: var(--bg-primary); border-bottom: 1px solid var(--border-primary); }
        .workspace-tab { padding: 6px 12px; font-size: 12px; color: var(--text-muted); border-radius: var(--radius-sm); cursor: pointer; transition: all var(--transition-fast); }
        .workspace-tab:hover { background: var(--bg-hover); color: var(--text-primary); }
        .workspace-tab.active { background: var(--primary-500); color: #fff; }
        .workspace-tab .workspace-count { margin-left: 6px; font-size: 10px; background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 8px; }
        .workspace-add-btn { padding: 6px 8px; font-size: 12px; color: var(--text-muted); cursor: pointer; }
        .workspace-add-btn:hover { color: var(--primary-400); }

        /* Nested Views */
        .table-view-item.nested-level-1 { padding-left: 60px; }
        .table-view-item.nested-level-2 { padding-left: 76px; }
        .table-view-item.nested-level-3 { padding-left: 92px; }
        .view-nest-indicator { font-size: 10px; color: var(--text-muted); margin-right: 4px; }
        .view-type-badge { font-size: 9px; padding: 2px 5px; border-radius: 3px; background: var(--bg-tertiary); color: var(--text-muted); margin-left: auto; }
        .view-type-badge.schema { background: rgba(124, 58, 237, 0.3); color: #a78bfa; }
        .view-type-badge.grid { background: rgba(59, 130, 246, 0.3); color: #60a5fa; }

        /* Events Sidebar Items */
        .events-section-header { padding: 12px 16px 8px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); border-bottom: 1px solid var(--border-primary); }
        .sidebar div.table-item.events-item { margin: 2px 8px; border-radius: var(--radius-lg); background: transparent; border: none; }
        .sidebar div.table-item.events-item .table-icon { background: rgba(245, 158, 11, 0.15); border-radius: 5px; }
        .sidebar div.table-item.events-item .table-icon svg { color: #d97706; }
        .sidebar div.table-item.events-item:hover { background: var(--bg-hover); }
        .sidebar div.table-item.events-item:active { background: rgba(139, 92, 246, 0.15); transition: background-color 0.05s; }
        .sidebar div.table-item.events-item.active { background: rgba(139, 92, 246, 0.15); }
        .sidebar div.table-item.events-item.active::before { background: #8b5cf6; }

        .sidebar div.table-item.sync-status-item { margin: 2px 8px; border-radius: var(--radius-lg); background: transparent; border: none; }
        .sidebar div.table-item.sync-status-item .table-icon { background: rgba(16, 185, 129, 0.15); border-radius: 5px; }
        .sidebar div.table-item.sync-status-item .table-icon svg { color: #10b981; }
        .sidebar div.table-item.sync-status-item:hover { background: var(--bg-hover); }
        .sidebar div.table-item.sync-status-item:active { background: rgba(16, 185, 129, 0.15); transition: background-color 0.05s; }
        .sidebar div.table-item.sync-status-item.active { background: rgba(16, 185, 129, 0.15); }
        .sidebar div.table-item.sync-status-item.active::before { background: #10b981; }

        /* ===== Sync Status View ===== */
        .sync-status-view { padding: 24px; max-width: 1200px; }
        .sync-status-header { display: flex; align-items: center; gap: 12px; margin-bottom: 24px; }
        .sync-status-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); }
        .sync-status-header .sync-status-badge { font-size: 11px; font-weight: 600; padding: 3px 10px; border-radius: 12px; }
        .sync-status-badge.synced { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-status-badge.syncing { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .sync-status-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-status-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; margin-bottom: 24px; }
        .sync-status-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 18px; }
        .sync-status-card .card-label { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 6px; }
        .sync-status-card .card-value { font-size: 22px; font-weight: 600; color: var(--text-primary); }
        .sync-status-card .card-sub { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
        .sync-status-section { margin-bottom: 24px; }
        .sync-status-section h3 { font-size: 14px; font-weight: 600; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .sync-status-section h3 .section-dot { width: 8px; height: 8px; border-radius: 50%; }
        .sync-status-section h3 .section-dot.green { background: #10b981; }
        .sync-status-section h3 .section-dot.amber { background: #f59e0b; }
        .sync-status-section h3 .section-dot.red { background: #ef4444; }

        .sync-history-table { width: 100%; border-collapse: collapse; font-size: 13px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); overflow: hidden; }
        .sync-history-table th { background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); padding: 10px 14px; text-align: left; font-weight: 600; color: var(--text-secondary); font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; }
        .sync-history-table td { border-bottom: 1px solid var(--border-primary); padding: 10px 14px; color: var(--text-secondary); }
        .sync-history-table tr:last-child td { border-bottom: none; }
        .sync-history-table tr:hover td { background: var(--bg-hover); }
        .sync-history-table .sync-type-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: var(--radius-sm); text-transform: uppercase; }
        .sync-history-table .sync-type-badge.incremental { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .sync-history-table .sync-type-badge.full { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .sync-history-table .sync-type-badge.snapshot { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-history-table .sync-type-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-result-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: var(--radius-sm); }
        .sync-result-badge.success { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-result-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-result-badge.no-change { background: var(--bg-tertiary); color: var(--text-muted); }
        .sync-poll-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .sync-poll-controls .btn-poll { display: inline-flex; align-items: center; gap: 6px; padding: 8px 16px; border-radius: var(--radius-lg); border: 1px solid var(--border-primary); background: var(--bg-secondary); font-size: 13px; font-weight: 500; color: var(--text-secondary); cursor: pointer; transition: all var(--transition-fast); }
        .sync-poll-controls .btn-poll:hover { background: var(--bg-hover); border-color: var(--border-secondary); }
        .sync-poll-controls .btn-poll.primary { background: var(--success-500); color: #fff; border-color: var(--success-500); }
        .sync-poll-controls .btn-poll.primary:hover { background: var(--success-600); }
        .sync-poll-controls .btn-poll:disabled { opacity: 0.5; cursor: not-allowed; }
        .snapshot-export-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }
        .sync-activity-log { background: var(--bg-primary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 16px; max-height: 300px; overflow-y: auto; font-family: var(--font-mono); font-size: 12px; line-height: 1.6; }
        .sync-activity-log .log-line { color: var(--text-muted); }
        .sync-activity-log .log-line .timestamp { color: var(--text-disabled); margin-right: 8px; }
        .sync-activity-log .log-line.info .message { color: #60a5fa; }
        .sync-activity-log .log-line.success .message { color: #34d399; }
        .sync-activity-log .log-line.error .message { color: #f87171; }
        .sync-activity-log .log-line.warn .message { color: #fbbf24; }
        .sync-activity-log .log-empty { color: var(--text-disabled); text-align: center; padding: 20px; }
        /* ===== Events Table ===== */
        .events-table { min-width: 100%; border-collapse: collapse; font-size: 13px; }
        .events-table th { background: var(--bg-secondary); border-bottom: 2px solid var(--border-primary); padding: 10px 12px; text-align: left; font-weight: 500; color: var(--text-secondary); position: sticky; top: 0; z-index: 10; white-space: nowrap; }
        .events-table td { border-bottom: 1px solid var(--border-primary); padding: 10px 12px; vertical-align: top; }
        .events-table tr:hover td { background: var(--bg-hover); }
        .events-table .event-id { font-family: var(--font-mono); font-size: 12px; color: var(--text-muted); }
        .events-table .event-timestamp { font-size: 12px; color: var(--text-muted); white-space: nowrap; }
        .events-table .event-set { font-family: var(--font-mono); font-size: 11px; color: var(--primary-400); background: rgba(59, 130, 246, 0.15); padding: 2px 6px; border-radius: var(--radius-sm); display: inline-block; max-width: 150px; overflow: hidden; text-overflow: ellipsis; }
        .events-table .event-record-id { font-family: var(--font-mono); font-size: 11px; color: #4ade80; background: rgba(34, 197, 94, 0.15); padding: 2px 6px; border-radius: var(--radius-sm); display: inline-block; }
        .events-table .event-type-badge { font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); }
        .events-table .event-type-badge.data { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .event-type-badge.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .event-type-badge.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .event-type-badge.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .events-table .event-type-badge.SYN { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .event-type-badge.table { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .event-type-badge.field { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .events-table .event-type-badge.view { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
        .events-table .event-type-badge.viewconfig { background: rgba(124, 58, 237, 0.15); color: #a78bfa; }
        .events-table .event-type-badge.current { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .field-op-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); margin-right: 4px; }
        .events-table .field-op-badge.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .field-op-badge.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .field-op-badge.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .events-table .field-op-badge.SYN { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .field-op-badge .field-count { font-weight: 400; opacity: 0.8; }
        .events-table .event-details { white-space: nowrap; }
        .events-table .current-state-row { background: rgba(34, 197, 94, 0.05); }
        .events-table .event-id.current-state { color: var(--text-disabled); }

        /* New Event Indicators */
        .events-table tr.new-event td { background: rgba(34, 197, 94, 0.05); }
        .events-table tr.new-event:hover td { background: rgba(34, 197, 94, 0.1); }
        .new-event-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: var(--radius-sm); background: var(--success-500); color: #fff; text-transform: uppercase; letter-spacing: 0.5px; margin-left: 6px; animation: pulse-new 2s ease-in-out infinite; }
        @keyframes pulse-new { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .new-events-divider { position: relative; padding: 8px 0; }
        .new-events-divider td { background: rgba(34, 197, 94, 0.1) !important; border-bottom: 2px solid var(--success-500); text-align: center; padding: 8px 12px; }
        .new-events-divider-text { display: inline-flex; align-items: center; gap: 8px; color: var(--success-500); font-size: 11px; font-weight: 600; }
        .new-events-divider-text::before, .new-events-divider-text::after { content: ''; display: inline-block; width: 40px; height: 1px; background: var(--success-500); }

        /* Payload Preview */
        .payload-preview-container { max-width: 400px; }
        .payload-preview { font-family: var(--font-mono); font-size: 11px; color: var(--text-secondary); background: var(--bg-tertiary); padding: 6px 10px; border-radius: var(--radius-sm); max-height: 60px; overflow: hidden; cursor: pointer; position: relative; transition: all 0.2s; border: 1px solid var(--border-primary); }
        .payload-preview:hover { background: var(--bg-hover); border-color: var(--border-secondary); }
        .payload-preview.expanded { max-height: none; white-space: pre-wrap; word-break: break-all; }
        .payload-expand-btn { position: absolute; bottom: 4px; right: 4px; font-size: 10px; color: var(--primary-400); background: var(--bg-secondary); padding: 2px 6px; border-radius: 3px; border: 1px solid var(--border-primary); cursor: pointer; }
        .payload-preview.expanded .payload-expand-btn { position: static; display: block; margin-top: 8px; }

        /* JSON Syntax Highlighting */
        .json-key { color: #a78bfa; }
        .json-string { color: #4ade80; }
        .json-number { color: #60a5fa; }
        .json-boolean { color: #f87171; }
        .json-null { color: var(--text-muted); font-style: italic; }

        /* Payload Fields */
        .payload-fields { }
        .payload-op-group { margin-bottom: 6px; }
        .payload-op-group:last-child { margin-bottom: 0; }
        .payload-op-label { display: inline-block; font-size: 9px; font-weight: 600; padding: 1px 5px; border-radius: 3px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        .payload-op-label.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .payload-op-label.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .payload-op-label.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .payload-field-row { display: flex; gap: 8px; padding: 2px 0; border-bottom: 1px solid var(--border-primary); }
        .payload-field-row:last-child { border-bottom: none; }
        .payload-field-name { color: #a78bfa; font-weight: 500; min-width: 80px; flex-shrink: 0; }
        .payload-field-value { color: var(--text-secondary); word-break: break-word; }
        .payload-field-value.string { color: #4ade80; }
        .payload-field-value.number { color: #60a5fa; }
        .payload-field-value.boolean { color: #f87171; }
        .payload-field-value.null { color: var(--text-muted); font-style: italic; }
        .payload-field-value.array { color: #a78bfa; }
        .payload-field-value.object { color: #22d3ee; }
        .payload-raw-toggle { font-size: 10px; color: var(--text-muted); cursor: pointer; margin-top: 6px; }
        .payload-raw-toggle:hover { color: var(--primary-400); text-decoration: underline; }

        /* Event Actions */
        .event-actions { display: flex; gap: 6px; }
        .event-action-btn { padding: 4px 8px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: inline-flex; align-items: center; gap: 4px; transition: all var(--transition-fast); white-space: nowrap; }
        .event-action-btn:hover { background: var(--bg-hover); border-color: var(--primary-500); color: var(--primary-400); }
        .event-action-btn.primary { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .event-action-btn.primary:hover { background: var(--primary-600); }

        /* Infinite Scroll */
        .events-load-more { display: flex; align-items: center; justify-content: center; padding: 20px; gap: 10px; color: var(--text-muted); font-size: 13px; }
        .events-load-more .loading-spinner-small { width: 20px; height: 20px; border: 2px solid var(--border-primary); border-top-color: var(--primary-500); border-radius: 50%; animation: spin 0.8s linear infinite; }
        .events-end-message { text-align: center; padding: 20px; color: var(--text-muted); font-size: 12px; border-top: 1px solid var(--border-primary); }

        /* Point in Time Modal */
        .pit-modal { max-width: 900px; width: 95%; }
        .pit-modal-header { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .pit-modal-header .pit-info { flex: 1; }
        .pit-modal-header .pit-event-badge { font-size: 11px; background: rgba(245, 158, 11, 0.15); color: #fbbf24; padding: 4px 8px; border-radius: var(--radius-sm); font-family: var(--font-mono); }
        .pit-modal-header .pit-timestamp { font-size: 12px; color: var(--text-muted); }

        /* Historical Notice */
        .historical-notice { display: flex; align-items: center; gap: 8px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: var(--radius-md); padding: 10px 14px; margin: 0 24px 12px 24px; font-size: 12px; color: #fbbf24; }
        .historical-notice svg { flex-shrink: 0; }
        .historical-notice-text { line-height: 1.4; }
        .historical-notice-text strong { font-weight: 600; }
        .history-modal .historical-notice { margin: 12px 16px; }

        .pit-record-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); margin: 16px 24px; overflow: hidden; }
        .pit-record-header { background: var(--bg-tertiary); padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .pit-record-header .pit-table-name { font-weight: 600; color: var(--text-primary); }
        .pit-record-header .pit-record-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); }
        .pit-record-header .pit-go-to-table { margin-left: auto; }
        .pit-record-fields { padding: 16px; }
        .pit-field-row { display: flex; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .pit-field-row:last-child { border-bottom: none; }
        .pit-field-name { width: 180px; flex-shrink: 0; font-weight: 500; color: var(--text-primary); font-size: 13px; }
        .pit-field-value { flex: 1; font-size: 13px; color: var(--text-secondary); word-break: break-word; }
        .pit-empty-state { padding: 40px 20px; text-align: center; color: var(--text-muted); }

        /* Events View Controls */
        .events-controls { padding: 12px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .events-filter-group { display: flex; align-items: center; gap: 8px; }
        .events-filter-group label { font-size: 12px; color: var(--text-muted); font-weight: 500; }
        .events-filter-group select, .events-filter-group input { padding: 6px 10px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; background: var(--bg-tertiary); color: var(--text-primary); }
        .events-filter-group input { width: 150px; }
        .events-stats { margin-left: auto; font-size: 12px; color: var(--text-muted); }
        .events-actions { display: flex; gap: 8px; margin-left: 12px; }
        .events-actions .btn { padding: 5px 10px; font-size: 11px; }
        .events-actions .btn svg { width: 14px; height: 14px; }
        .import-status { position: fixed; bottom: 20px; right: 20px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 16px 20px; box-shadow: var(--shadow-lg); z-index: 1000; min-width: 280px; }
        .import-status.success { border-color: var(--success-500); }
        .import-status.error { border-color: var(--danger-500); }
        .import-status-title { font-weight: 600; font-size: 14px; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
        .import-status-title.success { color: var(--success-500); }
        .import-status-title.error { color: var(--danger-500); }
        .import-status-details { font-size: 12px; color: var(--text-muted); }
        .import-progress { margin-top: 8px; height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; }
        .import-progress-bar { height: 100%; background: var(--primary-500); transition: width 0.3s; }
        /* ===== Record Profile Panel ===== */
        .record-profile-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .record-profile-overlay.open { opacity: 1; visibility: visible; }
        .record-profile-panel { position: fixed; top: 0; right: 0; bottom: 0; width: 600px; max-width: 90vw; background: var(--bg-secondary); box-shadow: var(--shadow-xl); transform: translateX(100%); transition: transform 0.25s ease-out; display: flex; flex-direction: column; z-index: 1001; border-left: 1px solid var(--border-primary); }
        .record-profile-overlay.open .record-profile-panel { transform: translateX(0); }
        .profile-header { padding: 16px 20px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; background: var(--bg-tertiary); }
        .profile-header h2 { font-size: 16px; font-weight: 600; color: var(--text-primary); margin: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .profile-header .profile-view-name { flex: 1; font-size: 11px; color: var(--text-muted); background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); padding: 3px 8px; border-radius: var(--radius-sm); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .profile-header .profile-view-name:empty { display: none; }
        .profile-header .profile-record-id { font-size: 11px; color: var(--text-muted); font-family: var(--font-mono); }
        .profile-close { width: 32px; height: 32px; border: none; background: var(--bg-secondary); border-radius: var(--radius-md); cursor: pointer; font-size: 18px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .profile-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .profile-tabs { display: flex; border-bottom: 1px solid var(--border-primary); background: var(--bg-secondary); padding: 0 20px; }
        .profile-tab { padding: 12px 16px; font-size: 13px; font-weight: 500; color: var(--text-muted); cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -1px; transition: all var(--transition-fast); }
        .profile-tab:hover { color: var(--text-primary); }
        .profile-tab.active { color: var(--primary-400); border-bottom-color: var(--primary-500); }
        .profile-tab-content { display: none; flex: 1; overflow-y: auto; }
        .profile-tab-content.active { display: flex; flex-direction: column; }

        .profile-sync-history-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; text-align: center; color: var(--text-muted); flex: 1; }
        .profile-sync-history-empty svg { width: 48px; height: 48px; color: var(--text-disabled); margin-bottom: 16px; }
        .profile-sync-history-empty h3 { font-size: 16px; font-weight: 500; color: var(--text-primary); margin: 0 0 8px 0; }
        .profile-sync-history-empty p { font-size: 13px; color: var(--text-muted); margin: 0; }
        .profile-sync-history-list { padding: 16px 20px; }
        .profile-sync-history-item { padding: 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); margin-bottom: 8px; background: var(--bg-primary); }
        .profile-sync-history-item:last-child { margin-bottom: 0; }
        .profile-sync-history-item-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .profile-sync-history-field { font-weight: 500; color: var(--text-primary); font-size: 13px; }
        .profile-sync-history-type { font-size: 11px; padding: 2px 6px; border-radius: 3px; font-weight: 500; }
        .profile-sync-history-type.created { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .profile-sync-history-type.updated { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .profile-sync-history-type.deleted { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .profile-sync-history-time { margin-left: auto; font-size: 11px; color: var(--text-muted); }
        .profile-sync-history-values { display: flex; gap: 12px; font-size: 12px; }
        .profile-sync-history-value { flex: 1; padding: 6px 8px; border-radius: var(--radius-sm); word-break: break-word; }
        .profile-sync-history-value.old { background: rgba(239, 68, 68, 0.1); color: #fca5a5; }
        .profile-sync-history-value.new { background: rgba(34, 197, 94, 0.1); color: #86efac; }
        .profile-sync-history-value-label { font-size: 10px; font-weight: 500; text-transform: uppercase; margin-bottom: 2px; opacity: 0.7; }

        /* Profile Toolbar */
        .profile-toolbar { padding: 10px 20px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 8px; flex-wrap: wrap; background: var(--bg-secondary); }
        .profile-toolbar-label { font-size: 12px; color: var(--text-muted); }
        .profile-layout-btn { padding: 4px 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .profile-layout-btn:hover { background: var(--bg-hover); }
        .profile-layout-btn.active { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .profile-toolbar-spacer { flex: 1; }
        .profile-add-block-btn { padding: 4px 10px; background: var(--bg-secondary); border: 1px dashed var(--border-secondary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .profile-add-block-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-configure-btn { padding: 4px 10px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; }
        .profile-configure-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }

        /* Profile Body */
        .profile-body { flex: 1; overflow-y: auto; padding: 16px 20px; }
        .profile-block { margin-bottom: 16px; border: 1px solid var(--border-primary); border-radius: var(--radius-lg); background: var(--bg-primary); }
        .profile-block-header { padding: 8px 12px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); border-radius: var(--radius-lg) var(--radius-lg) 0 0; display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text-muted); }
        .profile-block-header .block-drag-handle { cursor: grab; color: var(--text-disabled); }
        .profile-block-header .block-drag-handle:hover { color: var(--text-muted); }
        .profile-block-header .block-title { flex: 1; font-weight: 500; color: var(--text-primary); }
        .profile-block-header .block-cols-select { padding: 2px 6px; border: 1px solid var(--border-primary); border-radius: 3px; font-size: 11px; background: var(--bg-secondary); color: var(--text-secondary); }
        .profile-block-header .block-remove-btn { background: none; border: none; color: var(--text-disabled); cursor: pointer; padding: 2px; }
        .profile-block-header .block-remove-btn:hover { color: var(--danger-500); }
        .profile-block-content { padding: 12px; }
        .profile-field-grid { display: grid; gap: 12px; }
        .profile-field-grid.cols-1 { grid-template-columns: 1fr; }
        .profile-field-grid.cols-2 { grid-template-columns: 1fr 1fr; }
        .profile-field-grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }

        .profile-field-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 10px 12px; transition: all var(--transition-fast); }
        .profile-field-card:hover { border-color: var(--border-secondary); }
        .profile-field-card.dragging { opacity: 0.5; border-color: var(--primary-500); }
        .profile-field-card.drag-over { border-color: var(--primary-500); background: rgba(59, 130, 246, 0.1); }
        .profile-field-name { font-size: 11px; font-weight: 500; color: var(--text-muted); margin-bottom: 4px; display: flex; align-items: center; gap: 6px; }
        .profile-field-name .field-drag-handle { cursor: grab; color: var(--text-disabled); font-size: 10px; }
        .profile-field-name .field-drag-handle:hover { color: var(--text-muted); }
        .profile-field-value { font-size: 13px; color: var(--text-primary); word-break: break-word; }
        .profile-field-value.empty { color: var(--text-disabled); font-style: italic; }

        /* Profile Navigation */
        .profile-nav { padding: 12px 20px; border-top: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; background: var(--bg-tertiary); }
        .profile-nav-btn { padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; transition: all var(--transition-fast); }
        .profile-nav-btn:hover:not(:disabled) { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .profile-nav-info { flex: 1; text-align: center; font-size: 12px; color: var(--text-muted); }
        .profile-nav-history { padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; }
        .profile-nav-history:hover { border-color: var(--primary-500); color: var(--primary-400); }

        /* Profile Configure Mode */
        .profile-body.configure-mode .profile-field-card { cursor: move; border-style: dashed; }
        .profile-body.configure-mode .profile-field-card .field-drag-handle { display: inline; }
        .profile-body:not(.configure-mode) .profile-field-card .field-drag-handle { display: none; }
        .profile-body.configure-mode .profile-block-header .block-drag-handle { display: inline; }
        .profile-body:not(.configure-mode) .profile-block-header .block-drag-handle { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header .block-cols-select { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header .block-remove-btn { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header { display: none; }
        .profile-body:not(.configure-mode) .profile-block { border: none; background: transparent; }
        .profile-body:not(.configure-mode) .profile-block-content { padding: 0; }
        .profile-body:not(.configure-mode) .profile-block { margin-bottom: 0; }

        /* Add Field to Block */
        .profile-add-field-btn { width: 100%; padding: 8px; background: var(--bg-secondary); border: 1px dashed var(--border-secondary); border-radius: var(--radius-md); cursor: pointer; font-size: 12px; color: var(--text-muted); margin-top: 8px; }
        .profile-add-field-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-body:not(.configure-mode) .profile-add-field-btn { display: none; }
        .profile-field-picker { position: fixed; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 1100; width: 240px; max-height: 300px; overflow-y: auto; }
        .profile-field-picker-header { padding: 10px 12px; border-bottom: 1px solid var(--border-primary); font-size: 12px; font-weight: 600; color: var(--text-primary); }
        .profile-field-picker-item { padding: 8px 12px; cursor: pointer; font-size: 13px; color: var(--text-secondary); display: flex; align-items: center; gap: 8px; }
        .profile-field-picker-item:hover { background: var(--bg-hover); }
        .profile-field-picker-item .field-type-badge { font-size: 10px; color: var(--text-muted); background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; }

        /* ===== Matrix Setup Wizard ===== */
        #matrix-wizard {
            position: fixed; inset: 0; background: var(--bg-primary);
            display: flex; align-items: center; justify-content: center;
            z-index: 150;
        }
        #matrix-wizard.hidden { display: none; }
        .wizard-container {
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl); padding: 0; width: 540px; max-width: 95vw;
            max-height: 90vh; overflow-y: auto; box-shadow: var(--shadow-xl);
        }
        .wizard-header {
            padding: 28px 32px 0; text-align: center;
        }
        .wizard-header h2 { font-size: 22px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; }
        .wizard-header p { font-size: 13px; color: var(--text-muted); margin-bottom: 0; }
        .wizard-steps {
            display: flex; justify-content: center; gap: 8px;
            padding: 20px 32px 0; margin-bottom: 0;
        }
        .wizard-step-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--border-secondary); transition: all 0.2s;
        }
        .wizard-step-dot.active { background: var(--primary-500); transform: scale(1.2); }
        .wizard-step-dot.completed { background: var(--success-500); }
        .wizard-body { padding: 24px 32px; }
        .wizard-body .form-group { margin-bottom: 18px; }
        .wizard-body .form-group label {
            display: block; font-size: 13px; font-weight: 500;
            color: var(--text-secondary); margin-bottom: 6px;
        }
        .wizard-body .form-group label .label-hint {
            font-weight: 400; color: var(--text-muted); font-size: 12px;
        }
        .wizard-body input[type="text"],
        .wizard-body input[type="password"],
        .wizard-body select {
            width: 100%; padding: 10px 12px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            color: var(--text-primary); font-size: 14px; box-sizing: border-box;
        }
        .wizard-body input:focus, .wizard-body select:focus {
            outline: none; border-color: var(--primary-500);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        .wizard-body .checkbox-group {
            display: flex; flex-direction: column; gap: 8px;
            max-height: 200px; overflow-y: auto;
            padding: 8px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
        }
        .wizard-body .checkbox-item {
            display: flex; align-items: center; gap: 10px;
            padding: 6px 8px; border-radius: var(--radius-sm);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
        }
        .wizard-body .checkbox-item:hover { background: var(--bg-hover); }
        .wizard-body .checkbox-item input[type="checkbox"] {
            width: 16px; height: 16px; accent-color: var(--primary-500);
        }
        .wizard-body .linked-record-row {
            display: flex; align-items: center; gap: 8px;
            padding: 8px 0; border-bottom: 1px solid var(--border-primary);
        }
        .wizard-body .linked-record-row:last-child { border-bottom: none; }
        .wizard-body .linked-record-row .table-name {
            min-width: 120px; font-size: 13px; font-weight: 500; color: var(--text-primary);
        }
        .wizard-body .linked-record-row select { flex: 1; }
        .wizard-footer {
            padding: 16px 32px 28px; display: flex; justify-content: space-between; gap: 12px;
        }
        .wizard-footer button {
            padding: 10px 24px; border-radius: var(--radius-md); font-size: 14px;
            font-weight: 500; cursor: pointer; transition: all var(--transition-fast);
        }
        .wizard-footer .btn-back {
            background: var(--bg-tertiary); border: 1px solid var(--border-primary);
            color: var(--text-muted);
        }
        .wizard-footer .btn-back:hover { background: var(--bg-hover); color: var(--text-primary); }
        .wizard-footer .btn-next {
            background: var(--primary-500); border: 1px solid var(--primary-500);
            color: #fff; margin-left: auto;
        }
        .wizard-footer .btn-next:hover { background: var(--primary-600); }
        .wizard-footer .btn-next:disabled { background: var(--gray-600); border-color: var(--gray-600); cursor: not-allowed; }
        .wizard-error {
            color: #f87171; font-size: 13px; padding: 10px 12px;
            background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: var(--radius-md); margin-bottom: 16px; display: none;
        }
        .wizard-success {
            color: #4ade80; font-size: 13px; padding: 10px 12px;
            background: rgba(34, 197, 94, 0.15); border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: var(--radius-md); margin-bottom: 16px;
        }
        .wizard-progress-section { margin-top: 16px; }
        .wizard-progress-bar {
            height: 6px; background: var(--bg-tertiary); border-radius: 3px;
            overflow: hidden; margin-bottom: 10px;
        }
        .wizard-progress-fill {
            height: 100%; background: linear-gradient(90deg, var(--primary-500), #7c3aed);
            transition: width 0.3s ease; border-radius: 3px;
        }
        .wizard-progress-status { font-size: 13px; color: var(--text-secondary); }
        .wizard-progress-detail { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
        .wizard-info-box {
            background: var(--bg-tertiary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-md); padding: 12px 16px; font-size: 12px;
            color: var(--text-secondary); line-height: 1.5; margin-bottom: 16px;
        }
        .wizard-info-box strong { color: var(--text-primary); }
        #room-manager {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5);
            display: flex; align-items: center; justify-content: center;
            z-index: 160;
        }
        #room-manager.hidden { display: none; }
        #room-manager .rm-client-row {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 10px; border-radius: var(--radius-sm);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
        }
        #room-manager .rm-client-row:hover { background: var(--bg-hover); }
        #room-manager .rm-client-row .rm-room-info {
            font-size: 11px; color: var(--text-muted); margin-left: auto;
        }
    </style>
</head>
<body>
    <!-- Encryption Unlock Screen -->
    <div id="unlock-screen" class="hidden">
        <!-- Setup Mode (first time) -->
        <div id="unlock-setup" class="unlock-box">
            <h2><span class="lock-icon">&#128274;</span> Secure Your Data</h2>
            <p class="subtitle">Set up encryption to protect your locally cached data</p>
            <div id="unlock-setup-error" class="unlock-error"></div>

            <div class="security-note">
                <strong>Why encrypt?</strong> Your API key and cached data will be encrypted before being stored in your browser. If someone gains access to your browser's storage, they won't be able to read your data without your password or passkey.
            </div>

            <div class="setup-section">
                <label for="setup-password">Create a password</label>
                <input type="password" id="setup-password" placeholder="Enter a strong password" autocomplete="new-password" oninput="updatePasswordStrength()">
                <div class="password-strength"><div class="password-strength-fill" id="password-strength-fill"></div></div>
            </div>

            <div class="setup-section">
                <label for="setup-password-confirm">Confirm password</label>
                <input type="password" id="setup-password-confirm" placeholder="Confirm your password" autocomplete="new-password">
            </div>

            <button id="setup-password-btn" onclick="setupEncryptionWithPassword()">Set Up with Password</button>

            <div class="unlock-divider">or</div>

            <button id="setup-passkey-btn" class="passkey-btn" onclick="setupEncryptionWithPasskey()">
                <span class="passkey-icon">&#128273;</span> Set Up with Passkey
            </button>

            <button id="skip-encryption-btn" class="secondary" onclick="skipEncryption()">Skip (Not Recommended)</button>

            <div class="unlock-info">
                Passkeys use your device's biometrics (Face ID, Touch ID, Windows Hello) for secure, passwordless authentication.
            </div>
        </div>

        <!-- Unlock Mode (returning user) -->
        <div id="unlock-prompt" class="unlock-box hidden">
            <h2><span class="lock-icon">&#128274;</span> Unlock Your Data</h2>
            <p class="subtitle">Enter your password or use your passkey to access your encrypted data</p>
            <div id="unlock-prompt-error" class="unlock-error"></div>

            <div id="passkey-unlock-section">
                <button id="passkey-unlock-btn" class="passkey-btn" onclick="unlockWithPasskey()">
                    <span class="passkey-icon">&#128273;</span> Unlock with Passkey
                </button>
                <div class="unlock-divider">or enter your password</div>
            </div>

            <input type="password" id="unlock-password" placeholder="Enter your password" autocomplete="current-password">
            <button id="unlock-password-btn" onclick="unlockWithPassword()">Unlock</button>

            <button id="clear-encrypted-data-btn" class="secondary" onclick="clearEncryptedData()">Clear All Data & Start Fresh</button>

            <div class="unlock-info">
                Forgot your password? You'll need to clear all local data and start fresh. Your data on the server is not affected.
            </div>
        </div>
    </div>

    <div id="synapse-login-screen" class="hidden">
        <div class="synapse-login-box">
            <h2>Connect to Matrix</h2>
            <p>Sign in to enable room sync and collaboration. Your data works locally without this.</p>
            <div id="synapse-login-error" class="synapse-error"></div>
            <label for="synapse-username">Username</label>
            <input type="text" id="synapse-username" placeholder="Username" autocomplete="username">
            <label for="synapse-password">Password</label>
            <input type="password" id="synapse-password" placeholder="Password" autocomplete="current-password">
            <button id="synapse-login-btn">Sign In</button>
            <button id="synapse-skip-btn" onclick="hideSynapseLoginScreen()" style="width: 100%; padding: 10px; background: transparent; border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-muted); font-size: 13px; cursor: pointer; margin-top: 8px;">Skip - Stay Local Only</button>
        </div>
    </div>

    <div id="auth-screen" class="hidden">
        <div class="auth-box">
            <h2>Amino Viewer</h2>
            <p>Connect to your Amino event stream</p>
            <div id="auth-error" class="auth-error"></div>
            <input type="password" id="api-key-input" placeholder="API Key" autocomplete="off">
            <input type="text" id="set-filter-input" placeholder="Filter by set (optional)" autocomplete="off">
            <button id="auth-submit">Connect</button>
            <button id="auth-clear" class="secondary hidden">Clear Local Data</button>
            <div id="auth-info" class="auth-info"></div>
        </div>
    </div>

    <!-- Initial Data Loading Overlay -->
    <div id="loading-overlay" class="hidden">
        <div class="loading-particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
        </div>
        <div class="loading-content">
            <div class="loading-logo">
                <div class="loading-logo-inner">A</div>
            </div>
            <h1 class="loading-title">Setting Up Your Workspace</h1>
            <p class="loading-subtitle">We're downloading your data to this device for lightning-fast access.</p>

            <div class="loading-facts">
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-tables">0</div>
                    <div class="loading-fact-label">Tables</div>
                </div>
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-fields">0</div>
                    <div class="loading-fact-label">Fields</div>
                </div>
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-records">0</div>
                    <div class="loading-fact-label">Records</div>
                </div>
            </div>

            <div class="loading-progress-container">
                <div class="loading-progress-bar">
                    <div class="loading-progress-fill" id="loading-progress-fill" style="width: 0%"></div>
                    <div class="loading-progress-activity"></div>
                </div>
                <div class="loading-status" id="loading-status">Connecting to server...</div>
                <div class="loading-detail" id="loading-detail">Page 1</div>
                <div class="loading-time-estimate" id="loading-time-estimate"></div>
            </div>

            <div class="loading-note">
                <strong>One-time setup:</strong> This only happens once per device. After this, your data loads instantly from local storage.
            </div>

            <!-- CSV/AMO manual import removed - hydration is automatic from cloud snapshot -->
        </div>
    </div>

    <!-- Connect API Key Modal -->
    <div id="connect-api-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; align-items: center; justify-content: center;">
        <div style="background: #fff; border-radius: 8px; padding: 24px; width: 360px; box-shadow: 0 4px 24px rgba(0,0,0,0.3);">
            <h3 style="font-size: 16px; margin-bottom: 6px; color: #333;">Connect API Key</h3>
            <p style="font-size: 13px; color: #666; margin-bottom: 16px;">Add your API key to enable syncing with the server.</p>
            <div id="connect-api-error" style="color: #dc3545; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: #f8d7da; border-radius: 4px; display: none;"></div>
            <input type="password" id="connect-api-key-input" placeholder="API Key" autocomplete="off" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <input type="text" id="connect-api-set-filter" placeholder="Filter by set (optional)" autocomplete="off" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <button id="connect-api-submit" onclick="submitConnectApi()" style="width: 100%; padding: 10px; background: #2d6cdf; border: none; border-radius: 6px; color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500;">Connect</button>
            <button onclick="hideConnectApiModal()" style="width: 100%; padding: 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 6px; color: #333; font-size: 14px; cursor: pointer; font-weight: 500;">Cancel</button>
        </div>
    </div>

    <!-- Matrix Setup Wizard -->
    <div id="matrix-wizard" class="hidden">
        <div class="wizard-container">
            <div class="wizard-header">
                <h2 id="wizard-title">Connect to Matrix</h2>
                <p id="wizard-subtitle">Set up your organization's secure data infrastructure</p>
            </div>
            <div class="wizard-steps" id="wizard-steps">
                <div class="wizard-step-dot active"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
            </div>
            <div class="wizard-body" id="wizard-body">
                <!-- Wizard content rendered dynamically per step -->
            </div>
            <div class="wizard-footer" id="wizard-footer">
                <button class="btn-back" id="wizard-back" onclick="wizardBack()">Back</button>
                <button class="btn-next" id="wizard-next" onclick="wizardNext()">Next</button>
            </div>
        </div>
    </div>

    <!-- Room Manager Panel (Admin) -->
    <div id="room-manager" class="hidden">
        <div class="wizard-container" style="width: 620px;">
            <div class="wizard-header">
                <h2 id="rm-title">Manage Rooms</h2>
                <p id="rm-subtitle">Select client rooms to delete</p>
            </div>
            <div class="wizard-body" id="rm-body">
                <div class="wizard-error" id="rm-error"></div>
                <div id="rm-list-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <label class="checkbox-item" style="padding: 0; margin: 0;">
                            <input type="checkbox" id="rm-select-all" onchange="rmToggleSelectAll(this.checked)">
                            <span style="font-weight: 500;">Select all</span>
                        </label>
                        <span id="rm-selected-count" style="font-size: 12px; color: var(--text-muted);">0 selected</span>
                    </div>
                    <div class="checkbox-group" id="rm-client-list" style="max-height: 320px;"></div>
                </div>
                <div id="rm-progress-section" style="display: none;">
                    <div class="wizard-progress-section">
                        <div class="wizard-progress-bar">
                            <div class="wizard-progress-fill" id="rm-progress" style="width: 0%"></div>
                        </div>
                        <div class="wizard-progress-status" id="rm-status">Preparing...</div>
                        <div class="wizard-progress-detail" id="rm-detail"></div>
                    </div>
                </div>
                <div id="rm-result-section" style="display: none;"></div>
            </div>
            <div class="wizard-footer" id="rm-footer">
                <button class="btn-back" onclick="hideRoomManager()">Cancel</button>
                <button class="btn-next" id="rm-delete-btn" onclick="rmConfirmDelete()" style="background: var(--error-500, #ef4444); border-color: var(--error-500, #ef4444);" disabled>Delete Selected</button>
            </div>
        </div>
    </div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-header-top">
                <div class="sidebar-logo">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <ellipse cx="12" cy="5" rx="9" ry="3"/>
                        <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/>
                        <path d="M3 12c0 1.66 4 3 9 3s9-1.34 9-3"/>
                    </svg>
                </div>
                <h2>Amino Viewer</h2>
            </div>
            <div class="sidebar-search">
                <span class="sidebar-search-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.3-4.3"/>
                    </svg>
                </span>
                <input type="text" id="sidebar-search-input" placeholder="Search tables..." />
                <span class="sidebar-search-shortcut">&#8984;K</span>
            </div>
        </div>
        <div id="table-list"></div>
        <div class="sidebar-footer">
            <button class="theme-toggle-btn" id="matrix-connect-btn" onclick="showSynapseLoginScreen()" title="Connect to Matrix for room sync">
                <span id="matrix-status-icon">&#9675;</span>
                <span id="matrix-status-label">Connect Matrix</span>
            </button>
            <button class="theme-toggle-btn" id="manage-rooms-btn" onclick="showRoomManager()" title="Manage Matrix rooms" style="display: none;">
                <span>&#9881;</span>
                <span>Manage Rooms</span>
            </button>
            <button class="theme-toggle-btn" onclick="toggleTheme()" title="Toggle light/dark theme">
                <span id="theme-icon">&#9788;</span>
                <span id="theme-label">Light Mode</span>
            </button>
        </div>
    </div>

    <div class="main">
        <!-- Browser Tab Bar -->
        <div class="tab-bar" id="tab-bar">
            <div class="tab-bar-tabs" id="tab-bar-tabs">
                <!-- Tabs rendered dynamically -->
            </div>
            <button class="tab-bar-new-tab" id="tab-bar-new-tab" onclick="openNewTab()" title="Open in new tab">+</button>
        </div>
        <!-- Data Viewer View -->
        <div id="data-view" style="display: flex; flex-direction: column; height: 100%;">
            <div class="toolbar">
                <h1 id="title">Select a table</h1>

                <!-- View Selector -->
                <div class="toolbar-views">
                    <div class="view-selector" id="view-selector-container">
                        <button class="view-selector-btn" id="view-selector-btn" onclick="toggleViewSelector()">
                            <span class="view-icon" id="current-view-icon">&#9638;</span>
                            <span class="view-name" id="current-view-name">All Fields</span>
                            <span class="dropdown-arrow">&#9662;</span>
                        </button>
                        <div class="view-selector-dropdown" id="view-selector-dropdown">
                            <!-- View options will be rendered here -->
                        </div>
                    </div>

                    <!-- Fields Button -->
                    <button class="fields-btn" id="fields-btn" onclick="toggleFieldsDropdown()">
                        <span class="fields-icon">&#9776;</span>
                        <span>Fields</span>
                        <span class="fields-count" id="fields-visible-count">0</span>
                    </button>
                    <div class="fields-dropdown" id="fields-dropdown">
                        <div class="fields-dropdown-header">
                            <h3>Toggle Fields</h3>
                            <div class="fields-dropdown-actions">
                                <button onclick="showAllFields()">Show All</button>
                                <button onclick="hideAllFields()">Hide All</button>
                            </div>
                        </div>
                        <div class="fields-search-container">
                            <input type="text" class="fields-search-input" id="fields-search-input" placeholder="Search fields..." oninput="filterFieldsDropdown(this.value)">
                        </div>
                        <div class="fields-dropdown-list" id="fields-dropdown-list">
                            <!-- Field items will be rendered here -->
                        </div>
                        <div class="fields-dropdown-footer">
                            Drag to reorder  Click checkbox to toggle
                        </div>
                    </div>
                </div>

                <!-- View Save Indicator -->
                <div class="view-save-indicator" id="view-save-indicator" style="display: none;">
                    <span class="save-dot"></span>
                    <span id="save-indicator-text">Saved</span>
                </div>
                <button class="view-save-btn" id="manual-save-btn" onclick="saveViewToBackendNow()" style="display: none;">Save Now</button>

                <button class="btn" onclick="manualSync()">Sync</button>
                <button class="btn" id="connect-api-btn" onclick="showConnectApiModal()" style="display: none; background: #2d6cdf; color: #fff;">Connect API</button>
                <button class="btn" onclick="logout()">Logout</button>
            </div>

            <!-- Airtable-style View Controls Bar -->
            <div class="view-controls-bar" id="view-controls-bar">
                <!-- Filter Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="filter-btn" onclick="toggleFilterDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M4 8h8M6 12h4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                        <span>Filter</span>
                        <span class="control-count" id="filter-count" style="display: none;">0</span>
                    </button>
                    <div class="view-control-dropdown filter-dropdown" id="filter-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Filter records</span>
                                <button class="dropdown-action-btn" onclick="addFilter()">+ Add filter</button>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="filter-search-input" placeholder="Find a field" oninput="filterFilterDropdown(this.value)">
                            </div>
                            <div class="filter-list" id="filter-list">
                                <div class="empty-filters">No filters applied</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sort Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="sort-btn" onclick="toggleSortDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 5l2-2 2 2M6 3v10M12 11l-2 2-2-2M10 13V3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
                        <span>Sort</span>
                        <span class="control-count" id="sort-count" style="display: none;">0</span>
                    </button>
                    <div class="view-control-dropdown sort-dropdown" id="sort-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Sort records</span>
                                <button class="dropdown-action-btn" onclick="addSort()">+ Add sort</button>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="sort-search-input" placeholder="Find a field" oninput="filterSortDropdown(this.value)">
                            </div>
                            <div class="sort-list" id="sort-list">
                                <div class="empty-sorts">No sorts applied</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Group Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="group-btn" onclick="toggleGroupDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="2" y="3" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="3" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="2" y="9" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="9" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/></svg>
                        <span>Group</span>
                    </button>
                    <div class="view-control-dropdown group-dropdown" id="group-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Group records by</span>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="group-search-input" placeholder="Find a field" oninput="filterGroupDropdown(this.value)">
                            </div>
                            <div class="group-options" id="group-options">
                                <div class="group-option none-selected" onclick="setGroupBy(null)">
                                    <span class="check-mark">&#10003;</span>
                                    <span>None</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Color Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="color-btn" onclick="toggleColorDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="5" stroke="currentColor" stroke-width="1.5"/><path d="M8 3v10M3 8h10" stroke="currentColor" stroke-width="1.5"/></svg>
                        <span>Color</span>
                    </button>
                    <div class="view-control-dropdown color-dropdown" id="color-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Color records by</span>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="color-search-input" placeholder="Find a field" oninput="filterColorDropdown(this.value)">
                            </div>
                            <div class="color-options" id="color-options">
                                <div class="color-option none-selected" onclick="setColorBy(null)">
                                    <span class="check-mark">&#10003;</span>
                                    <span>None</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Row Height Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="row-height-btn" onclick="toggleRowHeightDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                        <span>Row height</span>
                    </button>
                    <div class="view-control-dropdown row-height-dropdown" id="row-height-dropdown">
                        <div class="dropdown-section">
                            <div class="row-height-option" onclick="setRowHeight('short')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 6h12M2 10h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Short</span>
                            </div>
                            <div class="row-height-option selected" onclick="setRowHeight('medium')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Medium</span>
                            </div>
                            <div class="row-height-option" onclick="setRowHeight('tall')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 3h12M2 7h12M2 11h12M2 15h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Tall</span>
                            </div>
                            <div class="row-height-option" onclick="setRowHeight('extra-tall')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 2h12M2 5h12M2 8h12M2 11h12M2 14h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Extra tall</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="view-controls-spacer"></div>

                <!-- Search -->
                <div class="view-search-wrapper">
                    <svg class="search-icon" width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="7" cy="7" r="4.5" stroke="currentColor" stroke-width="1.5"/><path d="M10.5 10.5L14 14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                    <input type="text" class="view-search-input" id="view-search-input" placeholder="Find in view" oninput="handleViewSearch(this.value)">
                </div>
            </div>
            <div class="status-bar">
                <span class="status-dot" id="status-dot"></span>
                <span id="status-text">Ready</span>
                <div class="progress-bar" id="progress-bar" style="display: none; flex: 1; max-width: 200px;">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <span id="status-detail" style="color: #999; font-size: 11px;"></span>
                <div class="sync-toggle-wrapper">
                    <button class="sync-feed-btn" id="sync-feed-btn" onclick="SyncStatusFeed.toggle()" title="View sync activity log">[log]</button>
                </div>
                <div class="sync-toggle-wrapper">
                    <span class="sync-toggle-label">Sync to Box</span>
                    <div class="sync-toggle" id="box-sync-toggle" onclick="toggleBoxSync()">
                        <div class="sync-toggle-knob"></div>
                    </div>
                    <button class="sync-feed-btn" id="box-push-btn" onclick="manualBoxPush()" title="Manually push snapshot to Box">[push]</button>
                </div>
                <span style="flex: 1;"></span>
                <span class="refresh-indicator" id="refresh-indicator">
                    <span class="refresh-dot"></span>
                    <span id="last-refresh-text">Auto-refresh in 60s</span>
                </span>
            </div>
            <div class="table-container" id="table-container">
                <table id="table"></table>
            </div>
            <div class="pagination" id="pagination">
                <button id="prev-btn" onclick="prevPage()">Previous</button>
                <span class="page-info" id="page-info">Page 1</span>
                <button id="next-btn" onclick="nextPage()">Next</button>
            </div>
        </div>
    </div>

    <!-- View Context Menu -->
    <div class="view-context-menu" id="view-context-menu">
        <div class="view-context-menu-item" onclick="moveViewToFolder()">
            <span>&#128193;</span> Move to folder...
        </div>
        <div class="view-context-menu-item" onclick="renameView()">
            <span>&#9998;</span> Rename
        </div>
        <div class="view-context-menu-item" onclick="manageViewTags()">
            <span>&#127991;</span> Manage tags...
        </div>
        <div class="view-context-menu-item" onclick="addViewToWorkspaceMenu()">
            <span>&#11088;</span> Add to workspace...
        </div>
        <div class="view-context-menu-item" onclick="setViewParent()">
            <span>&#128279;</span> Set parent view...
        </div>
        <div class="view-context-menu-separator"></div>
        <div class="view-context-menu-item danger" onclick="deleteView()">
            <span>&#128465;</span> Delete
        </div>
    </div>

    <!-- Table Context Menu -->
    <div class="view-context-menu" id="table-context-menu">
        <div class="view-context-menu-item" onclick="createViewFolderFromContextMenu()">
            <span>&#128193;</span> New folder
        </div>
    </div>

    <!-- Column Context Menu -->
    <div class="view-context-menu" id="column-context-menu">
        <div class="view-context-menu-item" onclick="hideColumnFromContextMenu()">
            <span>&#128065;</span> Hide column
        </div>
    </div>

    <!-- Field History Modal -->
    <div class="modal-overlay" id="history-modal-overlay" onclick="closeHistoryModal(event)">
        <div class="modal history-modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 id="history-modal-title">Field History</h2>
                <button class="modal-close" onclick="closeHistoryModal()">&times;</button>
            </div>
            <div class="modal-toolbar">
                <label>Filter by field:</label>
                <select id="history-field-filter" onchange="filterHistoryByField()">
                    <option value="">All Fields</option>
                </select>
                <span class="history-count" id="history-count"></span>
            </div>
            <div class="historical-notice">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M8 4.5V8L10.5 9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="historical-notice-text"><strong>Historical data:</strong> Values shown are what was recorded at the time of each change, not the current state of the record.</span>
            </div>
            <div class="modal-body" id="history-modal-body">
                <!-- History items will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Create View Modal -->
    <div class="create-view-modal" id="create-view-modal" onclick="closeCreateViewModal(event)">
        <div class="create-view-modal-content" onclick="event.stopPropagation()">
            <div class="create-view-modal-header">
                <h2>Create New View</h2>
                <p id="create-view-reason">Customize this view with your own filters and field settings.</p>
            </div>
            <div class="create-view-modal-body">
                <div class="create-view-field">
                    <label for="create-view-name">View Name</label>
                    <input type="text" id="create-view-name" placeholder="Enter view name...">
                </div>
                <div class="create-view-field">
                    <label for="create-view-type">View Type</label>
                    <select id="create-view-type">
                        <option value="grid">Grid View</option>
                        <option value="schema">Schema View (Cards)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-parent">Parent View (for nesting)</label>
                    <select id="create-view-parent">
                        <option value="">(No parent - root level)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-tags">Tags (comma-separated)</label>
                    <input type="text" id="create-view-tags" placeholder="e.g., reports, daily, team-a">
                </div>
                <div class="create-view-field">
                    <label for="create-view-workspace">Add to Workspace</label>
                    <select id="create-view-workspace">
                        <option value="">(None)</option>
                    </select>
                </div>
            </div>
            <div class="create-view-modal-footer">
                <button class="btn-cancel" onclick="closeCreateViewModal()">Cancel</button>
                <button class="btn-create" id="create-view-submit" onclick="submitCreateView()">Create View</button>
            </div>
        </div>
    </div>

    <!-- Point in Time Modal -->
    <div class="modal-overlay" id="pit-modal-overlay" onclick="closePitModal(event)">
        <div class="modal pit-modal" onclick="event.stopPropagation()">
            <div class="modal-header pit-modal-header">
                <div class="pit-info">
                    <h2 id="pit-modal-title">Record at Point in Time</h2>
                    <span class="pit-timestamp" id="pit-modal-timestamp"></span>
                </div>
                <span class="pit-event-badge" id="pit-modal-event-badge"></span>
                <button class="modal-close" onclick="closePitModal()">&times;</button>
            </div>
            <div class="historical-notice">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M8 4.5V8L10.5 9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="historical-notice-text"><strong>Snapshot:</strong> This shows the record as it existed at this point in time, not its current state. Click "View Current Record" to see the latest data.</span>
            </div>
            <div class="modal-body" id="pit-modal-body">
                <!-- Record state will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Record Profile Slide-out Panel -->
    <div class="record-profile-overlay" id="record-profile-overlay" onclick="closeRecordProfile(event)">
        <div class="record-profile-panel" onclick="event.stopPropagation()">
            <div class="profile-header">
                <h2 id="profile-title">Record</h2>
                <span class="profile-view-name" id="profile-view-name"></span>
                <span class="profile-record-id" id="profile-record-id"></span>
                <button class="profile-close" onclick="closeRecordProfile()">&times;</button>
            </div>
            <div class="profile-tabs">
                <div class="profile-tab active" data-tab="details" onclick="switchProfileTab('details')">Case Details</div>
                <div class="profile-tab" data-tab="sync-history" onclick="switchProfileTab('sync-history')">Sync History</div>
            </div>
            <div class="profile-tab-content active" id="profile-tab-details">
                <div class="profile-toolbar" id="profile-toolbar">
                    <button class="profile-configure-btn" id="profile-configure-btn" onclick="toggleProfileConfigureMode()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                        Configure
                    </button>
                    <div class="profile-toolbar-spacer"></div>
                    <button class="profile-add-block-btn" id="profile-add-block-btn" onclick="addProfileBlock()" style="display: none;">+ Add Block</button>
                </div>
                <div class="profile-body" id="profile-body">
                    <!-- Profile content will be rendered here -->
                </div>
            </div>
            <div class="profile-tab-content" id="profile-tab-sync-history">
                <!-- Sync history content will be rendered here -->
            </div>
            <div class="profile-nav">
                <button class="profile-nav-btn" id="profile-prev-btn" onclick="navigateProfile(-1)">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15,18 9,12 15,6"/></svg>
                    Prev
                </button>
                <span class="profile-nav-info" id="profile-nav-info">1 of 100</span>
                <button class="profile-nav-btn" id="profile-next-btn" onclick="navigateProfile(1)">
                    Next
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9,18 15,12 9,6"/></svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Room Publishing Modal -->
    <div class="room-publish-modal hidden" id="room-publish-modal" onclick="closeRoomPublishModal(event)">
        <div class="room-publish-box" onclick="event.stopPropagation()">
            <h2>Publish to Matrix Rooms</h2>
            <p class="pub-subtitle">Select tables to publish as Matrix rooms. Each table becomes a room with its schema and records stored as state events.</p>
            <div id="room-publish-not-connected" style="display: none;">
                <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                    <p style="margin-bottom: 12px;">Not connected to Matrix. Sign in first to publish rooms.</p>
                    <button class="pub-btn-publish" onclick="closeRoomPublishModal(); showSynapseLoginScreen();">Sign in to Matrix</button>
                </div>
            </div>
            <div id="room-publish-content">
                <div class="room-publish-section">
                    <h3>Organization</h3>
                    <div id="pub-org-section">
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="pub-org-name" placeholder="Organization name" style="flex:1; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;">
                            <span id="pub-org-status" style="font-size: 12px; color: var(--text-muted);"></span>
                        </div>
                    </div>
                </div>
                <div class="room-publish-section">
                    <h3>Tables to Publish</h3>
                    <div id="pub-table-list">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                <div class="room-publish-section">
                    <h3>Client Grouping (Optional)</h3>
                    <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">If you want per-client rooms, select the table and field that identifies clients.</p>
                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        <select id="pub-client-table" style="flex:1; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;" onchange="pubClientTableChanged()">
                            <option value="">No client grouping</option>
                        </select>
                        <select id="pub-client-field" style="flex:1; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;" disabled>
                            <option value="">Select identifier field</option>
                        </select>
                    </div>
                </div>
                <div id="pub-progress-section" style="display: none;">
                    <div class="pub-progress">
                        <div class="pub-progress-bar"><div class="pub-progress-fill" id="pub-progress-fill" style="width: 0%"></div></div>
                        <div class="pub-progress-text" id="pub-progress-text">Preparing...</div>
                    </div>
                </div>
            </div>
            <div class="pub-actions">
                <button class="pub-btn-cancel" onclick="closeRoomPublishModal()">Cancel</button>
                <button class="pub-btn-publish" id="pub-publish-btn" onclick="executeRoomPublish()">Publish Selected</button>
            </div>
        </div>
    </div>

    <!-- Sync Status Feed Panel -->
    <div class="sync-feed-panel" id="sync-feed-panel">
        <div class="sync-feed-header">
            <div class="sync-feed-header-left">
                <span class="sync-feed-status-dot" id="sync-feed-status-dot"></span>
                <span>Sync Activity</span>
            </div>
            <button class="sync-feed-close" onclick="SyncStatusFeed.hide()">&times;</button>
        </div>
        <div class="sync-feed-body" id="sync-feed-body">
            <div class="sync-feed-empty">No sync activity yet</div>
        </div>
        <div class="sync-feed-footer">
            <span id="sync-feed-stats">Idle</span>
            <button onclick="SyncStatusFeed.clear()">Clear</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@msgpack/msgpack@3.1.2/dist.umd/msgpack.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="matrix.js"></script>

    <script>
// ============ Theme Management ============
(function() {
    var saved = localStorage.getItem('amino_theme');
    if (saved === 'light') document.documentElement.classList.add('light-theme');
})();

function toggleTheme() {
    var html = document.documentElement;
    var isLight = html.classList.toggle('light-theme');
    localStorage.setItem('amino_theme', isLight ? 'light' : 'dark');
    var icon = document.getElementById('theme-icon');
    var label = document.getElementById('theme-label');
    if (icon) icon.textContent = isLight ? '\u263E' : '\u2606';
    if (label) label.textContent = isLight ? 'Dark Mode' : 'Light Mode';
}

// ============ Tab Bar Management ============
var openTabs = []; // { id, tableId, tableName, viewId, viewName, icon }
var activeTabId = null;

function generateTabId() {
    return 'tab_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
}

function openTableInTab(tableId, tableName, icon) {
    // Check if already open
    var existing = openTabs.find(function(t) { return t.tableId === tableId; });
    if (existing) {
        activeTabId = existing.id;
        // Update name if changed
        if (tableName) existing.tableName = tableName;
        renderTabBar();
        return;
    }
    var tab = { id: generateTabId(), tableId: tableId, tableName: tableName || tableId, icon: icon || '' };
    openTabs.push(tab);
    activeTabId = tab.id;
    renderTabBar();
}

var _tabNavInProgress = false;
function activateTab(tabId) {
    var tab = openTabs.find(function(t) { return t.id === tabId; });
    if (!tab) return;
    if (activeTabId === tabId && !_tabNavInProgress) { renderTabBar(); return; }
    activeTabId = tabId;
    renderTabBar();
    // Prevent re-entrant calls from showTable -> openTableInTab -> activateTab
    if (_tabNavInProgress) return;
    _tabNavInProgress = true;
    // Navigate to the appropriate view
    if (tab.tableId === '_events' && typeof showEventsView === 'function') {
        showEventsView().finally(function() { _tabNavInProgress = false; });
    } else if (tab.tableId === '_sync_status' && typeof showSyncStatusView === 'function') {
        showSyncStatusView().finally(function() { _tabNavInProgress = false; });
    } else if (typeof showTable === 'function') {
        showTable(tab.tableId).finally(function() { _tabNavInProgress = false; });
    } else {
        _tabNavInProgress = false;
    }
}

function closeTab(tabId, evt) {
    if (evt) { evt.stopPropagation(); evt.preventDefault(); }
    var idx = openTabs.findIndex(function(t) { return t.id === tabId; });
    if (idx === -1) return;
    openTabs.splice(idx, 1);
    if (activeTabId === tabId) {
        if (openTabs.length > 0) {
            var newIdx = Math.min(idx, openTabs.length - 1);
            activateTab(openTabs[newIdx].id);
        } else {
            activeTabId = null;
        }
    }
    renderTabBar();
}

function openNewTab() {
    // Focus the sidebar search to let user pick a table
    var searchInput = document.getElementById('sidebar-search-input');
    if (searchInput) { searchInput.focus(); searchInput.select(); }
}

function renderTabBar() {
    var container = document.getElementById('tab-bar-tabs');
    if (!container) return;
    container.innerHTML = '';
    openTabs.forEach(function(tab) {
        var el = document.createElement('div');
        el.className = 'browser-tab' + (tab.id === activeTabId ? ' active' : '');
        el.onclick = function() { activateTab(tab.id); };

        var iconEl = document.createElement('span');
        iconEl.className = 'tab-icon';
        iconEl.textContent = tab.icon || '\u25A6';
        el.appendChild(iconEl);

        var titleEl = document.createElement('span');
        titleEl.className = 'tab-title';
        titleEl.textContent = tab.tableName;
        el.appendChild(titleEl);

        if (openTabs.length > 1) {
            var closeEl = document.createElement('button');
            closeEl.className = 'tab-close';
            closeEl.textContent = '\u00D7';
            closeEl.onclick = function(e) { closeTab(tab.id, e); };
            el.appendChild(closeEl);
        }

        container.appendChild(el);
    });

    // Update theme icon state on render
    var saved = localStorage.getItem('amino_theme');
    var icon = document.getElementById('theme-icon');
    var label = document.getElementById('theme-label');
    if (icon) icon.textContent = saved === 'light' ? '\u263E' : '\u2606';
    if (label) label.textContent = saved === 'light' ? 'Dark Mode' : 'Light Mode';
}

var API = null; // Secured: initialized after authentication via initSecureEndpoints()
var DB_NAME = 'aminostream';
var DB_VERSION = 7;
var PAGE_SIZE = 100;

var API_KEY = null;
var SET_FILTER = null;
var db = null;

// ============ Encryption Configuration ============
var ENCRYPTION_CONFIG_KEY = 'amino_encryption_config';
var ENCRYPTED_CREDENTIALS_KEY = 'amino_encrypted_credentials';
var encryptionKey = null; // CryptoKey object, only kept in memory
var encryptionEnabled = false;
var passkeyCredentialId = null; // For WebAuthn

// ============ Secure Endpoint Management ============
// Webhook/API URLs are not stored in plaintext. They are encrypted with the
// user's API key using AES-GCM and persisted in localStorage. On first auth,
// endpoints are decoded from obfuscated bootstrap data, then encrypted and
// stored. On subsequent logins, they are decrypted from localStorage using
// the API key. If decryption fails (wrong key), endpoints remain null and
// no API calls can be made.
var ENCRYPTED_ENDPOINTS_KEY = 'amino_encrypted_endpoints';

// Obfuscated bootstrap endpoint data (not plaintext URLs)
var _EP = [
    'aHR0cHM6Ly94dmtxLXBxN2ktaWR0bC5uN2QueGFuby5pby9hcGk6bnJJTC1PaS0vYW1pbm9zdHJlYW0=',
    'aHR0cHM6Ly94dmtxLXBxN2ktaWR0bC5uN2QueGFuby5pby9hcGk6bnJJTC1PaS0vYW1pbm9zdHJlYW1wb3N0',
    'aHR0cHM6Ly9uOG4uaW50ZWxlY2hpYS5jb20vd2ViaG9vay9ib3gtdXBsb2Fk',
    'aHR0cHM6Ly9uOG4uaW50ZWxlY2hpYS5jb20vd2ViaG9vay9ib3gtZG93bmxvYWQ='
];

// Derive an AES-GCM key from the API key for endpoint encryption
async function deriveEndpointKey(apiKey) {
    var encoder = new TextEncoder();
    var keyMaterial = await crypto.subtle.importKey(
        'raw', encoder.encode(apiKey), 'PBKDF2', false, ['deriveKey']
    );
    return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: encoder.encode('amino-endpoints-v1'), iterations: 50000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
}

// Initialize secure endpoints after successful API key authentication
async function initSecureEndpoints(apiKey) {
    // Try to decrypt endpoints from localStorage first
    var stored = localStorage.getItem(ENCRYPTED_ENDPOINTS_KEY);
    if (stored) {
        try {
            var parsed = JSON.parse(stored);
            var key = await deriveEndpointKey(apiKey);
            var iv = Uint8Array.from(atob(parsed.iv), function(c) { return c.charCodeAt(0); });
            var data = Uint8Array.from(atob(parsed.data), function(c) { return c.charCodeAt(0); });
            var decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, key, data);
            var endpoints = JSON.parse(new TextDecoder().decode(decrypted));
            API = endpoints[0];
            XANO_POST_API = endpoints[1];
            BOX_SYNC_WEBHOOK = endpoints[2];
            BOX_DOWNLOAD_WEBHOOK = endpoints[3];
            return;
        } catch (e) {
            // Decryption failed (wrong key or corrupted data) - fall through to bootstrap
            localStorage.removeItem(ENCRYPTED_ENDPOINTS_KEY);
        }
    }

    // Bootstrap: decode from obfuscated source
    API = atob(_EP[0]);
    XANO_POST_API = atob(_EP[1]);
    BOX_SYNC_WEBHOOK = atob(_EP[2]);
    BOX_DOWNLOAD_WEBHOOK = atob(_EP[3]);

    // Encrypt endpoints with the user's API key and store for future use
    try {
        var key = await deriveEndpointKey(apiKey);
        var iv = crypto.getRandomValues(new Uint8Array(12));
        var encoder = new TextEncoder();
        var plaintext = encoder.encode(JSON.stringify([API, XANO_POST_API, BOX_SYNC_WEBHOOK, BOX_DOWNLOAD_WEBHOOK]));
        var encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, plaintext);
        var ivStr = '';
        for (var i = 0; i < iv.length; i++) ivStr += String.fromCharCode(iv[i]);
        var encArr = new Uint8Array(encrypted);
        var encStr = '';
        for (var j = 0; j < encArr.length; j++) encStr += String.fromCharCode(encArr[j]);
        localStorage.setItem(ENCRYPTED_ENDPOINTS_KEY, JSON.stringify({
            iv: btoa(ivStr),
            data: btoa(encStr)
        }));
    } catch (e) {
        console.warn('Failed to encrypt endpoints for storage:', e);
    }
}

// Clear all endpoint URLs from memory and storage (called on logout)
function clearSecureEndpoints() {
    API = null;
    XANO_POST_API = null;
    BOX_SYNC_WEBHOOK = null;
    BOX_DOWNLOAD_WEBHOOK = null;
    localStorage.removeItem(ENCRYPTED_ENDPOINTS_KEY);
}

// ============ Web Crypto API Utilities ============

// Generate a random salt for key derivation
function generateSalt() {
    return crypto.getRandomValues(new Uint8Array(16));
}

// Generate a random IV for AES-GCM encryption
function generateIV() {
    return crypto.getRandomValues(new Uint8Array(12));
}

// Derive an encryption key from a password using PBKDF2
async function deriveKeyFromPassword(password, salt) {
    var encoder = new TextEncoder();
    var passwordKey = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        'PBKDF2',
        false,
        ['deriveBits', 'deriveKey']
    );

    return crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        },
        passwordKey,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
}

// Encrypt data using AES-GCM
async function encryptData(data, key) {
    var encoder = new TextEncoder();
    var iv = generateIV();
    var encodedData = encoder.encode(JSON.stringify(data));

    var encryptedBuffer = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encodedData
    );

    // Combine IV and encrypted data
    var combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encryptedBuffer), iv.length);

    return arrayBufferToBase64(combined);
}

// Decrypt data using AES-GCM
async function decryptData(encryptedBase64, key) {
    var combined = base64ToArrayBuffer(encryptedBase64);
    var iv = combined.slice(0, 12);
    var encryptedData = combined.slice(12);

    var decryptedBuffer = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encryptedData
    );

    var decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decryptedBuffer));
}

// Helper: Convert ArrayBuffer to Base64
function arrayBufferToBase64(buffer) {
    var bytes = new Uint8Array(buffer);
    var binary = '';
    for (var i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

// Helper: Convert Base64 to ArrayBuffer
function base64ToArrayBuffer(base64) {
    var binary = atob(base64);
    var bytes = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

// ============ WebAuthn Passkey Utilities ============

// Check if WebAuthn is supported
function isPasskeySupported() {
    return !!(window.PublicKeyCredential && navigator.credentials);
}

// Create a new passkey for encryption
async function createPasskey() {
    if (!isPasskeySupported()) {
        throw new Error('Passkeys are not supported in this browser');
    }

    // Generate a random challenge
    var challenge = crypto.getRandomValues(new Uint8Array(32));
    var userId = crypto.getRandomValues(new Uint8Array(16));

    var publicKeyOptions = {
        challenge: challenge,
        rp: {
            name: 'Amino Viewer',
            id: window.location.hostname
        },
        user: {
            id: userId,
            name: 'amino-user',
            displayName: 'Amino Viewer User'
        },
        pubKeyCredParams: [
            { alg: -7, type: 'public-key' },   // ES256
            { alg: -257, type: 'public-key' }  // RS256
        ],
        authenticatorSelection: {
            authenticatorAttachment: 'platform',
            userVerification: 'required',
            residentKey: 'required'
        },
        timeout: 60000,
        attestation: 'none',
        extensions: {
            prf: {
                eval: {
                    first: new TextEncoder().encode('amino-encryption-key')
                }
            }
        }
    };

    var credential = await navigator.credentials.create({ publicKey: publicKeyOptions });

    // Check if PRF extension is supported
    var prfSupported = credential.getClientExtensionResults().prf !== undefined;

    return {
        credentialId: arrayBufferToBase64(credential.rawId),
        userId: arrayBufferToBase64(userId),
        prfSupported: prfSupported
    };
}

// Authenticate with an existing passkey
async function authenticateWithPasskey(credentialId) {
    if (!isPasskeySupported()) {
        throw new Error('Passkeys are not supported in this browser');
    }

    var challenge = crypto.getRandomValues(new Uint8Array(32));

    var publicKeyOptions = {
        challenge: challenge,
        allowCredentials: [{
            id: base64ToArrayBuffer(credentialId),
            type: 'public-key'
        }],
        userVerification: 'required',
        timeout: 60000,
        extensions: {
            prf: {
                eval: {
                    first: new TextEncoder().encode('amino-encryption-key')
                }
            }
        }
    };

    var assertion = await navigator.credentials.get({ publicKey: publicKeyOptions });

    // Check if PRF was used
    var prfResult = assertion.getClientExtensionResults().prf;

    return {
        credentialId: arrayBufferToBase64(assertion.rawId),
        prfOutput: prfResult ? arrayBufferToBase64(prfResult.results.first) : null,
        authenticatorData: arrayBufferToBase64(assertion.response.authenticatorData)
    };
}

// Derive encryption key from passkey authentication
async function deriveKeyFromPasskey(prfOutput, salt) {
    if (prfOutput) {
        // PRF is supported - use PRF output directly
        var prfBytes = base64ToArrayBuffer(prfOutput);
        var keyMaterial = await crypto.subtle.importKey(
            'raw',
            prfBytes,
            'HKDF',
            false,
            ['deriveBits', 'deriveKey']
        );

        return crypto.subtle.deriveKey(
            {
                name: 'HKDF',
                salt: salt,
                info: new TextEncoder().encode('amino-aes-key'),
                hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    } else {
        // PRF not supported - fall back to using authenticator data hash
        throw new Error('Your authenticator does not support the PRF extension needed for encryption. Please use a password instead.');
    }
}

// ============ Password Strength Checker ============

function checkPasswordStrength(password) {
    var strength = 0;
    if (password.length >= 8) strength++;
    if (password.length >= 12) strength++;
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
    if (/[0-9]/.test(password)) strength++;
    if (/[^a-zA-Z0-9]/.test(password)) strength++;

    if (strength <= 2) return 'weak';
    if (strength <= 3) return 'medium';
    return 'strong';
}

function updatePasswordStrength() {
    var password = document.getElementById('setup-password').value;
    var strengthFill = document.getElementById('password-strength-fill');
    strengthFill.className = 'password-strength-fill';

    if (password.length > 0) {
        var strength = checkPasswordStrength(password);
        strengthFill.classList.add(strength);
    }
}

// ============ Encryption Setup & Unlock Functions ============

// Check if encryption is already set up
function getEncryptionConfig() {
    var configStr = localStorage.getItem(ENCRYPTION_CONFIG_KEY);
    if (!configStr) return null;
    try {
        return JSON.parse(configStr);
    } catch (e) {
        return null;
    }
}

// Save encryption configuration
function saveEncryptionConfig(config) {
    localStorage.setItem(ENCRYPTION_CONFIG_KEY, JSON.stringify(config));
}

// Session key persistence: store encryption key in sessionStorage to survive refresh
var SESSION_KEY_STORAGE = 'amino_session_key';

async function saveSessionKey(key) {
    try {
        var raw = await crypto.subtle.exportKey('raw', key);
        sessionStorage.setItem(SESSION_KEY_STORAGE, arrayBufferToBase64(raw));
    } catch (e) {
        console.warn('Could not save session key:', e);
    }
}

async function loadSessionKey() {
    var stored = sessionStorage.getItem(SESSION_KEY_STORAGE);
    if (!stored) return null;
    try {
        var raw = base64ToArrayBuffer(stored);
        return await crypto.subtle.importKey(
            'raw',
            raw,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    } catch (e) {
        console.warn('Could not restore session key:', e);
        sessionStorage.removeItem(SESSION_KEY_STORAGE);
        return null;
    }
}

function clearSessionKey() {
    sessionStorage.removeItem(SESSION_KEY_STORAGE);
}

// Show the unlock screen (setup or prompt mode)
function showUnlockScreen(mode) {
    // Cancel any pending hide timeout to prevent race condition
    if (_hideUnlockTimeout) { clearTimeout(_hideUnlockTimeout); _hideUnlockTimeout = null; }

    var unlockScreen = document.getElementById('unlock-screen');
    var setupBox = document.getElementById('unlock-setup');
    var promptBox = document.getElementById('unlock-prompt');

    unlockScreen.classList.remove('hidden', 'fading-out');

    if (mode === 'setup') {
        setupBox.classList.remove('hidden');
        promptBox.classList.add('hidden');

        // Hide passkey button if not supported
        if (!isPasskeySupported()) {
            document.getElementById('setup-passkey-btn').style.display = 'none';
        }
    } else {
        setupBox.classList.add('hidden');
        promptBox.classList.remove('hidden');

        // Check encryption config for passkey vs password
        var config = getEncryptionConfig();
        var passkeySection = document.getElementById('passkey-unlock-section');
        var passwordInput = document.getElementById('unlock-password');
        var passwordBtn = document.getElementById('unlock-password-btn');
        if (config && config.type === 'passkey' && isPasskeySupported()) {
            passkeySection.style.display = 'block';
            passkeyCredentialId = config.credentialId;
            // Hide password fields for passkey-only users
            passwordInput.style.display = 'none';
            passwordBtn.style.display = 'none';
        } else {
            passkeySection.style.display = 'none';
            passwordInput.style.display = '';
            passwordBtn.style.display = '';
        }
    }
}

// Hide the unlock screen
var _hideUnlockTimeout = null;
function hideUnlockScreen() {
    var el = document.getElementById('unlock-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        if (_hideUnlockTimeout) { clearTimeout(_hideUnlockTimeout); _hideUnlockTimeout = null; }
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    _hideUnlockTimeout = setTimeout(function() { _hideUnlockTimeout = null; el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

// Show error on unlock screen
function showUnlockError(mode, message) {
    var errorId = mode === 'setup' ? 'unlock-setup-error' : 'unlock-prompt-error';
    var errorEl = document.getElementById(errorId);
    errorEl.textContent = message;
    errorEl.style.display = 'block';
}

// Hide error on unlock screen
function hideUnlockError(mode) {
    var errorId = mode === 'setup' ? 'unlock-setup-error' : 'unlock-prompt-error';
    document.getElementById(errorId).style.display = 'none';
}

// Set up encryption with password
async function setupEncryptionWithPassword() {
    hideUnlockError('setup');

    var password = document.getElementById('setup-password').value;
    var confirmPassword = document.getElementById('setup-password-confirm').value;

    if (!password) {
        showUnlockError('setup', 'Please enter a password');
        return;
    }

    if (password.length < 8) {
        showUnlockError('setup', 'Password must be at least 8 characters');
        return;
    }

    if (password !== confirmPassword) {
        showUnlockError('setup', 'Passwords do not match');
        return;
    }

    var btn = document.getElementById('setup-password-btn');
    btn.disabled = true;
    btn.textContent = 'Setting up...';

    try {
        var salt = generateSalt();
        encryptionKey = await deriveKeyFromPassword(password, salt);

        // Create verification token
        var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, encryptionKey);

        // Save config
        saveEncryptionConfig({
            type: 'password',
            salt: arrayBufferToBase64(salt),
            verificationToken: verificationToken
        });

        encryptionEnabled = true;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Encryption setup failed:', e);
        showUnlockError('setup', 'Failed to set up encryption: ' + e.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Set Up with Password';
    }
}

// Set up encryption with passkey
async function setupEncryptionWithPasskey() {
    hideUnlockError('setup');

    if (!isPasskeySupported()) {
        showUnlockError('setup', 'Passkeys are not supported in this browser');
        return;
    }

    var btn = document.getElementById('setup-passkey-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Setting up...';

    try {
        var passkeyResult = await createPasskey();

        if (!passkeyResult.prfSupported) {
            showUnlockError('setup', 'Your device does not support the encryption features needed for passkey-based encryption. Please use a password instead.');
            return;
        }

        // Authenticate immediately to get PRF output
        var authResult = await authenticateWithPasskey(passkeyResult.credentialId);

        if (!authResult.prfOutput) {
            showUnlockError('setup', 'Failed to get encryption key from passkey. Please use a password instead.');
            return;
        }

        var salt = generateSalt();
        encryptionKey = await deriveKeyFromPasskey(authResult.prfOutput, salt);

        // Create verification token
        var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, encryptionKey);

        // Save config
        saveEncryptionConfig({
            type: 'passkey',
            credentialId: passkeyResult.credentialId,
            salt: arrayBufferToBase64(salt),
            verificationToken: verificationToken
        });

        encryptionEnabled = true;
        passkeyCredentialId = passkeyResult.credentialId;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Passkey setup failed:', e);
        if (e.name === 'NotAllowedError') {
            showUnlockError('setup', 'Passkey setup was cancelled. Please try again.');
        } else {
            showUnlockError('setup', 'Failed to set up passkey: ' + e.message);
        }
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Set Up with Passkey';
    }
}

// Skip encryption (not recommended)
function skipEncryption() {
    if (!confirm('Are you sure? Your API key and cached data will be stored unencrypted, which means anyone with access to your browser could read them.')) {
        return;
    }

    saveEncryptionConfig({ type: 'none' });
    encryptionEnabled = false;
    encryptionKey = null;
    hideUnlockScreen();
    initAuthScreen();
}

// Unlock with password
async function unlockWithPassword() {
    hideUnlockError('prompt');

    var password = document.getElementById('unlock-password').value;
    if (!password) {
        showUnlockError('prompt', 'Please enter your password');
        return;
    }

    var btn = document.getElementById('unlock-password-btn');
    btn.disabled = true;
    btn.textContent = 'Unlocking...';

    try {
        var config = getEncryptionConfig();
        if (!config || !config.salt) {
            throw new Error('Invalid encryption configuration');
        }

        var salt = base64ToArrayBuffer(config.salt);
        encryptionKey = await deriveKeyFromPassword(password, salt);

        // Verify the key
        try {
            await decryptData(config.verificationToken, encryptionKey);
        } catch (e) {
            throw new Error('Incorrect password');
        }

        encryptionEnabled = true;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        document.getElementById('unlock-password').value = '';
        initAuthScreen();
    } catch (e) {
        console.error('Unlock failed:', e);
        showUnlockError('prompt', e.message || 'Failed to unlock');
        encryptionKey = null;
    } finally {
        btn.disabled = false;
        btn.textContent = 'Unlock';
    }
}

// Unlock with passkey
async function unlockWithPasskey() {
    hideUnlockError('prompt');

    var btn = document.getElementById('passkey-unlock-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Unlocking...';

    try {
        var config = getEncryptionConfig();
        if (!config || config.type !== 'passkey') {
            throw new Error('Passkey not configured');
        }

        var authResult = await authenticateWithPasskey(config.credentialId);

        if (!authResult.prfOutput) {
            throw new Error('Failed to get encryption key from passkey');
        }

        var salt = base64ToArrayBuffer(config.salt);
        encryptionKey = await deriveKeyFromPasskey(authResult.prfOutput, salt);

        // Verify the key
        try {
            await decryptData(config.verificationToken, encryptionKey);
        } catch (e) {
            throw new Error('Passkey authentication failed');
        }

        encryptionEnabled = true;
        passkeyCredentialId = config.credentialId;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Passkey unlock failed:', e);
        if (e.name === 'NotAllowedError') {
            showUnlockError('prompt', 'Passkey authentication was cancelled. Please try again.');
        } else {
            showUnlockError('prompt', e.message || 'Failed to unlock with passkey');
        }
        encryptionKey = null;
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Unlock with Passkey';
    }
}

// Clear all encrypted data and start fresh
async function clearEncryptedData() {
    if (!confirm('This will delete ALL local data including your cached database. Your data on the server is not affected. Continue?')) {
        return;
    }

    try {
        // Clear localStorage encryption config and credentials
        localStorage.removeItem(ENCRYPTION_CONFIG_KEY);
        localStorage.removeItem(ENCRYPTED_CREDENTIALS_KEY);
        localStorage.removeItem('amino_api_key');
        localStorage.removeItem('amino_set_filter');

        // Clear IndexedDB
        await new Promise((resolve, reject) => {
            var req = indexedDB.deleteDatabase(DB_NAME);
            req.onsuccess = resolve;
            req.onerror = () => reject(req.error);
        });

        encryptionKey = null;
        encryptionEnabled = false;
        passkeyCredentialId = null;

        // Show setup screen
        showUnlockScreen('setup');
    } catch (e) {
        console.error('Failed to clear data:', e);
        alert('Failed to clear data: ' + e.message);
    }
}

// ============ Encrypted Credentials Storage ============

// Save API credentials (encrypted if encryption is enabled)
async function saveEncryptedCredentials(apiKey, setFilter) {
    var credentials = { apiKey: apiKey, setFilter: setFilter };

    if (encryptionEnabled && encryptionKey) {
        var encrypted = await encryptData(credentials, encryptionKey);
        localStorage.setItem(ENCRYPTED_CREDENTIALS_KEY, encrypted);
        // Remove plaintext credentials
        localStorage.removeItem('amino_api_key');
        localStorage.removeItem('amino_set_filter');
    } else {
        // Store as plaintext (no encryption)
        localStorage.setItem('amino_api_key', apiKey);
        if (setFilter) {
            localStorage.setItem('amino_set_filter', setFilter);
        } else {
            localStorage.removeItem('amino_set_filter');
        }
    }
}

// Load API credentials (decrypt if necessary)
async function loadEncryptedCredentials() {
    if (encryptionEnabled && encryptionKey) {
        var encrypted = localStorage.getItem(ENCRYPTED_CREDENTIALS_KEY);
        if (encrypted) {
            try {
                return await decryptData(encrypted, encryptionKey);
            } catch (e) {
                console.error('Failed to decrypt credentials:', e);
                return null;
            }
        }
    } else {
        var apiKey = localStorage.getItem('amino_api_key');
        if (apiKey) {
            return {
                apiKey: apiKey,
                setFilter: localStorage.getItem('amino_set_filter')
            };
        }
    }
    return null;
}

// Clear saved credentials
function clearEncryptedCredentials() {
    localStorage.removeItem(ENCRYPTED_CREDENTIALS_KEY);
    localStorage.removeItem('amino_api_key');
    localStorage.removeItem('amino_set_filter');
}

// ============ Encrypted IndexedDB Wrapper ============

// Encrypt data before storing in IndexedDB
async function encryptForStorage(data) {
    if (encryptionEnabled && encryptionKey) {
        return {
            _encrypted: true,
            data: await encryptData(data, encryptionKey)
        };
    }
    return data;
}

// Decrypt data after retrieving from IndexedDB
async function decryptFromStorage(data) {
    if (data && data._encrypted && encryptionEnabled && encryptionKey) {
        return await decryptData(data.data, encryptionKey);
    }
    return data;
}

// ============ Encryption Init Flow ============

// Initialize encryption system - called before anything else
async function initEncryption() {
    var config = getEncryptionConfig();

    if (!config) {
        // First time user - show setup screen
        showUnlockScreen('setup');
        return false;
    }

    if (config.type === 'none') {
        // User chose to skip encryption
        encryptionEnabled = false;
        encryptionKey = null;
        return true;
    }

    // Check for session key (survives page refresh within same tab)
    var sessionKey = await loadSessionKey();
    if (sessionKey && config.verificationToken) {
        try {
            await decryptData(config.verificationToken, sessionKey);
            // Session key is valid
            encryptionKey = sessionKey;
            encryptionEnabled = true;
            return true;
        } catch (e) {
            // Session key is stale or invalid
            clearSessionKey();
        }
    }

    // User has encryption set up - show unlock screen
    showUnlockScreen('prompt');
    return false;
}

// Only keep lightweight metadata in memory
var META_TABLES = {};
var META_FIELDS = {};
var META_VIEWS = {};

// Human-readable names for entity/event types
var ENTITY_TYPE_NAMES = {
    'data': 'Data',
    'INS': 'Insert',
    'ALT': 'Alter',
    'NUL': 'Nullify',
    'SYN': 'Sync',
    'table': 'Table',
    'field': 'Field',
    'view': 'View',
    'viewConfig': 'View Config',
    'tableSettings': 'Table Settings',
    'current': 'Current State'
};

var currentTable = null;
var currentView = null; // Current view ID or null for "All Fields" default
var currentPage = 0;
var currentRecordIds = [];
var totalRecords = 0;
var lastEventTimestamp = null; // ISO timestamp of last synced event
var pollInterval = null;
var navVersion = 0; // Navigation guard to prevent race conditions when rapidly switching views

// View field configuration cache (in-memory, persisted to IndexedDB)
// Structure: VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [...], fieldOrder: [...] }
// Note: Views default to showing ALL fields; hiddenFieldIds stores fields to hide
var VIEW_FIELD_CONFIG = {};

// View folders: Structure: VIEW_FOLDERS[tableId][folderId] = { folderId, folderName, parentFolderId, sortOrder, isExpanded }
var VIEW_FOLDERS = {};

// Workspaces: Structure: WORKSPACES[workspaceId] = { workspaceId, workspaceName, viewIds: [], sortOrder }
var WORKSPACES = {};
var currentWorkspace = null; // Current active workspace filter

// Table Settings: User-specific preferences for tables and views
// Structure: TABLE_SETTINGS = {
//   tables: {
//     [tableId]: {
//       visible: boolean,      // Whether table is visible in sidebar
//       sortOrder: number      // Custom sort order
//     }
//   },
//   tableOrder: string[],      // Array of tableIds in user's preferred order
//   views: {
//     [viewId]: {
//       isPublic: boolean,     // Whether view is public (shared) or private
//       sortOrder: number      // Custom sort order within table
//     }
//   }
// }
var TABLE_SETTINGS = {
    tables: {},
    tableOrder: [],
    views: {}
};

// ============ Sidebar Configuration ============
// Table type definitions with colors and icons
var TABLE_TYPE_CONFIG = {
    primary: {
        color: '#ef4444',
        label: 'Primary',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>'
    },
    events: {
        color: '#f59e0b',
        label: 'Events',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>'
    },
    syncStatus: {
        color: '#10b981',
        label: 'Sync Status',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>'
    },
    operational: {
        color: '#3b82f6',
        label: 'Operational',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="3" x2="21" y1="9" y2="9"/><line x1="3" x2="21" y1="15" y2="15"/><line x1="9" x2="9" y1="9" y2="21"/><line x1="15" x2="15" y1="9" y2="21"/></svg>'
    },
    collection: {
        color: '#8b5cf6',
        label: 'Collections',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>'
    },
    reference: {
        color: '#10b981',
        label: 'Reference',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg>'
    },
    dev: {
        color: '#6b7280',
        label: 'Dev / Testing',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>'
    }
};

// Sidebar state (pinned tables, recent tables, expanded sections, search)
var SIDEBAR_STATE = {
    pinnedTables: [],
    recentTables: [],
    expandedSections: {
        primary: true,
        pinned: true,
        recent: true,
        operational: true,
        collections: false,
        reference: false,
        dev: false
    },
    searchQuery: '',
    maxRecentTables: 5
};

// Determine table type based on name patterns
function getTableType(tableName) {
    var name = (tableName || '').toLowerCase();

    // Primary tables (always at top for everyone)
    if (name === 'client info') return 'primary';
    if (name === 'case master view') return 'primary';
    if (name === 'events') return 'primary';

    // Events
    if (name.includes('event') && name.includes('stream')) return 'events';

    // Collections (date patterns)
    if (name.includes('collection')) return 'collection';
    if (/\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/.test(name)) return 'collection';
    if (/\d{1,2}(st|nd|rd|th)?\s*-\s*\d{1,2}(st|nd|rd|th)?/.test(name)) return 'collection';

    // Reference (small lookup tables)
    if (name.includes('dictionary') || name.includes('appendix') || name.includes('info')) return 'reference';
    if (name.includes('type') && !name.includes('activity')) return 'reference';

    // Dev
    if (name.includes('test') || name.includes('dev') || name.includes('data test')) return 'dev';

    // Default to operational
    return 'operational';
}

// Format record count (e.g., 73262 -> "73.3k")
function formatRecordCount(count) {
    if (count >= 1000) return (count / 1000).toFixed(1) + 'k';
    return count.toString();
}

// Get count bar width ratio (logarithmic scale)
function getCountBarWidth(count, maxCount) {
    if (count <= 0 || maxCount <= 0) return 0;
    var ratio = Math.log(count + 1) / Math.log(maxCount + 1);
    return Math.max(0.15, ratio);
}

// Add table to recent list
function addToRecentTables(tableId) {
    if (tableId === '_events') return;
    var recent = SIDEBAR_STATE.recentTables.filter(id => id !== tableId);
    recent.unshift(tableId);
    SIDEBAR_STATE.recentTables = recent.slice(0, SIDEBAR_STATE.maxRecentTables);
    saveSidebarState();
}

// Toggle table pin
function toggleTablePin(tableId, event) {
    if (event) event.stopPropagation();
    var idx = SIDEBAR_STATE.pinnedTables.indexOf(tableId);
    if (idx >= 0) {
        SIDEBAR_STATE.pinnedTables.splice(idx, 1);
    } else {
        SIDEBAR_STATE.pinnedTables.push(tableId);
    }
    saveSidebarState();
    renderSidebar();
}

// Toggle sidebar section
function toggleSidebarSection(sectionId) {
    SIDEBAR_STATE.expandedSections[sectionId] = !SIDEBAR_STATE.expandedSections[sectionId];
    saveSidebarState();
    renderSidebar();
}

// Save sidebar state to localStorage
function saveSidebarState() {
    try {
        localStorage.setItem('aminoSidebarState', JSON.stringify(SIDEBAR_STATE));
    } catch (e) { /* ignore */ }
}

// Load sidebar state from localStorage
function loadSidebarState() {
    try {
        var saved = localStorage.getItem('aminoSidebarState');
        if (saved) {
            var parsed = JSON.parse(saved);
            SIDEBAR_STATE.pinnedTables = parsed.pinnedTables || [];
            SIDEBAR_STATE.recentTables = parsed.recentTables || [];
            SIDEBAR_STATE.expandedSections = Object.assign({}, SIDEBAR_STATE.expandedSections, parsed.expandedSections || {});
        }
    } catch (e) { /* ignore */ }
}

// Initialize sidebar search functionality
function initSidebarSearch() {
    var searchInput = document.getElementById('sidebar-search-input');
    if (!searchInput) return;

    var debounceTimer = null;

    // Search input handler with debounce
    searchInput.addEventListener('input', function(e) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(function() {
            SIDEBAR_STATE.searchQuery = e.target.value;
            renderSidebar();
        }, 200);
    });

    // Clear search on Escape
    searchInput.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            searchInput.value = '';
            SIDEBAR_STATE.searchQuery = '';
            searchInput.blur();
            renderSidebar();
        }
    });

    // Keyboard shortcut: Cmd+K / Ctrl+K to focus search
    document.addEventListener('keydown', function(e) {
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            searchInput.focus();
            searchInput.select();
        }
    });
}

// SVG icons for sidebar
var SIDEBAR_ICONS = {
    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>',
    star: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    starFilled: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    clock: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>'
};

// Pending view action (when user tries to modify default view)
var pendingViewAction = null; // { action: 'filter'|'sort'|'fields'|'group', data: any }

// Box auto-sync state (off by default)
var boxSyncEnabled = false;
var BOX_SYNC_WEBHOOK = null; // Secured: initialized after authentication via initSecureEndpoints()
var BOX_DOWNLOAD_WEBHOOK = null; // Secured: initialized after authentication via initSecureEndpoints()
var BOX_SYNC_FOLDER_ID = '364363223627';
var BOX_SYNC_FILENAME = 'amino-snapshot.amo';

// ============ Events View State ============
var eventsPageSize = 50;
var eventsTypeFilter = ''; // 'INS', 'ALT', 'NUL', 'SYN', 'table', 'field', 'view', 'viewConfig', or '' for all
var eventsSetFilter = ''; // Filter by set (table id)
var eventsSearchQuery = '';
var expandedPayloads = new Set(); // Set of event IDs with expanded payloads
var appOpenedEventId = 0; // Highest event ID when app was opened (events with higher IDs are "new")

// Infinite scroll state
var loadedEvents = []; // All currently loaded events
var eventsOffset = 0; // Current offset for loading more
var isLoadingMoreEvents = false; // Prevent multiple simultaneous loads
var hasMoreEvents = true; // Whether there are more events to load
var eventsScrollHandler = null; // Reference to scroll handler for cleanup

// In-memory event cache for fast startup from file import
// Events are loaded into memory first for instant UI, then saved to IndexedDB in background
var inMemoryEvents = null; // Array of events or null if not using memory cache
var inMemoryEventsByRecord = null; // Map of recordId -> array of events for fast lookup
var isBackgroundSaveInProgress = false; // Track background IndexedDB save status

// ============ View Auto-Save System ============
var XANO_POST_API = null; // Secured: initialized after authentication via initSecureEndpoints()
var AUTO_SAVE_DELAY = 5 * 60 * 1000; // 5 minutes
var autoSaveTimer = null;

var viewDirtyState = {
    isDirty: false,
    lastEditTime: null,
    pendingChanges: {
        tableId: null,
        viewId: null,
        changes: {}
    }
};

// ============ AminoSync - Event Stream Client ============

var AminoSync = {
    // Post event to aminoStream
    async postEvent(event) {
        if (!API_KEY || !XANO_POST_API) throw new Error('Not authenticated');
        var streamRes = await fetch(XANO_POST_API + '?apiKey=' + encodeURIComponent(API_KEY), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(event)
        });

        if (!streamRes.ok) {
            throw new Error('Failed to post event: HTTP ' + streamRes.status);
        }

        var streamResult = await streamRes.json();
        return { eventId: streamResult.id, streamResult };
    }
};

// ============ AmoFormat - Binary Event Stream Format (.amo) ============
// Compact binary representation using MessagePack + gzip with columnar compression.
// Extension: .amo | MIME: application/x-amino-snapshot

var AmoFormat = {
    MAGIC: 'AMO1',
    VERSION: 1,
    HEADER_SIZE: 8,

    // Produce a .amo binary from the full event stream
    // events: array of raw aminoStream events (id, set, recordId, operator, created_at, payload, uuid, ...)
    // meta: optional { tables: META_TABLES, fields: META_FIELDS } to preserve table/field names
    // Returns: Uint8Array
    produceEvents: function(events, meta) {
        // Collect all unique keys across all events for the columnar schema
        var colSet = {};
        for (var i = 0; i < events.length; i++) {
            var keys = Object.keys(events[i]);
            for (var k = 0; k < keys.length; k++) {
                // Skip encrypted payload marker  we store the decrypted payload
                if (keys[k] !== '_encryptedPayload') {
                    colSet[keys[k]] = true;
                }
            }
        }
        // Ensure core columns come first for readability
        var coreColumns = ['id', 'set', 'recordId', 'operator', 'created_at', 'payload', 'uuid'];
        var columns = [];
        for (var c = 0; c < coreColumns.length; c++) {
            if (colSet[coreColumns[c]]) {
                columns.push(coreColumns[c]);
                delete colSet[coreColumns[c]];
            }
        }
        var extra = Object.keys(colSet);
        for (var e = 0; e < extra.length; e++) {
            columns.push(extra[e]);
        }

        // Convert events to positional arrays
        var rows = [];
        var maxId = 0;
        for (var j = 0; j < events.length; j++) {
            var ev = events[j];
            var row = [];
            for (var col = 0; col < columns.length; col++) {
                var val = ev[columns[col]];
                row.push(val !== undefined ? val : null);
            }
            rows.push(row);
            if (ev.id > maxId) maxId = ev.id;
        }

        var schema = { '_events': columns };
        var records = { '_events': rows };

        // Encode payload with MessagePack
        var payload = { v: 1, type: 'events', ts: Math.floor(Date.now() / 1000), cursor: maxId, schema: schema, records: records };
        if (meta) payload.meta = meta;
        var encoded = MessagePack.encode(payload);

        // Compress with gzip
        var compressed = pako.gzip(encoded);

        // Prepend 8-byte header: "AMO1" + version(1) + flags(0) + reserved(0,0)
        var header = new Uint8Array([0x41, 0x4D, 0x4F, 0x31, 0x01, 0x00, 0x00, 0x00]);
        var out = new Uint8Array(8 + compressed.length);
        out.set(header);
        out.set(compressed, 8);
        return out;
    },

    // Read a .amo binary file
    // arrayBuffer: ArrayBuffer or Uint8Array of the .amo file
    // Returns: { type: 'events'|'snapshot', events?: [...], tables?: {...}, cursor, ts, meta? }
    read: function(arrayBuffer) {
        var bytes = new Uint8Array(arrayBuffer);

        // Validate header
        if (bytes.length < this.HEADER_SIZE) {
            throw new Error('File too small to be a .amo file');
        }
        var magic = String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]);
        if (magic !== this.MAGIC) {
            throw new Error('Not a .amo file (bad magic bytes)');
        }
        if (bytes[4] !== this.VERSION) {
            throw new Error('Unknown .amo version: ' + bytes[4]);
        }
        if (bytes[5] !== 0x00) {
            throw new Error('Unsupported .amo flags: 0x' + bytes[5].toString(16));
        }

        // Decompress + decode
        var compressed = bytes.slice(this.HEADER_SIZE);
        var decompressed = pako.ungzip(compressed);
        var payload = MessagePack.decode(decompressed);

        // Check if this is the new events format
        if (payload.type === 'events') {
            var columns = payload.schema['_events'];
            var rows = payload.records['_events'] || [];
            var events = [];
            for (var j = 0; j < rows.length; j++) {
                var obj = {};
                for (var k = 0; k < columns.length; k++) {
                    obj[columns[k]] = (k < rows[j].length) ? (rows[j][k] !== undefined ? rows[j][k] : null) : null;
                }
                events.push(obj);
            }
            var result = { type: 'events', events: events, cursor: payload.cursor, ts: payload.ts };
            if (payload.meta) result.meta = payload.meta;
            return result;
        }

        // Legacy snapshot format: re-hydrate positional arrays back into objects
        var tables = {};
        var schemaEntries = Object.entries(payload.schema);
        for (var i = 0; i < schemaEntries.length; i++) {
            var tableName = schemaEntries[i][0];
            var cols = schemaEntries[i][1];
            var tblRows = payload.records[tableName] || [];
            tables[tableName] = [];
            for (var j2 = 0; j2 < tblRows.length; j2++) {
                var obj2 = {};
                for (var k2 = 0; k2 < cols.length; k2++) {
                    obj2[cols[k2]] = (k2 < tblRows[j2].length) ? (tblRows[j2][k2] !== undefined ? tblRows[j2][k2] : null) : null;
                }
                tables[tableName].push(obj2);
            }
        }

        var result2 = { type: 'snapshot', tables: tables, cursor: payload.cursor, ts: payload.ts };
        if (payload.meta) result2.meta = payload.meta;
        return result2;
    },

    // Detect the format of a buffer
    // Returns: 'amo' | 'json-gz' | 'json'
    detectFormat: function(buffer) {
        var b = new Uint8Array(buffer.slice(0, 4));
        if (b[0] === 0x41 && b[1] === 0x4D && b[2] === 0x4F && b[3] === 0x31) return 'amo';
        if (b[0] === 0x1F && b[1] === 0x8B) return 'json-gz';
        if (b[0] === 0x7B || b[0] === 0x5B) return 'json';
        throw new Error('Unknown format');
    }
};

// ============ Sync Status Feed ============
// Terminal-style log for sync activity visibility

var SyncStatusFeed = {
    maxLines: 100,
    lines: [],
    isVisible: false,
    isActive: false,

    // Log a message to the feed
    log(message, type) {
        type = type || 'info';
        var timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        this.lines.push({ timestamp: timestamp, message: message, type: type });

        // Trim to max lines
        if (this.lines.length > this.maxLines) {
            this.lines = this.lines.slice(-this.maxLines);
        }

        this.render();
        this.updateButton();
    },

    info(message) { this.log(message, 'info'); },
    success(message) { this.log(message, 'success'); },
    error(message) { this.log(message, 'error'); },
    warn(message) { this.log(message, 'warn'); },

    // Set active state (sync in progress)
    setActive(active) {
        this.isActive = active;
        var dot = document.getElementById('sync-feed-status-dot');
        if (dot) {
            dot.className = 'sync-feed-status-dot' + (active ? ' active' : '');
        }
        this.updateStats();
    },

    // Set error state
    setError() {
        var dot = document.getElementById('sync-feed-status-dot');
        if (dot) {
            dot.className = 'sync-feed-status-dot error';
        }
    },

    // Update the [log] button to indicate activity
    updateButton() {
        var btn = document.getElementById('sync-feed-btn');
        if (btn && this.lines.length > 0) {
            btn.classList.add('has-activity');
        }
    },

    // Update stats display
    updateStats() {
        var statsEl = document.getElementById('sync-feed-stats');
        if (statsEl) {
            statsEl.textContent = 'Idle';
        }
    },

    // Render the feed content
    render() {
        var body = document.getElementById('sync-feed-body');
        if (!body) return;

        if (this.lines.length === 0) {
            body.innerHTML = '<div class="sync-feed-empty">No sync activity yet</div>';
            return;
        }

        var html = '';
        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];
            html += '<div class="sync-feed-line ' + line.type + '">';
            html += '<span class="timestamp">' + line.timestamp + '</span>';
            html += '<span class="message">' + esc(line.message) + '</span>';
            html += '</div>';
        }
        body.innerHTML = html;

        // Auto-scroll to bottom
        body.scrollTop = body.scrollHeight;
    },

    // Show the panel
    show() {
        var panel = document.getElementById('sync-feed-panel');
        if (panel) {
            panel.classList.add('visible');
            this.isVisible = true;
            this.updateStats();
        }
    },

    // Hide the panel
    hide() {
        var panel = document.getElementById('sync-feed-panel');
        if (panel) {
            panel.classList.remove('visible');
            this.isVisible = false;
        }
    },

    // Toggle visibility
    toggle() {
        if (this.isVisible) {
            this.hide();
        } else {
            this.show();
        }
    },

    // Clear all lines
    clear() {
        this.lines = [];
        this.render();
        var btn = document.getElementById('sync-feed-btn');
        if (btn) btn.classList.remove('has-activity');
    }
};

// ============ Sync History Tracker ============
// Tracks all sync operations for the Sync Status view

var SyncHistory = {
    maxEntries: 200,
    entries: [],
    pollInterval: null,
    POLL_INTERVAL: 15000, // 15 seconds - base poll interval
    MAX_POLL_INTERVAL: 300000, // 5 minutes - max backoff cap
    isPolling: false,
    consecutiveFailures: 0,
    currentPollInterval: 15000, // tracks the active interval (may be backed off)
    listeners: [],

    // Calculate next poll interval with exponential backoff + jitter
    getBackoffInterval() {
        if (this.consecutiveFailures === 0) return this.POLL_INTERVAL;
        // Exponential backoff: base * 2^failures, capped at MAX_POLL_INTERVAL
        var exponential = this.POLL_INTERVAL * Math.pow(2, this.consecutiveFailures);
        var capped = Math.min(exponential, this.MAX_POLL_INTERVAL);
        // Add jitter: +/- 20% to avoid thundering herd
        var jitter = capped * 0.2 * (Math.random() * 2 - 1);
        return Math.round(capped + jitter);
    },

    // Record a sync operation
    record(entry) {
        this.entries.unshift({
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 5),
            timestamp: new Date(),
            type: entry.type || 'incremental',    // 'incremental', 'full', 'snapshot', 'poll'
            result: entry.result || 'success',      // 'success', 'error', 'no-change'
            eventsFound: entry.eventsFound || 0,
            snapshotsUpdated: entry.snapshotsUpdated || 0,
            duration: entry.duration || 0,
            detail: entry.detail || '',
            error: entry.error || null
        });
        if (this.entries.length > this.maxEntries) {
            this.entries = this.entries.slice(0, this.maxEntries);
        }
        this.notify();
    },

    // Poll the API for new events since last known timestamp.
    // Uses a lightweight "last" query to check if any new events exist,
    // then triggers a full incremental sync only when new data is available.
    async pollForUpdates() {
        if (this.isPolling || !API_KEY) return;
        this.isPolling = true;
        var pollStart = Date.now();
        try {
            // Lightweight check: fetch only the single most recent event
            // If created_after is set, this tells us if anything new exists since our last sync
            var hasNewEvents = false;
            if (lastEventTimestamp) {
                var peek = await fetchPage(1, lastEventTimestamp, { last: true });
                hasNewEvents = peek.events && peek.events.length > 0;
            } else {
                // No lastEventTimestamp means we haven't synced yet - check for any events
                var peek = await fetchPage(1, null, { last: true });
                hasNewEvents = peek.events && peek.events.length > 0;
            }

            // Poll succeeded - reset backoff state
            if (this.consecutiveFailures > 0) {
                var wasBackedOff = this.consecutiveFailures;
                this.consecutiveFailures = 0;
                this.currentPollInterval = this.POLL_INTERVAL;
                this.record({
                    type: 'poll',
                    result: 'success',
                    duration: Date.now() - pollStart,
                    detail: 'Server recovered after ' + wasBackedOff + ' failure(s), resuming normal ' + (this.POLL_INTERVAL / 1000) + 's polling'
                });
            }

            if (hasNewEvents) {
                this.record({
                    type: 'poll',
                    result: 'success',
                    eventsFound: 1,
                    duration: Date.now() - pollStart,
                    detail: 'New events detected since ' + (lastEventTimestamp || 'start') + ', syncing...'
                });

                // Trigger full incremental sync to fetch all new events with pagination
                await incrementalSync();
            } else {
                this.record({
                    type: 'poll',
                    result: 'no-change',
                    eventsFound: 0,
                    duration: Date.now() - pollStart,
                    detail: 'No new events since last sync'
                });
            }
        } catch (err) {
            this.consecutiveFailures++;
            var nextInterval = this.getBackoffInterval();
            this.currentPollInterval = nextInterval;
            this.record({
                type: 'poll',
                result: 'error',
                duration: Date.now() - pollStart,
                error: err.message,
                detail: 'Poll failed: ' + err.message + ' (failure ' + this.consecutiveFailures + ', next retry in ' + Math.round(nextInterval / 1000) + 's)'
            });
        } finally {
            this.isPolling = false;
            // If auto-polling is active, reschedule the next poll with the current interval
            if (this.pollInterval) {
                this.scheduleNextPoll();
            }
        }
    },

    // Schedule the next poll using setTimeout (allows dynamic interval changes)
    scheduleNextPoll() {
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
        }
        var interval = this.consecutiveFailures > 0 ? this.currentPollInterval : this.POLL_INTERVAL;
        this.currentPollInterval = interval;
        this.pollInterval = setTimeout(() => this.pollForUpdates(), interval);
    },

    // Start background polling
    startPolling() {
        if (this.pollInterval) return;
        this.consecutiveFailures = 0;
        this.currentPollInterval = this.POLL_INTERVAL;
        this.scheduleNextPoll();
        this.record({ type: 'poll', result: 'no-change', detail: 'Background polling started (' + (this.POLL_INTERVAL / 1000) + 's interval)' });
    },

    // Stop background polling
    stopPolling() {
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
            this.pollInterval = null;
            this.consecutiveFailures = 0;
            this.currentPollInterval = this.POLL_INTERVAL;
            this.record({ type: 'poll', result: 'no-change', detail: 'Background polling stopped' });
        }
    },

    // Get summary stats
    getStats() {
        var now = Date.now();
        var last5min = this.entries.filter(e => (now - e.timestamp.getTime()) < 300000);
        var lastHour = this.entries.filter(e => (now - e.timestamp.getTime()) < 3600000);
        var errors = this.entries.filter(e => e.result === 'error');
        var totalEvents = this.entries.reduce((sum, e) => sum + (e.eventsFound || 0), 0);
        var totalSnapshots = this.entries.reduce((sum, e) => sum + (e.snapshotsUpdated || 0), 0);
        var lastSync = this.entries.find(e => e.type !== 'poll' && e.result === 'success');
        var lastPoll = this.entries.find(e => e.type === 'poll');

        return {
            totalSyncs: this.entries.filter(e => e.type !== 'poll').length,
            totalPolls: this.entries.filter(e => e.type === 'poll').length,
            last5minOps: last5min.length,
            lastHourOps: lastHour.length,
            totalEventsProcessed: totalEvents,
            totalSnapshotsUpdated: totalSnapshots,
            errorCount: errors.length,
            lastSyncTime: lastSync ? lastSync.timestamp : null,
            lastPollTime: lastPoll ? lastPoll.timestamp : null,
            isPolling: !!this.pollInterval
        };
    },

    // Subscribe to changes (for live UI updates)
    onChange(fn) {
        this.listeners.push(fn);
        return () => { this.listeners = this.listeners.filter(l => l !== fn); };
    },

    notify() {
        this.listeners.forEach(fn => { try { fn(); } catch(e) {} });
    }
};

// ============ Post-Hydration Auto-Poll ============
// After hydrating from Box, aggressively polls Xano to fill in
// any events that occurred between the snapshot creation time and now.
// Uses rapid polling (3s intervals) until fully caught up, then stops.

var PostHydrationSync = {
    POLL_INTERVAL: 3000,     // 3 seconds between catch-up rounds
    MAX_ROUNDS: 50,          // Safety limit on catch-up rounds
    isRunning: false,
    totalEventsCaughtUp: 0,
    rounds: 0,

    // Start the catch-up process (non-blocking, runs in background)
    start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.totalEventsCaughtUp = 0;
        this.rounds = 0;

        console.log('[PostHydrationSync] Starting auto-poll to fill gaps since hydration');
        SyncStatusFeed.info('Post-hydration catch-up: polling Xano for missed updates...');

        this.scheduleNext();
    },

    scheduleNext() {
        if (!this.isRunning) return;
        var self = this;
        setTimeout(function() { self.runCatchUpRound(); }, this.POLL_INTERVAL);
    },

    async runCatchUpRound() {
        if (!this.isRunning || !API_KEY) {
            this.stop('no API key');
            return;
        }

        this.rounds++;
        if (this.rounds > this.MAX_ROUNDS) {
            this.stop('reached max rounds (' + this.MAX_ROUNDS + ')');
            return;
        }

        try {
            // Lightweight check: peek at the latest event to see if there's anything newer
            var peek = await fetchPage(1, lastEventTimestamp, { last: true });
            var hasNewEvents = peek.events && peek.events.length > 0;

            if (!hasNewEvents) {
                // Fully caught up  no more gap events
                this.stop('caught up');
                return;
            }

            // There are new events  run a full incremental sync to fetch them all
            SyncStatusFeed.info('Catch-up round ' + this.rounds + ': fetching new events...');
            await incrementalSync();

            // Check how many events were found in the last sync
            var lastEntry = SyncHistory.entries[0];
            var eventsThisRound = (lastEntry && lastEntry.eventsFound) || 0;
            this.totalEventsCaughtUp += eventsThisRound;

            if (eventsThisRound > 0) {
                SyncStatusFeed.info('Catch-up round ' + this.rounds + ': ' + eventsThisRound + ' events synced (' + this.totalEventsCaughtUp + ' total)');
            }

            // If incremental sync found events, there might be more  keep polling
            this.scheduleNext();

        } catch (err) {
            console.error('[PostHydrationSync] Catch-up error:', err);
            SyncStatusFeed.error('Catch-up error: ' + err.message);
            // Don't stop on error  retry on next round
            this.scheduleNext();
        }
    },

    stop(reason) {
        if (!this.isRunning) return;
        this.isRunning = false;
        var msg = 'Post-hydration catch-up complete';
        if (this.totalEventsCaughtUp > 0) {
            msg += ': ' + this.totalEventsCaughtUp + ' events synced across ' + this.rounds + ' round(s)';
        } else {
            msg += ': already up to date';
        }
        if (reason) msg += ' (' + reason + ')';
        console.log('[PostHydrationSync] ' + msg);
        SyncStatusFeed.success(msg);

        SyncHistory.record({
            type: 'incremental',
            result: 'success',
            eventsFound: this.totalEventsCaughtUp,
            detail: msg
        });
    }
};

// ============ Box Auto-Sync ============
// Pushes full event stream as .amo to Box via n8n webhook after each sync with new data

var BoxSync = {
    isPushing: false,

    // Push full event stream as .amo to Box via n8n webhook
    async push() {
        if (this.isPushing || !API_KEY || !BOX_SYNC_WEBHOOK) return;
        this.isPushing = true;
        try {
            // Read all raw events from IndexedDB
            if (!db || !db.objectStoreNames.contains('events')) {
                console.log('[BoxSync] No events store available');
                return;
            }

            var allEvents = await new Promise(function(resolve, reject) {
                var tx = db.transaction('events', 'readonly');
                var store = tx.objectStore('events');
                var results = [];
                var req = store.openCursor();
                req.onsuccess = function(e) {
                    var cursor = e.target.result;
                    if (cursor) {
                        results.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                };
                req.onerror = function() { reject(req.error); };
            });

            // Decrypt events if encryption is enabled
            if (encryptionEnabled && encryptionKey) {
                allEvents = await Promise.all(allEvents.map(function(e) { return decryptEventFromStorage(e); }));
            }

            if (allEvents.length === 0) {
                console.log('[BoxSync] No events to push');
                return;
            }

            // Produce .amo binary with full event stream
            var binary = AmoFormat.produceEvents(allEvents, { tables: META_TABLES, fields: META_FIELDS });
            var blob = new Blob([binary], { type: 'application/x-amino-snapshot' });

            // Build FormData and POST to n8n webhook
            var form = new FormData();
            form.append('file', blob, BOX_SYNC_FILENAME);

            var res = await fetch(BOX_SYNC_WEBHOOK, {
                method: 'POST',
                headers: {
                    'x-file-name': BOX_SYNC_FILENAME,
                    'x-folder-id': BOX_SYNC_FOLDER_ID,
                    'x-api-key': API_KEY
                },
                body: form
            });

            if (!res.ok) {
                throw new Error('Box upload failed: ' + res.status + ' ' + res.statusText);
            }

            var sizeStr = binary.length < 1024
                ? binary.length + ' B'
                : binary.length < 1048576
                    ? (binary.length / 1024).toFixed(1) + ' KB'
                    : (binary.length / 1048576).toFixed(1) + ' MB';

            console.log('[BoxSync] Pushed ' + allEvents.length + ' events (' + sizeStr + ') to Box');
            SyncStatusFeed.success('Box: pushed ' + allEvents.length + ' events (' + sizeStr + ')');
        } catch (err) {
            console.error('[BoxSync] Push failed:', err);
            SyncStatusFeed.error('Box push failed: ' + err.message);
        } finally {
            this.isPushing = false;
        }
    }
};

// Toggle Box sync on/off
function toggleBoxSync() {
    boxSyncEnabled = !boxSyncEnabled;
    var toggle = document.getElementById('box-sync-toggle');

    if (boxSyncEnabled) {
        toggle.classList.add('active');
        console.log('[BoxSync] Enabled');
        SyncStatusFeed.info('Box auto-sync enabled');
        // Push immediately on enable
        BoxSync.push();
    } else {
        toggle.classList.remove('active');
        console.log('[BoxSync] Disabled');
        SyncStatusFeed.info('Box auto-sync disabled');
    }
}

// Manually push snapshot to Box (independent of auto-sync toggle)
function manualBoxPush() {
    var btn = document.getElementById('box-push-btn');
    if (btn) btn.disabled = true;
    SyncStatusFeed.info('Box: manual push started');
    BoxSync.push().then(function() {
        if (btn) btn.disabled = false;
    });
}

// Initialize Box sync toggle UI state
function initBoxSyncToggle() {
    var toggle = document.getElementById('box-sync-toggle');
    if (toggle) {
        if (boxSyncEnabled) {
            toggle.classList.add('active');
        } else {
            toggle.classList.remove('active');
        }
    }
}

// ============ IndexedDB ============

function openDB() {
    return new Promise((resolve, reject) => {
        var req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve(req.result);
        req.onupgradeneeded = (e) => {
            var db = e.target.result;

            // Delete old stores if they exist
            if (db.objectStoreNames.contains('records')) {
                db.deleteObjectStore('records');
            }
            if (db.objectStoreNames.contains('meta')) {
                db.deleteObjectStore('meta');
            }

            // Data records: keyed by [tableId, recordId]
            if (!db.objectStoreNames.contains('data')) {
                var dataStore = db.createObjectStore('data', { keyPath: ['tableId', 'recordId'] });
                dataStore.createIndex('by_table', 'tableId');
            }

            // Table metadata
            if (!db.objectStoreNames.contains('tables')) {
                db.createObjectStore('tables', { keyPath: 'tableId' });
            }

            // Field metadata: keyed by [tableId, fieldId]
            if (!db.objectStoreNames.contains('fields')) {
                var fieldStore = db.createObjectStore('fields', { keyPath: ['tableId', 'fieldId'] });
                fieldStore.createIndex('by_table', 'tableId');
            }

            // View metadata: keyed by [tableId, viewId]
            if (!db.objectStoreNames.contains('views')) {
                var viewStore = db.createObjectStore('views', { keyPath: ['tableId', 'viewId'] });
                viewStore.createIndex('by_table', 'tableId');
            }

            // Field history: keyed by auto-increment, indexed by record and field
            if (!db.objectStoreNames.contains('fieldHistory')) {
                var historyStore = db.createObjectStore('fieldHistory', { keyPath: 'id', autoIncrement: true });
                historyStore.createIndex('by_record', ['tableId', 'recordId']);
                historyStore.createIndex('by_field', ['tableId', 'recordId', 'fieldId']);
                historyStore.createIndex('by_event', 'eventId');
            }

            // View folders: keyed by folderId
            if (!db.objectStoreNames.contains('viewFolders')) {
                var folderStore = db.createObjectStore('viewFolders', { keyPath: 'folderId' });
                folderStore.createIndex('by_table', 'tableId');
            }

            // Workspaces: keyed by workspaceId
            if (!db.objectStoreNames.contains('workspaces')) {
                db.createObjectStore('workspaces', { keyPath: 'workspaceId' });
            }

            // Sync state
            if (!db.objectStoreNames.contains('sync')) {
                db.createObjectStore('sync', { keyPath: 'key' });
            }

            // Raw events: keyed by event id, indexed by set and recordId
            if (!db.objectStoreNames.contains('events')) {
                var eventsStore = db.createObjectStore('events', { keyPath: 'id' });
                eventsStore.createIndex('by_set', 'set');
                eventsStore.createIndex('by_record', 'recordId');
                eventsStore.createIndex('by_timestamp', 'created_at');
            }

            // Snapshot: materialized current state, keyed by record_id
            if (!db.objectStoreNames.contains('snapshot')) {
                var snapshotStore = db.createObjectStore('snapshot', { keyPath: 'record_id' });
                snapshotStore.createIndex('by_source_table', 'source_table');
                snapshotStore.createIndex('by_last_amino_event', 'last_amino_event');
            }
        };
    });
}

function getSyncMeta(key) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readonly');
        var req = tx.objectStore('sync').get(key);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
        req.onerror = () => reject(req.error);
    });
}

function setSyncMeta(key, value) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readwrite');
        tx.objectStore('sync').put({ key, value });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// ============ Events Store Functions ============

// Encrypt event payloads for storage
async function encryptEventForStorage(event) {
    if (!encryptionEnabled || !encryptionKey || !event.payload) {
        return event;
    }
    var encrypted = { ...event };
    encrypted._encryptedPayload = await encryptData(event.payload, encryptionKey);
    delete encrypted.payload;
    return encrypted;
}

// Decrypt event payload after retrieval
async function decryptEventFromStorage(event) {
    if (!event || !event._encryptedPayload || !encryptionEnabled || !encryptionKey) {
        return event;
    }
    var decrypted = { ...event };
    decrypted.payload = await decryptData(event._encryptedPayload, encryptionKey);
    delete decrypted._encryptedPayload;
    return decrypted;
}

// Encrypt data record fields for storage
async function encryptRecordForStorage(record) {
    if (!encryptionEnabled || !encryptionKey || !record.fields) {
        return record;
    }
    var encrypted = { ...record };
    encrypted._encryptedFields = await encryptData(record.fields, encryptionKey);
    delete encrypted.fields;
    return encrypted;
}

// Decrypt data record fields after retrieval
async function decryptRecordFromStorage(record) {
    if (!record || !record._encryptedFields || !encryptionEnabled || !encryptionKey) {
        return record;
    }
    var decrypted = { ...record };
    decrypted.fields = await decryptData(record._encryptedFields, encryptionKey);
    delete decrypted._encryptedFields;
    return decrypted;
}

async function saveRawEvents(events) {
    if (!events || events.length === 0) return;

    // Encrypt events if encryption is enabled
    var eventsToStore = events;
    if (encryptionEnabled && encryptionKey) {
        eventsToStore = await Promise.all(events.map(e => encryptEventForStorage(e)));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readwrite');
        var store = tx.objectStore('events');
        eventsToStore.forEach(e => store.put(e));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function getAllRawEvents(limit, offset) {
    var maxLimit = limit || 100;
    var startOffset = offset || 0;

    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        // Events are sorted by ID ascending, we want newest first (descending)
        var reversed = [];
        for (var i = inMemoryEvents.length - 1; i >= 0; i--) {
            reversed.push(inMemoryEvents[i]);
        }
        return reversed.slice(startOffset, startOffset + maxLimit);
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;
        var collected = 0;

        // Use a cursor to iterate in reverse order (newest first)
        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor && collected < maxLimit) {
                if (skipped < startOffset) {
                    skipped++;
                    cursor.continue();
                } else {
                    results.push(cursor.value);
                    collected++;
                    cursor.continue();
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getRawEventsCount() {
    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        return Promise.resolve(inMemoryEvents.length);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var req = tx.objectStore('events').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

async function getRawEventsByRecordId(recordId, maxEventId) {
    // Check in-memory events first (from CSV import)
    if (inMemoryEventsByRecord && inMemoryEventsByRecord.has(recordId)) {
        var results = inMemoryEventsByRecord.get(recordId).slice();
        if (maxEventId) {
            results = results.filter(e => e.id <= maxEventId);
        }
        results.sort((a, b) => (a.id || 0) - (b.id || 0));
        return results;
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var index = tx.objectStore('events').index('by_record');
        var req = index.getAll(recordId);
        req.onsuccess = () => {
            var results = req.result || [];
            // Filter to events up to maxEventId and sort by id ascending
            if (maxEventId) {
                results = results.filter(e => e.id <= maxEventId);
            }
            results.sort((a, b) => (a.id || 0) - (b.id || 0));
            resolve(results);
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getRawEventsBySet(setFilter) {
    // DEPRECATED: Use getRawEventsBySetPaginated instead
    return getRawEventsBySetPaginated(setFilter, 0, 500);
}

// Memory-efficient paginated events by set retrieval
async function getRawEventsBySetPaginated(setFilter, offset, limit) {
    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        var filtered = [];
        for (var i = inMemoryEvents.length - 1; i >= 0; i--) {
            if (inMemoryEvents[i].set === setFilter) {
                filtered.push(inMemoryEvents[i]);
            }
        }
        return filtered.slice(offset, offset + limit);
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var index = tx.objectStore('events').index('by_set');

        // Get all matching, then sort and paginate
        // Note: IndexedDB index doesn't support ordering by different field, so we collect and sort
        var req = index.getAll(setFilter);
        req.onsuccess = () => {
            var all = req.result || [];
            all.sort((a, b) => (b.id || 0) - (a.id || 0)); // Newest first
            // Apply pagination
            resolve(all.slice(offset, offset + limit));
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function searchRawEvents(query, limit, offset) {
    var maxLimit = limit || 100;
    var skipCount = offset || 0;
    var lowerQuery = query.toLowerCase();

    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        var results = [];
        var skipped = 0;
        for (var i = inMemoryEvents.length - 1; i >= 0 && results.length < maxLimit; i--) {
            var event = inMemoryEvents[i];
            var matchesRecord = event.recordId && event.recordId.toLowerCase().includes(lowerQuery);
            var matchesSet = event.set && event.set.toLowerCase().includes(lowerQuery);
            var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);
            var matchesPayload = payloadStr && payloadStr.toLowerCase().includes(lowerQuery);

            if (matchesRecord || matchesSet || matchesPayload) {
                if (skipped < skipCount) {
                    skipped++;
                } else {
                    results.push(event);
                }
            }
        }
        return Promise.resolve(results);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;

        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                var event = cursor.value;
                // Search in recordId, set, and payload
                var matchesRecord = event.recordId && event.recordId.toLowerCase().includes(lowerQuery);
                var matchesSet = event.set && event.set.toLowerCase().includes(lowerQuery);
                var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);
                var matchesPayload = payloadStr && payloadStr.toLowerCase().includes(lowerQuery);

                if (matchesRecord || matchesSet || matchesPayload) {
                    if (skipped < skipCount) {
                        skipped++;
                        cursor.continue();
                    } else if (results.length < maxLimit) {
                        results.push(event);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                } else {
                    cursor.continue();
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

function getMaxEventId() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var req = store.openCursor(null, 'prev'); // Open cursor in reverse to get highest ID first
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                resolve(cursor.value.id || 0);
            } else {
                resolve(0); // No events
            }
        };
        req.onerror = () => reject(req.error);
    });
}

function getAllRawEventsNoPagination() {
    // DEPRECATED: Use getRawEventsPaginated instead to avoid memory issues
    return getRawEventsPaginated(0, 500); // Return max 500 events
}

// Memory-efficient paginated events retrieval using IndexedDB cursor
async function getRawEventsPaginated(offset, limit) {
    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;

        // Use cursor in reverse order (newest first, highest ID first)
        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                if (skipped < offset) {
                    skipped++;
                    cursor.continue();
                } else if (results.length < limit) {
                    results.push(cursor.value);
                    cursor.continue();
                } else {
                    resolve(results);
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

// Get total count of raw events
function getRawEventsTotalCount() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var req = tx.objectStore('events').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

// Get all current records from all tables as synthetic event-like objects
// DEPRECATED: Use getCurrentRecordsPaginated instead to avoid memory issues
function getAllCurrentRecords() {
    return getCurrentRecordsPaginated(0, 500); // Return max 500 records
}

// Memory-efficient paginated current records retrieval
function getCurrentRecordsPaginated(offset, limit, tableFilter, searchQuery) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var results = [];
        var skipped = 0;
        var setFilter = tableFilter || null;
        var query = searchQuery ? searchQuery.toLowerCase() : null;

        var req = store.openCursor();
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                var rec = cursor.value;
                var setVal = 'airtable:' + rec.tableId;

                // Apply table filter if set
                if (setFilter && setVal !== setFilter) {
                    cursor.continue();
                    return;
                }

                // Apply search filter if set
                if (query) {
                    var matchesSearch = (rec.recordId && rec.recordId.toLowerCase().includes(query)) ||
                                       (setVal.toLowerCase().includes(query)) ||
                                       (JSON.stringify(rec.fields || {}).toLowerCase().includes(query));
                    if (!matchesSearch) {
                        cursor.continue();
                        return;
                    }
                }

                if (skipped < offset) {
                    skipped++;
                    cursor.continue();
                } else if (results.length < limit) {
                    // Convert to synthetic event format
                    results.push({
                        id: 0,
                        recordId: rec.recordId,
                        set: setVal,
                        payload: JSON.stringify({
                            _set: 'current',
                            fields: { INS: rec.fields }
                        }),
                        created_at: null,
                        _isCurrentState: true
                    });
                    cursor.continue();
                } else {
                    resolve(results);
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

// Get count of all current records
function getCurrentRecordsCount() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var req = tx.objectStore('data').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

function getAllTables() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readonly');
        var req = tx.objectStore('tables').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getFieldsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var index = tx.objectStore('fields').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getViewsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var index = tx.objectStore('views').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllViews() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var req = tx.objectStore('views').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllFields() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var req = tx.objectStore('fields').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Query schema elements by recordId prefix
function getSchemaByPrefix(prefix) {
    // Returns tables (tbl*), fields (fld*), or views (viw*) based on prefix
    return new Promise(async (resolve) => {
        var results = [];
        if (prefix === 'tbl') {
            var tables = await getAllTables();
            results = tables.filter(t => t.tableId && t.tableId.startsWith('tbl'));
        } else if (prefix === 'fld') {
            var fields = await getAllFields();
            results = fields.filter(f => f.fieldId && f.fieldId.startsWith('fld'));
        } else if (prefix === 'viw') {
            var views = await getAllViews();
            results = views.filter(v => v.viewId && v.viewId.startsWith('viw'));
        }
        resolve(results);
    });
}

function getRecordIdsForTable(tableId) {
    // Check in-memory data first (from CSV import)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        return Promise.resolve(Object.keys(window.IN_MEMORY_DATA[tableId]));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var index = tx.objectStore('data').index('by_table');
        var req = index.getAllKeys(tableId);
        req.onsuccess = () => {
            // Keys are [tableId, recordId], extract recordIds
            var recordIds = (req.result || []).map(k => k[1]);
            resolve(recordIds);
        };
        req.onerror = () => reject(req.error);
    });
}

async function getRecord(tableId, recordId) {
    // Check in-memory data first (from CSV import)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
        return {
            tableId: tableId,
            recordId: recordId,
            fields: window.IN_MEMORY_DATA[tableId][recordId]
        };
    }

    var result = await new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var req = tx.objectStore('data').get([tableId, recordId]);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
    });

    // Decrypt record if needed
    if (result && encryptionEnabled && encryptionKey) {
        return decryptRecordFromStorage(result);
    }
    return result;
}

async function getRecordsByIds(tableId, recordIds) {
    if (!recordIds.length) return [];

    // Check in-memory data first (from CSV import)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        var memResults = [];
        var missingIds = [];
        for (var i = 0; i < recordIds.length; i++) {
            var rid = recordIds[i];
            if (window.IN_MEMORY_DATA[tableId][rid]) {
                memResults.push({
                    tableId: tableId,
                    recordId: rid,
                    fields: window.IN_MEMORY_DATA[tableId][rid]
                });
            } else {
                missingIds.push(rid);
            }
        }
        // If all records found in memory, return immediately
        if (missingIds.length === 0) {
            return memResults;
        }
        // Otherwise, also check IndexedDB for missing ones
        var dbResults = await getRecordsByIdsFromDB(tableId, missingIds);
        return memResults.concat(dbResults);
    }

    return getRecordsByIdsFromDB(tableId, recordIds);
}

// Internal: Get records from IndexedDB only
async function getRecordsByIdsFromDB(tableId, recordIds) {
    if (!recordIds.length) return [];

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var results = [];
        var pending = recordIds.length;

        recordIds.forEach(rid => {
            var req = store.get([tableId, rid]);
            req.onsuccess = () => {
                if (req.result) results.push(req.result);
                if (--pending === 0) resolve(results);
            };
            req.onerror = () => {
                if (--pending === 0) resolve(results);
            };
        });
    });

    // Decrypt records if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(r => decryptRecordFromStorage(r)));
    }
    return results;
}

function saveTable(table) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readwrite');
        tx.objectStore('tables').put(table);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveField(field) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readwrite');
        tx.objectStore('fields').put(field);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveView(view) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readwrite');
        tx.objectStore('views').put(view);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function saveDataRecord(record) {
    // Encrypt record if needed
    var recordToStore = record;
    if (encryptionEnabled && encryptionKey) {
        recordToStore = await encryptRecordForStorage(record);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readwrite');
        tx.objectStore('data').put(recordToStore);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function saveBatch(tables, fields, views, dataRecords) {
    var stores = [];
    if (tables.length) stores.push('tables');
    if (fields.length) stores.push('fields');
    if (views.length) stores.push('views');
    if (dataRecords.length) stores.push('data');
    if (!stores.length) return;

    // Encrypt data records if needed
    var recordsToStore = dataRecords;
    if (encryptionEnabled && encryptionKey && dataRecords.length) {
        recordsToStore = await Promise.all(dataRecords.map(r => encryptRecordForStorage(r)));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction(stores, 'readwrite');

        tables.forEach(t => tx.objectStore('tables').put(t));
        fields.forEach(f => tx.objectStore('fields').put(f));
        views.forEach(v => tx.objectStore('views').put(v));
        recordsToStore.forEach(d => tx.objectStore('data').put(d));

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function clearAllData() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction(['data', 'tables', 'fields', 'views', 'sync', 'fieldHistory', 'events'], 'readwrite');
        tx.objectStore('data').clear();
        tx.objectStore('tables').clear();
        tx.objectStore('fields').clear();
        tx.objectStore('views').clear();
        tx.objectStore('sync').clear();
        tx.objectStore('fieldHistory').clear();
        tx.objectStore('events').clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveFieldHistory(historyEntries) {
    return new Promise((resolve, reject) => {
        if (!historyEntries.length) return resolve();
        var tx = db.transaction('fieldHistory', 'readwrite');
        var store = tx.objectStore('fieldHistory');
        historyEntries.forEach(entry => store.add(entry));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Field history limit to prevent excessive memory usage
var FIELD_HISTORY_LIMIT = 1000;

function getFieldHistoryForRecord(tableId, recordId, limit) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fieldHistory', 'readonly');
        var index = tx.objectStore('fieldHistory').index('by_record');
        var maxLimit = limit || FIELD_HISTORY_LIMIT;

        // Use cursor for memory-efficient retrieval with limit
        var results = [];
        var req = index.openCursor(IDBKeyRange.only([tableId, recordId]));

        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor && results.length < maxLimit) {
                results.push(cursor.value);
                cursor.continue();
            } else {
                // Sort by eventId descending (most recent first)
                results.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

// Fetch and process any new history events for a specific record from API
async function fetchAndProcessHistoryForRecord(tableId, recordId) {
    if (!API_KEY) return;

    // Get the highest eventId we have for this record to fetch only newer events
    var existingHistory = await getFieldHistoryForRecord(tableId, recordId);
    var maxEventId = existingHistory.reduce((max, h) => Math.max(max, h.eventId || 0), 0);

    // Build API URL with recordId filter and id > maxEventId
    var url = API + '?page=1&per_page=500';
    url += '&apiKey=' + encodeURIComponent(API_KEY);
    url += '&recordId=' + encodeURIComponent(recordId);
    if (maxEventId > 0) {
        url += '&id=' + maxEventId;
    }

    try {
        var res = await fetch(url);
        if (!res.ok) return;

        var data = await res.json();
        var events = Array.isArray(data) ? data : (data.items || data.data || []);

        if (!events || events.length === 0) return;

        // Sort events by id ascending (oldest first for proper state tracking)
        events.sort((a, b) => (a.id || 0) - (b.id || 0));

        // Get existing record state to calculate oldValue correctly
        var existingRecord = await getRecord(tableId, recordId);
        var state = existingRecord ? { ...existingRecord.fields } : {};

        var fieldHistoryEntries = [];

        for (var e of events) {
            if (!e || !e.recordId || e.recordId !== recordId) continue;

            var payload = parsePayload(e.payload);
            if (!payload || typeof payload !== 'object') continue;

            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            var eventId = e.id;
            var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

            // Process INS (insert/create)
            if (pfields.INS) {
                for (var fieldId in pfields.INS) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'created',
                        oldValue: null,
                        newValue: pfields.INS[fieldId]
                    });
                }
                Object.assign(state, pfields.INS);
            }

            // Process ALT (alter/update)
            if (pfields.ALT) {
                for (var fieldId in pfields.ALT) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'updated',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.ALT[fieldId]
                    });
                }
                Object.assign(state, pfields.ALT);
            }

            // Process SYN (sync/snapshot)
            if (pfields.SYN) {
                for (var fieldId in pfields.SYN) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'synced',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.SYN[fieldId]
                    });
                }
                Object.assign(state, pfields.SYN);
            }

            // Process NUL (nullify/delete)
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'deleted',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: null
                    });
                    delete state[fieldId];
                });
            }
        }

        // Save new history entries
        if (fieldHistoryEntries.length > 0) {
            await saveFieldHistory(fieldHistoryEntries);
        }
    } catch (err) {
        console.error('Error fetching history for record:', err);
    }
}

// ============ View Folders ============

function getFoldersForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readonly');
        var index = tx.objectStore('viewFolders').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function saveFolder(folder) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readwrite');
        tx.objectStore('viewFolders').put(folder);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function deleteFolder(folderId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readwrite');
        tx.objectStore('viewFolders').delete(folderId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getAllFolders() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readonly');
        var req = tx.objectStore('viewFolders').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// ============ View Auto-Save System ============

// Mark view as dirty (edited)
function markViewDirty(changeType, data) {
    if (!currentTable || !currentView) return;

    viewDirtyState.isDirty = true;
    viewDirtyState.lastEditTime = Date.now();
    viewDirtyState.pendingChanges.tableId = currentTable;
    viewDirtyState.pendingChanges.viewId = currentView;
    viewDirtyState.pendingChanges.changes[changeType] = data;

    // Reset auto-save timer (debounce)
    clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(saveViewToBackend, AUTO_SAVE_DELAY);

    // Update UI indicator
    updateSaveIndicator('dirty');
}

// Update save indicator UI
function updateSaveIndicator(state) {
    var indicator = document.getElementById('view-save-indicator');
    var text = document.getElementById('save-indicator-text');
    var saveBtn = document.getElementById('manual-save-btn');

    if (!indicator || !text || !saveBtn) return;

    indicator.style.display = 'flex';
    indicator.className = 'view-save-indicator ' + state;

    switch(state) {
        case 'dirty':
            var remaining = Math.ceil((AUTO_SAVE_DELAY - (Date.now() - viewDirtyState.lastEditTime)) / 60000);
            text.textContent = 'Auto-save in ~' + Math.max(1, remaining) + 'm';
            saveBtn.style.display = 'inline-block';
            saveBtn.disabled = false;
            break;
        case 'saving':
            text.textContent = 'Saving...';
            saveBtn.style.display = 'inline-block';
            saveBtn.disabled = true;
            break;
        case 'saved':
            text.textContent = 'Saved';
            saveBtn.style.display = 'none';
            // Hide after 3 seconds
            setTimeout(() => {
                if (!viewDirtyState.isDirty) {
                    indicator.style.display = 'none';
                }
            }, 3000);
            break;
        default:
            indicator.style.display = 'none';
    }
}

// Save view changes to backend
async function saveViewToBackend() {
    if (!viewDirtyState.isDirty || !API_KEY) return;

    var { tableId, viewId, changes } = viewDirtyState.pendingChanges;
    if (!tableId || !viewId) return;

    updateSaveIndicator('saving');

    // Get the full view data
    var view = META_VIEWS[tableId]?.[viewId] || {};
    var config = VIEW_FIELD_CONFIG[tableId]?.[viewId] || {};

    // Build the complete view config data for snapshot
    var viewConfigData = {
        _set: 'viewConfig',
        tableId: tableId,
        viewId: viewId,
        viewName: view.viewName || viewId,
        hiddenFieldIds: config.hiddenFieldIds || [],
        fieldOrder: config.fieldOrder || [],
        filters: view.filters || [],
        sorts: view.sorts || [],
        folderId: view.folderId || null,
        ...changes
    };

    var payload = {
        uuid: crypto.randomUUID(),
        recordId: viewId,
        set: 'airtable:' + tableId,
        operator: 'ALT',
        created_at: new Date().toISOString(),
        apiKey: API_KEY,
        payload: JSON.stringify(viewConfigData)
    };

    try {
        await AminoSync.postEvent(payload);

        // Clear dirty state
        viewDirtyState.isDirty = false;
        viewDirtyState.pendingChanges = { tableId: null, viewId: null, changes: {} };
        clearTimeout(autoSaveTimer);

        updateSaveIndicator('saved');
        console.log('View saved to backend:', viewId);
    } catch (error) {
        console.error('Failed to save view to backend:', error);
        // Keep dirty state, will retry on next trigger
        updateSaveIndicator('dirty');
    }
}

// Manual save button handler
async function saveViewToBackendNow() {
    clearTimeout(autoSaveTimer);
    await saveViewToBackend();
}

// Auto-save before navigation
async function autoSaveBeforeNavigation() {
    if (viewDirtyState.isDirty) {
        clearTimeout(autoSaveTimer);
        await saveViewToBackend();
    }
}

// Browser beforeunload - auto-save
window.addEventListener('beforeunload', function(e) {
    if (viewDirtyState.isDirty) {
        // Attempt to save (may not complete if user leaves too quickly)
        saveViewToBackend();
    }
    if (tableSettingsDirty) {
        // Attempt to save table settings
        saveTableSettings();
    }
});

// ============ Table Settings (User-Specific Table/View Preferences) ============

// Table settings dirty state tracking
var tableSettingsDirty = false;
var tableSettingsAutoSaveTimer = null;

// Get current table settings
function getTableSettings() {
    return TABLE_SETTINGS;
}

// Update table visibility
function setTableVisible(tableId, visible) {
    if (!TABLE_SETTINGS.tables[tableId]) {
        TABLE_SETTINGS.tables[tableId] = {};
    }
    TABLE_SETTINGS.tables[tableId].visible = visible;
    markTableSettingsDirty();
}

// Update table sort order
function setTableSortOrder(tableId, sortOrder) {
    if (!TABLE_SETTINGS.tables[tableId]) {
        TABLE_SETTINGS.tables[tableId] = {};
    }
    TABLE_SETTINGS.tables[tableId].sortOrder = sortOrder;
    markTableSettingsDirty();
}

// Update the table order array (reorder tables)
function setTableOrder(tableOrder) {
    TABLE_SETTINGS.tableOrder = tableOrder;
    markTableSettingsDirty();
}

// Update view public/private setting
function setViewPublic(viewId, isPublic) {
    if (!TABLE_SETTINGS.views[viewId]) {
        TABLE_SETTINGS.views[viewId] = {};
    }
    TABLE_SETTINGS.views[viewId].isPublic = isPublic;
    markTableSettingsDirty();
}

// Update view sort order
function setViewSortOrder(viewId, sortOrder) {
    if (!TABLE_SETTINGS.views[viewId]) {
        TABLE_SETTINGS.views[viewId] = {};
    }
    TABLE_SETTINGS.views[viewId].sortOrder = sortOrder;
    markTableSettingsDirty();
}

// Check if a table is visible (defaults to true if not set)
function isTableVisible(tableId) {
    var settings = TABLE_SETTINGS.tables[tableId];
    return settings ? settings.visible !== false : true;
}

// Check if a view is public (defaults to false - private by default)
function isViewPublic(viewId) {
    var settings = TABLE_SETTINGS.views[viewId];
    return settings ? settings.isPublic === true : false;
}

// Get table sort order (returns null if not set)
function getTableSortOrder(tableId) {
    var settings = TABLE_SETTINGS.tables[tableId];
    return settings ? settings.sortOrder : null;
}

// Get view sort order (returns null if not set)
function getViewSortOrder(viewId) {
    var settings = TABLE_SETTINGS.views[viewId];
    return settings ? settings.sortOrder : null;
}

// Mark table settings as dirty and schedule auto-save
function markTableSettingsDirty() {
    tableSettingsDirty = true;

    // Clear existing timer
    if (tableSettingsAutoSaveTimer) {
        clearTimeout(tableSettingsAutoSaveTimer);
    }

    // Schedule auto-save after 2 seconds of inactivity
    tableSettingsAutoSaveTimer = setTimeout(function() {
        saveTableSettings();
    }, 2000);
}

// Save table settings to backend
async function saveTableSettings() {
    if (!tableSettingsDirty || !API_KEY) return;

    var tableSettingsData = {
        _set: 'tableSettings',
        tables: TABLE_SETTINGS.tables,
        tableOrder: TABLE_SETTINGS.tableOrder,
        views: TABLE_SETTINGS.views
    };

    var payload = {
        uuid: crypto.randomUUID(),
        recordId: 'tableSettings:' + (API_KEY || 'default'),
        set: 'userSettings',
        operator: 'ALT',
        created_at: new Date().toISOString(),
        apiKey: API_KEY,
        payload: JSON.stringify(tableSettingsData)
    };

    try {
        await AminoSync.postEvent(payload);

        // Clear dirty state
        tableSettingsDirty = false;
        clearTimeout(tableSettingsAutoSaveTimer);

        console.log('Table settings saved to backend');
    } catch (error) {
        console.error('Failed to save table settings to backend:', error);
        // Keep dirty state, will retry on next trigger
    }
}

// Load table settings from sync metadata
// Table settings are now persisted via events and restored during event replay
async function loadTableSettings() {
    try {
        var stored = await getSyncMeta('tableSettings');
        if (stored) {
            if (stored.tables) TABLE_SETTINGS.tables = stored.tables;
            if (stored.tableOrder) TABLE_SETTINGS.tableOrder = stored.tableOrder;
            if (stored.views) TABLE_SETTINGS.views = stored.views;
            console.log('Table settings loaded from sync metadata');
        }
    } catch (error) {
        console.error('Failed to load table settings:', error);
    }
}

// ============ Column Definition Registry & Smart Ordering ============
//
// Inspired by the EO/Noema definition concept: every column has semantic meaning
// beyond its label. A field named "name" is an identity field that belongs leftmost.
// A field named "created_at" is temporal metadata that belongs further right.
//
// This system:
// 1. Recognizes common field names via fuzzy matching (CommonDefinitionsRegistry)
// 2. Assigns semantic roles (identifier, property, temporal, quantity, etc.)
// 3. Scores each field's "relevance" for left-to-right column priority
// 4. Produces an intelligent default column order when a view is first created

// Definition roles - the semantic purpose of a field
var FieldRole = Object.freeze({
    PRIMARY_IDENTITY: 'primary_identity',   // Name, title - the "what is this?" column
    IDENTIFIER: 'identifier',               // IDs, codes, keys, references
    DESCRIPTIVE: 'descriptive',             // Description, notes, summary
    CONTACT: 'contact',                     // Email, phone, address
    STATUS: 'status',                       // Status, state, type, category
    QUANTITY: 'quantity',                    // Amounts, prices, counts
    TEMPORAL: 'temporal',                   // Dates, timestamps
    RELATIONAL: 'relational',              // Foreign keys, linked records
    ORGANIZATIONAL: 'organizational',       // Department, role, company
    SPATIAL: 'spatial',                     // Address, coordinates
    TECHNICAL: 'technical',                 // UUIDs, hashes, internal IDs
    UNKNOWN: 'unknown'
});

// Role display priority - lower number = further left (more relevant)
var ROLE_PRIORITY = {
    primary_identity: 0,    // "Name" column is almost always the most important
    identifier: 1,          // IDs that help identify the record
    descriptive: 2,         // Descriptions give context
    status: 3,              // Status/type helps at a glance
    contact: 4,             // Contact info is often actionable
    organizational: 5,      // Org context
    quantity: 6,            // Numeric values
    spatial: 7,             // Location data
    relational: 8,          // Links to other records
    temporal: 9,            // Dates tend to be reference, not primary
    technical: 10,          // Internal IDs, hashes - least human-relevant
    unknown: 11
};

/**
 * CommonDefinitionsRegistry - Recognizes common field names and assigns semantic meaning
 *
 * Borrowed from the Noema epistemic data workbench concept: definitions are not just
 * labels but carry meaning, authority, and role. Here we use a lightweight version
 * focused on field name recognition and semantic role assignment for column ordering.
 */
var COMMON_DEFINITIONS = [
    //  Primary Identity (the "what is this record?" fields) 
    { keys: ['name', 'full name', 'fullname', 'display name', 'displayname', 'record name', 'title', 'subject', 'headline', 'label'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Primary display name', sensitivity: 'low', stability: 'stable' },
    { keys: ['first name', 'firstname', 'fname', 'given name', 'givenname', 'first'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'First/given name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['last name', 'lastname', 'lname', 'surname', 'family name', 'familyname', 'last'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Last/family name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['middle name', 'middlename', 'mname', 'middle'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Middle name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['prefix', 'salutation', 'honorific'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Name prefix', sensitivity: 'low', stability: 'stable' },
    { keys: ['suffix', 'name suffix', 'generational'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Name suffix', sensitivity: 'low', stability: 'stable' },
    { keys: ['company name', 'companyname', 'company', 'org name', 'orgname', 'organization name', 'organization', 'org', 'business name', 'firm'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Organization name', sensitivity: 'low', stability: 'stable' },
    { keys: ['product name', 'productname', 'product', 'item name', 'itemname', 'item'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Product/item name', sensitivity: 'low', stability: 'stable' },

    //  Identifiers (unique keys and codes) 
    { keys: ['id', 'identifier', 'uid', 'guid', 'key', 'pk', 'primary key', 'unique identifier', 'record id', 'recordid'], role: FieldRole.IDENTIFIER, meaning: 'Unique identifier', sensitivity: 'low', stability: 'stable' },
    { keys: ['code', 'sku', 'barcode', 'upc', 'ean', 'gtin', 'item number', 'itemnumber', 'stock keeping unit', 'part number', 'partnumber'], role: FieldRole.IDENTIFIER, meaning: 'Item code', sensitivity: 'low', stability: 'stable' },
    { keys: ['account number', 'accountnumber', 'acct', 'account no'], role: FieldRole.IDENTIFIER, meaning: 'Account number', sensitivity: 'high', stability: 'stable' },
    { keys: ['invoice number', 'invoicenumber', 'invoice', 'inv number', 'invnumber', 'invoice no'], role: FieldRole.IDENTIFIER, meaning: 'Invoice number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['order number', 'ordernumber', 'order no', 'order'], role: FieldRole.IDENTIFIER, meaning: 'Order number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['transaction id', 'transactionid', 'trans id', 'transid', 'txn id', 'txnid', 'transaction'], role: FieldRole.IDENTIFIER, meaning: 'Transaction ID', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['employee number', 'employeenumber', 'employee no', 'emp number', 'empnumber', 'emp no', 'badge', 'badge number'], role: FieldRole.IDENTIFIER, meaning: 'Employee number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['social security number', 'ssn', 'social security', 'ss number', 'sin', 'national id'], role: FieldRole.IDENTIFIER, meaning: 'Social Security Number', sensitivity: 'high', stability: 'stable' },
    { keys: ['drivers license number', 'dl', 'drivers license', 'license number', 'dl number'], role: FieldRole.IDENTIFIER, meaning: 'Drivers license', sensitivity: 'high', stability: 'stable' },
    { keys: ['passport number', 'passport', 'passport no'], role: FieldRole.IDENTIFIER, meaning: 'Passport number', sensitivity: 'high', stability: 'stable' },

    //  Descriptive (text that describes/explains) 
    { keys: ['description', 'desc', 'details', 'summary', 'about', 'overview', 'bio', 'biography'], role: FieldRole.DESCRIPTIVE, meaning: 'Description text', sensitivity: 'low', stability: 'contextual' },
    { keys: ['notes', 'note', 'comments', 'comment', 'remarks', 'remark', 'memo', 'observation', 'observations'], role: FieldRole.DESCRIPTIVE, meaning: 'Notes/comments', sensitivity: 'low', stability: 'contextual' },
    { keys: ['body', 'content', 'text', 'message', 'body text'], role: FieldRole.DESCRIPTIVE, meaning: 'Body content', sensitivity: 'low', stability: 'contextual' },

    //  Status/Categorical (classification and state) 
    { keys: ['status', 'state', 'condition', 'stage', 'phase', 'workflow status'], role: FieldRole.STATUS, meaning: 'Current status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['type', 'kind', 'classification', 'record type', 'recordtype', 'entity type'], role: FieldRole.STATUS, meaning: 'Type classification', sensitivity: 'low', stability: 'stable' },
    { keys: ['category', 'cat', 'group', 'class', 'segment', 'division'], role: FieldRole.STATUS, meaning: 'Category', sensitivity: 'low', stability: 'stable' },
    { keys: ['subcategory', 'sub category', 'subcat', 'subgroup', 'sub group'], role: FieldRole.STATUS, meaning: 'Subcategory', sensitivity: 'low', stability: 'stable' },
    { keys: ['priority', 'pri', 'importance', 'urgency', 'severity', 'level'], role: FieldRole.STATUS, meaning: 'Priority level', sensitivity: 'low', stability: 'contextual' },
    { keys: ['tags', 'tag', 'labels', 'keywords'], role: FieldRole.STATUS, meaning: 'Tags/labels', sensitivity: 'low', stability: 'contextual' },
    { keys: ['active', 'isactive', 'is active', 'enabled', 'isenabled', 'is enabled', 'live'], role: FieldRole.STATUS, meaning: 'Active flag', sensitivity: 'low', stability: 'contextual' },
    { keys: ['approved', 'isapproved', 'is approved', 'approval', 'approval status'], role: FieldRole.STATUS, meaning: 'Approval status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['verified', 'isverified', 'is verified', 'confirmed', 'isconfirmed', 'is confirmed', 'validation'], role: FieldRole.STATUS, meaning: 'Verification status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['source', 'origin', 'referral source', 'lead source', 'channel'], role: FieldRole.STATUS, meaning: 'Source/origin', sensitivity: 'low', stability: 'stable' },
    { keys: ['gender', 'sex'], role: FieldRole.STATUS, meaning: 'Gender', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['race', 'ethnicity', 'race ethnicity', 'raceethnicity', 'race/ethnicity'], role: FieldRole.STATUS, meaning: 'Race/Ethnicity', sensitivity: 'high', stability: 'stable' },

    //  Contact (communication channels) 
    { keys: ['email', 'email address', 'emailaddress', 'e-mail', 'e mail', 'mail', 'primary email'], role: FieldRole.CONTACT, meaning: 'Email address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['phone', 'telephone', 'phone number', 'phonenumber', 'tel', 'primary phone', 'contact number'], role: FieldRole.CONTACT, meaning: 'Phone number', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['mobile phone', 'mobile', 'cell', 'cellphone', 'cell phone', 'mobilephone', 'mobile number'], role: FieldRole.CONTACT, meaning: 'Mobile phone', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['work phone', 'workphone', 'office phone', 'officephone', 'business phone'], role: FieldRole.CONTACT, meaning: 'Work phone', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['fax', 'fax number', 'faxnumber'], role: FieldRole.CONTACT, meaning: 'Fax number', sensitivity: 'low', stability: 'stable' },
    { keys: ['url', 'link', 'href', 'web address', 'webaddress', 'uri', 'website', 'web', 'homepage', 'webpage'], role: FieldRole.CONTACT, meaning: 'URL/website', sensitivity: 'low', stability: 'contextual' },
    { keys: ['image url', 'imageurl', 'image', 'img', 'photo', 'picture', 'pic', 'avatar', 'thumbnail', 'icon'], role: FieldRole.CONTACT, meaning: 'Image', sensitivity: 'low', stability: 'contextual' },

    //  Organizational (workplace structure) 
    { keys: ['department', 'dept', 'division', 'team', 'unit', 'group'], role: FieldRole.ORGANIZATIONAL, meaning: 'Department', sensitivity: 'low', stability: 'contextual' },
    { keys: ['job title', 'jobtitle', 'title', 'position', 'role', 'designation'], role: FieldRole.ORGANIZATIONAL, meaning: 'Job title', sensitivity: 'low', stability: 'contextual' },
    { keys: ['manager', 'supervisor', 'reports to', 'reportsto', 'boss', 'lead'], role: FieldRole.ORGANIZATIONAL, meaning: 'Manager', sensitivity: 'low', stability: 'contextual' },

    //  Quantity (numeric/measurable values) 
    { keys: ['amount', 'amt', 'value', 'total', 'sum', 'grand total'], role: FieldRole.QUANTITY, meaning: 'Amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['price', 'cost', 'unit price', 'unitprice', 'rate', 'charge', 'fee'], role: FieldRole.QUANTITY, meaning: 'Price/cost', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['revenue', 'income', 'earnings', 'sales', 'proceeds', 'gross'], role: FieldRole.QUANTITY, meaning: 'Revenue', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['balance', 'outstanding', 'remaining', 'due', 'owed'], role: FieldRole.QUANTITY, meaning: 'Balance', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['payment amount', 'paymentamount', 'payment', 'pay', 'payout'], role: FieldRole.QUANTITY, meaning: 'Payment amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['currency', 'curr', 'currency code', 'currencycode'], role: FieldRole.QUANTITY, meaning: 'Currency', sensitivity: 'low', stability: 'stable' },
    { keys: ['tax amount', 'taxamount', 'tax', 'taxes', 'vat', 'gst'], role: FieldRole.QUANTITY, meaning: 'Tax amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['discount', 'disc', 'discount amount', 'discountamount', 'rebate'], role: FieldRole.QUANTITY, meaning: 'Discount', sensitivity: 'low', stability: 'contextual' },
    { keys: ['quantity', 'qty', 'count', 'number', 'num', 'units', 'pieces', 'lot size'], role: FieldRole.QUANTITY, meaning: 'Quantity/count', sensitivity: 'low', stability: 'contextual' },
    { keys: ['age', 'years old', 'yearsold'], role: FieldRole.QUANTITY, meaning: 'Age', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['weight', 'mass', 'wt'], role: FieldRole.QUANTITY, meaning: 'Weight', sensitivity: 'low', stability: 'contextual' },
    { keys: ['height', 'length', 'width', 'depth', 'size', 'dimension'], role: FieldRole.QUANTITY, meaning: 'Dimension', sensitivity: 'low', stability: 'contextual' },
    { keys: ['percentage', 'percent', 'pct', 'ratio', 'rate'], role: FieldRole.QUANTITY, meaning: 'Percentage/ratio', sensitivity: 'low', stability: 'contextual' },
    { keys: ['score', 'rating', 'rank', 'grade', 'points'], role: FieldRole.QUANTITY, meaning: 'Score/rating', sensitivity: 'low', stability: 'contextual' },

    //  Spatial (location and geography) 
    { keys: ['street address', 'address', 'address1', 'address line 1', 'street', 'street1', 'mailing address', 'physical address'], role: FieldRole.SPATIAL, meaning: 'Street address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['address line 2', 'address2', 'address line2', 'apt', 'suite', 'unit', 'street2'], role: FieldRole.SPATIAL, meaning: 'Address line 2', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['city', 'town', 'municipality', 'locality'], role: FieldRole.SPATIAL, meaning: 'City', sensitivity: 'low', stability: 'contextual' },
    { keys: ['state', 'province', 'region', 'state province', 'stateprovince'], role: FieldRole.SPATIAL, meaning: 'State/province', sensitivity: 'low', stability: 'contextual' },
    { keys: ['postal code', 'zip', 'zipcode', 'zip code', 'postcode', 'post code'], role: FieldRole.SPATIAL, meaning: 'Postal code', sensitivity: 'low', stability: 'stable' },
    { keys: ['county', 'parish', 'district', 'borough'], role: FieldRole.SPATIAL, meaning: 'County/district', sensitivity: 'low', stability: 'stable' },
    { keys: ['country', 'nation', 'country code', 'countrycode'], role: FieldRole.SPATIAL, meaning: 'Country', sensitivity: 'low', stability: 'stable' },
    { keys: ['latitude', 'lat'], role: FieldRole.SPATIAL, meaning: 'Latitude', sensitivity: 'low', stability: 'stable' },
    { keys: ['longitude', 'lng', 'lon', 'long'], role: FieldRole.SPATIAL, meaning: 'Longitude', sensitivity: 'low', stability: 'stable' },
    { keys: ['full address', 'fulladdress', 'complete address', 'location', 'site'], role: FieldRole.SPATIAL, meaning: 'Full address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['po box', 'pobox', 'p.o. box'], role: FieldRole.SPATIAL, meaning: 'PO Box', sensitivity: 'low', stability: 'stable' },

    //  Relational (foreign keys, linked records) 
    { keys: ['parent id', 'parentid', 'parent'], role: FieldRole.RELATIONAL, meaning: 'Parent record', sensitivity: 'low', stability: 'stable' },
    { keys: ['customer id', 'customerid', 'customer', 'cust id', 'custid', 'client id', 'clientid', 'client'], role: FieldRole.RELATIONAL, meaning: 'Customer reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['user id', 'userid', 'user', 'member id', 'memberid'], role: FieldRole.RELATIONAL, meaning: 'User reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['account id', 'accountid', 'account', 'acct id', 'acctid'], role: FieldRole.RELATIONAL, meaning: 'Account reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['organization id', 'organizationid', 'orgid', 'org id', 'company id', 'companyid'], role: FieldRole.RELATIONAL, meaning: 'Organization reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['case id', 'caseid', 'case', 'case number', 'casenumber', 'ticket', 'ticket id', 'ticketid'], role: FieldRole.RELATIONAL, meaning: 'Case/ticket reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['order id', 'orderid'], role: FieldRole.RELATIONAL, meaning: 'Order reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['product id', 'productid', 'prod id', 'prodid', 'item id', 'itemid'], role: FieldRole.RELATIONAL, meaning: 'Product reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['vendor id', 'vendorid', 'supplier id', 'supplierid', 'vendor', 'supplier'], role: FieldRole.RELATIONAL, meaning: 'Vendor reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['employee id', 'employeeid', 'employee', 'emp id', 'empid', 'worker id'], role: FieldRole.RELATIONAL, meaning: 'Employee reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['owner', 'assigned to', 'assignedto', 'assignee', 'responsible', 'created by', 'createdby', 'modified by', 'modifiedby', 'author'], role: FieldRole.RELATIONAL, meaning: 'Person reference', sensitivity: 'low', stability: 'contextual' },

    //  Temporal (dates and times) 
    { keys: ['date', 'dt'], role: FieldRole.TEMPORAL, meaning: 'Date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['created date', 'createdat', 'created at', 'created', 'creation date', 'datecreated', 'date created', 'created on', 'createdon'], role: FieldRole.TEMPORAL, meaning: 'Creation date', sensitivity: 'low', stability: 'stable' },
    { keys: ['modified date', 'updatedat', 'updated at', 'updated', 'modifiedat', 'modified at', 'last modified', 'datemodified', 'date modified', 'modified on', 'modifiedon', 'last updated', 'lastupdated'], role: FieldRole.TEMPORAL, meaning: 'Last modified date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['deleted date', 'deletedat', 'deleted at', 'deleted', 'deletion date', 'removed date'], role: FieldRole.TEMPORAL, meaning: 'Deletion date', sensitivity: 'low', stability: 'stable' },
    { keys: ['start date', 'startdate', 'begin date', 'begindate', 'from date', 'fromdate', 'effective date', 'effectivedate', 'start'], role: FieldRole.TEMPORAL, meaning: 'Start date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['end date', 'enddate', 'finish date', 'finishdate', 'to date', 'todate', 'expiry date', 'expirydate', 'expiration date', 'expires', 'due date', 'duedate', 'deadline', 'end'], role: FieldRole.TEMPORAL, meaning: 'End date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['timestamp', 'ts', 'datetime', 'date time'], role: FieldRole.TEMPORAL, meaning: 'Timestamp', sensitivity: 'low', stability: 'stable' },
    { keys: ['year', 'yr', 'fiscal year', 'fiscalyear', 'fy'], role: FieldRole.TEMPORAL, meaning: 'Year', sensitivity: 'low', stability: 'stable' },
    { keys: ['month', 'mo', 'period'], role: FieldRole.TEMPORAL, meaning: 'Month', sensitivity: 'low', stability: 'stable' },
    { keys: ['quarter', 'qtr', 'q'], role: FieldRole.TEMPORAL, meaning: 'Quarter', sensitivity: 'low', stability: 'stable' },
    { keys: ['date of birth', 'dob', 'birthdate', 'birth date', 'birthday'], role: FieldRole.TEMPORAL, meaning: 'Date of birth', sensitivity: 'high', stability: 'stable' },
    { keys: ['hire date', 'hiredate', 'hired date', 'date hired', 'employment date', 'start date'], role: FieldRole.TEMPORAL, meaning: 'Hire date', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['termination date', 'terminationdate', 'term date', 'termdate', 'separation date', 'end of employment'], role: FieldRole.TEMPORAL, meaning: 'Termination date', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['duration', 'elapsed', 'time spent', 'timespent', 'hours', 'minutes'], role: FieldRole.TEMPORAL, meaning: 'Duration', sensitivity: 'low', stability: 'contextual' },
    { keys: ['time', 'clock time'], role: FieldRole.TEMPORAL, meaning: 'Time', sensitivity: 'low', stability: 'contextual' },
    { keys: ['day', 'day of week', 'weekday'], role: FieldRole.TEMPORAL, meaning: 'Day', sensitivity: 'low', stability: 'stable' },

    //  Technical (system/internal fields) 
    { keys: ['uuid', 'guid', 'unique id', 'uniqueid'], role: FieldRole.TECHNICAL, meaning: 'UUID', sensitivity: 'low', stability: 'stable' },
    { keys: ['hash', 'checksum', 'md5', 'sha256', 'sha1', 'digest'], role: FieldRole.TECHNICAL, meaning: 'Hash/checksum', sensitivity: 'low', stability: 'stable' },
    { keys: ['version', 'ver', 'revision', 'rev'], role: FieldRole.TECHNICAL, meaning: 'Version', sensitivity: 'low', stability: 'contextual' },
    { keys: ['sequence number', 'sequencenumber', 'seq', 'sequence', 'sort order', 'sortorder', 'display order', 'ordinal'], role: FieldRole.TECHNICAL, meaning: 'Sequence number', sensitivity: 'low', stability: 'contextual' },
    { keys: ['batch id', 'batchid', 'batch', 'run id', 'runid'], role: FieldRole.TECHNICAL, meaning: 'Batch ID', sensitivity: 'low', stability: 'stable' },
    { keys: ['api key', 'apikey', 'token', 'access token', 'secret', 'secret key'], role: FieldRole.TECHNICAL, meaning: 'API key', sensitivity: 'high', stability: 'stable' },
    { keys: ['ip address', 'ipaddress', 'ip', 'ipv4', 'ipv6'], role: FieldRole.TECHNICAL, meaning: 'IP address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['external identifier', 'externalidentifier', 'external id', 'externalid', 'ext id', 'extid', 'ref', 'reference', 'reference number'], role: FieldRole.TECHNICAL, meaning: 'External identifier', sensitivity: 'low', stability: 'stable' },
    { keys: ['file path', 'filepath', 'path', 'filename', 'file name'], role: FieldRole.TECHNICAL, meaning: 'File path', sensitivity: 'low', stability: 'contextual' },
    { keys: ['created by', 'createdby', 'author', 'creator'], role: FieldRole.TECHNICAL, meaning: 'Creator', sensitivity: 'low', stability: 'stable' },
    { keys: ['modified by', 'modifiedby', 'updated by', 'updatedby', 'last modified by', 'editor'], role: FieldRole.TECHNICAL, meaning: 'Last modifier', sensitivity: 'low', stability: 'stable' }
];

/**
 * Normalize a field name for comparison against definition keys.
 * Handles camelCase, snake_case, kebab-case, prefixes, suffixes.
 */
function normalizeFieldKey(fieldName) {
    return (fieldName || '')
        .toLowerCase()
        .replace(/([a-z])([A-Z])/g, '$1 $2')   // camelCase -> spaces
        .replace(/[-_]+/g, ' ')                  // separators -> spaces
        .replace(/\s+/g, ' ')                    // collapse whitespace
        .trim();
}

/**
 * Find the best matching definition for a field name.
 * Returns { definition, score, matchType } or null.
 */
function matchFieldToDefinition(fieldName) {
    if (!fieldName) return null;

    var normalized = normalizeFieldKey(fieldName);
    if (!normalized) return null;

    // Strip common prefixes (fld_, col_, field_, column_) and suffixes (_id, _key, _code, _num)
    var stripped = normalized
        .replace(/^(fld |col |field |column )/, '')
        .replace(/( id| key| code| num| no| number)$/, '');

    var bestMatch = null;
    var bestScore = 0;

    for (var i = 0; i < COMMON_DEFINITIONS.length; i++) {
        var def = COMMON_DEFINITIONS[i];
        var score = 0;
        var matchType = null;

        for (var k = 0; k < def.keys.length; k++) {
            var key = def.keys[k];

            // Exact match on normalized name
            if (normalized === key) {
                score = 1.0;
                matchType = 'exact';
                break;
            }

            // Exact match on stripped name
            if (stripped && stripped !== normalized && stripped === key) {
                score = 0.9;
                matchType = 'stripped';
                // Don't break, might find exact
            }

            // Contains match (field name contains the key or vice versa)
            if (score < 0.7) {
                if (normalized.includes(key) || key.includes(normalized)) {
                    var longer = normalized.length > key.length ? normalized : key;
                    var shorter = normalized.length > key.length ? key : normalized;
                    var containsScore = (shorter.length / longer.length) * 0.75;
                    if (containsScore > score) {
                        score = containsScore;
                        matchType = 'contains';
                    }
                }
            }
        }

        if (score > bestScore) {
            bestScore = score;
            bestMatch = { definition: def, score: score, matchType: matchType };
            if (score === 1.0) break; // Can't do better than exact
        }
    }

    // Minimum threshold
    return bestScore >= 0.4 ? bestMatch : null;
}

/**
 * Infer a field's semantic role from its name AND its data type.
 * Falls back to heuristics when no definition match is found.
 */
function inferFieldRole(fieldId, fieldMeta) {
    var fieldName = (fieldMeta && fieldMeta.fieldName) || fieldId;
    var fieldType = fieldMeta && fieldMeta.fieldType;

    // Try matching against known definitions first
    var match = matchFieldToDefinition(fieldName);
    if (match && match.score >= 0.4) {
        return {
            role: match.definition.role,
            confidence: match.score,
            meaning: match.definition.meaning,
            source: 'definition_match',
            matchType: match.matchType
        };
    }

    // Fallback: infer from field type
    if (fieldType === 'date' || fieldType === 'dateTime') {
        return { role: FieldRole.TEMPORAL, confidence: 0.6, meaning: 'Date field', source: 'type_inference' };
    }
    if (fieldType === 'number' || fieldType === 'currency' || fieldType === 'percent') {
        return { role: FieldRole.QUANTITY, confidence: 0.5, meaning: 'Numeric field', source: 'type_inference' };
    }
    if (fieldType === 'email') {
        return { role: FieldRole.CONTACT, confidence: 0.8, meaning: 'Email field', source: 'type_inference' };
    }
    if (fieldType === 'url') {
        return { role: FieldRole.CONTACT, confidence: 0.5, meaning: 'URL field', source: 'type_inference' };
    }
    if (fieldType === 'checkbox') {
        return { role: FieldRole.STATUS, confidence: 0.4, meaning: 'Boolean field', source: 'type_inference' };
    }
    if (fieldType === 'multipleRecordLinks') {
        return { role: FieldRole.RELATIONAL, confidence: 0.7, meaning: 'Linked records', source: 'type_inference' };
    }
    if (fieldType === 'multipleAttachments') {
        return { role: FieldRole.TECHNICAL, confidence: 0.5, meaning: 'Attachments', source: 'type_inference' };
    }

    // Fallback: heuristic patterns on the field name
    var norm = normalizeFieldKey(fieldName);
    if (/\b(id|key|pk|guid|uuid)\b/.test(norm)) {
        return { role: FieldRole.IDENTIFIER, confidence: 0.5, meaning: 'ID-like field', source: 'name_heuristic' };
    }
    if (/\b(date|time|created|updated|modified|timestamp)\b/.test(norm)) {
        return { role: FieldRole.TEMPORAL, confidence: 0.5, meaning: 'Time-like field', source: 'name_heuristic' };
    }
    if (/\b(name|title|label|subject|headline)\b/.test(norm)) {
        return { role: FieldRole.PRIMARY_IDENTITY, confidence: 0.5, meaning: 'Name-like field', source: 'name_heuristic' };
    }
    if (/\b(status|state|type|kind|category|active|enabled|flag)\b/.test(norm)) {
        return { role: FieldRole.STATUS, confidence: 0.4, meaning: 'Status-like field', source: 'name_heuristic' };
    }
    if (/\b(amount|price|cost|total|sum|count|qty|quantity|rate|fee|balance|revenue|payment|tax|discount|score|rating|percent|ratio)\b/.test(norm)) {
        return { role: FieldRole.QUANTITY, confidence: 0.4, meaning: 'Quantity-like field', source: 'name_heuristic' };
    }
    if (/\b(email|phone|mobile|cell|tel|fax|url|website|link)\b/.test(norm)) {
        return { role: FieldRole.CONTACT, confidence: 0.4, meaning: 'Contact-like field', source: 'name_heuristic' };
    }
    if (/\b(address|city|state|zip|postal|country|county|lat|lon|location)\b/.test(norm)) {
        return { role: FieldRole.SPATIAL, confidence: 0.4, meaning: 'Location-like field', source: 'name_heuristic' };
    }
    if (/\b(description|desc|notes|note|comment|remarks|memo|body|content|text|summary)\b/.test(norm)) {
        return { role: FieldRole.DESCRIPTIVE, confidence: 0.4, meaning: 'Descriptive field', source: 'name_heuristic' };
    }
    if (/\b(department|dept|team|role|position|manager|supervisor|job)\b/.test(norm)) {
        return { role: FieldRole.ORGANIZATIONAL, confidence: 0.4, meaning: 'Org field', source: 'name_heuristic' };
    }

    return { role: FieldRole.UNKNOWN, confidence: 0, meaning: 'Unknown', source: 'none' };
}

/**
 * Score a single field for left-to-right relevance.
 * Lower score = more relevant = further left.
 *
 * Scoring formula:
 *   base = ROLE_PRIORITY[role] * 100     (role is the primary sort factor)
 *   penalty adjustments:
 *     - High confidence match gets a bonus (moved left within role group)
 *     - Fields with "name" in them get extra left-push
 *     - Fields with only-ID suffixes get pushed right within their role group
 *     - Alphabetical tiebreaker within same score
 */
function scoreFieldRelevance(fieldId, fieldMeta) {
    var inference = inferFieldRole(fieldId, fieldMeta);
    var rolePriority = ROLE_PRIORITY[inference.role] !== undefined ? ROLE_PRIORITY[inference.role] : 11;

    // Base score from role (0-1100 range, in steps of 100)
    var score = rolePriority * 100;

    // Confidence adjustment: higher confidence = slightly more left (-0 to -40)
    score -= Math.round(inference.confidence * 40);

    // Name-like fields within identity get extra boost
    var norm = normalizeFieldKey((fieldMeta && fieldMeta.fieldName) || fieldId);
    if (inference.role === FieldRole.PRIMARY_IDENTITY) {
        // "name" or "full name" is the king column
        if (norm === 'name' || norm === 'full name' || norm === 'fullname' || norm === 'display name') {
            score -= 50;
        }
        // first name before last name
        if (norm.includes('first')) score -= 20;
        if (norm.includes('last')) score -= 10;
    }

    // Penalize pure ID fields (they look like "fldXyz123")
    if (/^fld[a-z0-9]+$/i.test(fieldId) && (!fieldMeta || !fieldMeta.fieldName || fieldMeta.fieldName === fieldId)) {
        score += 50; // Push raw field IDs to the right
    }

    return {
        fieldId: fieldId,
        score: score,
        role: inference.role,
        confidence: inference.confidence,
        meaning: inference.meaning,
        source: inference.source
    };
}

/**
 * Compute the intelligent default field order for a table.
 * This replaces the old alphabetical sort with semantic ordering.
 *
 * Returns an array of field IDs sorted by relevance (most relevant leftmost).
 */
function computeSmartFieldOrder(tableId) {
    var fields = META_FIELDS[tableId] || {};
    var fieldIds = Object.keys(fields);

    if (fieldIds.length === 0) return [];

    // Score every field
    var scored = fieldIds.map(function(fid) {
        return scoreFieldRelevance(fid, fields[fid]);
    });

    // Sort by score ascending (lower = more relevant = further left)
    // Tiebreaker: alphabetical by field name
    scored.sort(function(a, b) {
        if (a.score !== b.score) return a.score - b.score;
        var nameA = (fields[a.fieldId] && fields[a.fieldId].fieldName || a.fieldId).toLowerCase();
        var nameB = (fields[b.fieldId] && fields[b.fieldId].fieldName || b.fieldId).toLowerCase();
        return nameA.localeCompare(nameB);
    });

    // Log the smart ordering decision for debugging
    if (scored.length > 0) {
        console.log('Smart column order for table ' + tableId + ':',
            scored.slice(0, 8).map(function(s) {
                return (fields[s.fieldId] && fields[s.fieldId].fieldName || s.fieldId) +
                    ' [' + s.role + ', score=' + s.score + ']';
            }).join(' | ')
        );
    }

    return scored.map(function(s) { return s.fieldId; });
}

// ============ View Field Configuration ============

// Get the field configuration for a view (from cache or initialize default)
function getViewFieldConfig(tableId, viewId) {
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};

    // Return cached config if exists
    if (VIEW_FIELD_CONFIG[tableId][viewId]) {
        return VIEW_FIELD_CONFIG[tableId][viewId];
    }

    // Check if view has stored config in META_VIEWS
    var view = META_VIEWS[tableId]?.[viewId];
    if (view && (view.hiddenFieldIds || view.fieldOrder)) {
        VIEW_FIELD_CONFIG[tableId][viewId] = {
            hiddenFieldIds: view.hiddenFieldIds || [],
            fieldOrder: view.fieldOrder || []
        };
        return VIEW_FIELD_CONFIG[tableId][viewId];
    }

    // Initialize default config - show all fields in their natural order
    return initViewFieldConfig(tableId, viewId);
}

// Initialize default view field config (all fields visible)
function initViewFieldConfig(tableId, viewId) {
    // Use intelligent column ordering instead of alphabetical sort.
    // This puts the most relevant fields (names, identifiers) leftmost
    // and pushes metadata/technical fields to the right.
    var smartOrder = computeSmartFieldOrder(tableId);

    var config = {
        hiddenFieldIds: [],            // No fields hidden initially (all visible)
        fieldOrder: smartOrder.slice()  // Intelligent semantic order
    };

    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    VIEW_FIELD_CONFIG[tableId][viewId] = config;

    return config;
}

// Save view field configuration to memory and IndexedDB
async function saveViewFieldConfig(tableId, viewId, config) {
    // Update cache
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    VIEW_FIELD_CONFIG[tableId][viewId] = config;

    // Update META_VIEWS and persist to IndexedDB
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        // Create a synthetic view if it doesn't exist
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId,
            viewType: 'grid'
        };
    }

    // Merge config into view
    META_VIEWS[tableId][viewId].hiddenFieldIds = config.hiddenFieldIds;
    META_VIEWS[tableId][viewId].fieldOrder = config.fieldOrder;

    // Persist to IndexedDB
    await saveView(META_VIEWS[tableId][viewId]);
}

// Save view filters, sorts, and groupBy to IndexedDB
async function saveViewFiltersAndSorts(tableId, viewId, filters, sorts, groupBy) {
    if (!tableId || !viewId) return;

    // Update META_VIEWS
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        // Create a synthetic view if it doesn't exist
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId,
            viewType: 'grid'
        };
    }

    // Store filters, sorts, and groupBy
    META_VIEWS[tableId][viewId].filters = filters || [];
    META_VIEWS[tableId][viewId].sorts = sorts || [];
    META_VIEWS[tableId][viewId].groupBy = groupBy || null;

    // Persist to IndexedDB
    await saveView(META_VIEWS[tableId][viewId]);
}

// Get view filters, sorts, and groupBy
function getViewFiltersAndSorts(tableId, viewId) {
    if (!tableId || !viewId) return { filters: [], sorts: [], groupBy: null };

    var view = META_VIEWS[tableId]?.[viewId];
    return {
        filters: (view && view.filters) ? view.filters.slice() : [],
        sorts: (view && view.sorts) ? view.sorts.slice() : [],
        groupBy: (view && view.groupBy) ? view.groupBy : null
    };
}

// Get visible fields for current view in correct order
function getVisibleFieldsForView(tableId, viewId) {
    var config = getViewFieldConfig(tableId, viewId || '_default');
    var fields = META_FIELDS[tableId] || {};
    var allFieldIds = Object.keys(fields);

    // Hidden fields are in hiddenFieldIds; all others are visible
    var hiddenSet = new Set(config.hiddenFieldIds || []);
    var result = [];
    var addedSet = new Set();

    // First add fields from fieldOrder that are not hidden
    for (var fid of (config.fieldOrder || [])) {
        if (fields[fid] && !hiddenSet.has(fid) && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    // Add any remaining visible fields not in fieldOrder (newly added fields)
    for (var fid of allFieldIds) {
        if (!hiddenSet.has(fid) && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    return result;
}

// Get all fields in order (both visible and hidden) for the fields dropdown
function getAllFieldsInOrder(tableId, viewId) {
    var config = getViewFieldConfig(tableId, viewId || '_default');
    var fields = META_FIELDS[tableId] || {};
    var allFieldIds = Object.keys(fields);
    var result = [];
    var addedSet = new Set();

    // First add fields in fieldOrder
    for (var fid of (config.fieldOrder || [])) {
        if (fields[fid] && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    // Then add any remaining fields (newly added ones)
    for (var fid of allFieldIds) {
        if (!addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    return result;
}

// Toggle field visibility for current view
function toggleFieldVisibility(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    if (!config.hiddenFieldIds) config.hiddenFieldIds = [];

    var idx = config.hiddenFieldIds.indexOf(fieldId);
    if (idx >= 0) {
        // Field is hidden, make it visible
        config.hiddenFieldIds.splice(idx, 1);
    } else {
        // Field is visible, hide it
        config.hiddenFieldIds.push(fieldId);
    }

    // Ensure field is in fieldOrder
    if (!config.fieldOrder.includes(fieldId)) {
        config.fieldOrder.push(fieldId);
    }

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

// Move field up in order (optimized with DOM manipulation)
function moveFieldUp(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var idx = config.fieldOrder.indexOf(fieldId);
    if (idx > 0) {
        // Move column in DOM immediately (no full re-render)
        moveColumnInDOM(idx, idx - 1);

        // Swap with previous in array
        var temp = config.fieldOrder[idx - 1];
        config.fieldOrder[idx - 1] = config.fieldOrder[idx];
        config.fieldOrder[idx] = temp;

        // Fast update: in-memory + debounced save
        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();
    }
}

// Move field down in order (optimized with DOM manipulation)
function moveFieldDown(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var idx = config.fieldOrder.indexOf(fieldId);
    if (idx >= 0 && idx < config.fieldOrder.length - 1) {
        // Move column in DOM immediately (no full re-render)
        moveColumnInDOM(idx, idx + 1);

        // Swap with next in array
        var temp = config.fieldOrder[idx + 1];
        config.fieldOrder[idx + 1] = config.fieldOrder[idx];
        config.fieldOrder[idx] = temp;

        // Fast update: in-memory + debounced save
        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();
    }
}

// Show all fields
function showAllFields() {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var fields = META_FIELDS[currentTable] || {};
    var allFieldIds = Object.keys(fields);

    var config = getViewFieldConfig(currentTable, viewId);
    config.hiddenFieldIds = []; // Clear all hidden fields

    // Ensure all fields are in fieldOrder
    for (var fid of allFieldIds) {
        if (!config.fieldOrder.includes(fid)) {
            config.fieldOrder.push(fid);
        }
    }

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

// Hide all fields (except keep at least one visible)
function hideAllFields() {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var fields = META_FIELDS[currentTable] || {};
    var allFieldIds = Object.keys(fields);

    var config = getViewFieldConfig(currentTable, viewId);

    // Get all fields in order, keep the first one visible
    var orderedFields = getAllFieldsInOrder(currentTable, viewId);
    var firstField = orderedFields[0] || allFieldIds[0];

    // Hide all fields except the first one
    config.hiddenFieldIds = allFieldIds.filter(fid => fid !== firstField);

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

function getLocalStats() {
    return new Promise(async (resolve) => {
        try {
            var tempDb = await openDB();
            var count = await new Promise((res, rej) => {
                var tx = tempDb.transaction('data', 'readonly');
                var req = tx.objectStore('data').count();
                req.onsuccess = () => res(req.result);
                req.onerror = () => res(0);
            });
            var lastTimestamp = await new Promise((res, rej) => {
                var tx = tempDb.transaction('sync', 'readonly');
                var req = tx.objectStore('sync').get('lastEventTimestamp');
                req.onsuccess = () => res(req.result ? req.result.value : null);
                req.onerror = () => res(null);
            });
            tempDb.close();
            resolve({ count, lastTimestamp });
        } catch (e) {
            resolve({ count: 0, lastTimestamp: null });
        }
    });
}

// ============ Synapse Login ============

var SYNAPSE_HOMESERVER_URL = 'https://app.aminoimmigration.com';
var SYNAPSE_SESSION_KEY = 'amino_synapse_session';

function _saveSynapseSession(session) {
    try {
        localStorage.setItem(SYNAPSE_SESSION_KEY, JSON.stringify(session));
    } catch (e) {
        console.warn('[Synapse] Could not save session:', e);
    }
}

function _loadSynapseSession() {
    try {
        var stored = localStorage.getItem(SYNAPSE_SESSION_KEY);
        return stored ? JSON.parse(stored) : null;
    } catch (e) {
        return null;
    }
}

function _clearSynapseSession() {
    localStorage.removeItem(SYNAPSE_SESSION_KEY);
}

async function verifySynapseSession() {
    var session = _loadSynapseSession();
    if (!session || !session.accessToken) return false;

    try {
        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/account/whoami', {
            headers: { 'Authorization': 'Bearer ' + session.accessToken }
        });
        if (response.ok) return true;
        // Token expired or invalid
        _clearSynapseSession();
        return false;
    } catch (e) {
        // Network error  allow offline access if session exists
        console.warn('[Synapse] Could not verify session, allowing cached session:', e);
        return true;
    }
}

async function trySynapseLogin() {
    var username = document.getElementById('synapse-username').value.trim();
    var password = document.getElementById('synapse-password').value.trim();

    if (!username || !password) {
        showSynapseError('Please enter your username and password.');
        return;
    }

    var btn = document.getElementById('synapse-login-btn');
    btn.textContent = 'Signing in...';
    btn.disabled = true;
    hideSynapseError();

    try {
        var body = {
            type: 'm.login.password',
            identifier: { type: 'm.id.user', user: username },
            password: password,
            initial_device_display_name: 'Amino Viewer'
        };

        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });

        var data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'Login failed');
        }

        _saveSynapseSession({
            accessToken: data.access_token,
            userId: data.user_id,
            deviceId: data.device_id
        });

        // Set up MatrixClient session for room operations
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, data.access_token, data.user_id, data.device_id);

        hideSynapseLoginScreen();
        // Update sidebar to show Matrix-connected state
        updateMatrixStatus();
        renderSidebar();
    } catch (err) {
        console.error('[Synapse] Login failed:', err);
        showSynapseError(err.message || 'Login failed. Please check your credentials.');
    } finally {
        btn.textContent = 'Sign In';
        btn.disabled = false;
    }
}

function showSynapseError(msg) {
    var el = document.getElementById('synapse-login-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function hideSynapseError() {
    var el = document.getElementById('synapse-login-error');
    el.style.display = 'none';
}

function showSynapseLoginScreen() {
    var el = document.getElementById('synapse-login-screen');
    el.classList.remove('hidden', 'fading-out');
}

function hideSynapseLoginScreen() {
    var el = document.getElementById('synapse-login-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    setTimeout(function() { el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

async function initSynapseLogin() {
    var valid = await verifySynapseSession();
    if (valid) {
        // Session is valid, proceed to app auth
        return true;
    }
    // No valid session  show Synapse login screen
    showSynapseLoginScreen();
    return false;
}

function synapseLogout() {
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        // Fire and forget logout request
        fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/logout', {
            method: 'POST',
            headers: {
                'Authorization': 'Bearer ' + session.accessToken,
                'Content-Type': 'application/json'
            }
        }).catch(function() {});
    }
    _clearSynapseSession();
}

// Wire up Synapse login UI
document.getElementById('synapse-login-btn').onclick = trySynapseLogin;
document.getElementById('synapse-username').onkeydown = function(e) { if (e.key === 'Enter') document.getElementById('synapse-password').focus(); };
document.getElementById('synapse-password').onkeydown = function(e) { if (e.key === 'Enter') trySynapseLogin(); };

// ============ Auth ============

document.getElementById('auth-submit').onclick = tryAuth;
document.getElementById('api-key-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('set-filter-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('auth-clear').onclick = clearLocalAndReset;
document.getElementById('connect-api-key-input').onkeydown = (e) => { if (e.key === 'Enter') submitConnectApi(); };
document.getElementById('connect-api-set-filter').onkeydown = (e) => { if (e.key === 'Enter') submitConnectApi(); };

async function initAuthScreen() {
    var stats = await getLocalStats();
    var infoEl = document.getElementById('auth-info');
    var clearBtn = document.getElementById('auth-clear');

    if (stats.count > 0) {
        infoEl.textContent = 'Local cache: ' + stats.count.toLocaleString() + ' records';
        clearBtn.classList.remove('hidden');
    } else {
        infoEl.textContent = 'No local data';
        clearBtn.classList.add('hidden');
    }

    // Check for saved credentials and auto-authenticate (encrypted or plaintext)
    var savedCredentials = await loadEncryptedCredentials();

    // Pre-fill input fields with saved credentials
    if (savedCredentials && savedCredentials.apiKey) {
        document.getElementById('api-key-input').value = savedCredentials.apiKey;
    }
    if (savedCredentials && savedCredentials.setFilter) {
        document.getElementById('set-filter-input').value = savedCredentials.setFilter;
    }

    if (savedCredentials && savedCredentials.apiKey) {
        // Auto-login without showing auth screen
        API_KEY = savedCredentials.apiKey;
        SET_FILTER = savedCredentials.setFilter || null;

        // Step 1: Validate the saved API key still works
        try {
            await initSecureEndpoints(API_KEY);
            await fetchPage(1, null, { last: true });
        } catch (err) {
            console.error('Saved API key validation failed:', err);
            API_KEY = null;
            SET_FILTER = null;
            clearSecureEndpoints();
            // Key is invalid or revoked  clear it so user isn't stuck in a loop
            clearEncryptedCredentials();
            showAuthError('Saved API key is no longer valid. Please re-enter your API key.');
            if (stats.count > 0) {
                infoEl.textContent = 'Local cache: ' + stats.count.toLocaleString() + ' records';
            } else {
                infoEl.textContent = 'No local data';
            }
            // Fall through to show auth screen below
        }

        // Step 2: Key is valid, proceed with init
        if (API_KEY) {
            try {
                await init();
                // Silently restore Matrix session if one exists (non-blocking)
                restoreMatrixSessionQuietly();
                return; // Success - auth screen stays hidden
            } catch (err) {
                console.error('Auto-login init failed:', err);
                // Key was valid but init failed (transient error)  keep credentials
                // so auto-login can retry on next page load
                showAuthError('Initialization failed: ' + err.message + '. Click Connect to retry.');
                if (stats.count > 0) {
                    infoEl.textContent = 'Local cache: ' + stats.count.toLocaleString() + ' records';
                } else {
                    infoEl.textContent = 'No local data';
                }
            }
        }
    }

    // No saved credentials or auto-login failed - show auth screen
    // Cancel any pending hide timeout to prevent race condition
    if (_hideAuthTimeout) { clearTimeout(_hideAuthTimeout); _hideAuthTimeout = null; }
    var authEl = document.getElementById('auth-screen');
    authEl.classList.remove('hidden', 'fading-out');
}

// Silently restore Matrix session without blocking app startup
function restoreMatrixSessionQuietly() {
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
        updateMatrixStatus();
    }
}

async function clearLocalAndReset() {
    if (!confirm('Clear all local data?')) return;
    try {
        db = await openDB();
        await clearAllData();
        db.close();
        db = null;
    } catch (e) {
        console.error('Clear error:', e);
    }
    // Clear stale form state and errors
    document.getElementById('api-key-input').value = '';
    document.getElementById('set-filter-input').value = '';
    document.getElementById('auth-error').style.display = 'none';
    initAuthScreen();
}

async function tryAuth() {
    var key = document.getElementById('api-key-input').value.trim();
    if (!key) {
        showAuthError('Please enter an API key');
        return;
    }

    var btn = document.getElementById('auth-submit');
    btn.textContent = 'Connecting...';
    btn.disabled = true;
    document.getElementById('auth-error').style.display = 'none';

    API_KEY = key;
    SET_FILTER = document.getElementById('set-filter-input').value.trim() || null;

    try {
        await initSecureEndpoints(key);

        // Validate the API key with a lightweight test call before committing
        await fetchPage(1, null, { last: true });
    } catch (err) {
        console.error('Auth validation error:', err);
        showAuthError('Connection failed: ' + err.message);
        btn.textContent = 'Connect';
        btn.disabled = false;
        API_KEY = null;
        SET_FILTER = null;
        clearSecureEndpoints();
        return;
    }

    // API key is valid  save credentials immediately so they persist
    // even if hydration/init is interrupted (e.g. user closes tab)
    await saveEncryptedCredentials(API_KEY, SET_FILTER);

    try {
        await init();
    } catch (err) {
        console.error('Init error:', err);
        // Re-show auth screen in case init() already hid it before failing
        if (_hideAuthTimeout) { clearTimeout(_hideAuthTimeout); _hideAuthTimeout = null; }
        var authEl = document.getElementById('auth-screen');
        authEl.classList.remove('hidden', 'fading-out');
        showAuthError('Initialization failed: ' + err.message);
        btn.textContent = 'Connect';
        btn.disabled = false;
        // Don't clear credentials  the key is valid, init just had a transient error.
        // On next page load, auto-login will retry init.
        return;
    }

    // Silently restore Matrix session if one exists (non-blocking)
    restoreMatrixSessionQuietly();

    btn.textContent = 'Connect';
    btn.disabled = false;
}

function showAuthError(msg) {
    var el = document.getElementById('auth-error');
    el.textContent = msg;
    el.style.display = 'block';
}

var _hideAuthTimeout = null;
function hideAuthScreen() {
    var el = document.getElementById('auth-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        if (_hideAuthTimeout) { clearTimeout(_hideAuthTimeout); _hideAuthTimeout = null; }
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    _hideAuthTimeout = setTimeout(function() { _hideAuthTimeout = null; el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

function showAuthScreen() {
    // Cancel any pending hide timeout to prevent race condition
    if (_hideAuthTimeout) { clearTimeout(_hideAuthTimeout); _hideAuthTimeout = null; }

    var el = document.getElementById('auth-screen');
    el.classList.remove('hidden', 'fading-out');
    if (pollInterval) clearInterval(pollInterval);
    SyncHistory.stopPolling();
    initAuthScreen();
}

function logout() {
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = null;
    SyncHistory.stopPolling();
    API_KEY = null;
    SET_FILTER = null;
    clearSecureEndpoints();
    // Close stale IndexedDB connection
    if (db) {
        try { db.close(); } catch (e) { /* ignore */ }
        db = null;
    }
    // Clear saved credentials (both encrypted and plaintext)
    clearEncryptedCredentials();
    clearSessionKey();
    // Show auth screen (Matrix session is independent  user disconnects Matrix separately)
    showAuthScreen();
}

async function manualSync() {
    if (!API_KEY) {
        showConnectApiModal();
        return;
    }
    await incrementalSync();
}


// Show/hide the Connect API button based on API_KEY state
function updateConnectApiButton() {
    var btn = document.getElementById('connect-api-btn');
    if (btn) {
        btn.style.display = API_KEY ? 'none' : '';
    }
}

// Connect API modal functions
function showConnectApiModal() {
    var modal = document.getElementById('connect-api-modal');
    modal.style.display = 'flex';
    document.getElementById('connect-api-key-input').value = '';
    document.getElementById('connect-api-set-filter').value = '';
    document.getElementById('connect-api-error').style.display = 'none';
    document.getElementById('connect-api-key-input').focus();
}

function hideConnectApiModal() {
    document.getElementById('connect-api-modal').style.display = 'none';
}

async function submitConnectApi() {
    var key = document.getElementById('connect-api-key-input').value.trim();
    if (!key) {
        var errEl = document.getElementById('connect-api-error');
        errEl.textContent = 'Please enter an API key';
        errEl.style.display = 'block';
        return;
    }

    var btn = document.getElementById('connect-api-submit');
    btn.textContent = 'Connecting...';
    btn.disabled = true;
    document.getElementById('connect-api-error').style.display = 'none';

    API_KEY = key;
    SET_FILTER = document.getElementById('connect-api-set-filter').value.trim() || null;

    try {
        // Initialize endpoint URLs before making any API calls
        await initSecureEndpoints(key);

        // Test the connection with a lightweight check
        var testResult = await fetchPage(1, null, { last: true });

        // Save credentials
        await saveEncryptedCredentials(API_KEY, SET_FILTER);

        // Hide modal and update UI
        hideConnectApiModal();
        updateConnectApiButton();

        // Start syncing
        updateStatus('Connected! Syncing...', false, null, null);
        await incrementalSync();

        if (pollInterval) clearInterval(pollInterval);
        pollInterval = setInterval(incrementalSync, 60000);
        SyncHistory.startPolling();

        updateStatus('Up to date', true, null, null);
    } catch (err) {
        console.error('Connect API failed:', err);
        var errEl = document.getElementById('connect-api-error');
        errEl.textContent = 'Connection failed: ' + err.message;
        errEl.style.display = 'block';
        API_KEY = null;
        SET_FILTER = null;
        clearSecureEndpoints();
    }

    btn.textContent = 'Connect';
    btn.disabled = false;
}

// ============ Data Processing ============

function parsePayload(payload) {
    if (typeof payload === 'string') {
        try { return JSON.parse(payload); } catch { return null; }
    }
    return payload;
}

// Infer field type from a sample value (used for auto-discovered fields)
function inferFieldType(value) {
    if (value === null || value === undefined) return 'unknown';
    if (Array.isArray(value)) {
        // Check if it's an attachment array (objects with url property)
        if (value.length > 0 && typeof value[0] === 'object' && value[0].url) {
            return 'multipleAttachments';
        }
        // Check if it's a linked record array (strings starting with 'rec')
        if (value.length > 0 && typeof value[0] === 'string' && value[0].startsWith('rec')) {
            return 'multipleRecordLinks';
        }
        return 'multipleSelects';
    }
    if (typeof value === 'object') {
        // Could be a single attachment or other complex type
        if (value.url) return 'multipleAttachments';
        return 'object';
    }
    if (typeof value === 'number') {
        return Number.isInteger(value) ? 'number' : 'number';
    }
    if (typeof value === 'boolean') return 'checkbox';
    if (typeof value === 'string') {
        // Try to detect dates
        if (/^\d{4}-\d{2}-\d{2}/.test(value)) return 'date';
        // Try to detect emails
        if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) return 'email';
        // Try to detect URLs
        if (/^https?:\/\//.test(value)) return 'url';
        return 'singleLineText';
    }
    return 'unknown';
}

// Fast in-memory event processing for CSV import - skips IndexedDB entirely
// Calls onProgress periodically for UI updates
async function processEventsMemoryOnly(events, onProgress) {
    if (!events || !Array.isArray(events)) return;

    var tableDataMap = {}; // tableId -> { recordId -> fields }
    var total = events.length;

    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;

        if (recordType === 'table') {
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else if (recordType === 'viewConfig') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) {
                META_VIEWS[tableId][viewId] = { tableId, viewId };
            }
            var viewData = META_VIEWS[tableId][viewId];
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.hiddenFieldIds) viewData.hiddenFieldIds = payload.hiddenFieldIds;
            if (payload.fieldOrder) viewData.fieldOrder = payload.fieldOrder;
            if (payload.filters) viewData.filters = payload.filters;
            if (payload.sorts) viewData.sorts = payload.sorts;
            if (payload.folderId !== undefined) viewData.folderId = payload.folderId;

        } else if (recordType === 'tableSettings') {
            // User-specific table and view settings
            if (payload.tables) TABLE_SETTINGS.tables = payload.tables;
            if (payload.tableOrder) TABLE_SETTINGS.tableOrder = payload.tableOrder;
            if (payload.views) TABLE_SETTINGS.views = payload.views;

        } else {
            // Data record
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            // Auto-create placeholder table
            if (!META_TABLES[tableId]) {
                META_TABLES[tableId] = {
                    tableId: tableId,
                    tableName: tableId,
                    _placeholder: true
                };
            }

            // Auto-create placeholder fields
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            var allFieldIds = [
                ...Object.keys(pfields.INS || {}),
                ...Object.keys(pfields.ALT || {}),
                ...Object.keys(pfields.SYN || {}),
                ...(Array.isArray(pfields.NUL) ? pfields.NUL : [])
            ];
            for (var fid of allFieldIds) {
                if (!META_FIELDS[tableId][fid]) {
                    var sampleValue = (pfields.INS && pfields.INS[fid]) || (pfields.ALT && pfields.ALT[fid]) || (pfields.SYN && pfields.SYN[fid]);
                    META_FIELDS[tableId][fid] = {
                        tableId: tableId,
                        fieldId: fid,
                        fieldName: fid,
                        fieldType: inferFieldType(sampleValue),
                        _placeholder: true
                    };
                }
            }

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) tableDataMap[tableId][recordId] = {};

            var state = tableDataMap[tableId][recordId];
            if (pfields.INS) Object.assign(state, pfields.INS);
            if (pfields.ALT) Object.assign(state, pfields.ALT);
            if (pfields.SYN) Object.assign(state, pfields.SYN);
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => delete state[fieldId]);
            }
        }

        // Report progress and yield to UI every 5000 events
        if (i > 0 && i % 5000 === 0) {
            if (onProgress) onProgress(i, total, Object.keys(META_TABLES).length);
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Store data records in a memory-only snapshot (for showing table data)
    // Structure: IN_MEMORY_DATA[tableId][recordId] = { fields }
    window.IN_MEMORY_DATA = tableDataMap;

    if (onProgress) onProgress(total, total, Object.keys(META_TABLES).length);
}

async function processEvents(events) {
    if (!events || !Array.isArray(events)) return;

    var tables = [];
    var fields = [];
    var views = [];
    var dataRecords = [];
    var fieldHistoryEntries = [];
    var tableDataMap = {}; // tableId -> { recordId -> fields }

    // Pre-load existing record states from IndexedDB for accurate history oldValue tracking
    // First pass: collect all unique [tableId, recordId] pairs for data records
    var recordsToLoad = {}; // tableId -> Set of recordIds
    for (var e of events) {
        if (!e || !e.set || !e.recordId) continue;
        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;
        var recordType = payload._set;
        // Only load state for data records (not table/field/view metadata)
        if (recordType !== 'table' && recordType !== 'field' && recordType !== 'view') {
            var tableId = e.set.replace('airtable:', '');
            if (!recordsToLoad[tableId]) recordsToLoad[tableId] = new Set();
            recordsToLoad[tableId].add(e.recordId);
        }
    }

    // Load existing records from IndexedDB
    for (var tableId in recordsToLoad) {
        var recordIds = Array.from(recordsToLoad[tableId]);
        if (recordIds.length > 0) {
            var existingRecords = await getRecordsByIds(tableId, recordIds);
            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            for (var rec of existingRecords) {
                // Pre-populate with existing field values
                tableDataMap[tableId][rec.recordId] = { ...rec.fields };
            }
        }
    }

    for (var e of events) {
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;
        var eventId = e.id;
        var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

        if (recordType === 'table') {
            // Tables: recordId starts with "tbl", set points to base
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            tables.push(tableData);
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            // Fields: recordId starts with "fld", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            fields.push(fieldData);
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            // Views: recordId starts with "viw", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            views.push(viewData);
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else if (recordType === 'viewConfig') {
            // View configuration updates: hiddenFieldIds, fieldOrder, filters, sorts
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;

            // Initialize META_VIEWS if needed
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) {
                META_VIEWS[tableId][viewId] = { tableId, viewId };
            }

            // Update the view with config data
            var viewData = META_VIEWS[tableId][viewId];
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.hiddenFieldIds) viewData.hiddenFieldIds = payload.hiddenFieldIds;
            if (payload.fieldOrder) viewData.fieldOrder = payload.fieldOrder;
            if (payload.filters) viewData.filters = payload.filters;
            if (payload.sorts) viewData.sorts = payload.sorts;
            if (payload.folderId !== undefined) viewData.folderId = payload.folderId;

            views.push(viewData);

        } else if (recordType === 'tableSettings') {
            // User-specific table and view settings
            if (payload.tables) TABLE_SETTINGS.tables = payload.tables;
            if (payload.tableOrder) TABLE_SETTINGS.tableOrder = payload.tableOrder;
            if (payload.views) TABLE_SETTINGS.views = payload.views;

        } else {
            // Data record: recordId starts with "rec"
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            // Auto-create placeholder table if not seen yet (will be updated when real metadata arrives)
            if (!META_TABLES[tableId]) {
                var placeholderTable = {
                    tableId: tableId,
                    tableName: tableId,  // Use ID as placeholder name
                    _placeholder: true   // Mark as placeholder for later update
                };
                META_TABLES[tableId] = placeholderTable;
                tables.push(placeholderTable);
            }

            // Auto-create placeholder fields from INS/ALT/SYN/NUL keys
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            var allFieldIds = [
                ...Object.keys(pfields.INS || {}),
                ...Object.keys(pfields.ALT || {}),
                ...Object.keys(pfields.SYN || {}),
                ...(Array.isArray(pfields.NUL) ? pfields.NUL : [])
            ];
            for (var fid of allFieldIds) {
                if (!META_FIELDS[tableId][fid]) {
                    // Get a sample value to infer type
                    var sampleValue = (pfields.INS && pfields.INS[fid]) || (pfields.ALT && pfields.ALT[fid]) || (pfields.SYN && pfields.SYN[fid]);
                    var placeholderField = {
                        tableId: tableId,
                        fieldId: fid,
                        fieldName: fid,  // Use ID as placeholder name
                        fieldType: inferFieldType(sampleValue),
                        _placeholder: true  // Mark as placeholder for later update
                    };
                    META_FIELDS[tableId][fid] = placeholderField;
                    fields.push(placeholderField);
                }
            }

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) {
                // Initialize new record (existing records pre-loaded above)
                tableDataMap[tableId][recordId] = {};
            }

            var state = tableDataMap[tableId][recordId];

            // Default first ALT as INS: if record state is empty (new record) and
            // there's no INS but there IS ALT, promote ALT to INS
            if (Object.keys(state).length === 0 && !pfields.INS && pfields.ALT) {
                pfields = { INS: pfields.ALT, NUL: pfields.NUL };
            }

            // Capture field history for INS (insert/create)
            if (pfields.INS) {
                for (var fieldId in pfields.INS) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'created',
                        oldValue: null,
                        newValue: pfields.INS[fieldId]
                    });
                }
                Object.assign(state, pfields.INS);
            }

            // Capture field history for ALT (alter/update)
            if (pfields.ALT) {
                for (var fieldId in pfields.ALT) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'updated',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.ALT[fieldId]
                    });
                }
                Object.assign(state, pfields.ALT);
            }

            // Capture field history for SYN (sync/snapshot)
            if (pfields.SYN) {
                for (var fieldId in pfields.SYN) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'synced',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.SYN[fieldId]
                    });
                }
                Object.assign(state, pfields.SYN);
            }

            // Capture field history for NUL (nullify/delete)
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'deleted',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: null
                    });
                    delete state[fieldId];
                });
            }
        }

        // Track the latest event timestamp for incremental sync
        if (e.created_at && (!lastEventTimestamp || e.created_at > lastEventTimestamp)) {
            lastEventTimestamp = e.created_at;
        }
    }

    // Convert tableDataMap to dataRecords array
    for (var tableId in tableDataMap) {
        for (var recordId in tableDataMap[tableId]) {
            dataRecords.push({
                tableId,
                recordId,
                fields: tableDataMap[tableId][recordId]
            });
        }
    }

    // Save batch
    if (tables.length || fields.length || views.length || dataRecords.length) {
        await saveBatch(tables, fields, views, dataRecords);
    }

    // Save field history
    if (fieldHistoryEntries.length) {
        await saveFieldHistory(fieldHistoryEntries);
    }

    // Save raw events for Events view
    await saveRawEvents(events);
}

function applyPayloadFields(target, payload) {
    if (!payload.fields) return;
    var fields = payload.fields;
    if (fields.INS) Object.assign(target, fields.INS);
    if (fields.ALT) Object.assign(target, fields.ALT);
    if (fields.SYN) Object.assign(target, fields.SYN);
    if (fields.NUL && Array.isArray(fields.NUL)) {
        fields.NUL.forEach(k => delete target[k]);
    }
}

// ============ UI ============

async function renderSidebar() {
    var tableList = document.getElementById('table-list');
    tableList.innerHTML = '';

    // Get all tables
    var tables = await getAllTables();

    // Also get tables from META_TABLES (in-memory from current session)
    for (var tid in META_TABLES) {
        if (!tables.find(t => t.tableId === tid)) {
            tables.push(META_TABLES[tid]);
        }
    }

    // Get record counts for all tables (for count bar visualization)
    var tableCounts = {};
    var maxCount = 0;
    for (var table of tables) {
        var ids = await getRecordIdsForTable(table.tableId);
        tableCounts[table.tableId] = ids.length;
        if (ids.length > maxCount) maxCount = ids.length;
    }

    // Get events count
    var eventsCount = await getRawEventsCount();
    if (eventsCount > maxCount) maxCount = eventsCount;

    // Filter tables by search query
    var searchQuery = SIDEBAR_STATE.searchQuery.toLowerCase().trim();
    var filteredTables = tables;
    if (searchQuery) {
        filteredTables = tables.filter(t => {
            var name = (t.tableName || t.tableId || '').toLowerCase();
            return name.includes(searchQuery);
        });
    }

    // Group tables by type
    var groupedTables = {
        primary: [],
        operational: [],
        collection: [],
        reference: [],
        dev: []
    };

    filteredTables.forEach(table => {
        var tableName = table.tableName || table.tableId;
        var type = getTableType(tableName);
        // Map 'events' type to operational
        if (type === 'events') type = 'operational';
        if (groupedTables[type]) {
            groupedTables[type].push(table);
        } else {
            groupedTables.operational.push(table);
        }
    });

    // Sort each group alphabetically (except primary which has a fixed order)
    var primaryOrder = ['client info', 'case master view', 'events'];
    Object.keys(groupedTables).forEach(type => {
        if (type === 'primary') {
            groupedTables[type].sort((a, b) => {
                var aIdx = primaryOrder.indexOf((a.tableName || a.tableId).toLowerCase());
                var bIdx = primaryOrder.indexOf((b.tableName || b.tableId).toLowerCase());
                return aIdx - bIdx;
            });
        } else {
            groupedTables[type].sort((a, b) => (a.tableName || a.tableId).localeCompare(b.tableName || b.tableId));
        }
    });

    // Helper to render a table item
    function renderTableItem(table, showExpandArrow = true) {
        var tableId = table.tableId;
        var tableName = table.tableName || tableId;
        var type = getTableType(tableName);
        var config = TABLE_TYPE_CONFIG[type] || TABLE_TYPE_CONFIG.operational;
        var count = tableCounts[tableId] || 0;
        var isPinned = SIDEBAR_STATE.pinnedTables.includes(tableId);
        var isActive = tableId === currentTable;
        var barWidth = Math.round(getCountBarWidth(count, maxCount) * 20);

        var wrapper = document.createElement('div');
        wrapper.className = 'table-wrapper';
        wrapper.setAttribute('data-table-id', tableId);

        var div = document.createElement('div');
        div.className = 'table-item' + (isActive ? ' active expanded' : '');
        div.style.cssText = isActive ? '--active-color: ' + config.color + ';' : '';

        // Set the ::before background color for active state
        if (isActive) {
            div.style.setProperty('--type-color', config.color);
        }

        div.innerHTML =
            '<span class="table-icon type-' + type + '">' + config.icon + '</span>' +
            '<span class="table-name">' + esc(tableName) + '</span>' +
            '<button class="pin-btn' + (isPinned ? ' pinned' : '') + '" onclick="toggleTablePin(\'' + esc(tableId) + '\', event)" title="' + (isPinned ? 'Unpin' : 'Pin') + '">' +
                (isPinned ? SIDEBAR_ICONS.starFilled : SIDEBAR_ICONS.star) +
            '</button>' +
            '<span class="count-bar-wrapper">' +
                '<span class="count-bar" style="width: ' + barWidth + 'px; background: ' + config.color + ';"></span>' +
                '<span class="count-value" style="color: ' + config.color + ';">' + formatRecordCount(count) + '</span>' +
            '</span>' +
            (showExpandArrow ? '<span class="expand-arrow">&#9654;</span>' : '');

        div.oncontextmenu = ((t) => (e) => {
            showTableContextMenu(e, t);
        })(tableId);

        div.onclick = ((t) => (e) => {
            // Don't toggle if clicking pin button
            if (e.target.closest('.pin-btn')) return;
            toggleTableViews(t, e);
        })(tableId);

        wrapper.appendChild(div);

        // Create views list container
        var viewsList = document.createElement('div');
        viewsList.className = 'table-views-list' + (isActive ? ' expanded' : '');
        viewsList.id = 'views-list-' + tableId;
        viewsList.innerHTML = '<div class="table-view-item loading" style="color: #6b7280; font-style: italic;">Loading views...</div>';
        wrapper.appendChild(viewsList);

        return wrapper;
    }

    // Helper to render a section header
    function renderSectionHeader(sectionId, title, icon, color, count) {
        var isExpanded = SIDEBAR_STATE.expandedSections[sectionId];
        var header = document.createElement('div');
        header.className = 'sidebar-section-header' + (isExpanded ? '' : ' collapsed');
        header.innerHTML =
            SIDEBAR_ICONS.chevronDown +
            '<span class="section-icon" style="color: ' + color + ';">' + icon + '</span>' +
            '<span>' + title + '</span>' +
            '<span class="section-count">' + count + '</span>';
        header.onclick = () => toggleSidebarSection(sectionId);
        return header;
    }

    // If not searching, show pinned and recent sections
    if (!searchQuery) {
        // Events Stream (always at top)
        var eventsWrapper = document.createElement('div');
        eventsWrapper.className = 'table-wrapper';
        eventsWrapper.setAttribute('data-table-id', '_events');

        var eventsDiv = document.createElement('div');
        eventsDiv.className = 'table-item events-item' + (currentTable === '_events' ? ' active' : '');
        var eventsBarWidth = Math.round(getCountBarWidth(eventsCount, maxCount) * 20);
        eventsDiv.innerHTML =
            '<span class="table-icon type-events">' + TABLE_TYPE_CONFIG.events.icon + '</span>' +
            '<span class="table-name">Events Stream</span>' +
            '<span class="count-bar-wrapper">' +
                '<span class="count-bar" style="width: ' + eventsBarWidth + 'px; background: ' + TABLE_TYPE_CONFIG.events.color + ';"></span>' +
                '<span class="count-value" style="color: ' + TABLE_TYPE_CONFIG.events.color + ';">' + formatRecordCount(eventsCount) + '</span>' +
            '</span>';
        eventsDiv.onclick = () => showEventsView();
        eventsWrapper.appendChild(eventsDiv);
        tableList.appendChild(eventsWrapper);

        // Sync Status (below Events Stream)
        var syncStatusWrapper = document.createElement('div');
        syncStatusWrapper.className = 'table-wrapper';
        syncStatusWrapper.setAttribute('data-table-id', '_sync_status');

        var syncStatusDiv = document.createElement('div');
        syncStatusDiv.className = 'table-item sync-status-item' + (currentTable === '_sync_status' ? ' active' : '');
        syncStatusDiv.innerHTML =
            '<span class="table-icon type-sync-status">' + TABLE_TYPE_CONFIG.syncStatus.icon + '</span>' +
            '<span class="table-name">Sync Status</span>';
        syncStatusDiv.onclick = () => showSyncStatusView();
        syncStatusWrapper.appendChild(syncStatusDiv);
        tableList.appendChild(syncStatusWrapper);

        // Pinned Section
        var pinnedTables = tables.filter(t => SIDEBAR_STATE.pinnedTables.includes(t.tableId));
        if (pinnedTables.length > 0) {
            tableList.appendChild(renderSectionHeader('pinned', 'Pinned', SIDEBAR_ICONS.starFilled, '#fbbf24', pinnedTables.length));
            if (SIDEBAR_STATE.expandedSections.pinned) {
                pinnedTables.forEach(table => {
                    tableList.appendChild(renderTableItem(table));
                    loadTableViewsAsync(table.tableId);
                });
            }
        }

        // Recent Section
        var recentTables = SIDEBAR_STATE.recentTables
            .filter(id => !SIDEBAR_STATE.pinnedTables.includes(id))
            .map(id => tables.find(t => t.tableId === id))
            .filter(t => t);
        if (recentTables.length > 0) {
            tableList.appendChild(renderSectionHeader('recent', 'Recent', SIDEBAR_ICONS.clock, '#9ca3af', recentTables.length));
            if (SIDEBAR_STATE.expandedSections.recent) {
                recentTables.forEach(table => {
                    tableList.appendChild(renderTableItem(table));
                    loadTableViewsAsync(table.tableId);
                });
            }
        }

        // Divider
        if (pinnedTables.length > 0 || recentTables.length > 0) {
            var divider = document.createElement('div');
            divider.className = 'sidebar-divider';
            tableList.appendChild(divider);
        }
    }

    // Grouped Sections
    var sectionConfig = [
        { id: 'primary', key: 'primary', label: 'Primary', color: '#ef4444' },
        { id: 'operational', key: 'operational', label: 'Operational', color: '#3b82f6' },
        { id: 'collections', key: 'collection', label: 'Collections', color: '#8b5cf6' },
        { id: 'reference', key: 'reference', label: 'Reference', color: '#10b981' },
        { id: 'dev', key: 'dev', label: 'Dev / Testing', color: '#6b7280' }
    ];

    sectionConfig.forEach(section => {
        var sectionTables = groupedTables[section.key] || [];
        // When searching, show all matching tables; otherwise filter out pinned from main sections
        if (!searchQuery) {
            sectionTables = sectionTables.filter(t => !SIDEBAR_STATE.pinnedTables.includes(t.tableId));
        }
        if (sectionTables.length === 0 && searchQuery) return;
        if (sectionTables.length === 0 && !SIDEBAR_STATE.expandedSections[section.id]) return;

        var config = TABLE_TYPE_CONFIG[section.key] || TABLE_TYPE_CONFIG.operational;
        tableList.appendChild(renderSectionHeader(section.id, section.label, config.icon, section.color, sectionTables.length));

        if (SIDEBAR_STATE.expandedSections[section.id] || searchQuery) {
            sectionTables.forEach(table => {
                tableList.appendChild(renderTableItem(table));
                loadTableViewsAsync(table.tableId);
            });
        }
    });

    // Update active indicator color via CSS variable
    document.querySelectorAll('.sidebar .table-item.active').forEach(el => {
        var tableId = el.closest('.table-wrapper')?.getAttribute('data-table-id');
        if (tableId && tableId !== '_events') {
            var table = tables.find(t => t.tableId === tableId);
            if (table) {
                var type = getTableType(table.tableName || table.tableId);
                var config = TABLE_TYPE_CONFIG[type] || TABLE_TYPE_CONFIG.operational;
                el.style.setProperty('--before-bg', config.color);
                // Also update the ::before pseudo element
                var styleId = 'active-indicator-' + tableId.replace(/[^a-z0-9]/gi, '');
                var existingStyle = document.getElementById(styleId);
                if (existingStyle) existingStyle.remove();
                var style = document.createElement('style');
                style.id = styleId;
                style.textContent = '.table-wrapper[data-table-id="' + tableId + '"] .table-item.active::before { background: ' + config.color + ' !important; }';
                document.head.appendChild(style);
            }
        }
    });
}

// Load views for a table and populate the views list
async function loadTableViewsAsync(tableId) {
    var viewsList = document.getElementById('views-list-' + tableId);
    if (!viewsList) return;

    var views = await getViewsForTable(tableId);
    var folders = await getFoldersForTable(tableId);

    // Cache views in META_VIEWS
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

    // Cache folders in VIEW_FOLDERS
    if (!VIEW_FOLDERS[tableId]) VIEW_FOLDERS[tableId] = {};
    folders.forEach(f => VIEW_FOLDERS[tableId][f.folderId] = f);

    var html = '';

    // Add "All Fields" default option first
    var isDefaultActive = currentTable === tableId && (!currentView || currentView === '_default');
    html += '<div class="table-view-item' + (isDefaultActive ? ' active' : '') + '" onclick="selectTableView(\'' + esc(tableId) + '\', \'_default\')">' +
            '<span class="view-icon">&#9638;</span>' +
            '<span class="view-name table-view-default">All Fields</span>' +
            '</div>';

    // Group views by folder
    var viewsByFolder = { '_root': [] };
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    for (var vid of viewIds) {
        if (vid === '_default') continue;
        var view = META_VIEWS[tableId][vid];
        var folderId = view.folderId || '_root';
        if (!viewsByFolder[folderId]) viewsByFolder[folderId] = [];
        viewsByFolder[folderId].push(view);
    }

    // Render root-level views first
    for (var view of viewsByFolder['_root'] || []) {
        html += renderViewItem(tableId, view);
    }

    // Render folders and their views
    var folderIds = Object.keys(VIEW_FOLDERS[tableId] || {});
    folderIds.sort((a, b) => {
        var fa = VIEW_FOLDERS[tableId][a];
        var fb = VIEW_FOLDERS[tableId][b];
        return (fa.sortOrder || 0) - (fb.sortOrder || 0);
    });

    for (var fid of folderIds) {
        var folder = VIEW_FOLDERS[tableId][fid];
        var isExpanded = folder.isExpanded !== false;

        html += '<div class="table-view-folder' + (isExpanded ? ' expanded' : '') + '" data-folder-id="' + esc(fid) + '" onclick="toggleViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)">';
        html += '<span class="folder-icon">&#9654;</span>';
        html += '<span class="folder-name">&#128193; ' + esc(folder.folderName || 'Folder') + '</span>';
        html += '<span class="folder-actions">';
        html += '<button class="folder-action-btn" onclick="renameViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)" title="Rename">&#9998;</button>';
        html += '<button class="folder-action-btn" onclick="deleteViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)" title="Delete">&#128465;</button>';
        html += '</span>';
        html += '</div>';

        html += '<div class="folder-views-list' + (isExpanded ? ' expanded' : '') + '" id="folder-views-' + esc(fid) + '">';
        for (var view of viewsByFolder[fid] || []) {
            html += renderViewItem(tableId, view, true);
        }
        html += '</div>';
    }

    // Add "New view" button
    html += '<div class="table-view-add-btn" onclick="openCreateViewModal(\'' + esc(tableId) + '\')">';
    html += '<span class="add-icon">+</span>';
    html += '<span>New view</span>';
    html += '</div>';


    viewsList.innerHTML = html;
}

// Render a single view item
function renderViewItem(tableId, view, inFolder) {
    var isActive = currentTable === tableId && currentView === view.viewId;
    var viewName = view.viewName || view.viewId;
    var viewIcon = getViewTypeIcon(view.viewType);
    var paddingClass = inFolder ? ' style="padding-left: 52px;"' : '';

    return '<div class="table-view-item' + (isActive ? ' active' : '') + '"' + paddingClass + ' ' +
           'data-table-id="' + esc(tableId) + '" data-view-id="' + esc(view.viewId) + '" ' +
           'onclick="selectTableView(\'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'ondblclick="startViewRename(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'oncontextmenu="showViewContextMenu(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')">' +
           '<span class="view-icon">' + viewIcon + '</span>' +
           '<span class="view-name">' + esc(viewName) + '</span>' +
           '</div>';
}

// Toggle view folder expanded state
async function toggleViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var folder = VIEW_FOLDERS[tableId]?.[folderId];
    if (!folder) return;

    folder.isExpanded = !folder.isExpanded;
    await saveFolder(folder);

    // Update UI
    var folderEl = document.querySelector('.table-view-folder[data-folder-id="' + folderId + '"]');
    var viewsListEl = document.getElementById('folder-views-' + folderId);

    if (folderEl && viewsListEl) {
        if (folder.isExpanded) {
            folderEl.classList.add('expanded');
            viewsListEl.classList.add('expanded');
        } else {
            folderEl.classList.remove('expanded');
            viewsListEl.classList.remove('expanded');
        }
    }
}

// Create a new view folder
async function createViewFolder(tableId) {
    var folderName = prompt('Enter folder name:');
    if (!folderName) return;

    var folderId = 'vfld' + Date.now();
    var folder = {
        folderId: folderId,
        tableId: tableId,
        folderName: folderName,
        parentFolderId: null,
        sortOrder: Object.keys(VIEW_FOLDERS[tableId] || {}).length,
        isExpanded: true
    };

    await saveFolder(folder);
    if (!VIEW_FOLDERS[tableId]) VIEW_FOLDERS[tableId] = {};
    VIEW_FOLDERS[tableId][folderId] = folder;

    // Also sync to backend
    await saveFolderToBackend(folder, 'create');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Rename a view folder
async function renameViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var folder = VIEW_FOLDERS[tableId]?.[folderId];
    if (!folder) return;

    var newName = prompt('Enter new folder name:', folder.folderName);
    if (!newName || newName === folder.folderName) return;

    folder.folderName = newName;
    await saveFolder(folder);

    // Sync to backend
    await saveFolderToBackend(folder, 'update');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Delete a view folder
async function deleteViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    if (!confirm('Delete this folder? Views will be moved to the root level.')) return;

    // Move all views in this folder to root
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    for (var vid of viewIds) {
        var view = META_VIEWS[tableId][vid];
        if (view.folderId === folderId) {
            view.folderId = null;
            await saveView(view);
        }
    }

    // Delete the folder
    await deleteFolder(folderId);
    delete VIEW_FOLDERS[tableId][folderId];

    // Sync to backend
    await saveFolderToBackend({ folderId: folderId, tableId: tableId }, 'delete');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Save folder to backend
async function saveFolderToBackend(folder, operator) {
    if (!API_KEY) return;
    var payload = {
        uuid: crypto.randomUUID(),
        recordId: folder.folderId,
        set: 'viewFolders',
        operator: operator,
        created_at: new Date().toISOString(),
        apiKey: API_KEY,
        payload: JSON.stringify(folder)
    };

    try {
        await AminoSync.postEvent(payload);
    } catch (error) {
        console.error('Failed to save folder to backend:', error);
    }
}

// View context menu state
var contextMenuViewId = null;
var contextMenuTableId = null;

// Show view context menu
function showViewContextMenu(event, tableId, viewId) {
    event.preventDefault();
    event.stopPropagation();

    contextMenuTableId = tableId;
    contextMenuViewId = viewId;

    var menu = document.getElementById('view-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close view context menu
function closeViewContextMenu() {
    var menu = document.getElementById('view-context-menu');
    menu.classList.remove('open');
    contextMenuViewId = null;
    contextMenuTableId = null;
}

// Table context menu state
var tableContextMenuTableId = null;

// Show table context menu
function showTableContextMenu(event, tableId) {
    event.preventDefault();
    event.stopPropagation();

    tableContextMenuTableId = tableId;

    var menu = document.getElementById('table-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close table context menu
function closeTableContextMenu() {
    var menu = document.getElementById('table-context-menu');
    menu.classList.remove('open');
    tableContextMenuTableId = null;
}

// Column context menu state
var contextMenuFieldId = null;

// Show column context menu
function showColumnContextMenu(event, fieldId) {
    event.preventDefault();
    event.stopPropagation();

    contextMenuFieldId = fieldId;

    var menu = document.getElementById('column-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close column context menu
function closeColumnContextMenu() {
    var menu = document.getElementById('column-context-menu');
    menu.classList.remove('open');
    contextMenuFieldId = null;
}

// Hide column from context menu
function hideColumnFromContextMenu() {
    if (!contextMenuFieldId) return;
    var fieldId = contextMenuFieldId;
    closeColumnContextMenu();
    toggleFieldVisibility(fieldId);
}

// Create view folder from table context menu
async function createViewFolderFromContextMenu() {
    if (!tableContextMenuTableId) return;
    var tableId = tableContextMenuTableId;
    closeTableContextMenu();
    await createViewFolder(tableId);

    // Ensure the table's views list is expanded so the user can see the new folder
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItem = wrapper.querySelector('.table-item');
        var viewsList = wrapper.querySelector('.table-views-list');
        if (tableItem && !tableItem.classList.contains('expanded')) {
            tableItem.classList.add('expanded');
        }
        if (viewsList && !viewsList.classList.contains('expanded')) {
            viewsList.classList.add('expanded');
        }
    }
}

// Move view to folder
async function moveViewToFolder() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var folders = VIEW_FOLDERS[contextMenuTableId] || {};
    var folderNames = Object.values(folders).map(f => f.folderName);

    var options = ['(Root level)', ...folderNames];
    var choice = prompt('Move to folder:\n' + options.map((n, i) => i + ': ' + n).join('\n') + '\n\nEnter number:');

    if (choice === null) {
        closeViewContextMenu();
        return;
    }

    var choiceIdx = parseInt(choice);
    if (isNaN(choiceIdx) || choiceIdx < 0 || choiceIdx >= options.length) {
        closeViewContextMenu();
        return;
    }

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    if (choiceIdx === 0) {
        view.folderId = null;
    } else {
        var folderIds = Object.keys(folders);
        view.folderId = folderIds[choiceIdx - 1];
    }

    await saveView(view);
    markViewDirty('folderId', view.folderId);

    closeViewContextMenu();
    await loadTableViewsAsync(contextMenuTableId);
}

// Start inline view rename (double-click)
function startViewRename(event, tableId, viewId) {
    event.preventDefault();
    event.stopPropagation();

    var view = META_VIEWS[tableId]?.[viewId];
    if (!view) return;

    var viewItem = event.currentTarget;
    var nameSpan = viewItem.querySelector('.view-name');
    if (!nameSpan) return;

    // Create input element
    var input = document.createElement('input');
    input.type = 'text';
    input.className = 'view-name-input';
    input.value = view.viewName || '';
    input.setAttribute('data-table-id', tableId);
    input.setAttribute('data-view-id', viewId);

    // Replace span with input
    nameSpan.style.display = 'none';
    nameSpan.parentNode.insertBefore(input, nameSpan.nextSibling);
    input.focus();
    input.select();

    // Handle blur and enter key
    input.addEventListener('blur', finishViewRename);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            input.value = view.viewName || '';
            input.blur();
        }
    });
    input.addEventListener('click', function(e) {
        e.stopPropagation();
    });
}

// Finish inline view rename
async function finishViewRename(event) {
    var input = event.target;
    var tableId = input.getAttribute('data-table-id');
    var viewId = input.getAttribute('data-view-id');
    var newName = input.value.trim();

    var view = META_VIEWS[tableId]?.[viewId];
    var nameSpan = input.previousElementSibling;

    // Restore the span
    if (nameSpan) {
        nameSpan.style.display = '';
    }
    input.remove();

    if (!view || !newName || newName === view.viewName) {
        return;
    }

    // Update the view name
    view.viewName = newName;
    await saveView(view);
    markViewDirty('viewName', newName);

    // Refresh the UI
    await loadTableViewsAsync(tableId);
    renderViewSelector();
}

// Rename view (from context menu)
async function renameView() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    closeViewContextMenu();

    // Find the view item and trigger inline rename
    var viewItem = document.querySelector('.table-view-item[data-view-id="' + contextMenuViewId + '"]');
    if (viewItem) {
        var fakeEvent = {
            preventDefault: function() {},
            stopPropagation: function() {},
            currentTarget: viewItem
        };
        startViewRename(fakeEvent, contextMenuTableId, contextMenuViewId);
    } else {
        // Fallback to prompt if element not found
        var newName = prompt('Enter new view name:', view.viewName);
        if (!newName || newName === view.viewName) {
            return;
        }
        view.viewName = newName;
        await saveView(view);
        markViewDirty('viewName', newName);
        await loadTableViewsAsync(contextMenuTableId);
        renderViewSelector();
    }
}

// Delete view
async function deleteView() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    if (!confirm('Delete this view?')) {
        closeViewContextMenu();
        return;
    }

    // Remove from META_VIEWS
    delete META_VIEWS[contextMenuTableId][contextMenuViewId];

    // Remove from IndexedDB
    await new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readwrite');
        tx.objectStore('views').delete([contextMenuTableId, contextMenuViewId]);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });

    // If current view was deleted, switch to default
    if (currentView === contextMenuViewId) {
        currentView = '_default';
        renderViewSelector();
        renderFieldsDropdown();
        updateFieldsCount();
        await renderTable();
    }

    closeViewContextMenu();
    await loadTableViewsAsync(contextMenuTableId);
}

// Manage view tags from context menu
async function manageViewTags() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    var currentTags = (view.tags || []).join(', ');
    var newTags = prompt('Enter tags (comma-separated):', currentTags);

    if (newTags !== null) {
        view.tags = newTags.split(',').map(t => t.trim()).filter(t => t);
        await saveView(view);
        markViewDirty('tags', view.tags);
        await loadTableViewsAsync(contextMenuTableId);
    }

    closeViewContextMenu();
}

// Add view to workspace from context menu
async function addViewToWorkspaceMenu() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var wsIds = Object.keys(WORKSPACES);

    if (wsIds.length === 0) {
        var name = prompt('No workspaces exist. Enter a name to create one:');
        if (name) {
            var wsId = await createWorkspace(name);
            await addViewToWorkspace(contextMenuViewId, wsId);
            renderWorkspaceTabs();
            await loadTableViewsAsync(contextMenuTableId);
        }
        closeViewContextMenu();
        return;
    }

    var options = wsIds.map((wid, i) => {
        var ws = WORKSPACES[wid];
        var inWs = ws.viewIds.includes(contextMenuViewId) ? ' [already added]' : '';
        return i + ': ' + ws.workspaceName + inWs;
    });
    options.push(wsIds.length + ': Create new workspace...');

    var choice = prompt('Add to workspace:\n' + options.join('\n') + '\n\nEnter number:');

    if (choice !== null) {
        var idx = parseInt(choice);
        if (idx >= 0 && idx < wsIds.length) {
            await addViewToWorkspace(contextMenuViewId, wsIds[idx]);
            renderWorkspaceTabs();
        } else if (idx === wsIds.length) {
            var name = prompt('Enter workspace name:');
            if (name) {
                var wsId = await createWorkspace(name);
                await addViewToWorkspace(contextMenuViewId, wsId);
                renderWorkspaceTabs();
            }
        }
    }

    closeViewContextMenu();
}

// Set parent view from context menu
async function setViewParent() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    var views = META_VIEWS[contextMenuTableId] || {};
    var options = ['0: (No parent - root level)'];
    var viewIds = [''];

    var idx = 1;
    for (var vid in views) {
        if (vid === '_default' || vid === contextMenuViewId) continue;
        var v = views[vid];
        options.push(idx + ': ' + (v.viewName || vid));
        viewIds.push(vid);
        idx++;
    }

    var choice = prompt('Set parent view (for nesting):\n' + options.join('\n') + '\n\nEnter number:');

    if (choice !== null) {
        var choiceIdx = parseInt(choice);
        if (choiceIdx >= 0 && choiceIdx < viewIds.length) {
            view.parentViewId = viewIds[choiceIdx] || null;
            await saveView(view);
            markViewDirty('parentViewId', view.parentViewId);
            await loadTableViewsAsync(contextMenuTableId);
        }
    }

    closeViewContextMenu();
}

// Open create view modal directly (not from default view protection)
function openCreateViewModal(tableId) {
    if (tableId) {
        // Temporarily switch context to the target table
        currentTable = tableId;
    }

    pendingViewAction = null;

    // Close any open dropdowns so they don't overlap the modal
    closeAllDropdowns();

    // Set the reason text
    var reasonEl = document.getElementById('create-view-reason');
    if (reasonEl) {
        reasonEl.textContent = 'Create a custom view with your own filters, sorting, and field configuration.';
    }

    // Set default view name
    var nameInput = document.getElementById('create-view-name');
    if (nameInput) {
        nameInput.value = generateDefaultViewName();
    }

    // Reset other fields
    document.getElementById('create-view-type').value = 'grid';
    document.getElementById('create-view-tags').value = '';

    // Populate parent view options
    populateParentViewOptions();

    // Populate workspace options
    populateWorkspaceOptions();

    // Show modal
    document.getElementById('create-view-modal').classList.add('open');

    // Focus name input
    setTimeout(() => nameInput?.focus(), 100);
}

// Close context menu on click outside
document.addEventListener('click', function() {
    closeViewContextMenu();
    closeTableContextMenu();
    closeColumnContextMenu();
});

// Clean up state from special views (Events, Sync Status) before switching
function cleanupSpecialViewState() {
    // Clean up events view state
    expandedPayloads.clear();
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;
    if (eventsScrollHandler) {
        var container = document.querySelector('.table-container');
        if (container) container.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }

    // Clean up sync status listener
    if (syncStatusUnsubscribe) { syncStatusUnsubscribe(); syncStatusUnsubscribe = null; }

    // Restore view controls bar visibility
    var viewControlsBar = document.getElementById('view-controls-bar');
    if (viewControlsBar) viewControlsBar.style.display = '';
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = '';
}

// Toggle the expanded views list for a table
function toggleTableViews(tableId, event) {
    event.stopPropagation();

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (!wrapper) return;

    var tableItem = wrapper.querySelector('.table-item');
    var viewsList = wrapper.querySelector('.table-views-list');

    if (tableItem.classList.contains('expanded')) {
        // Collapse
        tableItem.classList.remove('expanded');
        viewsList.classList.remove('expanded');
    } else {
        // Expand
        tableItem.classList.add('expanded');
        viewsList.classList.add('expanded');

        // If clicking a different table, also load it with its default view
        if (currentTable !== tableId) {
            showTable(tableId);
        }
    }
}

// Select a view from the sidebar and show the table
async function selectTableView(tableId, viewId) {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Auto-save any pending changes before navigating
    await autoSaveBeforeNavigation();
    if (navVersion !== myNav) return; // Another navigation started, abort

    // Clean up any special view state (Events, Sync Status)
    cleanupSpecialViewState();

    // Update sidebar active states
    document.querySelectorAll('.table-item').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.table-view-item').forEach(el => el.classList.remove('active'));

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        wrapper.querySelector('.table-item').classList.add('active');
        // Find and mark the selected view as active
        var viewItems = wrapper.querySelectorAll('.table-view-item');
        viewItems.forEach(item => {
            var onclickAttr = item.getAttribute('onclick') || '';
            if (onclickAttr.includes("'" + viewId + "'")) {
                item.classList.add('active');
            }
        });
    }

    // If switching to a different table, load it first
    if (currentTable !== tableId) {
        currentTable = tableId;
        currentPage = 0;

        var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
        if (navVersion !== myNav) return;
        var tableName = table.tableName || tableId;
        document.getElementById('title').textContent = tableName;

        // Show loading state immediately
        showTableLoading('Loading table structure...');

        // Load fields first (table structure)
        var fields = await getFieldsForTable(tableId);
        if (navVersion !== myNav) return;
        META_FIELDS[tableId] = {};
        fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

        // Load views for this table
        var views = await getViewsForTable(tableId);
        if (navVersion !== myNav) return;
        META_VIEWS[tableId] = {};
        views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

        // Load record IDs
        originalRecordIds = await getRecordIdsForTable(tableId);
        if (navVersion !== myNav) return;
        currentRecordIds = originalRecordIds.slice();
        totalRecords = currentRecordIds.length;
    }

    // Set the current view
    currentView = viewId;

    // Load and apply view filters, sorts, and groupBy
    var viewConfig = getViewFiltersAndSorts(tableId, viewId);
    currentFilters = viewConfig.filters;
    currentSorts = viewConfig.sorts;
    currentGroupBy = viewConfig.groupBy;
    currentSearchQuery = ''; // Reset search when switching views

    // Update filter/sort/group button states
    updateFilterCount();
    updateSortCount();
    updateGroupButtonState();
    var searchInput = document.getElementById('view-search-input');
    if (searchInput) searchInput.value = '';

    // Render view selector and fields dropdown
    renderViewSelector();
    renderFieldsDropdown();
    updateFieldsCount();

    // Render the table
    await renderTable();
}

function updateStatus(msg, isSynced, progress, detail) {
    var dot = document.getElementById('status-dot');
    var text = document.getElementById('status-text');
    var progressBar = document.getElementById('progress-bar');
    var progressFill = document.getElementById('progress-fill');
    var statusDetail = document.getElementById('status-detail');

    dot.className = 'status-dot ' + (isSynced ? 'synced' : 'loading');
    text.textContent = msg;

    if (typeof progress === 'number' && progress >= 0) {
        progressBar.style.display = 'block';
        progressFill.style.width = Math.min(100, progress) + '%';
    } else {
        progressBar.style.display = 'none';
    }

    statusDetail.textContent = detail || '';
}

// ============ Loading Overlay ============

var refreshCountdownInterval = null;
var lastSyncTime = null;

function showLoadingOverlay() {
    var overlay = document.getElementById('loading-overlay');
    overlay.classList.remove('hidden', 'fading-out');
}

function hideLoadingOverlay() {
    var overlay = document.getElementById('loading-overlay');
    overlay.classList.add('fading-out');
    overlay.addEventListener('transitionend', function handler() {
        overlay.removeEventListener('transitionend', handler);
        overlay.classList.add('hidden');
        overlay.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    setTimeout(function() { overlay.classList.add('hidden'); overlay.classList.remove('fading-out'); }, 500);
}

function updateLoadingOverlay(status, detail, progress, tables, fields, records, timeEstimate) {
    var statusEl = document.getElementById('loading-status');
    var detailEl = document.getElementById('loading-detail');
    var progressEl = document.getElementById('loading-progress-fill');
    var tablesEl = document.getElementById('loading-tables');
    var fieldsEl = document.getElementById('loading-fields');
    var recordsEl = document.getElementById('loading-records');
    var timeEl = document.getElementById('loading-time-estimate');

    if (statusEl) statusEl.textContent = status || 'Loading...';
    if (detailEl) detailEl.textContent = detail || '';
    if (progressEl) progressEl.style.width = Math.min(100, progress || 0) + '%';
    if (tablesEl) tablesEl.textContent = (tables || 0).toLocaleString();
    if (fieldsEl) fieldsEl.textContent = (fields || 0).toLocaleString();
    if (recordsEl) recordsEl.textContent = (records || 0).toLocaleString();
    if (timeEl) timeEl.textContent = timeEstimate || '';
}

function setRefreshIndicatorSyncing(isSyncing) {
    var indicator = document.getElementById('refresh-indicator');
    var textEl = document.getElementById('last-refresh-text');
    if (!indicator) return;

    if (isSyncing) {
        indicator.classList.add('syncing');
        textEl.textContent = 'Checking for updates...';
    } else {
        indicator.classList.remove('syncing');
        lastSyncTime = Date.now();
        startRefreshCountdown();
    }
}

function startRefreshCountdown() {
    if (refreshCountdownInterval) clearInterval(refreshCountdownInterval);

    var textEl = document.getElementById('last-refresh-text');
    if (!textEl) return;

    function updateCountdown() {
        var elapsed = Math.floor((Date.now() - lastSyncTime) / 1000);
        var remaining = Math.max(0, 180 - elapsed);

        if (remaining > 0) {
            textEl.textContent = 'Auto-refresh in ' + remaining + 's';
        } else {
            textEl.textContent = 'Refreshing soon...';
        }
    }

    updateCountdown();
    refreshCountdownInterval = setInterval(updateCountdown, 1000);
}

async function showTable(tableId) {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Auto-save any pending changes before switching tables
    await autoSaveBeforeNavigation();
    if (navVersion !== myNav) return;

    // Clean up special view state (Events, Sync Status)
    cleanupSpecialViewState();

    currentTable = tableId;
    currentView = null; // Reset view when switching tables
    currentPage = 0;

    // Track as recently accessed table
    addToRecentTables(tableId);

    // Reset search and other controls (filters/sorts will be loaded from view)
    if (typeof currentGroupBy !== 'undefined') currentGroupBy = null;
    if (typeof currentColorBy !== 'undefined') currentColorBy = null;
    if (typeof currentSearchQuery !== 'undefined') currentSearchQuery = '';

    // Reset non-filter/sort button states and search input
    var groupBtn = document.getElementById('group-btn');
    var colorBtn = document.getElementById('color-btn');
    var searchInput = document.getElementById('view-search-input');
    if (groupBtn) groupBtn.classList.remove('active');
    if (colorBtn) colorBtn.classList.remove('active');
    if (searchInput) searchInput.value = '';

    var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
    if (navVersion !== myNav) return;
    var tableName = table.tableName || tableId;

    document.getElementById('title').textContent = tableName;

    // Update tab bar - open or activate tab for this table
    var tableType = table.tableType || 'operational';
    var tabIcons = { events: '\u26A1', operational: '\u25A6', collection: '\uD83D\uDCC5', reference: '\uD83D\uDCD6', dev: '\u2699' };
    openTableInTab(tableId, tableName, tabIcons[tableType] || '\u25A6');

    // Update sidebar - expand the selected table and highlight it
    document.querySelectorAll('.table-item').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.table-view-item').forEach(el => el.classList.remove('active'));

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItem = wrapper.querySelector('.table-item');
        var viewsList = wrapper.querySelector('.table-views-list');
        if (tableItem) {
            tableItem.classList.add('active', 'expanded');
        }
        if (viewsList) {
            viewsList.classList.add('expanded');
        }
    }

    // Show loading state immediately
    showTableLoading('Loading table structure...');

    // Load fields first (table structure)
    var fields = await getFieldsForTable(tableId);
    if (navVersion !== myNav) return;
    META_FIELDS[tableId] = {};
    fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

    // Load views for this table
    var views = await getViewsForTable(tableId);
    if (navVersion !== myNav) return;
    META_VIEWS[tableId] = {};
    views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

    // Set current view to the first available view or default
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    if (viewIds.length > 0 && !currentView) {
        // Check if there's a saved preference or use first view
        currentView = viewIds[0];
    } else if (!currentView) {
        currentView = '_default';
    }

    // Load and apply view filters, sorts, and groupBy
    var viewConfig = getViewFiltersAndSorts(tableId, currentView);
    currentFilters = viewConfig.filters;
    currentSorts = viewConfig.sorts;
    currentGroupBy = viewConfig.groupBy;

    // Update filter/sort/group button states
    updateFilterCount();
    updateSortCount();
    updateGroupButtonState();

    // Update the view list to highlight the active view
    updateSidebarViewActive(tableId, currentView);

    // Render view selector and fields dropdown
    renderViewSelector();
    renderFieldsDropdown();
    updateFieldsCount();

    // Show table headers immediately with skeleton rows (even before data loads)
    renderTableHeaders();

    // Update status (don't overwrite table headers with loading spinner)
    updateStatus('Loading records...', false, null, null);

    // Load record IDs
    originalRecordIds = await getRecordIdsForTable(tableId);
    if (navVersion !== myNav) return;
    currentRecordIds = originalRecordIds.slice();
    totalRecords = currentRecordIds.length;

    // Now render full table with data
    await renderTable();
}

// Update the sidebar to highlight the active view
function updateSidebarViewActive(tableId, viewId) {
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (!wrapper) return;

    var viewItems = wrapper.querySelectorAll('.table-view-item');
    viewItems.forEach(item => {
        item.classList.remove('active');
        var onclickAttr = item.getAttribute('onclick') || '';
        if (onclickAttr.includes("'" + viewId + "'")) {
            item.classList.add('active');
        }
    });
}

function showTableLoading(message) {
    var container = document.getElementById('table-container');
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>' + esc(message) + '</h3></div>';
    document.getElementById('pagination').style.display = 'none';
}

function renderTableHeaders() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');
    var fields = META_FIELDS[currentTable] || {};

    // Use view field configuration for visible fields
    var viewId = currentView || '_default';
    var colList = getVisibleFieldsForView(currentTable, viewId);

    if (colList.length === 0) {
        // No visible fields, show empty state
        container.innerHTML = '<div class="empty-state"><h3>No visible fields</h3><p>Click the Fields button to show columns</p></div>';
        return;
    }

    var colNames = {};
    colList.forEach(fid => {
        colNames[fid] = fields[fid]?.fieldName || fid;
    });

    // Build table with headers and skeleton rows
    var html = '<table id="table"><thead><tr><th style="width: 70px;">Actions</th><th>ID</th>';
    colList.forEach(col => {
        html += '<th title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    // Add skeleton loading rows
    for (var i = 0; i < 5; i++) {
        html += '<tr class="skeleton-row"><td><div class="skeleton-cell" style="width: 50px;"></div></td><td><div class="skeleton-cell" style="width: 60px;"></div></td>';
        colList.forEach(() => {
            html += '<td><div class="skeleton-cell" style="width: ' + (60 + Math.random() * 80) + 'px;"></div></td>';
        });
        html += '</tr>';
    }

    html += '</tbody></table>';
    container.innerHTML = html;
}

async function renderTable() {
    if (!currentTable) return;
    // Skip rendering if we're in a special view (Events or Sync Status)
    if (currentTable === '_events' || currentTable === '_sync_status') return;

    var renderNav = navVersion; // Capture current nav version for stale check

    // Check if table container exists - may not exist during early loading
    var tableContainer = document.getElementById('table-container');
    if (!tableContainer) {
        console.log('renderTable: table-container not ready yet');
        return;
    }

    // Apply filters, search, and sorts
    var needsFiltering = currentFilters.length > 0 || currentSearchQuery || currentSorts.length > 0;
    if (needsFiltering) {
        currentRecordIds = await getFilteredSortedRecords();
        if (navVersion !== renderNav) return; // Navigation changed, abort stale render
    } else {
        currentRecordIds = originalRecordIds.slice();
    }
    totalRecords = currentRecordIds.length;

    var tableEl = document.getElementById('table');

    // Determine which records to display
    var displayRecordIds;
    var isGrouped = !!currentGroupBy;

    if (isGrouped) {
        // When grouping, show all records (no pagination) - up to a reasonable limit
        var maxGroupedRecords = 1000;
        displayRecordIds = currentRecordIds.slice(0, maxGroupedRecords);
    } else {
        // Standard pagination
        displayRecordIds = currentRecordIds.slice(currentPage * PAGE_SIZE, (currentPage + 1) * PAGE_SIZE);

        // Check if we're on a page beyond available data (can happen after filtering)
        if (displayRecordIds.length === 0 && currentPage > 0) {
            currentPage = 0;
            displayRecordIds = currentRecordIds.slice(0, PAGE_SIZE);
        }
    }

    if (displayRecordIds.length === 0) {
        if (tableEl) tableEl.innerHTML = '';
        var emptyMsg = (currentFilters.length > 0 || currentSearchQuery)
            ? '<div class="empty-state"><h3>No matching records</h3><p>Try adjusting your filters or search</p></div>'
            : '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        tableContainer.innerHTML = emptyMsg;
        document.getElementById('pagination').style.display = 'none';
        return;
    }

    // Fetch records before clearing the container to avoid a white flash
    var records = await getRecordsByIds(currentTable, displayRecordIds);
    if (navVersion !== renderNav) return; // Navigation changed, abort stale render
    var recordMap = {};
    records.forEach(r => recordMap[r.recordId] = r.fields || {});

    // Get columns from view configuration
    var fields = META_FIELDS[currentTable] || {};
    var viewId = currentView || '_default';
    var colList = getVisibleFieldsForView(currentTable, viewId);

    // If no visible fields but we have data, initialize with all fields
    if (colList.length === 0 && Object.keys(fields).length === 0) {
        // Discover from data
        var colSet = {};
        records.forEach(r => {
            if (r.fields) Object.keys(r.fields).forEach(k => colSet[k] = true);
        });
        colList = Object.keys(colSet).sort();
    }

    var colNames = {};
    colList.forEach(fid => {
        colNames[fid] = fields[fid]?.fieldName || fid;
    });

    // Get group field name for header display
    var groupFieldName = currentGroupBy ? (fields[currentGroupBy]?.fieldName || currentGroupBy) : null;

    // Build table with draggable headers
    var html = '<thead><tr><th style="width: 70px; cursor: default;">Actions</th>';
    colList.forEach((col, idx) => {
        html += '<th draggable="true" data-field-id="' + esc(col) + '" data-field-index="' + idx + '" ' +
                'ondragstart="handleColumnDragStart(event)" ondragover="handleColumnDragOver(event)" ' +
                'ondrop="handleColumnDrop(event)" ondragend="handleColumnDragEnd(event)" ' +
                'oncontextmenu="showColumnContextMenu(event, \'' + esc(col) + '\')" ' +
                'title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    if (isGrouped) {
        // Group records by field value
        var groups = groupRecordsByField(displayRecordIds, recordMap, currentGroupBy, colNames);

        // Render grouped rows
        var groupIndex = 0;
        for (var groupKey in groups) {
            var groupRecords = groups[groupKey];
            var groupId = 'group-' + groupIndex;

            // Group header row
            html += '<tr class="group-header-row" data-group-id="' + groupId + '" onclick="toggleGroup(\'' + groupId + '\')">';
            html += '<td colspan="' + (colList.length + 1) + '">';
            html += '<span class="group-toggle">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg>';
            html += '<span class="group-name">' + esc(groupFieldName) + ': ' + esc(groupKey) + '</span>';
            html += '<span class="group-count">(' + groupRecords.length + ')</span>';
            html += '</span>';
            html += '</td></tr>';

            // Group data rows
            groupRecords.forEach(rid => {
                var row = recordMap[rid] || {};
                html += '<tr class="group-row" data-group-id="' + groupId + '" data-record-id="' + esc(rid) + '" onclick="handleRowClick(event, \'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" style="cursor: pointer;">';
                html += '<td><button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="View field history">';
                html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
                html += 'History</button></td>';
                colList.forEach(col => {
                    var value = row[col];
                    if (value === undefined) value = row[colNames[col]];
                    html += '<td>' + formatCell(value) + '</td>';
                });
                html += '</tr>';
            });

            groupIndex++;
        }
    } else {
        // Standard flat rendering
        displayRecordIds.forEach(rid => {
            var row = recordMap[rid] || {};
            html += '<tr data-record-id="' + esc(rid) + '" onclick="handleRowClick(event, \'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" style="cursor: pointer;">';
            html += '<td><button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="View field history">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
            html += 'History</button></td>';
            colList.forEach(col => {
                var value = row[col];
                if (value === undefined) value = row[colNames[col]];
                html += '<td>' + formatCell(value) + '</td>';
            });
            html += '</tr>';
        });
    }

    html += '</tbody>';

    // Replace container content in one shot after data is ready (no intermediate blank state)
    tableContainer.innerHTML = '<table id="table"></table>';
    tableEl = document.getElementById('table');
    tableEl.innerHTML = html;

    // Update pagination (hide when grouped)
    if (isGrouped) {
        document.getElementById('pagination').style.display = 'none';
    } else {
        document.getElementById('pagination').style.display = '';
        updatePagination();
    }
}

// Group records by a field value
function groupRecordsByField(recordIds, recordMap, fieldId, colNames) {
    var groups = {};
    var emptyGroupKey = '(Empty)';

    recordIds.forEach(rid => {
        var row = recordMap[rid] || {};
        var value = row[fieldId];
        if (value === undefined) value = row[colNames[fieldId]];

        // Convert value to display string for grouping
        var groupKey = getGroupKeyFromValue(value);

        if (!groups[groupKey]) {
            groups[groupKey] = [];
        }
        groups[groupKey].push(rid);
    });

    // Sort groups: put (Empty) last, then sort alphabetically
    var sortedGroups = {};
    var keys = Object.keys(groups).sort((a, b) => {
        if (a === emptyGroupKey) return 1;
        if (b === emptyGroupKey) return -1;
        return a.localeCompare(b);
    });
    keys.forEach(k => sortedGroups[k] = groups[k]);

    return sortedGroups;
}

// Get a display string for grouping from a cell value
function getGroupKeyFromValue(value) {
    if (value == null || value === '') return '(Empty)';

    if (Array.isArray(value)) {
        if (value.length === 0) return '(Empty)';
        // For arrays, join values for display
        return value.map(v => {
            if (typeof v === 'object' && v !== null) {
                return v.name || v.filename || v.email || v.id || JSON.stringify(v);
            }
            return String(v);
        }).join(', ');
    }

    if (typeof value === 'object') {
        return value.name || value.filename || value.email || value.url || JSON.stringify(value);
    }

    return String(value);
}

// Toggle group visibility
function toggleGroup(groupId) {
    var headerRow = document.querySelector('.group-header-row[data-group-id="' + groupId + '"]');
    var dataRows = document.querySelectorAll('.group-row[data-group-id="' + groupId + '"]');

    if (headerRow.classList.contains('collapsed')) {
        headerRow.classList.remove('collapsed');
        dataRows.forEach(row => row.classList.remove('hidden'));
    } else {
        headerRow.classList.add('collapsed');
        dataRows.forEach(row => row.classList.add('hidden'));
    }
}

function formatCell(v) {
    if (v == null || v === '') {
        return '<span class="cell-empty"></span>';
    }

    if (Array.isArray(v)) {
        if (v.length === 0) return '<span class="cell-empty"></span>';

        // Check if it's an array of objects (linked records, attachments, etc.)
        if (typeof v[0] === 'object' && v[0] !== null) {
            var items = v.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return '<span class="cell-array">' + items.map(i => '<span class="tag">' + esc(i) + '</span>').join('') + '</span>';
        }

        // Simple array - join with commas
        return '<span class="cell-array">' + v.map(i => '<span class="tag">' + esc(String(i)) + '</span>').join('') + '</span>';
    }

    if (typeof v === 'object') {
        // Single object
        if (v.name) return esc(v.name);
        if (v.filename) return esc(v.filename);
        if (v.email) return esc(v.email);
        if (v.url) return '<a class="cell-link" href="' + esc(v.url) + '" target="_blank">' + esc(v.url.slice(0, 40)) + '</a>';
        return esc(JSON.stringify(v).slice(0, 50));
    }

    if (typeof v === 'boolean') {
        return '<span class="cell-bool ' + v + '">' + (v ? 'Yes' : 'No') + '</span>';
    }

    if (typeof v === 'number') {
        return '<span class="cell-number">' + v.toLocaleString() + '</span>';
    }

    // String - check for URLs
    var str = String(v);
    if (str.startsWith('http://') || str.startsWith('https://')) {
        return '<a class="cell-link" href="' + esc(str) + '" target="_blank">' + esc(str.slice(0, 50)) + '</a>';
    }

    return esc(str);
}

function updatePagination() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    var start = currentPage * PAGE_SIZE + 1;
    var end = Math.min((currentPage + 1) * PAGE_SIZE, totalRecords);

    document.getElementById('page-info').textContent = start + '-' + end + ' of ' + totalRecords.toLocaleString();
    document.getElementById('prev-btn').disabled = currentPage === 0;
    document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
    document.getElementById('pagination').style.display = totalRecords > PAGE_SIZE ? 'flex' : 'none';
}

function prevPage() {
    if (currentPage > 0) {
        currentPage--;
        renderTable();
    }
}

function nextPage() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    if (currentPage < totalPages - 1) {
        currentPage++;
        renderTable();
    }
}

// ============ API ============

// Fetch all records of a specific set type (table, field, view)
// Fetch all pages and filter events client-side by set type
async function fetchAllBySet(setType, onProgress) {
    var allEvents = [];
    var page = 1;
    var iterations = 0;
    while (true) {
        // Fetch using page-based pagination
        var result = await fetchPage(page);
        if (!result.events || result.events.length === 0) break;

        // Filter events client-side by payload._set
        var matchingEvents = result.events.filter(function(e) {
            if (!e || !e.payload) return false;
            var payload = parsePayload(e.payload);
            return payload && payload._set === setType;
        });

        allEvents = allEvents.concat(matchingEvents);
        if (onProgress) onProgress(allEvents.length);
        if (!result.hasMore) break;
        page = result.nextPage;
        iterations++;
        if (iterations > 100) break; // Safety limit for schema
    }
    return allEvents;
}

// Fetch events using page-based pagination
// API returns 2500 records per page with nextPage indicator
// Supports aminoStream query parameters:
//   page (int, min:1, default 1), per_page (int, min:1, max:10000, default 2500),
//   created_after (timestamp), created_before (timestamp), last (bool - single most recent record)
var FETCH_PAGE_TIMEOUT = 30000; // 30 second timeout per request
var FETCH_PAGE_RETRIES = 3;    // retry up to 3 times on network errors

async function fetchPage(page, createdAfter, options) {
    options = options || {};
    var params = [];
    if (API_KEY) params.push('apiKey=' + encodeURIComponent(API_KEY));
    if (page && page > 1) params.push('page=' + page);
    if (createdAfter) params.push('created_after=' + encodeURIComponent(createdAfter));
    if (options.createdBefore) params.push('created_before=' + encodeURIComponent(options.createdBefore));
    if (options.perPage) params.push('per_page=' + encodeURIComponent(options.perPage));
    if (options.last) params.push('last=true');

    var url = API + (params.length > 0 ? '?' + params.join('&') : '');

    var maxRetries = options.last ? 1 : FETCH_PAGE_RETRIES;
    var lastErr = null;

    for (var attempt = 0; attempt <= maxRetries; attempt++) {
        var controller = new AbortController();
        var timeoutId = setTimeout(function() { controller.abort(); }, FETCH_PAGE_TIMEOUT);
        try {
            var res = await fetch(url, { signal: controller.signal });
            clearTimeout(timeoutId);
            break; // success - exit retry loop
        } catch (err) {
            clearTimeout(timeoutId);
            lastErr = err;
            if (err.name === 'AbortError') {
                lastErr = new Error('Request timed out after ' + (FETCH_PAGE_TIMEOUT / 1000) + 's');
            }
            if (attempt < maxRetries) {
                var delay = 2000 * Math.pow(2, attempt); // 2s, 4s, 8s
                console.warn('[fetchPage] Attempt ' + (attempt + 1) + '/' + (maxRetries + 1) + ' failed: ' + lastErr.message + ', retrying in ' + (delay / 1000) + 's...');
                await new Promise(function(r) { setTimeout(r, delay); });
                continue;
            }
            throw lastErr;
        }
    }

    if (res.status === 401 || res.status === 403) {
        throw new Error('Invalid API key');
    }

    var contentType = res.headers.get('content-type') || '';
    if (!contentType.includes('application/json')) {
        throw new Error('Server returned non-JSON response (HTTP ' + res.status + '). Check your connection and try again.');
    }

    var data = await res.json();

    if (!res.ok) {
        throw new Error(data.message || data.error || 'HTTP ' + res.status);
    }

    // If 'last' was requested, API returns a single record instead of a paginated list
    if (options.last) {
        var singleEvent = Array.isArray(data) ? data[0] : (data.items ? data.items[0] : data);
        return { events: singleEvent ? [singleEvent] : [], hasMore: false, nextPage: null };
    }

    // Handle paginated response format: { itemsReceived, curPage, nextPage, prevPage, offset, perPage, items }
    var events = Array.isArray(data) ? data : (data.items || data.data || []);
    // API returns nextPage as number if more pages exist, null otherwise
    var hasMore = data.nextPage != null;
    var nextPage = data.nextPage || null;

    // Normalize event fields: API may return payload under alternative field names
    for (var i = 0; i < events.length; i++) {
        var ev = events[i];
        if (ev && ev.payload === undefined) {
            // Check for alternative payload field names from Xano/API
            if (ev._payload !== undefined) { ev.payload = ev._payload; delete ev._payload; }
            else if (ev.event_payload !== undefined) { ev.payload = ev.event_payload; delete ev.event_payload; }
        }
    }

    return { events, hasMore, nextPage };
}

async function fullSync() {
    if (!API_KEY) return;
    var eventsLoaded = 0;
    var tablesFound = 0;
    var fieldsFound = 0;
    var viewsFound = 0;
    var recordsFound = 0;
    var schemaLoaded = false;
    var syncStartTime = Date.now();
    var lastBatchTime = syncStartTime;
    var recordsPerSecond = 0;

    // Helper to format time remaining
    function formatTimeRemaining(seconds) {
        if (seconds < 0 || !isFinite(seconds)) return 'Calculating...';
        if (seconds < 5) return 'Almost done...';
        if (seconds < 60) return 'About ' + Math.ceil(seconds) + ' seconds remaining';
        var minutes = Math.ceil(seconds / 60);
        return 'About ' + minutes + ' minute' + (minutes > 1 ? 's' : '') + ' remaining';
    }

    // Show the loading overlay for initial sync
    showLoadingOverlay();

    // Background function to load schema metadata (proper names for tables/fields/views)
    // Fetches all events once and filters by type client-side
    async function loadSchemaInBackground() {
        try {
            var tableEvents = [];
            var fieldEvents = [];
            var viewEvents = [];
            var page = 1; // Page-based pagination
            var iterations = 0;

            // Fetch all events once and categorize by payload._set
            while (true) {
                var result = await fetchPage(page);
                if (!result.events || result.events.length === 0) break;

                for (var e of result.events) {
                    if (!e || !e.payload) continue;
                    var payload = parsePayload(e.payload);
                    if (!payload) continue;

                    if (payload._set === 'table') {
                        tableEvents.push(e);
                    } else if (payload._set === 'field') {
                        fieldEvents.push(e);
                    } else if (payload._set === 'view') {
                        viewEvents.push(e);
                    }
                }

                if (!result.hasMore) break;
                page = result.nextPage;
                iterations++;
                if (iterations > 100) break; // Safety limit for schema
            }

            // Process tables
            if (tableEvents.length > 0) {
                tableEvents.sort((a, b) => (a.id || 0) - (b.id || 0));
                await processEvents(tableEvents);
                eventsLoaded += tableEvents.length;
                tablesFound = tableEvents.length;
            }

            // Process fields
            if (fieldEvents.length > 0) {
                fieldEvents.sort((a, b) => (a.id || 0) - (b.id || 0));
                await processEvents(fieldEvents);
                eventsLoaded += fieldEvents.length;
                fieldsFound = fieldEvents.length;
            }

            // Process views
            if (viewEvents.length > 0) {
                viewEvents.sort((a, b) => (a.id || 0) - (b.id || 0));
                await processEvents(viewEvents);
                eventsLoaded += viewEvents.length;
                viewsFound = viewEvents.length;
            }

            schemaLoaded = true;

            // Re-render UI with proper names
            await renderSidebar();
            if (currentTable && currentTable !== '_events') {
                await renderTable();
            }
        } catch (err) {
            console.error('Background schema load error:', err);
        }
    }

    // PHASE 1: Start streaming data immediately (schema will be auto-discovered from records)
    // This shows tables/fields right away with ID placeholders
    updateStatus('Loading recent data...', false, 5, 'Streaming records...');
    updateLoadingOverlay('Loading data...', 'Starting...', 5, 0, 0, 0, 'Connecting to server...');

    // Start schema loading in background (will update placeholders with proper names)
    var schemaPromise = loadSchemaInBackground();

    var page = 1; // Page-based pagination
    var iterations = 0;
    var smoothProgress = 5; // For smooth animation between batches
    var targetProgress = 5;

    // Smooth progress animation - updates every 100ms between batches
    var progressAnimationInterval = setInterval(function() {
        if (smoothProgress < targetProgress) {
            smoothProgress = Math.min(targetProgress, smoothProgress + 0.5);
            var progressEl = document.getElementById('loading-progress-fill');
            if (progressEl) progressEl.style.width = smoothProgress + '%';
        }
    }, 100);

    while (true) {
        // Calculate time-based estimates
        var elapsed = (Date.now() - syncStartTime) / 1000;
        var timeEstimate = '';

        if (iterations > 0 && recordsFound > 0) {
            // Calculate records per second based on overall progress
            recordsPerSecond = recordsFound / elapsed;

            // Estimate remaining time - we use hasMore to determine if there's more data
            // Rough estimate: assume linear progress based on batch count
            var estimatedTotalBatches = Math.max(iterations + 1, iterations * 1.2);
            var remainingBatches = estimatedTotalBatches - iterations;
            var avgBatchTime = elapsed / iterations;
            var remainingSeconds = remainingBatches * avgBatchTime;

            if (remainingSeconds > 0) {
                timeEstimate = formatTimeRemaining(remainingSeconds) + '  ' + Math.round(recordsPerSecond).toLocaleString() + ' records/sec';
            }
        } else {
            timeEstimate = 'Calculating speed...';
        }

        // Show progress with estimates - smoother progress calculation
        targetProgress = Math.min(95, 5 + (iterations / 50) * 85);
        var tableCount = Object.keys(META_TABLES).length;
        var fieldCount = Object.values(META_FIELDS).reduce((sum, t) => sum + Object.keys(t).length, 0);
        var detail = tableCount + ' tables, ' + fieldCount + ' fields, ' + recordsFound.toLocaleString() + ' records';
        updateStatus('Loading page ' + page + '...', false, targetProgress, detail);

        // Update the loading overlay with progress and time estimate
        updateLoadingOverlay('Downloading data...', 'Page ' + page + '  ' + Math.round(elapsed) + 's elapsed', targetProgress, tableCount, fieldCount, recordsFound, timeEstimate);

        // Fetch all events using page-based pagination
        var result = await fetchPage(page);
        if (!result.events || result.events.length === 0) {
            clearInterval(progressAnimationInterval);
            break;
        }

        // Process all events (data records will auto-create placeholder schema,
        // schema events will update with proper names)
        var allEvents = result.events;
        if (allEvents.length > 0) {
            eventsLoaded += allEvents.length;
            // Count data records (non-schema events)
            var dataCount = allEvents.filter(function(e) {
                var payload = parsePayload(e.payload);
                var set = payload && payload._set;
                return set !== 'table' && set !== 'field' && set !== 'view';
            }).length;
            recordsFound += dataCount;

            // Sort events by ID ascending for correct state processing
            allEvents.sort((a, b) => (a.id || 0) - (b.id || 0));
            await processEvents(allEvents);

            // Stream data to UI - render after every page for immediate feedback
            await renderSidebar();

            // Auto-select first table after first batch of data
            if (!currentTable && Object.keys(META_TABLES).length > 0) {
                var firstTable = Object.keys(META_TABLES)[0];
                await showTable(firstTable);
            }

            // Refresh current table view to show new data
            if (currentTable && currentTable !== '_events') {
                originalRecordIds = await getRecordIdsForTable(currentTable);
                currentRecordIds = originalRecordIds.slice();
                totalRecords = currentRecordIds.length;
                await renderTable();
            }
        }

        // Keep overlay visible during initial sync - only hide when complete
        if (!result.hasMore) {
            clearInterval(progressAnimationInterval);
            break;
        }
        page = result.nextPage;
        iterations++;
        if (iterations > 500) {
            clearInterval(progressAnimationInterval);
            break;
        }
    }

    // Wait for schema to finish loading (ensures proper names are applied)
    var totalElapsed = Math.round((Date.now() - syncStartTime) / 1000);
    updateLoadingOverlay('Finalizing schema...', 'Processing metadata', 95, Object.keys(META_TABLES).length, Object.values(META_FIELDS).reduce((sum, t) => sum + Object.keys(t).length, 0), recordsFound, 'Almost done...');
    await schemaPromise;

    // Final render after sync completes
    await renderSidebar();
    if (currentTable && currentTable !== '_events') {
        originalRecordIds = await getRecordIdsForTable(currentTable);
        currentRecordIds = originalRecordIds.slice();
        totalRecords = currentRecordIds.length;
        await renderTable();
    }

    await setSyncMeta('lastEventTimestamp', lastEventTimestamp);
    var finalTableCount = Object.keys(META_TABLES).length;
    var finalFieldCount = Object.values(META_FIELDS).reduce((sum, t) => sum + Object.keys(t).length, 0);
    var finalDetail = finalTableCount + ' tables, ' + finalFieldCount + ' fields, ' + viewsFound + ' views, ' + recordsFound.toLocaleString() + ' records';

    // Show completion on overlay before hiding
    var completionTime = Math.round((Date.now() - syncStartTime) / 1000);
    var completionMsg = 'Completed in ' + completionTime + ' seconds';
    updateLoadingOverlay('Setup complete!', 'Ready to explore your data', 100, finalTableCount, finalFieldCount, recordsFound, completionMsg);

    // Brief delay to show completion, then hide overlay
    await new Promise(resolve => setTimeout(resolve, 500));
    hideLoadingOverlay();

    updateStatus('Synced ' + eventsLoaded.toLocaleString() + ' events', true, null, finalDetail);

    // Push .amo to Box after full sync if auto-sync is enabled
    if (boxSyncEnabled) {
        BoxSync.push();
    }
}

var _incrementalSyncRunning = false;

async function incrementalSync() {
    if (!API_KEY) return;
    if (_incrementalSyncRunning) {
        console.warn('[incrementalSync] Already running, skipping concurrent call');
        return;
    }
    _incrementalSyncRunning = true;
    var syncStartTime = Date.now();
    try {
        // Show syncing indicator
        setRefreshIndicatorSyncing(true);
        updateStatus('Checking for updates...', false, null, null);

        // Fetch all events created after the last synced timestamp (with pagination)
        var allEvents = [];
        var page = 1;
        var iterations = 0;
        while (true) {
            var result = await fetchPage(page, lastEventTimestamp);
            if (!result.events || result.events.length === 0) break;
            allEvents = allEvents.concat(result.events);
            if (!result.hasMore) break;
            page = result.nextPage;
            iterations++;
            if (iterations > 100) break; // Safety limit
        }

        if (allEvents.length > 0) {
            updateStatus('Processing ' + allEvents.length + ' new events...', false, null, null);
            // Sort by timestamp for correct processing order (handle both string and numeric timestamps)
            allEvents.sort((a, b) => {
                var aTime = a.created_at ? (typeof a.created_at === 'number' ? a.created_at : new Date(a.created_at).getTime()) : 0;
                var bTime = b.created_at ? (typeof b.created_at === 'number' ? b.created_at : new Date(b.created_at).getTime()) : 0;
                return aTime - bTime;
            });
            await processEvents(allEvents);
            await setSyncMeta('lastEventTimestamp', lastEventTimestamp);

            updateStatus('Updating views...', false, null, null);
            await renderSidebar();

            // Update data view if table is selected
            if (currentTable && currentTable !== '_sync_status') {
                originalRecordIds = await getRecordIdsForTable(currentTable);
                currentRecordIds = originalRecordIds.slice();
                totalRecords = currentRecordIds.length;
                await renderTable();
            }

            var syncDetail = allEvents.length + ' events synced';
            updateStatus('Up to date', true, null, syncDetail);

            // Record to sync history
            SyncHistory.record({
                type: 'incremental',
                result: 'success',
                eventsFound: allEvents.length,
                duration: Date.now() - syncStartTime,
                detail: syncDetail
            });

            // Push .amo to Box if auto-sync is enabled and new data arrived
            if (boxSyncEnabled) {
                BoxSync.push();
            }
        } else {
            updateStatus('Up to date', true, null, null);

            // Record no-change sync
            SyncHistory.record({
                type: 'incremental',
                result: 'no-change',
                eventsFound: 0,
                duration: Date.now() - syncStartTime,
                detail: 'No new events'
            });
        }

        // Reset indicator and start countdown
        setRefreshIndicatorSyncing(false);
    } catch (err) {
        console.error('Sync error:', err);
        updateStatus('Sync error: ' + err.message, false, null, null);
        setRefreshIndicatorSyncing(false);

        // Record error to sync history
        SyncHistory.record({
            type: 'incremental',
            result: 'error',
            duration: Date.now() - syncStartTime,
            error: err.message,
            detail: 'Sync error: ' + err.message
        });
    } finally {
        _incrementalSyncRunning = false;
    }
}

// ============ Sync Status View ============

var syncStatusUnsubscribe = null;

async function showSyncStatusView() {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Open tab for sync status
    openTableInTab('_sync_status', 'Sync Status', '\uD83D\uDD04');

    // Clean up events view state
    expandedPayloads.clear();
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;
    if (eventsScrollHandler) {
        var evContainer = document.querySelector('.table-container');
        if (evContainer) evContainer.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }

    currentTable = '_sync_status';
    currentView = null;

    // Update sidebar selection
    document.querySelectorAll('.sidebar .table-item').forEach(el => el.classList.remove('active', 'expanded'));
    document.querySelectorAll('.sidebar .table-view-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.sidebar .table-item.sync-status-item')?.classList.add('active');

    // Hide view controls and show sync status view
    document.getElementById('view-controls-bar').style.display = 'none';
    document.getElementById('title').textContent = 'Sync Status';
    document.getElementById('pagination').style.display = 'none';

    // Hide toolbar views section
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = 'none';

    // Show loading state immediately
    var container = document.querySelector('.table-container');
    if (container) container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading sync status...</h3></div>';

    await renderSyncStatusView();
    if (navVersion !== myNav) return;

    // Subscribe to live updates
    if (syncStatusUnsubscribe) syncStatusUnsubscribe();
    syncStatusUnsubscribe = SyncHistory.onChange(() => {
        if (currentTable === '_sync_status') renderSyncStatusView();
    });
}

async function renderSyncStatusView() {
    var container = document.querySelector('.table-container');
    var stats = SyncHistory.getStats();
    var passiveStats = { isRunning: false, pulled: 0, verified: 0 };
    var totalEventsCount = await getRawEventsCount();

    // Determine overall sync state
    var syncState = 'synced';
    var syncLabel = 'Up to Date';
    if (SyncHistory.isPolling) {
        syncState = 'syncing';
        syncLabel = 'Checking...';
    } else if (stats.errorCount > 0 && stats.errorCount === stats.totalSyncs + stats.totalPolls) {
        syncState = 'error';
        syncLabel = 'Errors Detected';
    }

    var html = '<div class="sync-status-view">';

    // Header
    html += '<div class="sync-status-header">';
    html += '<h2>Sync Status</h2>';
    html += '<span class="sync-status-badge ' + syncState + '">' + syncLabel + '</span>';
    html += '</div>';

    // Summary cards
    html += '<div class="sync-status-cards">';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Total Events in DB</div>';
    html += '<div class="card-value">' + totalEventsCount.toLocaleString() + '</div>';
    html += '<div class="card-sub">Last event timestamp: ' + (lastEventTimestamp ? formatTimestamp(lastEventTimestamp) : 'N/A') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Events Synced (Session)</div>';
    html += '<div class="card-value">' + stats.totalEventsProcessed.toLocaleString() + '</div>';
    html += '<div class="card-sub">' + stats.totalSyncs + ' sync operation' + (stats.totalSyncs !== 1 ? 's' : '') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Snapshots Updated</div>';
    html += '<div class="card-value">' + stats.totalSnapshotsUpdated.toLocaleString() + '</div>';
    html += '<div class="card-sub">Passive: ' + passiveStats.pulled + ' pulled, ' + passiveStats.verified + ' verified</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Last Sync</div>';
    html += '<div class="card-value" style="font-size: 16px;">' + (stats.lastSyncTime ? formatSyncTimestamp(stats.lastSyncTime) : 'Never') + '</div>';
    html += '<div class="card-sub">Last poll: ' + (stats.lastPollTime ? formatSyncTimestamp(stats.lastPollTime) : 'Never') + '</div>';
    html += '</div>';

    html += '</div>';

    // Polling controls
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (SyncHistory.pollInterval ? (SyncHistory.consecutiveFailures > 0 ? 'red' : 'green') : 'amber') + '"></span>Database Polling</h3>';
    html += '<div class="sync-poll-controls">';
    html += '<button class="btn-poll primary" onclick="SyncHistory.pollForUpdates()" ' + (SyncHistory.isPolling ? 'disabled' : '') + '>';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>';
    html += 'Poll Now</button>';
    if (SyncHistory.pollInterval) {
        html += '<button class="btn-poll" onclick="SyncHistory.stopPolling(); renderSyncStatusView();">Stop Auto-Poll</button>';
        if (SyncHistory.consecutiveFailures > 0) {
            html += '<span style="font-size: 12px; color: #ef4444;">Backing off: ' + Math.round(SyncHistory.currentPollInterval / 1000) + 's interval (' + SyncHistory.consecutiveFailures + ' consecutive failure' + (SyncHistory.consecutiveFailures > 1 ? 's' : '') + ')</span>';
        } else {
            html += '<span style="font-size: 12px; color: #6b7280;">Polling every ' + (SyncHistory.POLL_INTERVAL / 1000) + 's</span>';
        }
    } else {
        html += '<button class="btn-poll" onclick="SyncHistory.startPolling(); renderSyncStatusView();">Start Auto-Poll</button>';
        html += '<span style="font-size: 12px; color: #6b7280;">Auto-poll is off</span>';
    }
    html += '</div>';
    html += '</div>';

    // Sync history table
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (stats.errorCount > 0 ? 'red' : 'green') + '"></span>Sync History</h3>';

    if (SyncHistory.entries.length === 0) {
        html += '<div style="text-align: center; padding: 32px; color: #9ca3af; font-size: 13px;">No sync operations recorded yet. Syncs will appear here as they occur.</div>';
    } else {
        html += '<table class="sync-history-table">';
        html += '<thead><tr>';
        html += '<th>Time</th>';
        html += '<th>Type</th>';
        html += '<th>Result</th>';
        html += '<th>Events</th>';
        html += '<th>Snapshots</th>';
        html += '<th>Duration</th>';
        html += '<th>Detail</th>';
        html += '</tr></thead>';
        html += '<tbody>';

        var displayEntries = SyncHistory.entries.slice(0, 50);
        for (var i = 0; i < displayEntries.length; i++) {
            var entry = displayEntries[i];
            html += '<tr>';
            html += '<td style="white-space: nowrap; font-size: 12px; color: #6b7280;">' + formatSyncTimestamp(entry.timestamp) + '</td>';
            html += '<td><span class="sync-type-badge ' + entry.type + '">' + entry.type + '</span></td>';
            html += '<td><span class="sync-result-badge ' + entry.result + '">' + entry.result.replace('-', ' ') + '</span></td>';
            html += '<td>' + (entry.eventsFound || 0) + '</td>';
            html += '<td>' + (entry.snapshotsUpdated || 0) + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280;">' + (entry.duration > 0 ? entry.duration + 'ms' : '-') + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + esc(entry.detail || '') + '</td>';
            html += '</tr>';
        }

        html += '</tbody></table>';
        if (SyncHistory.entries.length > 50) {
            html += '<div style="text-align: center; padding: 8px; color: #9ca3af; font-size: 12px;">Showing 50 of ' + SyncHistory.entries.length + ' entries</div>';
        }
    }
    html += '</div>';

    // Activity log (mirrors SyncStatusFeed)
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (SyncStatusFeed.isActive ? 'green' : 'amber') + '"></span>Activity Log</h3>';
    html += '<div class="sync-activity-log">';
    if (SyncStatusFeed.lines.length === 0) {
        html += '<div class="log-empty">No sync activity logged yet</div>';
    } else {
        var logLines = SyncStatusFeed.lines.slice(-50);
        for (var j = 0; j < logLines.length; j++) {
            var line = logLines[j];
            html += '<div class="log-line ' + line.type + '">';
            html += '<span class="timestamp">' + line.timestamp + '</span>';
            html += '<span class="message">' + esc(line.message) + '</span>';
            html += '</div>';
        }
    }
    html += '</div>';
    html += '</div>';

    html += '</div>';
    container.innerHTML = html;

    // Scroll activity log to bottom
    var logEl = container.querySelector('.sync-activity-log');
    if (logEl) logEl.scrollTop = logEl.scrollHeight;
}

function formatSyncTimestamp(ts) {
    var d;
    if (ts instanceof Date) {
        d = ts;
    } else if (typeof ts === 'number') {
        d = new Date(ts);
    } else {
        d = new Date(ts);
    }
    if (isNaN(d.getTime())) return String(ts);
    var now = new Date();
    var isToday = d.toDateString() === now.toDateString();
    var time = d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });
    if (isToday) return time;
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' + time;
}

// ============ Init ============

async function init() {
    META_TABLES = {};
    META_FIELDS = {};
    META_VIEWS = {};
    TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
    currentTable = null;
    currentPage = 0;
    currentRecordIds = [];
    originalRecordIds = [];
    totalRecords = 0;
    lastEventTimestamp = null;

    // Load sidebar state (pinned, recent, expanded sections)
    loadSidebarState();
    initSidebarSearch();

    db = await openDB();

    // Capture the highest event ID at app open time for "new" event indicators
    appOpenedEventId = await getMaxEventId();

    updateStatus('Loading local data...', false, null, null);

    var storedLastTimestamp = await getSyncMeta('lastEventTimestamp');
    var tables = await getAllTables();
    var fields = await getAllFields();
    var views = await getAllViews();

    // Load metadata into memory
    tables.forEach(t => META_TABLES[t.tableId] = t);
    fields.forEach(f => {
        if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
        META_FIELDS[f.tableId][f.fieldId] = f;
    });
    views.forEach(v => {
        if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
        META_VIEWS[v.tableId][v.viewId] = v;
    });

    // Load user-specific table settings
    await loadTableSettings();

    hideAuthScreen();

    if (tables.length > 0) {
        updateStatus('Found ' + tables.length + ' tables', false, null, 'Loading data...');
        await renderSidebar();

        // Auto-select first table
        var firstTable = Object.keys(META_TABLES)[0];
        if (firstTable) {
            await showTable(firstTable);
        }

        lastEventTimestamp = storedLastTimestamp || null;
        if (API_KEY) await incrementalSync();
    } else {
        // No local data - always try to hydrate from Box snapshot first
        updateStatus('Hydrating from cloud snapshot...', false, 0, 'Downloading snapshot...');
        var hydrated = await hydrateFromBoxDownload();

        if (hydrated) {
            // Reload metadata after hydration
            tables = await getAllTables();
            fields = await getAllFields();
            views = await getAllViews();
            tables.forEach(t => META_TABLES[t.tableId] = t);
            fields.forEach(f => {
                if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
                META_FIELDS[f.tableId][f.fieldId] = f;
            });
            views.forEach(v => {
                if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
                META_VIEWS[v.tableId][v.viewId] = v;
            });

            await renderSidebar();
            var firstTable = Object.keys(META_TABLES)[0];
            if (firstTable) {
                await showTable(firstTable);
            }

            // Continue with incremental sync if API key is available
            if (API_KEY) {
                // Re-read lastEventTimestamp that was set during hydration
                // (storedLastTimestamp was read before hydration, so it would be null)
                var postHydrationTimestamp = await getSyncMeta('lastEventTimestamp');
                lastEventTimestamp = postHydrationTimestamp || null;

                // Run one immediate sync to fill the most critical gap
                await incrementalSync();

                // Start aggressive background polling to catch up any remaining events
                PostHydrationSync.start();
            }
        } else if (API_KEY) {
            // Box download failed or empty - fall back to full event sync
            updateStatus('Starting initial sync...', false, 0, 'Fetching data from server...');
            await renderSidebar();
            await fullSync();
            await renderSidebar();
        } else {
            // No snapshot, no API key - show empty state
            updateStatus('No data available - add API key to sync', true, null, null);
            await renderSidebar();
        }
    }

    updateStatus(API_KEY ? 'Up to date' : 'Offline mode', true, null, null);
    updateConnectApiButton();

    // Start the refresh indicator countdown
    lastSyncTime = Date.now();
    startRefreshCountdown();

    if (API_KEY) {
        if (pollInterval) clearInterval(pollInterval);
        pollInterval = setInterval(incrementalSync, 180000);

        // Start background polling for new events (lightweight 15s checks)
        // This uses the 'last' query parameter to efficiently detect new events
        // and triggers incremental sync only when new data is available
        SyncHistory.startPolling();
    }

    // Initialize Box sync toggle
    initBoxSyncToggle();
}

// ============ Field History Modal ============

var currentHistoryData = [];
var currentHistoryRecordId = null;
var currentHistoryTableId = null;

async function openHistoryModal(tableId, recordId) {
    currentHistoryTableId = tableId;
    currentHistoryRecordId = recordId;

    // Set modal title
    var tableName = META_TABLES[tableId]?.tableName || tableId;
    document.getElementById('history-modal-title').textContent = 'Field History - ' + tableName;

    // Show modal with loading state
    var overlay = document.getElementById('history-modal-overlay');
    var body = document.getElementById('history-modal-body');
    body.innerHTML = '<div class="modal-empty"><div class="loading-spinner"></div><h3>Loading history...</h3></div>';
    overlay.classList.add('open');

    // Fetch history data
    try {
        // First fetch any new events from API for this specific record (incremental)
        await fetchAndProcessHistoryForRecord(tableId, recordId);

        // Then get all history from IndexedDB (includes newly fetched entries)
        currentHistoryData = await getFieldHistoryForRecord(tableId, recordId);
        renderHistoryModal();
    } catch (err) {
        console.error('Error loading history:', err);
        body.innerHTML = '<div class="modal-empty"><h3>Error loading history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closeHistoryModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('history-modal-overlay').classList.remove('open');
    currentHistoryData = [];
    currentHistoryRecordId = null;
    currentHistoryTableId = null;
}

function renderHistoryModal() {
    var body = document.getElementById('history-modal-body');
    var filterSelect = document.getElementById('history-field-filter');
    var countEl = document.getElementById('history-count');

    if (!currentHistoryData || currentHistoryData.length === 0) {
        body.innerHTML = '<div class="modal-empty"><h3>No history available</h3><p>Field changes will appear here after the next sync</p></div>';
        filterSelect.innerHTML = '<option value="">All Fields</option>';
        countEl.textContent = '0 changes';
        return;
    }

    // Build field filter options
    var fieldIds = [...new Set(currentHistoryData.map(h => h.fieldId))];
    var fields = META_FIELDS[currentHistoryTableId] || {};

    var filterHtml = '<option value="">All Fields</option>';
    fieldIds.forEach(fid => {
        var fieldName = fields[fid]?.fieldName || fid;
        filterHtml += '<option value="' + esc(fid) + '">' + esc(fieldName) + '</option>';
    });
    filterSelect.innerHTML = filterHtml;

    // Get selected filter
    var selectedField = filterSelect.value;
    var filteredData = selectedField
        ? currentHistoryData.filter(h => h.fieldId === selectedField)
        : currentHistoryData;

    countEl.textContent = filteredData.length + ' change' + (filteredData.length !== 1 ? 's' : '');

    // Render history items
    var html = '<div class="history-timeline">';

    for (var item of filteredData) {
        var fieldName = fields[item.fieldId]?.fieldName || item.fieldId;
        var changeTypeClass = item.changeType || 'updated';
        var timestamp = item.timestamp ? formatTimestamp(item.timestamp) : 'Unknown time';

        html += '<div class="history-item">';
        html += '<div class="history-item-header">';
        html += '<span class="history-field-name">' + esc(fieldName) + '</span>';
        html += '<span class="history-change-type ' + changeTypeClass + '">' + changeTypeClass + '</span>';
        html += '<span class="history-timestamp">' + esc(timestamp) + '</span>';
        html += '<span class="history-event-id">Event #' + (item.eventId || '?') + '</span>';
        html += '</div>';

        html += '<div class="history-values">';

        // Old value
        if (item.changeType !== 'created') {
            html += '<div class="history-value-box ' + (item.oldValue === null ? 'null' : 'old') + '">';
            html += '<div class="history-value-label">Previous</div>';
            html += '<div class="history-value-content">' + formatHistoryValue(item.oldValue) + '</div>';
            html += '</div>';
            html += '<span class="history-arrow">&#8594;</span>';
        }

        // New value
        html += '<div class="history-value-box ' + (item.newValue === null ? 'null' : 'new') + '">';
        html += '<div class="history-value-label">' + (item.changeType === 'created' ? 'Initial Value' : 'New Value') + '</div>';
        html += '<div class="history-value-content">' + formatHistoryValue(item.newValue) + '</div>';
        html += '</div>';

        html += '</div>'; // .history-values
        html += '</div>'; // .history-item
    }

    html += '</div>';
    body.innerHTML = html;
}

function filterHistoryByField() {
    renderHistoryModal();
}

function formatTimestamp(ts) {
    if (!ts) return 'Unknown';
    var date = new Date(ts);
    var now = new Date();
    var diff = now - date;

    // If less than 24 hours, show relative time
    if (diff < 86400000) {
        if (diff < 60000) return 'Just now';
        if (diff < 3600000) return Math.floor(diff / 60000) + ' min ago';
        return Math.floor(diff / 3600000) + ' hour' + (Math.floor(diff / 3600000) !== 1 ? 's' : '') + ' ago';
    }

    // Otherwise show date and time
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatHistoryValue(value) {
    if (value === null || value === undefined) {
        return '<span style="color: #999; font-style: italic;">empty</span>';
    }

    if (Array.isArray(value)) {
        if (value.length === 0) return '<span style="color: #999; font-style: italic;">empty array</span>';

        // Check if it's an array of objects
        if (typeof value[0] === 'object' && value[0] !== null) {
            var items = value.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return items.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(i) + '</span>').join('');
        }

        return value.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(String(i)) + '</span>').join('');
    }

    if (typeof value === 'object') {
        if (value.name) return esc(value.name);
        if (value.filename) return esc(value.filename);
        if (value.email) return esc(value.email);
        return esc(JSON.stringify(value).slice(0, 100));
    }

    if (typeof value === 'boolean') {
        return '<span style="padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; ' +
            (value ? 'background: #d4edda; color: #155724;' : 'background: #f8d7da; color: #721c24;') + '">' +
            (value ? 'Yes' : 'No') + '</span>';
    }

    if (typeof value === 'number') {
        return '<span style="font-family: monospace;">' + value.toLocaleString() + '</span>';
    }

    return esc(String(value));
}

// Keyboard handler for modal
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        var overlay = document.getElementById('history-modal-overlay');
        if (overlay && overlay.classList.contains('open')) {
            closeHistoryModal();
        }
        // Also close PIT modal
        var pitOverlay = document.getElementById('pit-modal-overlay');
        if (pitOverlay && pitOverlay.classList.contains('open')) {
            closePitModal();
        }
        // Also close view selector and fields dropdown
        closeAllDropdowns();
    }
});

// ============ Events View ============

async function showEventsView() {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Open tab for events
    openTableInTab('_events', 'Events Stream', '\u26A1');

    // Clean up sync status listener
    if (syncStatusUnsubscribe) { syncStatusUnsubscribe(); syncStatusUnsubscribe = null; }

    currentTable = '_events';
    currentView = null;

    // Update sidebar selection
    document.querySelectorAll('.sidebar .table-item').forEach(el => el.classList.remove('active', 'expanded'));
    document.querySelectorAll('.sidebar .table-view-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.sidebar .table-item.events-item')?.classList.add('active');

    // Hide view controls and show events view
    document.getElementById('view-controls-bar').style.display = 'none';
    document.getElementById('title').textContent = 'Events Stream';
    document.getElementById('pagination').style.display = 'none';

    // Hide toolbar views section for events view
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = 'none';

    await renderEventsView();
    // Navigation guard check after async work (renderEventsView handles its own loading state)
}

async function renderEventsView() {
    var container = document.querySelector('.table-container');
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading events...</h3></div>';

    // Clean up previous scroll handler
    if (eventsScrollHandler) {
        container.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }

    // Reset infinite scroll state
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;

    try {
        var totalEventsCount = await getRawEventsCount();
        var totalRecordsCount = await getCurrentRecordsCount();

        // Load initial batch of events
        var events = await fetchEventsForInfiniteScroll(eventsOffset, eventsPageSize);
        loadedEvents = events;
        eventsOffset = events.length;
        hasMoreEvents = events.length === eventsPageSize;

        // Count new events (events with ID > appOpenedEventId)
        var newEventsCount = events.filter(e => e.id > appOpenedEventId).length;

        var html = '';

        // Events controls bar
        html += '<div class="events-controls">';
        html += '<div class="events-filter-group">';
        html += '<label>Type:</label>';
        html += '<select onchange="setEventsTypeFilter(this.value)">';
        html += '<option value=""' + (!eventsTypeFilter ? ' selected' : '') + '>All Events</option>';
        html += '<option value="current"' + (eventsTypeFilter === 'current' ? ' selected' : '') + '>All Records (' + ENTITY_TYPE_NAMES['current'] + ')</option>';
        ['INS', 'ALT', 'NUL', 'SYN', 'table', 'field', 'view', 'viewConfig'].forEach(function(t) {
            html += '<option value="' + t + '"' + (eventsTypeFilter === t ? ' selected' : '') + '>' + ENTITY_TYPE_NAMES[t] + '</option>';
        });
        html += '</select>';
        html += '</div>';

        html += '<div class="events-filter-group">';
        html += '<label>Table:</label>';
        html += '<select onchange="setEventsSetFilter(this.value)">';
        html += '<option value="">All Tables</option>';
        for (var tid in META_TABLES) {
            var tableName = META_TABLES[tid].tableName || tid;
            var setVal = 'airtable:' + tid;
            html += '<option value="' + esc(setVal) + '"' + (eventsSetFilter === setVal ? ' selected' : '') + '>' + esc(tableName) + '</option>';
        }
        html += '</select>';
        html += '</div>';

        html += '<div class="events-filter-group">';
        html += '<label>Search:</label>';
        html += '<input type="text" placeholder="Search events..." value="' + esc(eventsSearchQuery) + '" onkeydown="if(event.key===\'Enter\')setEventsSearch(this.value)">';
        html += '</div>';

        // Show loaded count and total
        html += '<div class="events-stats" id="events-stats">';
        if (eventsTypeFilter === 'current') {
            html += 'Loaded ' + loadedEvents.length.toLocaleString();
            html += ' <span style="color: #666;">(' + totalRecordsCount.toLocaleString() + ' total records)</span>';
        } else {
            html += 'Loaded ' + loadedEvents.length.toLocaleString();
            html += ' <span style="color: #666;">(' + totalEventsCount.toLocaleString() + ' total events)</span>';
            if (newEventsCount > 0) {
                html += ' <span class="new-event-badge">' + newEventsCount + ' new</span>';
            }
        }
        html += '</div>';

        // Import/Export buttons
        html += '<div class="events-actions">';
        html += '<button class="btn" onclick="exportEventsToCSV()" title="Export events to CSV">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>';
        html += ' Export CSV';
        html += '</button>';
        html += '<button class="btn" onclick="importEventsFromCSV()" title="Import events from CSV (deduplicates by ID)">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>';
        html += ' Import CSV';
        html += '</button>';
        html += '</div>';

        html += '</div>';

        // Events table
        html += '<table class="events-table">';
        html += '<thead><tr>';
        html += '<th style="width: 80px;">ID</th>';
        html += '<th style="width: 140px;">Timestamp</th>';
        html += '<th style="width: 90px;">Type</th>';
        html += '<th style="width: 140px;">Set</th>';
        html += '<th style="width: 130px;">Record ID</th>';
        html += '<th style="width: 140px;">Details</th>';
        html += '<th>Payload</th>';
        html += '<th style="width: 120px;">Actions</th>';
        html += '</tr></thead>';
        html += '<tbody id="events-tbody">';

        if (events.length === 0) {
            html += '<tr><td colspan="8" style="text-align: center; padding: 40px; color: #666;">No events found</td></tr>';
        } else {
            html += renderEventRows(events, newEventsCount);
        }

        html += '</tbody></table>';

        // Infinite scroll loading indicator
        html += '<div id="events-load-more" class="events-load-more" style="display: ' + (hasMoreEvents ? 'flex' : 'none') + ';">';
        html += '<div class="loading-spinner-small"></div>';
        html += '<span>Loading more events...</span>';
        html += '</div>';

        // End of events message
        html += '<div id="events-end-message" class="events-end-message" style="display: ' + (hasMoreEvents ? 'none' : 'block') + ';">';
        html += 'All events loaded';
        html += '</div>';

        container.innerHTML = html;

        // Set up infinite scroll
        setupEventsInfiniteScroll(container, totalEventsCount, totalRecordsCount);

    } catch (err) {
        console.error('Error loading events:', err);
        container.innerHTML = '<div class="empty-state"><h3>Error loading events</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Helper function to fetch events based on current filters
async function fetchEventsForInfiniteScroll(offset, limit) {
    var events = [];

    if (eventsTypeFilter === 'current') {
        events = await getCurrentRecordsPaginated(offset, limit, eventsSetFilter, eventsSearchQuery);
    } else {
        if (eventsSearchQuery) {
            events = await searchRawEvents(eventsSearchQuery, limit, offset);
        } else if (eventsSetFilter) {
            events = await getRawEventsBySetPaginated(eventsSetFilter, offset, limit);
        } else {
            events = await getRawEventsPaginated(offset, limit);
        }

        // Apply type filter if set (post-filter since we need to parse payload)
        if (eventsTypeFilter) {
            events = events.filter(e => {
                var payload = parsePayload(e.payload);
                var baseType = payload?._set || 'data';
                // For data events, resolve to operator type (INS/ALT/NUL)
                var type = baseType;
                if (baseType === 'data') {
                    if (e.operator) {
                        type = e.operator;
                    } else if (payload && payload.fields) {
                        if (payload.fields.INS) type = 'INS';
                        else if (payload.fields.ALT) type = 'ALT';
                        else if (payload.fields.NUL) type = 'NUL';
                        else if (payload.fields.SYN) type = 'SYN';
                    }
                }
                return type === eventsTypeFilter;
            });
        }
    }

    return events;
}

// Render multiple event rows and track new events divider
function renderEventRows(events, newEventsCount) {
    var html = '';
    var addedDivider = loadedEvents.length > events.length; // Divider already added if we've loaded more than initial batch

    for (var i = 0; i < events.length; i++) {
        var event = events[i];
        var isNew = event.id > appOpenedEventId;

        // Add divider between new and old events (only once)
        if (!addedDivider && !isNew && newEventsCount > 0) {
            html += '<tr class="new-events-divider"><td colspan="7"><span class="new-events-divider-text">Events when app opened</span></td></tr>';
            addedDivider = true;
        }

        html += renderEventRow(event, isNew);
    }

    return html;
}

// Set up infinite scroll for events
function setupEventsInfiniteScroll(container, totalEventsCount, totalRecordsCount) {
    eventsScrollHandler = function() {
        // Check if we're near the bottom (within 200px)
        var scrollTop = container.scrollTop;
        var scrollHeight = container.scrollHeight;
        var clientHeight = container.clientHeight;

        if (scrollHeight - scrollTop - clientHeight < 200) {
            loadMoreEvents(totalEventsCount, totalRecordsCount);
        }
    };

    container.addEventListener('scroll', eventsScrollHandler);
}

// Load more events for infinite scroll
async function loadMoreEvents(totalEventsCount, totalRecordsCount) {
    if (isLoadingMoreEvents || !hasMoreEvents) return;

    isLoadingMoreEvents = true;
    var loadMoreDiv = document.getElementById('events-load-more');
    if (loadMoreDiv) loadMoreDiv.style.display = 'flex';

    try {
        var newEvents = await fetchEventsForInfiniteScroll(eventsOffset, eventsPageSize);

        if (newEvents.length === 0) {
            hasMoreEvents = false;
        } else {
            // Add new events to loaded array
            loadedEvents = loadedEvents.concat(newEvents);
            eventsOffset += newEvents.length;
            hasMoreEvents = newEvents.length === eventsPageSize;

            // Count new events in this batch
            var newEventsCount = newEvents.filter(e => e.id > appOpenedEventId).length;

            // Append rows to tbody
            var tbody = document.getElementById('events-tbody');
            if (tbody) {
                var rowsHtml = renderEventRows(newEvents, newEventsCount);
                tbody.insertAdjacentHTML('beforeend', rowsHtml);
            }

            // Update stats
            updateEventsStats(totalEventsCount, totalRecordsCount);
        }
    } catch (err) {
        console.error('Error loading more events:', err);
    } finally {
        isLoadingMoreEvents = false;

        // Update loading indicator visibility
        var loadMoreDiv = document.getElementById('events-load-more');
        var endMessage = document.getElementById('events-end-message');

        if (loadMoreDiv) loadMoreDiv.style.display = hasMoreEvents ? 'none' : 'none';
        if (endMessage) endMessage.style.display = hasMoreEvents ? 'none' : 'block';
    }
}

// Update the events stats display
function updateEventsStats(totalEventsCount, totalRecordsCount) {
    var statsDiv = document.getElementById('events-stats');
    if (!statsDiv) return;

    var newEventsCount = loadedEvents.filter(e => e.id > appOpenedEventId).length;

    var html = '';
    if (eventsTypeFilter === 'current') {
        html += 'Loaded ' + loadedEvents.length.toLocaleString();
        html += ' <span style="color: #666;">(' + totalRecordsCount.toLocaleString() + ' total records)</span>';
    } else {
        html += 'Loaded ' + loadedEvents.length.toLocaleString();
        html += ' <span style="color: #666;">(' + totalEventsCount.toLocaleString() + ' total events)</span>';
        if (newEventsCount > 0) {
            html += ' <span class="new-event-badge">' + newEventsCount + ' new</span>';
        }
    }

    statsDiv.innerHTML = html;
}

function renderEventRow(event, isNew) {
    var payload = parsePayload(event.payload);
    var baseType = payload?._set || 'data';
    // For data events, show the operator (INS/ALT/NUL) instead of generic "data"
    var eventType = baseType;
    if (baseType === 'data') {
        if (event.operator) {
            eventType = event.operator;
        } else if (payload && payload.fields) {
            // Infer from payload fields
            if (payload.fields.INS) eventType = 'INS';
            else if (payload.fields.ALT) eventType = 'ALT';
            else if (payload.fields.NUL) eventType = 'NUL';
            else if (payload.fields.SYN) eventType = 'SYN';
        }
    }
    var isCurrentState = event._isCurrentState || eventType === 'current';
    var timestamp = event.created_at ? formatTimestamp(new Date(event.created_at).getTime()) : (isCurrentState ? 'Current' : 'Unknown');
    var isExpanded = expandedPayloads.has(event.id || event.recordId);

    var rowClass = isNew ? 'new-event' : (isCurrentState ? 'current-state-row' : '');
    var html = '<tr data-event-id="' + (event.id || event.recordId) + '"' + (rowClass ? ' class="' + rowClass + '"' : '') + '>';

    // ID column - show "" for current state
    if (isCurrentState) {
        html += '<td><span class="event-id current-state"></span></td>';
    } else {
        html += '<td><span class="event-id">' + event.id + (isNew ? '<span class="new-event-badge">NEW</span>' : '') + '</span></td>';
    }

    html += '<td><span class="event-timestamp">' + esc(timestamp) + '</span></td>';
    html += '<td><span class="event-type-badge ' + eventType + '">' + esc(ENTITY_TYPE_NAMES[eventType] || eventType) + '</span></td>';
    var setTableId = (event.set || '').replace('airtable:', '');
    var setDisplayName = (META_TABLES[setTableId] && META_TABLES[setTableId].tableName) || event.set || '';
    html += '<td><span class="event-set" title="' + esc(event.set || '') + '">' + esc(setDisplayName) + '</span></td>';
    html += '<td><span class="event-record-id">' + esc(event.recordId || '') + '</span></td>';

    // Details column - show field operation types and counts
    html += '<td class="event-details">';
    var fieldOps = getFieldOperationDetails(payload);
    if (fieldOps) {
        fieldOps.forEach(function(op) {
            html += '<span class="field-op-badge ' + op.type + '">' + op.type + ' <span class="field-count">' + op.label + '</span></span>';
        });
    } else if (eventType !== 'data') {
        html += '<span style="color: #9ca3af; font-size: 11px;"></span>';
    } else {
        html += '<span style="color: #9ca3af; font-size: 11px;"></span>';
    }
    html += '</td>';

    // Payload preview
    html += '<td class="payload-preview-container">';
    html += '<div class="payload-preview' + (isExpanded ? ' expanded' : '') + '" onclick="togglePayloadExpand(\'' + (event.id || event.recordId) + '\')">';
    html += formatPayloadPreview(payload, isExpanded);
    if (!isExpanded) {
        html += '<span class="payload-expand-btn">Expand</span>';
    } else {
        html += '<span class="payload-expand-btn">Collapse</span>';
    }
    html += '</div>';
    html += '</td>';

    // Actions
    html += '<td class="event-actions">';
    if (event.recordId && event.recordId.startsWith('rec')) {
        if (isCurrentState) {
            // For current state, show "View Record" button that opens profile
            var tableId = (event.set || '').replace('airtable:', '');
            html += '<button class="event-action-btn primary" onclick="openRecordProfile(\'' + esc(tableId) + '\', \'' + esc(event.recordId) + '\')" title="View full record details">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';
            html += 'View Record';
            html += '</button>';
        } else {
            html += '<button class="event-action-btn primary" onclick="viewRecordAtPointInTime(' + event.id + ', \'' + esc(event.recordId) + '\', \'' + esc(event.set || '') + '\')" title="View record state at this point in time">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M8 3v5l3 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="1.5"/></svg>';
            html += 'View State';
            html += '</button>';
        }
    }
    html += '</td>';

    html += '</tr>';
    return html;
}

function getFieldOperationDetails(payload) {
    if (!payload || !payload.fields) return null;

    var fields = payload.fields;
    var details = [];

    if (fields.INS && typeof fields.INS === 'object') {
        var count = Object.keys(fields.INS).length;
        details.push({ type: 'INS', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    if (fields.ALT && typeof fields.ALT === 'object') {
        var count = Object.keys(fields.ALT).length;
        details.push({ type: 'ALT', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    if (fields.NUL && Array.isArray(fields.NUL)) {
        var count = fields.NUL.length;
        if (count > 0) {
            details.push({ type: 'NUL', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
        }
    }

    if (fields.SYN && typeof fields.SYN === 'object') {
        var count = Object.keys(fields.SYN).length;
        details.push({ type: 'SYN', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    return details.length > 0 ? details : null;
}

function formatPayloadPreview(payload, expanded) {
    if (!payload) return '<span class="json-null">null</span>';

    // Try to extract INS/ALT/NUL field data for nice display
    var fields = payload.fields;
    var hasFieldData = fields && (fields.INS || fields.ALT || fields.NUL || fields.SYN);

    if (hasFieldData) {
        return formatPayloadFields(fields, expanded);
    }

    // Check if payload has context.data (alternative structure)
    if (payload.context && payload.context.data) {
        return formatPayloadFields({ INS: payload.context.data }, expanded);
    }

    // Fallback to raw JSON display
    try {
        var str = typeof payload === 'string' ? payload : JSON.stringify(payload, null, expanded ? 2 : 0);

        // Apply syntax highlighting
        str = esc(str)
            .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span>:')
            .replace(/: "([^"]*)"([,\n\}])/g, ': <span class="json-string">"$1"</span>$2')
            .replace(/: (-?\d+\.?\d*)([,\n\}])/g, ': <span class="json-number">$1</span>$2')
            .replace(/: (true|false)([,\n\}])/g, ': <span class="json-boolean">$1</span>$2')
            .replace(/: (null)([,\n\}])/g, ': <span class="json-null">$1</span>$2');

        return str;
    } catch (e) {
        return esc(String(payload));
    }
}

function formatPayloadFields(fields, expanded) {
    var html = '<div class="payload-fields">';
    var ops = ['INS', 'ALT', 'NUL'];
    var hasAnyFields = false;

    for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        var data = fields[op];
        if (!data) continue;

        // NUL is an array of field names, INS/ALT are objects
        if (op === 'NUL' && Array.isArray(data) && data.length > 0) {
            hasAnyFields = true;
            html += '<div class="payload-op-group">';
            html += '<span class="payload-op-label ' + op + '">' + op + '</span>';
            html += '<div class="payload-field-row">';
            html += '<span class="payload-field-value null">' + esc(data.join(', ')) + '</span>';
            html += '</div></div>';
        } else if (typeof data === 'object' && !Array.isArray(data)) {
            var keys = Object.keys(data);
            if (keys.length === 0) continue;

            hasAnyFields = true;
            html += '<div class="payload-op-group">';
            html += '<span class="payload-op-label ' + op + '">' + op + '</span>';

            // In collapsed mode, show limited fields
            var displayKeys = expanded ? keys : keys.slice(0, 3);

            for (var j = 0; j < displayKeys.length; j++) {
                var key = displayKeys[j];
                var value = data[key];
                html += '<div class="payload-field-row">';
                html += '<span class="payload-field-name">' + esc(getFieldDisplayName(key)) + '</span>';
                html += '<span class="payload-field-value ' + getValueClass(value) + '">' + formatFieldValue(value, expanded) + '</span>';
                html += '</div>';
            }

            if (!expanded && keys.length > 3) {
                html += '<div class="payload-field-row" style="color: #9ca3af; font-style: italic;">+' + (keys.length - 3) + ' more fields</div>';
            }

            html += '</div>';
        }
    }

    html += '</div>';
    return hasAnyFields ? html : '<span class="json-null">no field data</span>';
}

function getFieldDisplayName(fieldId) {
    // Try to get human-readable field name from schema
    if (window.fields && window.fields[fieldId]) {
        return window.fields[fieldId].name || fieldId;
    }
    // Truncate long field IDs
    if (fieldId.length > 20) {
        return fieldId.substring(0, 17) + '...';
    }
    return fieldId;
}

function getValueClass(value) {
    if (value === null || value === undefined) return 'null';
    if (Array.isArray(value)) return 'array';
    if (typeof value === 'object') return 'object';
    if (typeof value === 'number') return 'number';
    if (typeof value === 'boolean') return 'boolean';
    return 'string';
}

function formatFieldValue(value, expanded) {
    if (value === null || value === undefined) return 'null';

    if (Array.isArray(value)) {
        if (value.length === 0) return '[]';
        if (!expanded && value.length > 2) {
            return '[' + esc(String(value[0])) + ', ... +' + (value.length - 1) + ']';
        }
        return '[' + value.map(function(v) { return esc(String(v)); }).join(', ') + ']';
    }

    if (typeof value === 'object') {
        var keys = Object.keys(value);
        if (keys.length === 0) return '{}';
        if (!expanded) return '{' + keys.length + ' keys}';
        return esc(JSON.stringify(value));
    }

    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'number') return String(value);

    // String value - truncate if too long
    var str = String(value);
    if (!expanded && str.length > 50) {
        return esc(str.substring(0, 47)) + '...';
    }
    return esc(str);
}

function togglePayloadExpand(eventId) {
    if (expandedPayloads.has(eventId)) {
        expandedPayloads.delete(eventId);
    } else {
        expandedPayloads.add(eventId);
    }

    // Find the row and update just the payload cell instead of re-rendering everything
    var row = document.querySelector('tr[data-event-id="' + eventId + '"]');
    if (row) {
        var event = loadedEvents.find(e => (e.id || e.recordId) == eventId);
        if (event) {
            var payload = parsePayload(event.payload);
            var isExpanded = expandedPayloads.has(eventId);
            var payloadCell = row.querySelector('.payload-preview-container');
            if (payloadCell) {
                var html = '<div class="payload-preview' + (isExpanded ? ' expanded' : '') + '" onclick="togglePayloadExpand(\'' + eventId + '\')">';
                html += formatPayloadPreview(payload, isExpanded);
                if (!isExpanded) {
                    html += '<span class="payload-expand-btn">Expand</span>';
                } else {
                    html += '<span class="payload-expand-btn">Collapse</span>';
                }
                html += '</div>';
                payloadCell.innerHTML = html;
            }
        }
    }
}

function setEventsTypeFilter(type) {
    eventsTypeFilter = type;
    renderEventsView();
}

function setEventsSetFilter(set) {
    eventsSetFilter = set;
    renderEventsView();
}

function setEventsSearch(query) {
    eventsSearchQuery = query;
    renderEventsView();
}

// ============ Events CSV Export/Import ============

async function exportEventsToCSV() {
    try {
        // Show progress
        showImportStatus('Exporting...', 'Collecting events from database...', 'progress', 0);

        // Get all events from IndexedDB
        var allEvents = [];
        var batchSize = 1000;
        var offset = 0;
        var totalCount = await getRawEventsCount();

        while (true) {
            var batch = await getRawEventsPaginated(offset, batchSize);
            if (batch.length === 0) break;
            allEvents = allEvents.concat(batch);
            offset += batch.length;

            var progress = Math.round((allEvents.length / totalCount) * 50);
            showImportStatus('Exporting...', 'Collected ' + allEvents.length.toLocaleString() + ' of ' + totalCount.toLocaleString() + ' events', 'progress', progress);
        }

        if (allEvents.length === 0) {
            showImportStatus('No Events', 'No events to export.', 'error');
            return;
        }

        showImportStatus('Exporting...', 'Building CSV file...', 'progress', 60);

        // CSV header
        var csvLines = ['id,set,recordId,created_at,payload'];

        // Convert events to CSV rows
        for (var i = 0; i < allEvents.length; i++) {
            var event = allEvents[i];
            var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);

            // Escape CSV fields
            var row = [
                event.id,
                escapeCSVField(event.set || ''),
                escapeCSVField(event.recordId || ''),
                escapeCSVField(event.created_at || ''),
                escapeCSVField(payloadStr)
            ];
            csvLines.push(row.join(','));

            if (i % 1000 === 0) {
                var progress = 60 + Math.round((i / allEvents.length) * 30);
                showImportStatus('Exporting...', 'Processing event ' + i.toLocaleString() + ' of ' + allEvents.length.toLocaleString(), 'progress', progress);
            }
        }

        showImportStatus('Exporting...', 'Creating download...', 'progress', 95);

        // Create and download file
        var csvContent = csvLines.join('\n');
        var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        var url = URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = url;
        link.download = 'events_export_' + new Date().toISOString().slice(0, 10) + '.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        showImportStatus('Export Complete', 'Exported ' + allEvents.length.toLocaleString() + ' events to CSV.', 'success');

    } catch (err) {
        console.error('Error exporting events:', err);
        showImportStatus('Export Failed', err.message, 'error');
    }
}

function escapeCSVField(value) {
    if (value === null || value === undefined) return '';
    var str = String(value);
    // If contains comma, newline, or quote, wrap in quotes and escape inner quotes
    if (str.includes(',') || str.includes('\n') || str.includes('"') || str.includes('\r')) {
        return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
}

function parseCSVLine(line) {
    var result = [];
    var current = '';
    var inQuotes = false;
    var i = 0;

    while (i < line.length) {
        var char = line[i];

        if (inQuotes) {
            if (char === '"') {
                // Check for escaped quote
                if (i + 1 < line.length && line[i + 1] === '"') {
                    current += '"';
                    i += 2;
                    continue;
                } else {
                    inQuotes = false;
                    i++;
                    continue;
                }
            }
            current += char;
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === ',') {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        i++;
    }
    result.push(current);
    return result;
}

async function importEventsFromCSV() {
    // Create file input
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;

        try {
            showImportStatus('Importing...', 'Reading file...', 'progress', 0);

            var text = await file.text();
            var lines = text.split(/\r?\n/);

            if (lines.length < 2) {
                showImportStatus('Import Failed', 'CSV file is empty or has no data rows.', 'error');
                return;
            }

            // Parse header
            var header = parseCSVLine(lines[0]);
            var idIndex = header.indexOf('id');
            var setIndex = header.indexOf('set');
            var recordIdIndex = header.indexOf('recordId');
            var createdAtIndex = header.indexOf('created_at');
            var payloadIndex = header.indexOf('payload');

            if (idIndex === -1) {
                showImportStatus('Import Failed', 'CSV must have an "id" column.', 'error');
                return;
            }

            showImportStatus('Importing...', 'Parsing CSV data...', 'progress', 10);

            // Parse all event rows
            var events = [];
            for (var i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                var fields = parseCSVLine(lines[i]);
                var event = {
                    id: parseInt(fields[idIndex], 10)
                };

                if (isNaN(event.id)) continue; // Skip invalid IDs

                if (setIndex !== -1) event.set = fields[setIndex] || '';
                if (recordIdIndex !== -1) event.recordId = fields[recordIdIndex] || '';
                if (createdAtIndex !== -1) event.created_at = fields[createdAtIndex] || '';
                if (payloadIndex !== -1) {
                    var payloadStr = fields[payloadIndex] || '{}';
                    try {
                        event.payload = JSON.parse(payloadStr);
                    } catch (e) {
                        event.payload = payloadStr;
                    }
                }

                events.push(event);

                if (i % 1000 === 0) {
                    showImportStatus('Importing...', 'Parsed ' + events.length.toLocaleString() + ' events...', 'progress', 10 + Math.round((i / lines.length) * 20));
                }
            }

            if (events.length === 0) {
                showImportStatus('Import Failed', 'No valid events found in CSV.', 'error');
                return;
            }

            showImportStatus('Importing...', 'Checking for duplicates...', 'progress', 35);

            // Get existing event IDs from IndexedDB for deduplication
            var existingIds = await getExistingEventIds();

            showImportStatus('Importing...', 'Found ' + existingIds.size.toLocaleString() + ' existing events. Filtering duplicates...', 'progress', 50);

            // Filter out duplicates
            var newEvents = events.filter(function(e) {
                return !existingIds.has(e.id);
            });

            var duplicateCount = events.length - newEvents.length;

            if (newEvents.length === 0) {
                showImportStatus('Import Complete', 'All ' + events.length.toLocaleString() + ' events already exist (no new events to import).', 'success');
                return;
            }

            showImportStatus('Importing...', 'Importing ' + newEvents.length.toLocaleString() + ' new events (skipping ' + duplicateCount.toLocaleString() + ' duplicates)...', 'progress', 60);

            // Import events in batches
            var batchSize = 500;
            var imported = 0;

            for (var j = 0; j < newEvents.length; j += batchSize) {
                var batch = newEvents.slice(j, j + batchSize);
                await saveRawEvents(batch);
                imported += batch.length;

                var progress = 60 + Math.round((imported / newEvents.length) * 35);
                showImportStatus('Importing...', 'Imported ' + imported.toLocaleString() + ' of ' + newEvents.length.toLocaleString() + ' events...', 'progress', progress);
            }

            showImportStatus('Import Complete',
                'Imported ' + newEvents.length.toLocaleString() + ' new events' +
                (duplicateCount > 0 ? ' (skipped ' + duplicateCount.toLocaleString() + ' duplicates)' : '') + '.',
                'success');

            // Refresh the events view
            if (currentTable === '_events') {
                renderEventsView();
            }

        } catch (err) {
            console.error('Error importing events:', err);
            showImportStatus('Import Failed', err.message, 'error');
        }
    };

    input.click();
}

async function getExistingEventIds() {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var ids = new Set();

        var req = store.openKeyCursor();
        req.onsuccess = function(e) {
            var cursor = e.target.result;
            if (cursor) {
                ids.add(cursor.key);
                cursor.continue();
            } else {
                resolve(ids);
            }
        };
        req.onerror = function() {
            reject(req.error);
        };
    });
}

function showImportStatus(title, details, type, progress) {
    var existing = document.querySelector('.import-status');
    if (existing) existing.remove();

    var div = document.createElement('div');
    div.className = 'import-status' + (type === 'success' ? ' success' : type === 'error' ? ' error' : '');

    var icon = type === 'success' ? '' : type === 'error' ? '' : '';
    var titleClass = type === 'success' ? ' success' : type === 'error' ? ' error' : '';

    div.innerHTML = '<div class="import-status-title' + titleClass + '">' + icon + ' ' + esc(title) + '</div>' +
                    '<div class="import-status-details">' + esc(details) + '</div>' +
                    (type === 'progress' ? '<div class="import-progress"><div class="import-progress-bar" style="width: ' + (progress || 0) + '%"></div></div>' : '');

    document.body.appendChild(div);

    // Auto-remove success/error messages after 5 seconds
    if (type === 'success' || type === 'error') {
        setTimeout(function() {
            if (div.parentNode) div.remove();
        }, 5000);
    }
}

// Skip setup and upload CSV file directly
var skipSyncAbortController = null;

// Build in-memory lookup map for events by recordId
function buildInMemoryEventsByRecord(events) {
    var map = new Map();
    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (e.recordId) {
            if (!map.has(e.recordId)) {
                map.set(e.recordId, []);
            }
            map.get(e.recordId).push(e);
        }
    }
    return map;
}

// Background save events to IndexedDB (non-blocking)
async function backgroundSaveToIndexedDB(events, onProgress) {
    isBackgroundSaveInProgress = true;
    var batchSize = 500;
    var saved = 0;
    var total = events.length;

    try {
        // Phase 1: Save raw events
        for (var j = 0; j < events.length; j += batchSize) {
            var batch = events.slice(j, j + batchSize);
            await saveRawEvents(batch);
            saved += batch.length;

            if (onProgress) {
                onProgress(saved, total);
            }

            // Yield to main thread periodically to keep UI responsive
            if (j % 2000 === 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Phase 2: Save metadata (tables, fields, views)
        var tables = Object.values(META_TABLES);
        var fields = [];
        for (var tid in META_FIELDS) {
            for (var fid in META_FIELDS[tid]) {
                fields.push(META_FIELDS[tid][fid]);
            }
        }
        var views = [];
        for (var tid in META_VIEWS) {
            for (var vid in META_VIEWS[tid]) {
                views.push(META_VIEWS[tid][vid]);
            }
        }

        // Phase 3: Save data records from IN_MEMORY_DATA
        var dataRecords = [];
        if (window.IN_MEMORY_DATA) {
            for (var tableId in window.IN_MEMORY_DATA) {
                for (var recordId in window.IN_MEMORY_DATA[tableId]) {
                    dataRecords.push({
                        tableId: tableId,
                        recordId: recordId,
                        fields: window.IN_MEMORY_DATA[tableId][recordId]
                    });
                }
            }
        }

        // Save metadata and records in batch
        if (tables.length || fields.length || views.length || dataRecords.length) {
            await saveBatch(tables, fields, views, dataRecords);
        }

        // Phase 4: Build and save field history from raw events
        // Group events by tableId and recordId, then build history for each record
        // Only process data events (set starts with 'airtable:')
        var eventsByTableAndRecord = {};
        for (var i = 0; i < events.length; i++) {
            var evt = events[i];
            if (evt.recordId && evt.set && evt.set.startsWith('airtable:')) {
                var tableId = evt.set.replace('airtable:', '');
                var key = tableId + '|' + evt.recordId;
                if (!eventsByTableAndRecord[key]) {
                    eventsByTableAndRecord[key] = { tableId: tableId, recordId: evt.recordId, events: [] };
                }
                eventsByTableAndRecord[key].events.push(evt);
            }
        }

        var allFieldHistoryEntries = [];
        var recordKeys = Object.keys(eventsByTableAndRecord);
        for (var k = 0; k < recordKeys.length; k++) {
            var group = eventsByTableAndRecord[recordKeys[k]];
            var historyEntries = buildFieldHistoryFromRawEvents(group.tableId, group.recordId, group.events);
            allFieldHistoryEntries = allFieldHistoryEntries.concat(historyEntries);

            // Yield periodically to keep UI responsive
            if (k % 500 === 0 && k > 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Save field history in batches
        if (allFieldHistoryEntries.length > 0) {
            for (var h = 0; h < allFieldHistoryEntries.length; h += batchSize) {
                var historyBatch = allFieldHistoryEntries.slice(h, h + batchSize);
                await saveFieldHistory(historyBatch);
            }
            console.log('Saved ' + allFieldHistoryEntries.length + ' field history entries');
        }

        // Update the last event timestamp in IndexedDB
        var maxId = events.reduce(function(max, e) { return Math.max(max, e.id); }, 0);
        var lastEvent = events.find(function(e) { return e.id === maxId; });
        if (lastEvent && lastEvent.created_at) {
            await setSyncMeta('lastEventTimestamp', lastEvent.created_at);
        }

        console.log('Background IndexedDB save complete: ' + saved + ' events, ' + dataRecords.length + ' records');

        // Clear in-memory cache after successful IndexedDB save to free memory
        // (functions will now read from IndexedDB)
        inMemoryEvents = null;
        inMemoryEventsByRecord = null;
        window.IN_MEMORY_DATA = null;

    } catch (err) {
        console.error('Background IndexedDB save failed:', err);
        // Keep in-memory cache if save failed
    } finally {
        isBackgroundSaveInProgress = false;
    }
}


// ============ Hydrate from Box Download ============

// Fetches .amo event stream from Box via webhook and replays it locally.
// Data is encrypted locally via the existing encryption system (user's password/passkey).
// Returns true if hydration succeeded, false otherwise.
async function hydrateFromBoxDownload() {
    try {
        showLoadingOverlay();
        updateLoadingOverlay('Downloading data...', 'Fetching from cloud storage...', 5, 0, 0, 0, '');

        if (!BOX_DOWNLOAD_WEBHOOK || !API_KEY) {
            hideLoadingOverlay();
            return false;
        }
        var downloadUrl = BOX_DOWNLOAD_WEBHOOK + '?api_key=' + encodeURIComponent(API_KEY);
        var response = await fetch(downloadUrl);
        if (!response.ok) {
            console.warn('[BoxDownload] HTTP ' + response.status + ' - no data available');
            hideLoadingOverlay();
            return false;
        }

        var buffer = await response.arrayBuffer();
        if (!buffer || buffer.byteLength === 0) {
            console.warn('[BoxDownload] Empty response');
            hideLoadingOverlay();
            return false;
        }

        updateLoadingOverlay('Downloading data...', 'Parsing data...', 15, 0, 0, 0, '');

        // Detect format
        var format;
        try {
            format = AmoFormat.detectFormat(buffer);
        } catch (err) {
            console.warn('[BoxDownload] Unrecognized format:', err);
            hideLoadingOverlay();
            return false;
        }

        var amoData;
        if (format === 'amo') {
            amoData = AmoFormat.read(buffer);
        } else {
            console.warn('[BoxDownload] Unsupported format:', format);
            hideLoadingOverlay();
            return false;
        }

        // Restore table/field metadata if available
        var savedMeta = amoData.meta || {};
        if (savedMeta.tables) {
            var savedTableIds = Object.keys(savedMeta.tables);
            for (var m = 0; m < savedTableIds.length; m++) {
                var tid = savedTableIds[m];
                META_TABLES[tid] = savedMeta.tables[tid];
            }
        }
        if (savedMeta.fields) {
            var savedFieldTableIds = Object.keys(savedMeta.fields);
            for (var m2 = 0; m2 < savedFieldTableIds.length; m2++) {
                var tid2 = savedFieldTableIds[m2];
                if (!META_FIELDS[tid2]) META_FIELDS[tid2] = {};
                var fieldIds = Object.keys(savedMeta.fields[tid2]);
                for (var f = 0; f < fieldIds.length; f++) {
                    META_FIELDS[tid2][fieldIds[f]] = savedMeta.fields[tid2][fieldIds[f]];
                }
            }
        }

        // Handle events format: replay the full event stream
        if (amoData.type === 'events' && amoData.events) {
            var events = amoData.events;
            if (events.length === 0) {
                console.warn('[BoxDownload] No events in file');
                hideLoadingOverlay();
                return false;
            }

            updateLoadingOverlay('Replaying events...', 'Processing ' + events.length.toLocaleString() + ' events...', 30, 0, 0, events.length, '');

            // Sort events by ID ascending for correct replay order
            events.sort(function(a, b) { return (a.id || 0) - (b.id || 0); });

            // Store raw events in IndexedDB
            updateLoadingOverlay('Storing events...', 'Saving ' + events.length.toLocaleString() + ' raw events...', 50, 0, 0, events.length, '');
            await saveRawEvents(events);

            // Replay events through processEvents to rebuild current state
            updateLoadingOverlay('Rebuilding state...', 'Replaying ' + events.length.toLocaleString() + ' events...', 65, 0, 0, events.length, '');
            await processEvents(events);

            // Set the last event timestamp for incremental sync
            if (events.length > 0) {
                var lastEvent = events[events.length - 1];
                if (lastEvent.created_at) {
                    lastEventTimestamp = lastEvent.created_at;
                    await setSyncMeta('lastEventTimestamp', lastEventTimestamp);
                }
            }

            var totalRecords = await getCurrentRecordsCount();
            updateLoadingOverlay('Hydration complete!', events.length.toLocaleString() + ' events replayed, ' + totalRecords.toLocaleString() + ' records', 100, 0, 0, totalRecords, '');
            setTimeout(hideLoadingOverlay, 300);

            console.log('[BoxDownload] Hydration complete: ' + events.length + ' events replayed, ' + totalRecords + ' records rebuilt');
            return true;
        }

        // Legacy snapshot format fallback
        if (amoData.type === 'snapshot' && amoData.tables) {
            var tableNames = Object.keys(amoData.tables);
            if (tableNames.length === 0) {
                console.warn('[BoxDownload] Snapshot contains no data');
                hideLoadingOverlay();
                return false;
            }

            updateLoadingOverlay('Importing snapshot...', 'Building tables and fields...', 40, tableNames.length, 0, 0, '');

            var batchTables = [];
            var batchFields = [];
            var batchData = [];
            var totalRecordCount = 0;
            var totalFieldCount = 0;

            for (var t = 0; t < tableNames.length; t++) {
                var fullTableName = tableNames[t];
                var tableId = fullTableName.replace('airtable:', '');
                var rows = amoData.tables[fullTableName];

                if (!META_TABLES[tableId]) {
                    META_TABLES[tableId] = { tableId: tableId, tableName: tableId, _placeholder: true };
                }
                batchTables.push(META_TABLES[tableId]);

                if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};

                for (var r = 0; r < rows.length; r++) {
                    var row = rows[r];
                    var recordId = row.record_id;
                    if (!recordId) continue;

                    var data = {};
                    var keys = Object.keys(row);
                    for (var k = 0; k < keys.length; k++) {
                        if (keys[k] !== 'record_id') {
                            data[keys[k]] = row[keys[k]];
                            if (!META_FIELDS[tableId][keys[k]]) {
                                META_FIELDS[tableId][keys[k]] = {
                                    tableId: tableId, fieldId: keys[k], fieldName: keys[k],
                                    fieldType: inferFieldType(row[keys[k]]), _placeholder: true
                                };
                                totalFieldCount++;
                            }
                        }
                    }

                    batchData.push({ tableId: tableId, recordId: recordId, fields: data });
                    totalRecordCount++;
                }
            }

            var fieldTableIds = Object.keys(META_FIELDS);
            for (var ft = 0; ft < fieldTableIds.length; ft++) {
                var fids = Object.keys(META_FIELDS[fieldTableIds[ft]]);
                for (var fi = 0; fi < fids.length; fi++) {
                    batchFields.push(META_FIELDS[fieldTableIds[ft]][fids[fi]]);
                }
            }

            updateLoadingOverlay('Saving to local storage...', 'Persisting ' + totalRecordCount.toLocaleString() + ' records...', 85, tableNames.length, totalFieldCount, totalRecordCount, '');
            await saveBatch(batchTables, batchFields, [], batchData);

            // Set lastEventTimestamp from snapshot so post-hydration sync only fetches the gap
            if (amoData.ts > 0) {
                var hydratedTimestamp = new Date(amoData.ts * 1000).toISOString();
                await setSyncMeta('lastEventTimestamp', hydratedTimestamp);
                console.log('[BoxDownload] Set lastEventTimestamp to ' + hydratedTimestamp + ' from hydrated file (ts=' + amoData.ts + ')');
            }

            updateLoadingOverlay('Hydration complete!', totalRecordCount.toLocaleString() + ' records from ' + tableNames.length + ' tables', 100, tableNames.length, totalFieldCount, totalRecordCount, '');
            setTimeout(hideLoadingOverlay, 300);

            console.log('[BoxDownload] Legacy hydration complete: ' + totalRecordCount + ' records across ' + tableNames.length + ' tables');
            return true;
        }

        console.warn('[BoxDownload] Unknown data format in .amo file');
        hideLoadingOverlay();
        return false;

    } catch (err) {
        console.error('[BoxDownload] Hydration failed:', err);
        hideLoadingOverlay();
        return false;
    }
}

// ============ Point in Time View ============

async function viewRecordAtPointInTime(eventId, recordId, set) {
    var overlay = document.getElementById('pit-modal-overlay');
    var body = document.getElementById('pit-modal-body');

    // Show loading state
    body.innerHTML = '<div class="pit-empty-state"><div class="loading-spinner"></div><h3>Replaying events...</h3><p>Building record state at event #' + eventId + '</p></div>';
    overlay.classList.add('open');

    try {
        // Get all events for this record up to the specified event ID
        var events = await getRawEventsByRecordId(recordId, eventId);

        if (events.length === 0) {
            body.innerHTML = '<div class="pit-empty-state"><h3>No events found</h3><p>Could not find any events for this record.</p></div>';
            return;
        }

        // Determine the table ID from the set
        var tableId = set ? set.replace('airtable:', '') : null;

        // Replay events to build the record state
        var recordState = {};
        var lastTimestamp = null;

        for (var e of events) {
            var payload = parsePayload(e.payload);
            if (!payload || !payload.fields) continue;

            var fields = payload.fields;

            // Default first ALT as INS if record state is empty and no INS exists
            if (Object.keys(recordState).length === 0 && !fields.INS && fields.ALT) {
                fields = { INS: fields.ALT, NUL: fields.NUL };
            }

            // Apply INS (insert)
            if (fields.INS) {
                Object.assign(recordState, fields.INS);
            }

            // Apply ALT (alter)
            if (fields.ALT) {
                Object.assign(recordState, fields.ALT);
            }

            // Apply SYN (sync)
            if (fields.SYN) {
                Object.assign(recordState, fields.SYN);
            }

            // Apply NUL (nullify)
            if (fields.NUL && Array.isArray(fields.NUL)) {
                fields.NUL.forEach(k => delete recordState[k]);
            }

            if (e.created_at) {
                lastTimestamp = e.created_at;
            }
        }

        // Update modal header
        var tableName = META_TABLES[tableId]?.tableName || tableId || 'Unknown Table';
        document.getElementById('pit-modal-title').textContent = tableName;
        document.getElementById('pit-modal-event-badge').textContent = 'Event #' + eventId;
        document.getElementById('pit-modal-timestamp').textContent = lastTimestamp ? formatTimestamp(new Date(lastTimestamp).getTime()) : '';

        // Render the record state
        var html = '<div class="pit-record-card">';
        html += '<div class="pit-record-header">';
        html += '<span class="pit-table-name">' + esc(tableName) + '</span>';
        html += '<span class="pit-record-id">' + esc(recordId) + '</span>';
        if (tableId && META_TABLES[tableId]) {
            html += '<button class="event-action-btn pit-go-to-table" onclick="goToRecordInTable(\'' + esc(tableId) + '\', \'' + esc(recordId) + '\')">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M6 3L11 8L6 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
            html += 'View Current Record';
            html += '</button>';
        }
        html += '</div>';

        html += '<div class="pit-record-fields">';

        var fieldIds = Object.keys(recordState);
        if (fieldIds.length === 0) {
            html += '<div class="pit-empty-state">No fields recorded at this point in time</div>';
        } else {
            // Sort fields by name
            var fieldsInfo = META_FIELDS[tableId] || {};
            fieldIds.sort((a, b) => {
                var nameA = (fieldsInfo[a]?.fieldName || a).toLowerCase();
                var nameB = (fieldsInfo[b]?.fieldName || b).toLowerCase();
                return nameA.localeCompare(nameB);
            });

            for (var fieldId of fieldIds) {
                var fieldName = fieldsInfo[fieldId]?.fieldName || fieldId;
                var value = recordState[fieldId];

                html += '<div class="pit-field-row">';
                html += '<div class="pit-field-name">' + esc(fieldName) + '</div>';
                html += '<div class="pit-field-value">' + formatHistoryValue(value) + '</div>';
                html += '</div>';
            }
        }

        html += '</div>'; // .pit-record-fields
        html += '</div>'; // .pit-record-card

        body.innerHTML = html;

    } catch (err) {
        console.error('Error viewing record at point in time:', err);
        body.innerHTML = '<div class="pit-empty-state"><h3>Error</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closePitModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('pit-modal-overlay').classList.remove('open');
}

function goToRecordInTable(tableId, recordId) {
    closePitModal();
    showTable(tableId);
    // Open the record profile after navigating
    setTimeout(function() {
        openRecordProfile(tableId, recordId);
    }, 100);
}

// ============ Record Profile Panel ============

var profileCurrentTableId = null;
var profileCurrentRecordId = null;
var profileConfigureMode = false;
var profileFieldPicker = null;

// Default profile configuration - one block with all visible fields in 2 columns
function getDefaultProfileConfig(tableId, viewId) {
    var visibleFields = getVisibleFieldsForView(tableId, viewId || '_default');
    return {
        blocks: [
            {
                id: 'block-1',
                columns: 2,
                fieldIds: visibleFields.slice()
            }
        ]
    };
}

// Get profile configuration for a view
// Returns { config: {...}, isDefault: boolean }
function getProfileConfig(tableId, viewId) {
    var view = META_VIEWS[tableId]?.[viewId || '_default'];
    if (view && view.profileConfig && view.profileConfig.blocks && view.profileConfig.blocks.length > 0) {
        return { config: view.profileConfig, isDefault: false };
    }
    return { config: getDefaultProfileConfig(tableId, viewId), isDefault: true };
}

// Save profile configuration for a view
async function saveProfileConfig(tableId, viewId, config) {
    viewId = viewId || '_default';
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId
        };
    }
    META_VIEWS[tableId][viewId].profileConfig = config;
    await saveView(META_VIEWS[tableId][viewId]);
}

// Open record profile panel
async function openRecordProfile(tableId, recordId, viewId) {
    profileCurrentTableId = tableId;
    profileCurrentRecordId = recordId;

    // Use current view if not specified
    if (!viewId && tableId === currentTable) {
        viewId = currentView;
    }

    var overlay = document.getElementById('record-profile-overlay');
    overlay.classList.add('open');

    // Update header
    var tableName = META_TABLES[tableId]?.tableName || tableId;
    document.getElementById('profile-title').textContent = tableName;

    // Show view name
    var actualViewId = viewId || currentView || '_default';
    var viewData = META_VIEWS[tableId]?.[actualViewId];
    var viewName = viewData?.viewName || (actualViewId === '_default' ? 'All Fields' : actualViewId);
    document.getElementById('profile-view-name').textContent = viewName;

    document.getElementById('profile-record-id').textContent = recordId;

    // Reset configure mode
    profileConfigureMode = false;
    document.getElementById('profile-body').classList.remove('configure-mode');
    document.getElementById('profile-add-block-btn').style.display = 'none';
    document.getElementById('profile-configure-btn').innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg> Configure';

    // Reset to details tab
    profileCurrentTab = 'details';
    document.querySelectorAll('.profile-tab').forEach(function(tab) {
        tab.classList.toggle('active', tab.dataset.tab === 'details');
    });
    document.getElementById('profile-tab-details').classList.add('active');
    document.getElementById('profile-tab-sync-history').classList.remove('active');

    // Render profile content
    await renderRecordProfile();

    // Update navigation
    updateProfileNavigation();
}

// Close record profile panel
function closeRecordProfile(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('record-profile-overlay').classList.remove('open');
    closeFieldPicker();
    profileCurrentTableId = null;
    profileCurrentRecordId = null;
}

// Render the record profile content
async function renderRecordProfile() {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var body = document.getElementById('profile-body');
    var viewId = currentView || '_default';

    // Get record data
    var records = await getRecordsByIds(profileCurrentTableId, [profileCurrentRecordId]);
    if (records.length === 0) {
        body.innerHTML = '<div class="profile-empty-state">Record not found</div>';
        return;
    }

    var record = records[0];
    var recordFields = record.fields || {};
    var fields = META_FIELDS[profileCurrentTableId] || {};

    // Get profile configuration
    var profileResult = getProfileConfig(profileCurrentTableId, viewId);
    var config = profileResult.config;
    var isDefaultConfig = profileResult.isDefault;

    var html = '';

    config.blocks.forEach(function(block, blockIndex) {
        html += '<div class="profile-block" data-block-index="' + blockIndex + '">';

        // Block header (visible in configure mode)
        html += '<div class="profile-block-header">';
        html += '<span class="block-drag-handle" draggable="true" ondragstart="handleBlockDragStart(event, ' + blockIndex + ')" ondragover="handleBlockDragOver(event)" ondrop="handleBlockDrop(event, ' + blockIndex + ')">&#8942;&#8942;</span>';
        html += '<span class="block-title">Block ' + (blockIndex + 1) + '</span>';
        html += '<select class="block-cols-select" onchange="setBlockColumns(' + blockIndex + ', this.value)">';
        html += '<option value="1"' + (block.columns === 1 ? ' selected' : '') + '>1 column</option>';
        html += '<option value="2"' + (block.columns === 2 ? ' selected' : '') + '>2 columns</option>';
        html += '<option value="3"' + (block.columns === 3 ? ' selected' : '') + '>3 columns</option>';
        html += '</select>';
        html += '<button class="block-remove-btn" onclick="removeProfileBlock(' + blockIndex + ')" title="Remove block">&times;</button>';
        html += '</div>';

        // Block content
        html += '<div class="profile-block-content">';
        html += '<div class="profile-field-grid cols-' + block.columns + '">';

        block.fieldIds.forEach(function(fieldId, fieldIndex) {
            var field = fields[fieldId];
            var fieldName = field?.fieldName || fieldId;
            var value = recordFields[fieldId];
            if (value === undefined) value = recordFields[fieldName];

            // Skip fields with no data when using default config and not in configure mode
            var isEmpty = value == null || value === '' || (Array.isArray(value) && value.length === 0);
            if (isEmpty && isDefaultConfig && !profileConfigureMode) {
                return; // Skip this field
            }

            html += '<div class="profile-field-card" data-field-id="' + esc(fieldId) + '" data-block-index="' + blockIndex + '" data-field-index="' + fieldIndex + '" draggable="true" ondragstart="handleFieldDragStart(event)" ondragover="handleFieldDragOver(event)" ondragleave="handleFieldDragLeave(event)" ondrop="handleFieldDrop(event)">';
            html += '<div class="profile-field-name">';
            html += '<span class="field-drag-handle">&#8942;&#8942;</span>';
            html += esc(fieldName);
            if (profileConfigureMode) {
                html += '<button style="margin-left: auto; background: none; border: none; color: #ccc; cursor: pointer; font-size: 12px;" onclick="removeFieldFromBlock(' + blockIndex + ', ' + fieldIndex + ')">&times;</button>';
            }
            html += '</div>';
            if (isEmpty) {
                html += '<div class="profile-field-value empty"></div>';
            } else {
                html += '<div class="profile-field-value">' + formatCell(value) + '</div>';
            }
            html += '</div>';
        });

        html += '</div>'; // .profile-field-grid

        // Add field button (visible in configure mode)
        html += '<button class="profile-add-field-btn" onclick="showFieldPicker(event, ' + blockIndex + ')">+ Add Field</button>';

        html += '</div>'; // .profile-block-content
        html += '</div>'; // .profile-block
    });

    body.innerHTML = html;

    // Maintain configure mode if active
    if (profileConfigureMode) {
        body.classList.add('configure-mode');
    }
}

// Toggle configure mode
function toggleProfileConfigureMode() {
    profileConfigureMode = !profileConfigureMode;
    var body = document.getElementById('profile-body');
    var addBlockBtn = document.getElementById('profile-add-block-btn');
    var configureBtn = document.getElementById('profile-configure-btn');

    if (profileConfigureMode) {
        body.classList.add('configure-mode');
        addBlockBtn.style.display = '';
        configureBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"/></svg> Done';
    } else {
        body.classList.remove('configure-mode');
        addBlockBtn.style.display = 'none';
        configureBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg> Configure';
        closeFieldPicker();
    }

    renderRecordProfile();
}

// Set block columns
async function setBlockColumns(blockIndex, columns) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].columns = parseInt(columns);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Add a new block
async function addProfileBlock() {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    config.blocks.push({
        id: 'block-' + (config.blocks.length + 1) + '-' + Date.now(),
        columns: 2,
        fieldIds: []
    });

    await saveProfileConfig(profileCurrentTableId, viewId, config);
    renderRecordProfile();
}

// Remove a block
async function removeProfileBlock(blockIndex) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks.length > 1) {
        config.blocks.splice(blockIndex, 1);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Show field picker dropdown
function showFieldPicker(event, blockIndex) {
    event.stopPropagation();
    closeFieldPicker();

    var fields = META_FIELDS[profileCurrentTableId] || {};
    var fieldIds = Object.keys(fields);

    var picker = document.createElement('div');
    picker.className = 'profile-field-picker';
    picker.innerHTML = '<div class="profile-field-picker-header">Add Field</div>';

    fieldIds.sort(function(a, b) {
        var nameA = (fields[a]?.fieldName || a).toLowerCase();
        var nameB = (fields[b]?.fieldName || b).toLowerCase();
        return nameA.localeCompare(nameB);
    });

    fieldIds.forEach(function(fieldId) {
        var field = fields[fieldId];
        var fieldName = field?.fieldName || fieldId;
        var fieldType = field?.fieldType || 'text';

        var item = document.createElement('div');
        item.className = 'profile-field-picker-item';
        item.innerHTML = '<span>' + esc(fieldName) + '</span><span class="field-type-badge">' + esc(fieldType) + '</span>';
        item.onclick = function() {
            addFieldToBlock(blockIndex, fieldId);
            closeFieldPicker();
        };
        picker.appendChild(item);
    });

    // Position the picker
    var rect = event.target.getBoundingClientRect();
    picker.style.left = rect.left + 'px';
    picker.style.top = (rect.bottom + 4) + 'px';

    document.body.appendChild(picker);
    profileFieldPicker = picker;

    // Close on outside click
    setTimeout(function() {
        document.addEventListener('click', closeFieldPickerOnOutsideClick);
    }, 0);
}

function closeFieldPickerOnOutsideClick(event) {
    if (profileFieldPicker && !profileFieldPicker.contains(event.target)) {
        closeFieldPicker();
    }
}

function closeFieldPicker() {
    if (profileFieldPicker) {
        profileFieldPicker.remove();
        profileFieldPicker = null;
        document.removeEventListener('click', closeFieldPickerOnOutsideClick);
    }
}

// Add field to a block
async function addFieldToBlock(blockIndex, fieldId) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].fieldIds.push(fieldId);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Remove field from a block
async function removeFieldFromBlock(blockIndex, fieldIndex) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].fieldIds.splice(fieldIndex, 1);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Field drag and drop
var profileDragData = null;

function handleFieldDragStart(event) {
    if (!profileConfigureMode) {
        event.preventDefault();
        return;
    }
    var card = event.target.closest('.profile-field-card');
    profileDragData = {
        type: 'field',
        blockIndex: parseInt(card.dataset.blockIndex),
        fieldIndex: parseInt(card.dataset.fieldIndex),
        fieldId: card.dataset.fieldId
    };
    card.classList.add('dragging');
    event.dataTransfer.effectAllowed = 'move';
}

function handleFieldDragOver(event) {
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'field') return;
    event.preventDefault();
    var card = event.target.closest('.profile-field-card');
    if (card) {
        card.classList.add('drag-over');
    }
}

function handleFieldDragLeave(event) {
    var card = event.target.closest('.profile-field-card');
    if (card) {
        card.classList.remove('drag-over');
    }
}

async function handleFieldDrop(event) {
    event.preventDefault();
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'field') return;

    var targetCard = event.target.closest('.profile-field-card');
    if (!targetCard) return;

    var targetBlockIndex = parseInt(targetCard.dataset.blockIndex);
    var targetFieldIndex = parseInt(targetCard.dataset.fieldIndex);

    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    // Remove from source
    var fieldId = config.blocks[profileDragData.blockIndex].fieldIds.splice(profileDragData.fieldIndex, 1)[0];

    // Adjust target index if in same block and after source
    if (targetBlockIndex === profileDragData.blockIndex && targetFieldIndex > profileDragData.fieldIndex) {
        targetFieldIndex--;
    }

    // Insert at target
    config.blocks[targetBlockIndex].fieldIds.splice(targetFieldIndex, 0, fieldId);

    await saveProfileConfig(profileCurrentTableId, viewId, config);

    profileDragData = null;
    renderRecordProfile();
}

// Block drag and drop
function handleBlockDragStart(event, blockIndex) {
    if (!profileConfigureMode) {
        event.preventDefault();
        return;
    }
    profileDragData = {
        type: 'block',
        blockIndex: blockIndex
    };
    event.dataTransfer.effectAllowed = 'move';
}

function handleBlockDragOver(event) {
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'block') return;
    event.preventDefault();
}

async function handleBlockDrop(event, targetBlockIndex) {
    event.preventDefault();
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'block') return;

    if (targetBlockIndex === profileDragData.blockIndex) return;

    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    // Remove from source
    var block = config.blocks.splice(profileDragData.blockIndex, 1)[0];

    // Adjust target index if after source
    if (targetBlockIndex > profileDragData.blockIndex) {
        targetBlockIndex--;
    }

    // Insert at target
    config.blocks.splice(targetBlockIndex, 0, block);

    await saveProfileConfig(profileCurrentTableId, viewId, config);

    profileDragData = null;
    renderRecordProfile();
}

// Navigation between records
function updateProfileNavigation() {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var recordIndex = currentRecordIds.indexOf(profileCurrentRecordId);
    var total = currentRecordIds.length;

    document.getElementById('profile-nav-info').textContent = (recordIndex + 1) + ' of ' + total;
    document.getElementById('profile-prev-btn').disabled = recordIndex <= 0;
    document.getElementById('profile-next-btn').disabled = recordIndex >= total - 1;
}

async function navigateProfile(direction) {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var recordIndex = currentRecordIds.indexOf(profileCurrentRecordId);
    var newIndex = recordIndex + direction;

    if (newIndex >= 0 && newIndex < currentRecordIds.length) {
        profileCurrentRecordId = currentRecordIds[newIndex];
        document.getElementById('profile-record-id').textContent = profileCurrentRecordId;
        await renderRecordProfile();
        updateProfileNavigation();

        // Refresh sync history if that tab is active
        if (profileCurrentTab === 'sync-history') {
            renderProfileSyncHistory();
        }
    }
}

// Open history from profile
function openHistoryFromProfile() {
    if (profileCurrentTableId && profileCurrentRecordId) {
        openHistoryModal(profileCurrentTableId, profileCurrentRecordId);
    }
}

// Profile tab state
var profileCurrentTab = 'details';

// Switch profile tab
function switchProfileTab(tabName) {
    profileCurrentTab = tabName;

    // Update tab buttons
    document.querySelectorAll('.profile-tab').forEach(function(tab) {
        if (tab.dataset.tab === tabName) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // Update tab content
    document.querySelectorAll('.profile-tab-content').forEach(function(content) {
        content.classList.remove('active');
    });

    if (tabName === 'details') {
        document.getElementById('profile-tab-details').classList.add('active');
    } else if (tabName === 'sync-history') {
        document.getElementById('profile-tab-sync-history').classList.add('active');
        renderProfileSyncHistory();
    }
}

// Build field history entries from raw events (used for in-memory events from CSV)
function buildFieldHistoryFromRawEvents(tableId, recordId, events) {
    // Sort events by id ascending (oldest first for proper state tracking)
    var sorted = events.slice().sort((a, b) => (a.id || 0) - (b.id || 0));

    var state = {};
    var fieldHistoryEntries = [];

    for (var e of sorted) {
        if (!e || !e.recordId || e.recordId !== recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var pfields = payload.fields;
        if (!pfields || typeof pfields !== 'object') continue;

        var eventId = e.id;
        var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

        // Process INS (insert/create)
        if (pfields.INS) {
            for (var fieldId in pfields.INS) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'created',
                    oldValue: null,
                    newValue: pfields.INS[fieldId]
                });
            }
            Object.assign(state, pfields.INS);
        }

        // Process ALT (alter/update)
        if (pfields.ALT) {
            for (var fieldId in pfields.ALT) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'updated',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: pfields.ALT[fieldId]
                });
            }
            Object.assign(state, pfields.ALT);
        }

        // Process SYN (sync/snapshot)
        if (pfields.SYN) {
            for (var fieldId in pfields.SYN) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'synced',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: pfields.SYN[fieldId]
                });
            }
            Object.assign(state, pfields.SYN);
        }

        // Process NUL (nullify/delete)
        if (pfields.NUL && Array.isArray(pfields.NUL)) {
            pfields.NUL.forEach(fieldId => {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'deleted',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: null
                });
                delete state[fieldId];
            });
        }
    }

    // Return sorted by eventId descending (most recent first) for display
    return fieldHistoryEntries.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
}

// Render sync history in the profile tab
async function renderProfileSyncHistory() {
    var container = document.getElementById('profile-tab-sync-history');
    if (!profileCurrentTableId || !profileCurrentRecordId) {
        container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No record selected</h3><p>Select a record to view its sync history</p></div>';
        return;
    }

    // Show loading state
    container.innerHTML = '<div class="profile-sync-history-empty"><div class="loading-spinner"></div><h3>Loading sync history...</h3></div>';

    try {
        var history;

        // Check if we have in-memory events (from CSV import) - use them for instant display
        if (inMemoryEventsByRecord && inMemoryEventsByRecord.has(profileCurrentRecordId)) {
            var rawEvents = inMemoryEventsByRecord.get(profileCurrentRecordId);
            history = buildFieldHistoryFromRawEvents(profileCurrentTableId, profileCurrentRecordId, rawEvents);
            // Limit to 100 most recent entries
            if (history.length > 100) {
                history = history.slice(0, 100);
            }
        } else {
            // Fall back to API + IndexedDB when no in-memory events
            await fetchAndProcessHistoryForRecord(profileCurrentTableId, profileCurrentRecordId);
            // Get history from IndexedDB
            history = await getFieldHistoryForRecord(profileCurrentTableId, profileCurrentRecordId, 100);
        }

        if (!history || history.length === 0) {
            container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No sync history available for this record</h3><p>Field changes will appear here after syncing</p></div>';
            return;
        }

        // Get field metadata
        var fields = META_FIELDS[profileCurrentTableId] || {};

        // Render history items
        var html = '<div class="profile-sync-history-list">';

        history.forEach(function(item) {
            var fieldName = fields[item.fieldId]?.fieldName || item.fieldId;
            var changeType = item.changeType || 'updated';
            var timestamp = item.timestamp ? new Date(item.timestamp).toLocaleString() : 'Unknown';

            html += '<div class="profile-sync-history-item">';
            html += '<div class="profile-sync-history-item-header">';
            html += '<span class="profile-sync-history-field">' + esc(fieldName) + '</span>';
            html += '<span class="profile-sync-history-type ' + changeType + '">' + changeType.charAt(0).toUpperCase() + changeType.slice(1) + '</span>';
            html += '<span class="profile-sync-history-time">' + esc(timestamp) + '</span>';
            html += '</div>';

            if (changeType !== 'created' || item.oldValue != null) {
                html += '<div class="profile-sync-history-values">';
                if (item.oldValue != null) {
                    html += '<div class="profile-sync-history-value old">';
                    html += '<div class="profile-sync-history-value-label">Old</div>';
                    html += formatHistoryValue(item.oldValue);
                    html += '</div>';
                }
                if (item.newValue != null) {
                    html += '<div class="profile-sync-history-value new">';
                    html += '<div class="profile-sync-history-value-label">New</div>';
                    html += formatHistoryValue(item.newValue);
                    html += '</div>';
                }
                html += '</div>';
            } else if (item.newValue != null) {
                html += '<div class="profile-sync-history-values">';
                html += '<div class="profile-sync-history-value new">';
                html += '<div class="profile-sync-history-value-label">Value</div>';
                html += formatHistoryValue(item.newValue);
                html += '</div>';
                html += '</div>';
            }

            html += '</div>';
        });

        html += '</div>';
        container.innerHTML = html;

    } catch (err) {
        console.error('Error loading sync history:', err);
        container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>Error loading sync history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Format history value for display
function formatHistoryValue(value) {
    if (value == null) return '<em>empty</em>';
    if (typeof value === 'object') {
        return esc(JSON.stringify(value));
    }
    return esc(String(value));
}

// Handle row click to open profile
function handleRowClick(event, tableId, recordId) {
    // Don't open profile if clicking on a button, link, or interactive element
    if (event.target.closest('button, a, input, select, textarea')) {
        return;
    }
    openRecordProfile(tableId, recordId);
}

// Keyboard navigation for profile
document.addEventListener('keydown', function(e) {
    var overlay = document.getElementById('record-profile-overlay');
    if (!overlay.classList.contains('open')) return;

    if (e.key === 'Escape') {
        closeRecordProfile();
    } else if (e.key === 'ArrowLeft' && !e.target.matches('input, textarea, select')) {
        navigateProfile(-1);
    } else if (e.key === 'ArrowRight' && !e.target.matches('input, textarea, select')) {
        navigateProfile(1);
    }
});

// ============ View Selector & Fields Dropdown UI ============

// Toggle view selector dropdown
function toggleViewSelector() {
    var dropdown = document.getElementById('view-selector-dropdown');
    var fieldsDropdown = document.getElementById('fields-dropdown');

    // Close fields dropdown if open
    fieldsDropdown.classList.remove('open');

    dropdown.classList.toggle('open');
}

// Toggle fields dropdown
function toggleFieldsDropdown() {
    var dropdown = document.getElementById('fields-dropdown');
    var viewDropdown = document.getElementById('view-selector-dropdown');

    // Close view dropdown if open
    viewDropdown.classList.remove('open');

    dropdown.classList.toggle('open');

    // Focus search input and clear it when opening
    if (dropdown.classList.contains('open')) {
        var searchInput = document.getElementById('fields-search-input');
        if (searchInput) {
            searchInput.value = '';
            filterFieldsDropdown('');
            setTimeout(function() { searchInput.focus(); }, 50);
        }
    }
}

// Close all dropdowns
function closeAllDropdowns() {
    document.getElementById('view-selector-dropdown')?.classList.remove('open');
    document.getElementById('fields-dropdown')?.classList.remove('open');
}

// Click outside handler to close dropdowns
document.addEventListener('click', function(e) {
    var viewSelector = document.getElementById('view-selector-container');
    var fieldsBtn = document.getElementById('fields-btn');
    var fieldsDropdown = document.getElementById('fields-dropdown');

    // Close view selector if clicked outside
    if (viewSelector && !viewSelector.contains(e.target)) {
        document.getElementById('view-selector-dropdown')?.classList.remove('open');
    }

    // Close fields dropdown if clicked outside
    if (fieldsBtn && fieldsDropdown && !fieldsBtn.contains(e.target) && !fieldsDropdown.contains(e.target)) {
        fieldsDropdown.classList.remove('open');
    }
});

// Get view type icon
function getViewTypeIcon(viewType) {
    switch ((viewType || '').toLowerCase()) {
        case 'grid': return '&#9638;';
        case 'gallery': return '&#128444;';
        case 'kanban': return '&#9636;';
        case 'calendar': return '&#128197;';
        case 'timeline': return '&#8594;';
        case 'form': return '&#128196;';
        default: return '&#9638;';
    }
}

// Render view selector dropdown
function renderViewSelector() {
    if (!currentTable) return;

    var dropdown = document.getElementById('view-selector-dropdown');
    var currentViewIcon = document.getElementById('current-view-icon');
    var currentViewName = document.getElementById('current-view-name');

    var views = META_VIEWS[currentTable] || {};
    var viewIds = Object.keys(views);

    // Update current view display
    var viewId = currentView || '_default';
    var currentViewObj = views[viewId];
    if (currentViewObj) {
        currentViewIcon.innerHTML = getViewTypeIcon(currentViewObj.viewType);
        currentViewName.textContent = currentViewObj.viewName || viewId;
    } else {
        currentViewIcon.innerHTML = '&#9638;';
        currentViewName.textContent = 'All Fields';
    }

    // Build dropdown
    var html = '<div class="view-selector-dropdown-header">Views</div>';

    // Add "All Fields" default option
    var isDefaultActive = !currentView || currentView === '_default';
    html += '<div class="view-selector-option' + (isDefaultActive ? ' active' : '') + '" onclick="selectView(\'_default\')">';
    html += '<span class="view-type-icon">&#9638;</span>';
    html += '<span class="view-option-name">All Fields</span>';
    if (isDefaultActive) html += '<span class="view-check">&#10003;</span>';
    html += '</div>';

    // Add existing views
    for (var vid of viewIds) {
        if (vid === '_default') continue;
        var view = views[vid];
        var isActive = currentView === vid;
        html += '<div class="view-selector-option' + (isActive ? ' active' : '') + '" onclick="selectView(\'' + esc(vid) + '\')">';
        html += '<span class="view-type-icon">' + getViewTypeIcon(view.viewType) + '</span>';
        html += '<span class="view-option-name">' + esc(view.viewName || vid) + '</span>';
        if (isActive) html += '<span class="view-check">&#10003;</span>';
        html += '</div>';
    }

    // Add "Create New View" option at bottom
    html += '<div style="border-top: 1px solid #eee; margin-top: 4px; padding-top: 4px;"></div>';
    html += '<div class="view-selector-option" onclick="openCreateViewModal()" style="color: #2d6cdf;">';
    html += '<span class="view-type-icon">+</span>';
    html += '<span class="view-option-name">Create New View</span>';
    html += '</div>';

    dropdown.innerHTML = html;
}

// Select a view
async function selectView(viewId) {
    // Auto-save any pending changes before switching views
    await autoSaveBeforeNavigation();

    currentView = viewId;
    closeAllDropdowns();

    // Load and apply view filters, sorts, and groupBy for the new view
    if (currentTable) {
        var viewConfig = getViewFiltersAndSorts(currentTable, viewId);
        currentFilters = viewConfig.filters;
        currentSorts = viewConfig.sorts;
        currentGroupBy = viewConfig.groupBy;
        updateFilterCount();
        updateSortCount();
        updateGroupButtonState();
    }

    // Update sidebar to reflect the new active view
    if (currentTable) {
        updateSidebarViewActive(currentTable, viewId);
    }

    // Render view selector to update current view display
    renderViewSelector();

    // Render fields dropdown for new view
    renderFieldsDropdown();
    updateFieldsCount();

    // Re-render table with new view's field configuration
    await renderTable();
}

// Render fields dropdown
function renderFieldsDropdown() {
    if (!currentTable) return;

    var list = document.getElementById('fields-dropdown-list');
    var fields = META_FIELDS[currentTable] || {};
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);
    var hiddenSet = new Set(config.hiddenFieldIds || []);

    // Get all fields in order
    var allFieldIds = getAllFieldsInOrder(currentTable, viewId);

    var html = '';
    for (var i = 0; i < allFieldIds.length; i++) {
        var fid = allFieldIds[i];
        var field = fields[fid];
        if (!field) continue;

        var isVisible = !hiddenSet.has(fid);
        var fieldName = field.fieldName || fid;
        var fieldType = field.fieldType || 'unknown';

        html += '<div class="fields-dropdown-item" data-field-id="' + esc(fid) + '" draggable="true">';

        // Drag handle
        html += '<span class="field-drag-handle" title="Drag to reorder">&#9776;</span>';

        // Checkbox
        html += '<div class="field-checkbox' + (isVisible ? ' checked' : '') + '" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<span class="check-icon">&#10003;</span>';
        html += '</div>';

        // Field info
        html += '<div class="field-info" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<div class="field-name">' + esc(fieldName) + '</div>';
        html += '<div class="field-type">' + esc(fieldType) + '</div>';
        html += '</div>';

        // Move buttons
        html += '<div class="field-move-btns">';
        if (i > 0) {
            html += '<button class="field-move-btn" onclick="moveFieldUp(\'' + esc(fid) + '\')" title="Move up">&#9650;</button>';
        } else {
            html += '<button class="field-move-btn" disabled style="opacity: 0.3;">&#9650;</button>';
        }
        if (i < allFieldIds.length - 1) {
            html += '<button class="field-move-btn" onclick="moveFieldDown(\'' + esc(fid) + '\')" title="Move down">&#9660;</button>';
        } else {
            html += '<button class="field-move-btn" disabled style="opacity: 0.3;">&#9660;</button>';
        }
        html += '</div>';

        html += '</div>';
    }

    list.innerHTML = html;
    initFieldsDropdownDrag();

    // Preserve search filter if active
    var searchInput = document.getElementById('fields-search-input');
    if (searchInput && searchInput.value) {
        filterFieldsDropdown(searchInput.value);
    }
}

// Update visible fields count badge
function updateFieldsCount() {
    if (!currentTable) return;

    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);
    var fields = META_FIELDS[currentTable] || {};
    var totalFields = Object.keys(fields).length;
    var hiddenCount = (config.hiddenFieldIds || []).length;
    var visibleCount = totalFields - hiddenCount;

    var countEl = document.getElementById('fields-visible-count');
    if (countEl) {
        countEl.textContent = visibleCount + '/' + totalFields;
    }
}

// Filter fields dropdown by search query
function filterFieldsDropdown(query) {
    var list = document.getElementById('fields-dropdown-list');
    if (!list) return;
    var items = list.querySelectorAll('.fields-dropdown-item');
    var lowerQuery = (query || '').toLowerCase().trim();

    for (var i = 0; i < items.length; i++) {
        var nameEl = items[i].querySelector('.field-name');
        var name = nameEl ? nameEl.textContent.toLowerCase() : '';
        if (!lowerQuery || name.indexOf(lowerQuery) >= 0) {
            items[i].style.display = '';
        } else {
            items[i].style.display = 'none';
        }
    }
}

// --- Drag-to-reorder for fields dropdown ---
var draggedFieldItem = null;
var draggedFieldId = null;

function initFieldsDropdownDrag() {
    var list = document.getElementById('fields-dropdown-list');
    if (!list) return;

    list.addEventListener('dragstart', function(e) {
        var item = e.target.closest('.fields-dropdown-item');
        if (!item) return;
        draggedFieldItem = item;
        draggedFieldId = item.dataset.fieldId;
        item.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', draggedFieldId);
    });

    list.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        var item = e.target.closest('.fields-dropdown-item');
        if (!item || item === draggedFieldItem) return;

        // Clear previous indicators
        list.querySelectorAll('.drag-over-above, .drag-over-below').forEach(function(el) {
            el.classList.remove('drag-over-above', 'drag-over-below');
        });

        // Determine if above or below midpoint
        var rect = item.getBoundingClientRect();
        var midY = rect.top + rect.height / 2;
        if (e.clientY < midY) {
            item.classList.add('drag-over-above');
        } else {
            item.classList.add('drag-over-below');
        }
    });

    list.addEventListener('dragleave', function(e) {
        var item = e.target.closest('.fields-dropdown-item');
        if (item) {
            item.classList.remove('drag-over-above', 'drag-over-below');
        }
    });

    list.addEventListener('dragend', function() {
        list.querySelectorAll('.dragging, .drag-over-above, .drag-over-below').forEach(function(el) {
            el.classList.remove('dragging', 'drag-over-above', 'drag-over-below');
        });
        draggedFieldItem = null;
        draggedFieldId = null;
    });

    list.addEventListener('drop', function(e) {
        e.preventDefault();

        var item = e.target.closest('.fields-dropdown-item');
        if (!item || !draggedFieldId) return;

        var targetFieldId = item.dataset.fieldId;
        if (targetFieldId === draggedFieldId) return;

        // Determine insert position based on drop location
        var rect = item.getBoundingClientRect();
        var midY = rect.top + rect.height / 2;
        var insertAfter = e.clientY >= midY;

        // Perform reorder
        if (!currentTable) return;
        var viewId = currentView || '_default';
        var config = getViewFieldConfig(currentTable, viewId);

        var fromIdx = config.fieldOrder.indexOf(draggedFieldId);
        var toIdx = config.fieldOrder.indexOf(targetFieldId);
        if (fromIdx < 0 || toIdx < 0) return;

        // Remove from old position
        config.fieldOrder.splice(fromIdx, 1);

        // Recalculate target index after removal
        var newToIdx = config.fieldOrder.indexOf(targetFieldId);
        var insertIdx = insertAfter ? newToIdx + 1 : newToIdx;
        config.fieldOrder.splice(insertIdx, 0, draggedFieldId);

        // Move column in table DOM
        moveColumnInDOM(fromIdx, insertIdx);

        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();

        // Restore search filter if active
        var searchInput = document.getElementById('fields-search-input');
        if (searchInput && searchInput.value) {
            filterFieldsDropdown(searchInput.value);
        }
    });
}

function esc(s) {
    if (s == null) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ============ View Controls (Filter, Sort, Group, etc.) ============

var currentFilters = [];
var currentSorts = [];
var currentGroupBy = null;
var currentColorBy = null;
var currentRowHeight = 'medium';
var currentSearchQuery = '';

// Original unfiltered/unsorted record IDs
var originalRecordIds = [];

// Get cell value from a record for filtering/sorting
function getCellValue(record, fieldId) {
    if (!record || !record.fields) return null;
    var value = record.fields[fieldId];
    if (value === undefined) {
        // Try field name lookup
        var fields = META_FIELDS[currentTable] || {};
        var fieldName = fields[fieldId]?.fieldName;
        if (fieldName) value = record.fields[fieldName];
    }
    return value;
}

// Convert value to string for comparison
function valueToString(value) {
    if (value == null) return '';
    if (Array.isArray(value)) {
        return value.map(v => {
            if (typeof v === 'object' && v !== null) {
                return v.name || v.filename || v.email || v.id || JSON.stringify(v);
            }
            return String(v);
        }).join(' ');
    }
    if (typeof value === 'object') {
        return value.name || value.filename || value.email || value.url || JSON.stringify(value);
    }
    return String(value);
}

// Check if a record matches a single filter
function matchesFilter(record, filter) {
    var value = getCellValue(record, filter.fieldId);
    var strValue = valueToString(value).toLowerCase();
    var filterValue = (filter.value || '').toLowerCase();

    switch (filter.operator) {
        case 'contains':
            return strValue.includes(filterValue);
        case 'equals':
            return strValue === filterValue;
        case 'not_equals':
            return strValue !== filterValue;
        case 'is_empty':
            return value == null || value === '' || (Array.isArray(value) && value.length === 0);
        case 'is_not_empty':
            return value != null && value !== '' && !(Array.isArray(value) && value.length === 0);
        default:
            return true;
    }
}

// Check if a record matches search query
function matchesSearch(record, query) {
    if (!query) return true;
    var fields = record.fields || {};
    for (var key in fields) {
        var strValue = valueToString(fields[key]).toLowerCase();
        if (strValue.includes(query)) return true;
    }
    return false;
}

// Compare two values for sorting
function compareValues(a, b, direction) {
    // Handle nulls
    if (a == null && b == null) return 0;
    if (a == null) return direction === 'asc' ? -1 : 1;
    if (b == null) return direction === 'asc' ? 1 : -1;

    // Convert to strings for comparison
    var strA = valueToString(a).toLowerCase();
    var strB = valueToString(b).toLowerCase();

    // Try numeric comparison
    var numA = parseFloat(strA);
    var numB = parseFloat(strB);
    if (!isNaN(numA) && !isNaN(numB)) {
        var result = numA - numB;
        return direction === 'asc' ? result : -result;
    }

    // String comparison
    var result = strA.localeCompare(strB);
    return direction === 'asc' ? result : -result;
}

// Apply all filters, search, and sorts to get filtered record IDs
async function getFilteredSortedRecords() {
    if (!currentTable) return [];

    // Fetch all records for the table
    var allRecords = await getRecordsByIds(currentTable, originalRecordIds);

    // Build record map
    var recordsById = {};
    allRecords.forEach(r => {
        recordsById[r.recordId] = r;
    });

    // Start with original order
    var filteredIds = originalRecordIds.slice();

    // Apply search filter
    if (currentSearchQuery) {
        filteredIds = filteredIds.filter(id => {
            var record = recordsById[id];
            return record && matchesSearch(record, currentSearchQuery);
        });
    }

    // Apply custom filters
    if (currentFilters.length > 0) {
        filteredIds = filteredIds.filter(id => {
            var record = recordsById[id];
            if (!record) return false;
            return currentFilters.every(filter => matchesFilter(record, filter));
        });
    }

    // Apply sorts
    if (currentSorts.length > 0) {
        filteredIds.sort((idA, idB) => {
            var recordA = recordsById[idA];
            var recordB = recordsById[idB];

            for (var i = 0; i < currentSorts.length; i++) {
                var sort = currentSorts[i];
                var valueA = getCellValue(recordA, sort.fieldId);
                var valueB = getCellValue(recordB, sort.fieldId);
                var cmp = compareValues(valueA, valueB, sort.direction);
                if (cmp !== 0) return cmp;
            }
            return 0;
        });
    }

    return filteredIds;
}

// Close all view control dropdowns
function closeViewControlDropdowns() {
    document.querySelectorAll('.view-control-dropdown').forEach(d => d.classList.remove('open'));
}

// Toggle filter dropdown
function toggleFilterDropdown() {
    var dropdown = document.getElementById('filter-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        filterDropdownSearch = '';
        var searchInput = document.getElementById('filter-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderFilterDropdown();
    }
}

// Toggle sort dropdown
function toggleSortDropdown() {
    var dropdown = document.getElementById('sort-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        sortDropdownSearch = '';
        var searchInput = document.getElementById('sort-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderSortDropdown();
    }
}

// Toggle group dropdown
function toggleGroupDropdown() {
    var dropdown = document.getElementById('group-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        groupDropdownSearch = '';
        var searchInput = document.getElementById('group-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderGroupDropdown();
    }
}

// Toggle color dropdown
function toggleColorDropdown() {
    var dropdown = document.getElementById('color-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        var searchInput = document.getElementById('color-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderColorDropdown();
    }
}

// Toggle row height dropdown
function toggleRowHeightDropdown() {
    var dropdown = document.getElementById('row-height-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        updateRowHeightDropdown();
    }
}

// Get sorted fields for dropdown: alphabetical, with selected/used fields at top
function getSortedFieldsForDropdown(fields, usedFieldIds, filterText) {
    var filter = (filterText || '').toLowerCase().trim();
    var fieldArray = [];

    for (var fid in fields) {
        var field = fields[fid];
        var fieldName = field.fieldName || fid;

        // Filter by search text
        if (filter && !fieldName.toLowerCase().includes(filter)) {
            continue;
        }

        fieldArray.push({
            fieldId: fid,
            fieldName: fieldName,
            isUsed: usedFieldIds.indexOf(fid) !== -1
        });
    }

    // Sort: used fields first, then alphabetically
    fieldArray.sort(function(a, b) {
        if (a.isUsed !== b.isUsed) {
            return a.isUsed ? -1 : 1;
        }
        return a.fieldName.localeCompare(b.fieldName);
    });

    return fieldArray;
}

// Current search state for dropdowns
var filterDropdownSearch = '';
var sortDropdownSearch = '';
var groupDropdownSearch = '';

// Render filter dropdown
function renderFilterDropdown(filterText) {
    if (!currentTable) return;
    var list = document.getElementById('filter-list');

    if (filterText !== undefined) {
        filterDropdownSearch = filterText;
    }

    if (currentFilters.length === 0) {
        list.innerHTML = '<div class="empty-filters">No filters applied</div>';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};

    // Get used field IDs from current filters
    var usedFieldIds = currentFilters.map(function(f) { return f.fieldId; });
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filterDropdownSearch);

    var html = '';

    for (var i = 0; i < currentFilters.length; i++) {
        var filter = currentFilters[i];
        html += '<div class="filter-row">';
        html += '<select onchange="updateFilter(' + i + ', \'field\', this.value)">';

        // Add sorted fields to dropdown, ensuring selected field is always included
        var selectedInList = false;
        for (var j = 0; j < sortedFields.length; j++) {
            var sf = sortedFields[j];
            var sel = filter.fieldId === sf.fieldId ? ' selected' : '';
            if (sel) selectedInList = true;
            html += '<option value="' + esc(sf.fieldId) + '"' + sel + '>' + esc(sf.fieldName) + '</option>';
        }
        // If selected field was filtered out, still include it
        if (!selectedInList && fields[filter.fieldId]) {
            var selField = fields[filter.fieldId];
            html += '<option value="' + esc(filter.fieldId) + '" selected>' + esc(selField.fieldName || filter.fieldId) + '</option>';
        }

        html += '</select>';
        html += '<select onchange="updateFilter(' + i + ', \'operator\', this.value)">';
        html += '<option value="contains"' + (filter.operator === 'contains' ? ' selected' : '') + '>contains</option>';
        html += '<option value="equals"' + (filter.operator === 'equals' ? ' selected' : '') + '>equals</option>';
        html += '<option value="not_equals"' + (filter.operator === 'not_equals' ? ' selected' : '') + '>does not equal</option>';
        html += '<option value="is_empty"' + (filter.operator === 'is_empty' ? ' selected' : '') + '>is empty</option>';
        html += '<option value="is_not_empty"' + (filter.operator === 'is_not_empty' ? ' selected' : '') + '>is not empty</option>';
        html += '</select>';
        if (filter.operator !== 'is_empty' && filter.operator !== 'is_not_empty') {
            html += '<input type="text" value="' + esc(filter.value || '') + '" onchange="updateFilter(' + i + ', \'value\', this.value)" placeholder="Value">';
        }
        html += '<button class="filter-remove-btn" onclick="removeFilter(' + i + ')" title="Remove">&times;</button>';
        html += '</div>';
    }

    list.innerHTML = html;
    updateFilterCount();
}

// Filter filter dropdown based on search input
function filterFilterDropdown(filterText) {
    renderFilterDropdown(filterText);
}

// Add filter
function addFilter() {
    if (!currentTable) return;
    var fields = META_FIELDS[currentTable] || {};
    // Get sorted fields (alphabetically)
    var sortedFields = getSortedFieldsForDropdown(fields, [], '');
    var firstFieldId = sortedFields.length > 0 ? sortedFields[0].fieldId : null;
    if (!firstFieldId) return;

    currentFilters.push({
        fieldId: firstFieldId,
        operator: 'contains',
        value: ''
    });
    renderFilterDropdown();
    applyFilters();
}

// Update filter
function updateFilter(index, prop, value) {
    if (currentFilters[index]) {
        currentFilters[index][prop] = value;
        renderFilterDropdown();
        applyFilters();
    }
}

// Remove filter
function removeFilter(index) {
    currentFilters.splice(index, 1);
    renderFilterDropdown();
    applyFilters();
}

// Update filter count badge
function updateFilterCount() {
    var countEl = document.getElementById('filter-count');
    var btn = document.getElementById('filter-btn');
    if (currentFilters.length > 0) {
        countEl.textContent = currentFilters.length;
        countEl.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        countEl.style.display = 'none';
        btn.classList.remove('active');
    }
}

// Apply filters (re-render table)
async function applyFilters() {
    updateFilterCount();
    await renderTable();
    // Save filters to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('filters', currentFilters);
    }
}

// Render sort dropdown
function renderSortDropdown(filterText) {
    if (!currentTable) return;
    var list = document.getElementById('sort-list');

    if (filterText !== undefined) {
        sortDropdownSearch = filterText;
    }

    if (currentSorts.length === 0) {
        list.innerHTML = '<div class="empty-sorts">No sorts applied</div>';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};

    // Get used field IDs from current sorts
    var usedFieldIds = currentSorts.map(function(s) { return s.fieldId; });
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, sortDropdownSearch);

    var html = '';

    for (var i = 0; i < currentSorts.length; i++) {
        var sort = currentSorts[i];
        html += '<div class="sort-row">';
        html += '<select onchange="updateSort(' + i + ', \'field\', this.value)">';

        // Add sorted fields to dropdown, ensuring selected field is always included
        var selectedInList = false;
        for (var j = 0; j < sortedFields.length; j++) {
            var sf = sortedFields[j];
            var sel = sort.fieldId === sf.fieldId ? ' selected' : '';
            if (sel) selectedInList = true;
            html += '<option value="' + esc(sf.fieldId) + '"' + sel + '>' + esc(sf.fieldName) + '</option>';
        }
        // If selected field was filtered out, still include it
        if (!selectedInList && fields[sort.fieldId]) {
            var selField = fields[sort.fieldId];
            html += '<option value="' + esc(sort.fieldId) + '" selected>' + esc(selField.fieldName || sort.fieldId) + '</option>';
        }

        html += '</select>';
        html += '<div class="sort-direction-btns">';
        html += '<button class="sort-direction-btn' + (sort.direction === 'asc' ? ' active' : '') + '" onclick="updateSort(' + i + ', \'direction\', \'asc\')">AZ</button>';
        html += '<button class="sort-direction-btn' + (sort.direction === 'desc' ? ' active' : '') + '" onclick="updateSort(' + i + ', \'direction\', \'desc\')">ZA</button>';
        html += '</div>';
        html += '<button class="sort-remove-btn" onclick="removeSort(' + i + ')" title="Remove">&times;</button>';
        html += '</div>';
    }

    list.innerHTML = html;
    updateSortCount();
}

// Filter sort dropdown based on search input
function filterSortDropdown(filterText) {
    renderSortDropdown(filterText);
}

// Add sort
function addSort() {
    if (!currentTable) return;
    var fields = META_FIELDS[currentTable] || {};
    // Get sorted fields (alphabetically)
    var sortedFields = getSortedFieldsForDropdown(fields, [], '');
    var firstFieldId = sortedFields.length > 0 ? sortedFields[0].fieldId : null;
    if (!firstFieldId) return;

    currentSorts.push({
        fieldId: firstFieldId,
        direction: 'asc'
    });
    renderSortDropdown();
    applySorts();
}

// Update sort
function updateSort(index, prop, value) {
    if (currentSorts[index]) {
        currentSorts[index][prop] = value;
        renderSortDropdown();
        applySorts();
    }
}

// Remove sort
function removeSort(index) {
    currentSorts.splice(index, 1);
    renderSortDropdown();
    applySorts();
}

// Update sort count badge
function updateSortCount() {
    var countEl = document.getElementById('sort-count');
    var btn = document.getElementById('sort-btn');
    if (currentSorts.length > 0) {
        countEl.textContent = currentSorts.length;
        countEl.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        countEl.style.display = 'none';
        btn.classList.remove('active');
    }
}

// Apply sorts (re-render table)
async function applySorts() {
    updateSortCount();
    await renderTable();
    // Save sorts to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('sorts', currentSorts);
    }
}

// Render group dropdown
function renderGroupDropdown(filterText) {
    if (!currentTable) return;
    var container = document.getElementById('group-options');
    var fields = META_FIELDS[currentTable] || {};

    if (filterText !== undefined) {
        groupDropdownSearch = filterText;
    }

    var filter = (groupDropdownSearch || '').toLowerCase().trim();

    var html = '';

    // Show "None" option only if it matches filter or no filter
    if (!filter || 'none'.includes(filter)) {
        html += '<div class="group-option' + (!currentGroupBy ? ' none-selected' : '') + '" onclick="setGroupBy(null)">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>None</span>';
        html += '</div>';
    }

    // Get sorted fields with selected at top
    var usedFieldIds = currentGroupBy ? [currentGroupBy] : [];
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filter);

    for (var i = 0; i < sortedFields.length; i++) {
        var sf = sortedFields[i];
        var isSelected = currentGroupBy === sf.fieldId;
        html += '<div class="group-option' + (isSelected ? ' selected' : '') + '" onclick="setGroupBy(\'' + esc(sf.fieldId) + '\')">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>' + esc(sf.fieldName) + '</span>';
        html += '</div>';
    }

    if (!html) {
        html = '<div class="group-option" style="color: #999; cursor: default;">No matching fields</div>';
    }

    container.innerHTML = html;
}

// Filter group dropdown based on search input
function filterGroupDropdown(filterText) {
    renderGroupDropdown(filterText);
}

// Update group button state
function updateGroupButtonState() {
    var btn = document.getElementById('group-btn');
    if (currentGroupBy) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

// Set group by field
async function setGroupBy(fieldId) {
    currentGroupBy = fieldId;
    closeViewControlDropdowns();
    updateGroupButtonState();
    await renderTable();
    // Save groupBy to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('groupBy', currentGroupBy);
    }
}

// Render color dropdown
function renderColorDropdown(filterText) {
    if (!currentTable) return;
    var container = document.getElementById('color-options');
    var fields = META_FIELDS[currentTable] || {};
    var filter = (filterText || '').toLowerCase().trim();

    var html = '';

    // Show "None" option only if it matches filter or no filter
    if (!filter || 'none'.includes(filter)) {
        html += '<div class="color-option' + (!currentColorBy ? ' none-selected' : '') + '" onclick="setColorBy(null)">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>None</span>';
        html += '</div>';
    }

    // Get sorted fields with selected at top
    var usedFieldIds = currentColorBy ? [currentColorBy] : [];
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filter);

    for (var i = 0; i < sortedFields.length; i++) {
        var sf = sortedFields[i];
        var isSelected = currentColorBy === sf.fieldId;
        html += '<div class="color-option' + (isSelected ? ' selected' : '') + '" onclick="setColorBy(\'' + esc(sf.fieldId) + '\')">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>' + esc(sf.fieldName) + '</span>';
        html += '</div>';
    }

    if (!html) {
        html = '<div class="color-option" style="color: #999; cursor: default;">No matching fields</div>';
    }

    container.innerHTML = html;
}

// Filter color dropdown based on search input
function filterColorDropdown(filterText) {
    renderColorDropdown(filterText);
}

// Set color by field
async function setColorBy(fieldId) {
    currentColorBy = fieldId;
    closeViewControlDropdowns();
    var btn = document.getElementById('color-btn');
    if (fieldId) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
    await renderTable();
}

// Update row height dropdown selection
function updateRowHeightDropdown() {
    document.querySelectorAll('.row-height-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    var options = document.querySelectorAll('.row-height-option');
    options.forEach(opt => {
        if (opt.textContent.trim().toLowerCase().replace(' ', '-') === currentRowHeight ||
            (opt.textContent.trim() === 'Short' && currentRowHeight === 'short') ||
            (opt.textContent.trim() === 'Medium' && currentRowHeight === 'medium') ||
            (opt.textContent.trim() === 'Tall' && currentRowHeight === 'tall') ||
            (opt.textContent.trim() === 'Extra tall' && currentRowHeight === 'extra-tall')) {
            opt.classList.add('selected');
        }
    });
}

// Set row height
function setRowHeight(height) {
    currentRowHeight = height;
    closeViewControlDropdowns();

    var table = document.getElementById('table');
    if (table) {
        table.className = 'row-height-' + height;
    }
}

// Handle view search
function handleViewSearch(query) {
    currentSearchQuery = query.toLowerCase();
    renderTable();
}

// Update closeAllDropdowns to also close view control dropdowns
var originalCloseAllDropdowns = closeAllDropdowns;
closeAllDropdowns = function() {
    originalCloseAllDropdowns();
    closeViewControlDropdowns();
};

// Add click handler for view control dropdowns
document.addEventListener('click', function(e) {
    var wrapper = e.target.closest('.view-control-wrapper');
    if (!wrapper) {
        closeViewControlDropdowns();
    }
});

// ============ Column Drag & Drop Reordering ============

var draggedColumnFieldId = null;

// Optimized DOM-based column movement (no full table re-render)
function moveColumnInDOM(fromIndex, toIndex) {
    var table = document.getElementById('table');
    if (!table) return false;

    // Account for the Actions column at index 0
    var domFromIndex = fromIndex + 1;
    var domToIndex = toIndex + 1;

    // Move header
    var headerRow = table.querySelector('thead tr');
    if (!headerRow) return false;

    var headers = headerRow.children;
    if (domFromIndex >= headers.length || domToIndex >= headers.length) return false;

    var headerToMove = headers[domFromIndex];
    var targetHeader = headers[domToIndex];

    if (domFromIndex < domToIndex) {
        // Moving right: insert after target
        targetHeader.after(headerToMove);
    } else {
        // Moving left: insert before target
        targetHeader.before(headerToMove);
    }

    // Update data-field-index attributes on all headers
    Array.from(headers).forEach((th, idx) => {
        if (idx > 0 && th.dataset.fieldIndex !== undefined) {
            th.dataset.fieldIndex = idx - 1;
        }
    });

    // Move cells in all body rows
    var bodyRows = table.querySelectorAll('tbody tr:not(.group-header-row)');
    bodyRows.forEach(row => {
        var cells = row.children;
        if (domFromIndex >= cells.length || domToIndex >= cells.length) return;

        var cellToMove = cells[domFromIndex];
        var targetCell = cells[domToIndex];

        if (domFromIndex < domToIndex) {
            targetCell.after(cellToMove);
        } else {
            targetCell.before(cellToMove);
        }
    });

    return true;
}

// Update field visibility in memory and trigger debounced save (no IndexedDB await)
function updateFieldVisibilityFast(tableId, viewId, newHiddenFieldIds) {
    // Update in-memory config
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    if (!VIEW_FIELD_CONFIG[tableId][viewId]) {
        VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [], fieldOrder: [] };
    }
    VIEW_FIELD_CONFIG[tableId][viewId].hiddenFieldIds = newHiddenFieldIds;

    // Update META_VIEWS as well for consistency
    if (META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId].hiddenFieldIds = newHiddenFieldIds;
    }

    // Mark dirty for debounced auto-save (uses existing system)
    markViewDirty('hiddenFieldIds', newHiddenFieldIds);
}

// Update field order in memory and trigger debounced save
function updateFieldOrderFast(tableId, viewId, newFieldOrder) {
    // Update in-memory config
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    if (!VIEW_FIELD_CONFIG[tableId][viewId]) {
        VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [], fieldOrder: [] };
    }
    VIEW_FIELD_CONFIG[tableId][viewId].fieldOrder = newFieldOrder;

    // Update META_VIEWS as well for consistency
    if (META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId].fieldOrder = newFieldOrder;
    }

    // Mark dirty for debounced auto-save (uses existing system)
    markViewDirty('fieldOrder', newFieldOrder);
}

function handleColumnDragStart(event) {
    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId) return;

    draggedColumnFieldId = th.dataset.fieldId;
    th.classList.add('dragging');

    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', draggedColumnFieldId);
}

function handleColumnDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';

    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId) return;

    // Remove drag-over class from all headers
    document.querySelectorAll('th.drag-over').forEach(el => el.classList.remove('drag-over'));

    // Add drag-over class to current target
    if (th.dataset.fieldId !== draggedColumnFieldId) {
        th.classList.add('drag-over');
    }
}

function handleColumnDragEnd(event) {
    // Remove all drag classes
    document.querySelectorAll('th.dragging').forEach(el => el.classList.remove('dragging'));
    document.querySelectorAll('th.drag-over').forEach(el => el.classList.remove('drag-over'));
    draggedColumnFieldId = null;
}

function handleColumnDrop(event) {
    event.preventDefault();

    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId || !draggedColumnFieldId) {
        handleColumnDragEnd(event);
        return;
    }

    var targetFieldId = th.dataset.fieldId;
    if (targetFieldId === draggedColumnFieldId) {
        handleColumnDragEnd(event);
        return;
    }

    // Reorder the fields (synchronous DOM update)
    reorderColumn(draggedColumnFieldId, targetFieldId);

    handleColumnDragEnd(event);
}

function reorderColumn(draggedFieldId, targetFieldId) {
    if (!currentTable) return;

    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var fromIdx = config.fieldOrder.indexOf(draggedFieldId);
    var toIdx = config.fieldOrder.indexOf(targetFieldId);

    if (fromIdx < 0 || toIdx < 0) return;

    // Optimized: Move columns in DOM immediately (no full re-render)
    var domMoved = moveColumnInDOM(fromIdx, toIdx);

    // Update the field order array
    config.fieldOrder.splice(fromIdx, 1);
    var insertIdx = fromIdx < toIdx ? toIdx - 1 : toIdx;
    config.fieldOrder.splice(insertIdx, 0, draggedFieldId);

    // Fast update: in-memory + debounced save (no blocking await)
    updateFieldOrderFast(currentTable, viewId, config.fieldOrder);

    // Update fields dropdown to reflect new order
    renderFieldsDropdown();
}

// ============ Default View Protection & View Creation ============

// Check if current view is the default view (cannot be modified directly)
function isDefaultView() {
    return !currentView || currentView === '_default';
}

// Generate default view name: "{Table Name} {DateTime}"
function generateDefaultViewName() {
    var tableName = 'View';
    if (currentTable && META_TABLES[currentTable]) {
        tableName = META_TABLES[currentTable].tableName || currentTable;
    }
    var now = new Date();
    var dateStr = now.toLocaleDateString() + ' ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    return tableName + ' ' + dateStr;
}

// Show create view modal when user tries to modify default view
function promptCreateViewFromDefault(action, data, reason) {
    pendingViewAction = { action: action, data: data };

    // Close any open dropdowns so they don't overlap the modal
    closeAllDropdowns();

    // Set the reason text
    var reasonEl = document.getElementById('create-view-reason');
    if (reasonEl) {
        reasonEl.textContent = reason || 'The default view cannot be modified. Create a new view to customize.';
    }

    // Set default view name
    var nameInput = document.getElementById('create-view-name');
    if (nameInput) {
        nameInput.value = generateDefaultViewName();
    }

    // Reset other fields
    document.getElementById('create-view-type').value = 'grid';
    document.getElementById('create-view-tags').value = '';

    // Populate parent view options
    populateParentViewOptions();

    // Populate workspace options
    populateWorkspaceOptions();

    // Show modal
    document.getElementById('create-view-modal').classList.add('open');

    // Focus name input
    setTimeout(() => nameInput?.focus(), 100);
}

// Populate parent view dropdown for nesting
function populateParentViewOptions() {
    var select = document.getElementById('create-view-parent');
    if (!select || !currentTable) return;

    var html = '<option value="">(No parent - root level)</option>';
    var views = META_VIEWS[currentTable] || {};

    for (var vid in views) {
        if (vid === '_default') continue;
        var view = views[vid];
        html += '<option value="' + esc(vid) + '">' + esc(view.viewName || vid) + '</option>';
    }

    select.innerHTML = html;
}

// Populate workspace dropdown
function populateWorkspaceOptions() {
    var select = document.getElementById('create-view-workspace');
    if (!select) return;

    var html = '<option value="">(None)</option>';

    for (var wid in WORKSPACES) {
        var ws = WORKSPACES[wid];
        html += '<option value="' + esc(wid) + '">' + esc(ws.workspaceName) + '</option>';
    }

    // Add option to create new workspace
    html += '<option value="_new">+ Create new workspace...</option>';

    select.innerHTML = html;
}

// Close create view modal
function closeCreateViewModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('create-view-modal').classList.remove('open');
    pendingViewAction = null;
}

// Submit create view
async function submitCreateView() {
    var nameInput = document.getElementById('create-view-name');
    var typeSelect = document.getElementById('create-view-type');
    var parentSelect = document.getElementById('create-view-parent');
    var tagsInput = document.getElementById('create-view-tags');
    var workspaceSelect = document.getElementById('create-view-workspace');

    var viewName = nameInput.value.trim();
    if (!viewName) {
        alert('Please enter a view name');
        nameInput.focus();
        return;
    }

    // Disable button to prevent double-clicks
    var submitBtn = document.getElementById('create-view-submit');
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Creating...';
    }

    try {
        var viewType = typeSelect.value;
        var parentViewId = parentSelect.value || null;
        var tags = tagsInput.value.split(',').map(t => t.trim()).filter(t => t);
        var workspaceId = workspaceSelect.value;

        // Handle "create new workspace" option
        if (workspaceId === '_new') {
            var wsName = prompt('Enter workspace name:');
            if (wsName) {
                workspaceId = await createWorkspace(wsName);
            } else {
                workspaceId = null;
            }
        }

        // Create the new view
        var newViewId = 'viw_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        var newView = {
            tableId: currentTable,
            viewId: newViewId,
            viewName: viewName,
            viewType: viewType,
            parentViewId: parentViewId,
            tags: tags,
            hiddenFieldIds: [],
            fieldOrder: [],
            filters: [],
            sorts: [],
            groupBy: null,
            folderId: null
        };

        // If there was a pending action (filter, sort, etc.), apply it to the new view
        if (pendingViewAction) {
            switch (pendingViewAction.action) {
                case 'filter':
                    newView.filters = [pendingViewAction.data];
                    break;
                case 'sort':
                    newView.sorts = [pendingViewAction.data];
                    break;
                case 'group':
                    newView.groupBy = pendingViewAction.data;
                    break;
                case 'hideField':
                    newView.hiddenFieldIds = [pendingViewAction.data];
                    break;
            }
        }

        // Add to workspace if selected
        if (workspaceId && WORKSPACES[workspaceId]) {
            WORKSPACES[workspaceId].viewIds.push(newViewId);
            await saveWorkspace(WORKSPACES[workspaceId]);
        }

        // Save the view
        if (!META_VIEWS[currentTable]) META_VIEWS[currentTable] = {};
        META_VIEWS[currentTable][newViewId] = newView;
        await saveView(newView);

        // Close modal
        closeCreateViewModal();

        // Refresh sidebar
        await loadTableViewsAsync(currentTable);

        // Switch to the new view
        await selectTableView(currentTable, newViewId);
    } catch (err) {
        console.error('Failed to create view:', err);
        alert('Failed to create view: ' + (err.message || 'Unknown error'));
    } finally {
        // Re-enable button
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Create View';
        }
    }
}

// ============ Workspace Management ============

// Get all workspaces from IndexedDB
function getAllWorkspaces() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readonly');
        var req = tx.objectStore('workspaces').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Save a workspace to IndexedDB
function saveWorkspace(workspace) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readwrite');
        tx.objectStore('workspaces').put(workspace);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Delete a workspace from IndexedDB
function deleteWorkspaceFromDB(workspaceId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readwrite');
        tx.objectStore('workspaces').delete(workspaceId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Create a new workspace
async function createWorkspace(name) {
    var workspaceId = 'ws_' + Date.now();
    var workspace = {
        workspaceId: workspaceId,
        workspaceName: name,
        viewIds: [],
        sortOrder: Object.keys(WORKSPACES).length
    };

    WORKSPACES[workspaceId] = workspace;
    await saveWorkspace(workspace);

    // Sync to backend
    await saveWorkspaceToBackend(workspace, 'create');

    return workspaceId;
}

// Add a view to a workspace
async function addViewToWorkspace(viewId, workspaceId) {
    if (!WORKSPACES[workspaceId]) return;

    if (!WORKSPACES[workspaceId].viewIds.includes(viewId)) {
        WORKSPACES[workspaceId].viewIds.push(viewId);
        await saveWorkspace(WORKSPACES[workspaceId]);
        await saveWorkspaceToBackend(WORKSPACES[workspaceId], 'update');
    }
}

// Remove a view from a workspace
async function removeViewFromWorkspace(viewId, workspaceId) {
    if (!WORKSPACES[workspaceId]) return;

    var idx = WORKSPACES[workspaceId].viewIds.indexOf(viewId);
    if (idx >= 0) {
        WORKSPACES[workspaceId].viewIds.splice(idx, 1);
        await saveWorkspace(WORKSPACES[workspaceId]);
        await saveWorkspaceToBackend(WORKSPACES[workspaceId], 'update');
    }
}

// Delete a workspace
async function deleteWorkspace(workspaceId) {
    if (!confirm('Delete this workspace?')) return;

    delete WORKSPACES[workspaceId];
    await deleteWorkspaceFromDB(workspaceId);
    await saveWorkspaceToBackend({ workspaceId: workspaceId }, 'delete');

    if (currentWorkspace === workspaceId) {
        currentWorkspace = null;
    }

    renderSidebar();
}

// Save workspace to backend
async function saveWorkspaceToBackend(workspace, operator) {
    if (!API_KEY) return;
    var payload = {
        uuid: crypto.randomUUID(),
        recordId: workspace.workspaceId,
        set: 'workspaces',
        operator: operator,
        created_at: new Date().toISOString(),
        apiKey: API_KEY,
        payload: JSON.stringify(workspace)
    };

    try {
        await AminoSync.postEvent(payload);
    } catch (error) {
        console.error('Failed to save workspace to backend:', error);
    }
}

// Load workspaces into memory
async function loadWorkspaces() {
    try {
        var workspaces = await getAllWorkspaces();
        WORKSPACES = {};
        workspaces.forEach(ws => WORKSPACES[ws.workspaceId] = ws);
    } catch (err) {
        console.error('Error loading workspaces:', err);
    }
}

// ============ Schema View Rendering ============

// Render schema view (card-based vertical layout)
async function renderSchemaView() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');

    // Get records (limited for performance)
    var displayRecordIds = currentRecordIds.slice(0, 50); // Show up to 50 cards

    if (displayRecordIds.length === 0) {
        container.innerHTML = '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        document.getElementById('pagination').style.display = 'none';
        return;
    }

    var records = await getRecordsByIds(currentTable, displayRecordIds);
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);

    var html = '<div class="schema-view-container">';

    for (var record of records) {
        var recordId = record.recordId;
        var recordFields = record.fields || {};

        html += '<div class="schema-card" data-record-id="' + esc(recordId) + '" onclick="handleRowClick(event, \'' + esc(currentTable) + '\', \'' + esc(recordId) + '\')" style="cursor: pointer;">';

        // Card header
        html += '<div class="schema-card-header">';
        html += '<span class="schema-card-id">' + esc(recordId) + '</span>';
        html += '<div class="schema-card-actions">';
        html += '<button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(recordId) + '\')" title="View field history">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
        html += '</button>';
        html += '</div>';
        html += '</div>';

        // Card body - all fields vertically
        html += '<div class="schema-card-body">';

        for (var fid of fieldIds) {
            var field = fields[fid];
            var fieldName = field.fieldName || fid;
            var value = recordFields[fid];
            if (value === undefined) value = recordFields[fieldName];

            html += '<div class="schema-field-row">';
            html += '<div class="schema-field-name">' + esc(fieldName) + '</div>';

            if (value == null || value === '') {
                html += '<div class="schema-field-value empty"></div>';
            } else {
                html += '<div class="schema-field-value">' + formatCell(value) + '</div>';
            }

            html += '</div>';
        }

        html += '</div>'; // .schema-card-body
        html += '</div>'; // .schema-card
    }

    html += '</div>'; // .schema-view-container

    container.innerHTML = html;

    // Update pagination info (schema view shows limited records)
    document.getElementById('pagination').style.display = 'none';
    updateStatus('Showing ' + displayRecordIds.length + ' of ' + totalRecords + ' records', true, null, 'Schema view');
}

// ============ View Type Detection & Rendering ============

// Get the current view's type
function getCurrentViewType() {
    if (!currentTable || !currentView || currentView === '_default') {
        return 'grid'; // Default view is always grid
    }

    var view = META_VIEWS[currentTable]?.[currentView];
    return view?.viewType || 'grid';
}

// Override renderTable to handle different view types
var originalRenderTable = renderTable;
renderTable = async function() {
    var viewType = getCurrentViewType();

    if (viewType === 'schema') {
        await renderSchemaView();
    } else {
        await originalRenderTable();
    }
};

// ============ Override Filter/Sort/Field Functions for Default View Protection ============

// Store original functions
var originalAddFilter = addFilter;
var originalAddSort = addSort;
var originalSetGroupBy = setGroupBy;
var originalToggleFieldVisibility = toggleFieldVisibility;

// Override addFilter to protect default view
addFilter = function() {
    if (isDefaultView()) {
        var fields = META_FIELDS[currentTable] || {};
        var firstFieldId = Object.keys(fields)[0];
        promptCreateViewFromDefault('filter', {
            fieldId: firstFieldId,
            operator: 'contains',
            value: ''
        }, 'To add filters, please create a new view. The default view shows all records without filters.');
        return;
    }
    originalAddFilter();
};

// Override addSort to protect default view
addSort = function() {
    if (isDefaultView()) {
        var fields = META_FIELDS[currentTable] || {};
        var firstFieldId = Object.keys(fields)[0];
        promptCreateViewFromDefault('sort', {
            fieldId: firstFieldId,
            direction: 'asc'
        }, 'To add sorting, please create a new view. The default view maintains the original record order.');
        return;
    }
    originalAddSort();
};

// Override setGroupBy to protect default view
setGroupBy = async function(fieldId) {
    if (isDefaultView() && fieldId) {
        promptCreateViewFromDefault('group', fieldId, 'To group records, please create a new view. The default view shows records ungrouped.');
        return;
    }
    await originalSetGroupBy(fieldId);
};

// Override toggleFieldVisibility to protect default view
toggleFieldVisibility = async function(fieldId) {
    if (isDefaultView()) {
        promptCreateViewFromDefault('hideField', fieldId, 'To customize visible fields, please create a new view. The default view shows all fields.');
        return;
    }
    await originalToggleFieldVisibility(fieldId);
};

// ============ View Tags UI ============

// Get tags for a view
function getViewTags(tableId, viewId) {
    var view = META_VIEWS[tableId]?.[viewId];
    return view?.tags || [];
}

// Add tag to a view
async function addTagToView(tableId, viewId, tag) {
    var view = META_VIEWS[tableId]?.[viewId];
    if (!view) return;

    if (!view.tags) view.tags = [];
    if (!view.tags.includes(tag)) {
        view.tags.push(tag);
        await saveView(view);
        markViewDirty('tags', view.tags);
    }
}

// Remove tag from a view
async function removeTagFromView(tableId, viewId, tag) {
    var view = META_VIEWS[tableId]?.[viewId];
    if (!view || !view.tags) return;

    var idx = view.tags.indexOf(tag);
    if (idx >= 0) {
        view.tags.splice(idx, 1);
        await saveView(view);
        markViewDirty('tags', view.tags);
    }
}

// Render tags for a view in sidebar
function renderViewTags(tags) {
    if (!tags || tags.length === 0) return '';

    var html = '<div class="view-tags">';
    tags.slice(0, 3).forEach(tag => {
        html += '<span class="view-tag">' + esc(tag) + '</span>';
    });
    if (tags.length > 3) {
        html += '<span class="view-tag">+' + (tags.length - 3) + '</span>';
    }
    html += '</div>';
    return html;
}

// ============ Enhanced Sidebar View Rendering ============

// Update renderViewItem to show tags, type badges, and nesting
var originalRenderViewItem = renderViewItem;
renderViewItem = function(tableId, view, inFolder) {
    var isActive = currentTable === tableId && currentView === view.viewId;
    var viewName = view.viewName || view.viewId;
    var viewIcon = getViewTypeIcon(view.viewType);
    var paddingClass = inFolder ? ' style="padding-left: 52px;"' : '';

    // Calculate nesting level
    var nestLevel = 0;
    var parentId = view.parentViewId;
    while (parentId && nestLevel < 3) {
        nestLevel++;
        var parentView = META_VIEWS[tableId]?.[parentId];
        parentId = parentView?.parentViewId;
    }

    var nestClass = nestLevel > 0 ? ' nested-level-' + nestLevel : '';

    var html = '<div class="table-view-item' + (isActive ? ' active' : '') + nestClass + '"' + paddingClass + ' ' +
           'onclick="selectTableView(\'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'oncontextmenu="showViewContextMenu(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')">';

    // Nesting indicator
    if (nestLevel > 0) {
        html += '<span class="view-nest-indicator"></span>';
    }

    html += '<span class="view-icon">' + viewIcon + '</span>' +
           '<span class="view-name">' + esc(viewName) + '</span>';

    // View type badge
    if (view.viewType && view.viewType !== 'grid') {
        var badgeLabel = view.viewType === 'schema' ? 'cards' : view.viewType;
        html += '<span class="view-type-badge ' + esc(view.viewType) + '">' + esc(badgeLabel) + '</span>';
    }

    html += '</div>';

    // Tags row (if present)
    var tags = view.tags || [];
    if (tags.length > 0) {
        html += renderViewTags(tags);
    }

    return html;
};

// ============ Matrix Setup Wizard ============

var wizardStep = 0;
var wizardData = {
    orgName: '',
    orgSpaceId: null,
    // Legacy data source
    aminoApiKey: '',
    aminoEndpoints: null,
    // Schema from legacy system
    legacyTables: {},
    legacyFields: {},
    legacyAmoData: null,
    // Client configuration
    clientTable: '',
    clientIdentifierField: '',
    clientVisibleTables: [],
    clientVisibleLinkedTables: [], // "which linked record types can a client see?"
    linkedRecordTables: {} // tableId -> fieldId that links to client table
};

var WIZARD_STEPS = [
    { id: 'org', title: 'Organization', subtitle: 'Set up or join your organization' },
    { id: 'legacy', title: 'Import Data', subtitle: 'Connect your existing data source' },
    { id: 'client-table', title: 'Client Records', subtitle: 'Which record type creates clients?' },
    { id: 'visibility', title: 'Client Visibility', subtitle: 'What can clients see?' },
    { id: 'hydrate', title: 'Hydrating', subtitle: 'Building your Matrix rooms' }
];

async function showMatrixWizard() {
    document.getElementById('matrix-wizard').classList.remove('hidden');
    wizardStep = 0;

    // Reuse existing Synapse session for MatrixClient (no second login needed)
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
        try {
            await MatrixClient.initialSync();
            wizardData.orgSpaceId = await MatrixClient.findOrgSpace();
        } catch (e) {
            console.error('[Wizard] Failed to initialize Matrix session:', e);
        }
    }

    renderWizardStep();
}

function hideMatrixWizard() {
    document.getElementById('matrix-wizard').classList.add('hidden');
}

function renderWizardStep() {
    var step = WIZARD_STEPS[wizardStep];

    // Update header
    document.getElementById('wizard-title').textContent = step.title;
    document.getElementById('wizard-subtitle').textContent = step.subtitle;

    // Update step dots
    var dots = document.querySelectorAll('.wizard-step-dot');
    dots.forEach(function(dot, i) {
        dot.className = 'wizard-step-dot';
        if (i < wizardStep) dot.classList.add('completed');
        if (i === wizardStep) dot.classList.add('active');
    });

    // Update footer buttons
    var backBtn = document.getElementById('wizard-back');
    var nextBtn = document.getElementById('wizard-next');
    backBtn.style.display = wizardStep > 0 ? '' : 'none';
    nextBtn.disabled = false;

    if (wizardStep === WIZARD_STEPS.length - 1) {
        nextBtn.style.display = 'none';
    } else {
        nextBtn.style.display = '';
        nextBtn.textContent = wizardStep === WIZARD_STEPS.length - 2 ? 'Begin Hydration' : 'Next';
    }

    // Render step body
    var body = document.getElementById('wizard-body');
    switch (step.id) {
        case 'org': renderWizardOrg(body); break;
        case 'legacy': renderWizardLegacy(body); break;
        case 'client-table': renderWizardClientTable(body); break;
        case 'visibility': renderWizardVisibility(body); break;
        case 'hydrate': renderWizardHydrate(body); break;
    }
}

// ---- Step 1: Org Setup ----
function renderWizardOrg(container) {
    if (wizardData.orgSpaceId) {
        container.innerHTML =
            '<div class="wizard-success">Connected to existing organization.</div>' +
            '<div class="wizard-info-box">' +
                '<strong>Organization space found.</strong> Your rooms and configuration are already set up.' +
            '</div>';
    } else {
        container.innerHTML =
            '<div class="wizard-error" id="wizard-error"></div>' +
            '<div class="form-group">' +
                '<label>Organization Name</label>' +
                '<input type="text" id="wiz-org-name" placeholder="e.g. Ramirez & Associates" value="' + esc(wizardData.orgName) + '">' +
            '</div>' +
            '<div class="wizard-info-box">' +
                '<strong>This creates a Matrix Space</strong> that will contain all your client rooms and firm data. ' +
                'Staff and clients will be invited to specific rooms within this space.' +
            '</div>';
    }
}

// ---- Step 3: Legacy Data Source ----
function renderWizardLegacy(container) {
    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Amino API Key <span class="label-hint">(your existing key)</span></label>' +
            '<input type="password" id="wiz-amino-key" placeholder="API Key" value="' + esc(wizardData.aminoApiKey) + '">' +
        '</div>' +
        '<div class="wizard-info-box">' +
            '<strong>How this works:</strong> We\'ll download your current snapshot from Box, ' +
            'then build Matrix rooms from it. Your Airtable data stays untouched until you decide to sever the connection.' +
        '</div>';
}

// ---- Step 4: Client Table Selection ----
function renderWizardClientTable(container) {
    var tableOptions = '<option value="">-- Select a table --</option>';
    var tableIds = Object.keys(wizardData.legacyTables);
    tableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var selected = wizardData.clientTable === tid ? ' selected' : '';
        tableOptions += '<option value="' + esc(tid) + '"' + selected + '>' + esc(t.tableName || tid) + '</option>';
    });

    // Field selector (populated when table changes)
    var fieldOptions = '<option value="">-- Select a field --</option>';
    if (wizardData.clientTable && wizardData.legacyFields[wizardData.clientTable]) {
        var fields = wizardData.legacyFields[wizardData.clientTable];
        Object.keys(fields).forEach(function(fid) {
            var f = fields[fid];
            var selected = wizardData.clientIdentifierField === fid ? ' selected' : '';
            fieldOptions += '<option value="' + esc(fid) + '"' + selected + '>' + esc(f.fieldName || fid) + '</option>';
        });
    }

    // Linked record field detection per table
    var linkedHtml = '';
    tableIds.forEach(function(tid) {
        if (tid === wizardData.clientTable) return;
        var t = wizardData.legacyTables[tid];
        var fields = wizardData.legacyFields[tid] || {};
        var fids = Object.keys(fields);
        // Find fields that could be linked records (arrays or IDs referencing client table)
        var linkFieldOptions = '<option value="">-- No link --</option>';
        fids.forEach(function(fid) {
            var f = fields[fid];
            var selected = wizardData.linkedRecordTables[tid] === fid ? ' selected' : '';
            linkFieldOptions += '<option value="' + esc(fid) + '"' + selected + '>' + esc(f.fieldName || fid) + '</option>';
        });
        linkedHtml +=
            '<div class="linked-record-row">' +
                '<span class="table-name">' + esc(t.tableName || tid) + '</span>' +
                '<select onchange="wizardSetLinkedField(\'' + esc(tid) + '\', this.value)">' + linkFieldOptions + '</select>' +
            '</div>';
    });

    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Which table represents your clients?</label>' +
            '<select id="wiz-client-table" onchange="wizardClientTableChanged(this.value)">' + tableOptions + '</select>' +
        '</div>' +
        '<div class="form-group">' +
            '<label>Which field identifies each client?</label>' +
            '<select id="wiz-client-field" onchange="wizardData.clientIdentifierField=this.value">' + fieldOptions + '</select>' +
        '</div>' +
        (linkedHtml ?
        '<div class="form-group">' +
            '<label>Which field on each table links to a client record? <span class="label-hint">(the linked record field)</span></label>' +
            '<div class="checkbox-group">' + linkedHtml + '</div>' +
        '</div>' : '') +
        '<div class="wizard-info-box">' +
            '<strong>This is how rooms get created.</strong> Each unique client gets their own Matrix Space with a Matter Room. ' +
            'Other records are assigned to clients via the linked record field you select.' +
        '</div>';
}

function wizardClientTableChanged(tableId) {
    wizardData.clientTable = tableId;
    wizardData.clientIdentifierField = '';
    renderWizardStep(); // re-render to update field dropdown
}

function wizardSetLinkedField(tableId, fieldId) {
    if (fieldId) {
        wizardData.linkedRecordTables[tableId] = fieldId;
    } else {
        delete wizardData.linkedRecordTables[tableId];
    }
}

// ---- Step 5: Client Visibility ----
function renderWizardVisibility(container) {
    var tableIds = Object.keys(wizardData.legacyTables);

    // Table visibility checkboxes
    var tableCheckboxes = '';
    tableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var checked = wizardData.clientVisibleTables.indexOf(tid) !== -1 ? ' checked' : '';
        tableCheckboxes +=
            '<label class="checkbox-item">' +
                '<input type="checkbox" value="' + esc(tid) + '"' + checked +
                    ' onchange="wizardToggleClientVisibleTable(\'' + esc(tid) + '\', this.checked)">' +
                '<span>' + esc(t.tableName || tid) + '</span>' +
            '</label>';
    });

    // Linked record type visibility (which linked record types can a client see?)
    var linkedTableCheckboxes = '';
    var linkedTableIds = Object.keys(wizardData.linkedRecordTables);
    linkedTableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var checked = wizardData.clientVisibleLinkedTables.indexOf(tid) !== -1 ? ' checked' : '';
        linkedTableCheckboxes +=
            '<label class="checkbox-item">' +
                '<input type="checkbox" value="' + esc(tid) + '"' + checked +
                    ' onchange="wizardToggleClientVisibleLinkedTable(\'' + esc(tid) + '\', this.checked)">' +
                '<span>' + esc(t.tableName || tid) + '</span>' +
            '</label>';
    });

    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Which tables can clients see in their portal?</label>' +
            '<div class="checkbox-group">' + tableCheckboxes + '</div>' +
        '</div>' +
        (linkedTableCheckboxes ?
        '<div class="form-group">' +
            '<label>Which linked record types can a client see? <span class="label-hint">(records linked to their client record)</span></label>' +
            '<div class="checkbox-group">' + linkedTableCheckboxes + '</div>' +
        '</div>' : '') +
        '<div class="wizard-info-box">' +
            '<strong>Clients only see their own data.</strong> Tables you check here will be visible in the client portal. ' +
            'Internal notes, billing, and strategy data should remain unchecked.' +
        '</div>';
}

function wizardToggleClientVisibleTable(tableId, checked) {
    var idx = wizardData.clientVisibleTables.indexOf(tableId);
    if (checked && idx === -1) wizardData.clientVisibleTables.push(tableId);
    if (!checked && idx !== -1) wizardData.clientVisibleTables.splice(idx, 1);
}

function wizardToggleClientVisibleLinkedTable(tableId, checked) {
    var idx = wizardData.clientVisibleLinkedTables.indexOf(tableId);
    if (checked && idx === -1) wizardData.clientVisibleLinkedTables.push(tableId);
    if (!checked && idx !== -1) wizardData.clientVisibleLinkedTables.splice(idx, 1);
}

// ---- Step 6: Hydration ----
function renderWizardHydrate(container) {
    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="wizard-progress-section">' +
            '<div class="wizard-progress-bar">' +
                '<div class="wizard-progress-fill" id="wiz-hydrate-progress" style="width: 0%"></div>' +
            '</div>' +
            '<div class="wizard-progress-status" id="wiz-hydrate-status">Preparing...</div>' +
            '<div class="wizard-progress-detail" id="wiz-hydrate-detail"></div>' +
        '</div>';

    // Start hydration automatically
    setTimeout(runHydration, 300);
}

// ============ Wizard Navigation ============

function wizardBack() {
    if (wizardStep > 0) {
        wizardStep--;
        renderWizardStep();
    }
}

async function wizardNext() {
    var nextBtn = document.getElementById('wizard-next');
    nextBtn.disabled = true;

    try {
        switch (WIZARD_STEPS[wizardStep].id) {
            case 'org':
                await wizardValidateOrg();
                break;
            case 'legacy':
                await wizardValidateLegacy();
                break;
            case 'client-table':
                wizardValidateClientTable();
                break;
            case 'visibility':
                // No validation needed, proceed to hydration
                break;
        }
        wizardStep++;
        renderWizardStep();
    } catch (err) {
        showWizardError(err.message);
        nextBtn.disabled = false;
    }
}

function showWizardError(msg) {
    var el = document.getElementById('wizard-error');
    if (el) { el.style.display = 'block'; el.textContent = msg; }
}

function hideWizardError() {
    var el = document.getElementById('wizard-error');
    if (el) el.style.display = 'none';
}

// ============ Wizard Validation ============

async function wizardValidateOrg() {
    if (!wizardData.orgSpaceId) {
        var orgName = document.getElementById('wiz-org-name');
        if (!orgName) throw new Error('Organization already configured');
        var name = orgName.value.trim();
        if (!name) throw new Error('Please enter an organization name');
        wizardData.orgName = name;
        wizardData.orgSpaceId = await MatrixClient.createOrgSpace(name);
    }
}

async function wizardValidateLegacy() {
    var apiKey = document.getElementById('wiz-amino-key').value.trim();
    if (!apiKey) throw new Error('Please enter your Amino API Key');

    wizardData.aminoApiKey = apiKey;

    // Initialize legacy endpoints using existing mechanism
    await initSecureEndpoints(apiKey);
    wizardData.aminoEndpoints = {
        stream: API,
        post: XANO_POST_API,
        boxUpload: BOX_SYNC_WEBHOOK,
        boxDownload: BOX_DOWNLOAD_WEBHOOK
    };

    // Set the global API_KEY so existing functions work
    API_KEY = apiKey;

    // Open IndexedDB
    if (!db) db = await openDB();

    // Try to hydrate from Box to get data locally
    var hydrated = await hydrateFromBoxDownload();

    if (!hydrated) {
        // Fall back to full sync from stream
        await fullSync();
    }

    // Reload metadata
    var tables = await getAllTables();
    var fields = await getAllFields();
    tables.forEach(function(t) { wizardData.legacyTables[t.tableId] = t; });
    fields.forEach(function(f) {
        if (!wizardData.legacyFields[f.tableId]) wizardData.legacyFields[f.tableId] = {};
        wizardData.legacyFields[f.tableId][f.fieldId] = f;
    });

    if (Object.keys(wizardData.legacyTables).length === 0) {
        throw new Error('No tables found. Check your API key and try again.');
    }
}

function wizardValidateClientTable() {
    if (!wizardData.clientTable) throw new Error('Please select which table represents your clients');
    if (!wizardData.clientIdentifierField) throw new Error('Please select which field identifies each client');
}

// ============ Hydration Execution ============

async function runHydration() {
    var progressEl = document.getElementById('wiz-hydrate-progress');
    var statusEl = document.getElementById('wiz-hydrate-status');
    var detailEl = document.getElementById('wiz-hydrate-detail');

    function updateProgress(pct, status, detail) {
        if (progressEl) progressEl.style.width = pct + '%';
        if (statusEl) statusEl.textContent = status;
        if (detailEl) detailEl.textContent = detail || '';
    }

    try {
        updateProgress(5, 'Preparing data...');

        // Build amo-style data structure from IndexedDB for the bridge
        var allRecords = [];
        var tableIds = Object.keys(wizardData.legacyTables);
        for (var i = 0; i < tableIds.length; i++) {
            var tid = tableIds[i];
            var recordIds = await new Promise(function(resolve, reject) {
                var tx = db.transaction('data', 'readonly');
                var store = tx.objectStore('data');
                var index = store.index('by_table');
                var req = index.getAllKeys(tid);
                req.onsuccess = function() { resolve(req.result || []); };
                req.onerror = function() { reject(req.error); };
            });

            for (var r = 0; r < recordIds.length; r++) {
                var rec = await new Promise(function(resolve, reject) {
                    var tx2 = db.transaction('data', 'readonly');
                    var req2 = tx2.objectStore('data').get(recordIds[r]);
                    req2.onsuccess = function() { resolve(req2.result); };
                    req2.onerror = function() { reject(req2.error); };
                });
                if (rec) {
                    // Decrypt if needed
                    if (encryptionEnabled && rec._encrypted) {
                        rec = await decryptRecordFromStorage(rec);
                    }
                    allRecords.push({
                        tableId: rec.tableId,
                        recordId: rec.recordId,
                        fields: rec.fields || {}
                    });
                }
            }
        }

        updateProgress(15, 'Grouping records by client...', allRecords.length + ' records found');

        // Configure bridge
        MatrixBridge.setConfig({
            mode: 'bridge',
            orgSpaceId: wizardData.orgSpaceId,
            clientTable: wizardData.clientTable,
            clientIdentifierField: wizardData.clientIdentifierField,
            clientVisibleTables: wizardData.clientVisibleTables,
            clientHiddenTables: tableIds.filter(function(t) {
                return wizardData.clientVisibleTables.indexOf(t) === -1;
            }),
            linkedRecordTables: wizardData.linkedRecordTables,
            clientRoomMap: {},
            lastSyncCursor: 0
        });

        // Group records
        var grouped = MatrixBridge.groupRecordsByClient(
            allRecords,
            wizardData.legacyFields,
            wizardData.clientTable,
            wizardData.clientIdentifierField,
            wizardData.linkedRecordTables
        );

        var clientNames = Object.keys(grouped.groups);
        var totalClients = clientNames.length;

        updateProgress(20, 'Creating Matrix rooms...', totalClients + ' clients detected');

        // Create firm reference room for unassigned data
        var config = MatrixBridge.getConfig();
        if (grouped.unassigned.length > 0) {
            updateProgress(22, 'Creating firm reference room...', grouped.unassigned.length + ' unassigned records');
            var firmRoomId = await MatrixClient.createRoom({
                name: 'Firm Reference Data',
                preset: 'private_chat'
            });
            await MatrixClient.addChildToSpace(wizardData.orgSpaceId, firmRoomId);
            config.firmRoomId = firmRoomId;

            // Write unassigned records to firm room
            for (var u = 0; u < grouped.unassigned.length; u++) {
                var urec = grouped.unassigned[u];
                await MatrixClient.writeRecord(firmRoomId, urec.tableId, urec.recordId, urec.fields);
                if (u % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
            }
        }

        // For each client, create space + matter room + write data
        for (var c = 0; c < clientNames.length; c++) {
            var clientName = clientNames[c];
            var clientGroup = grouped.groups[clientName];
            var pct = 25 + Math.round((c / totalClients) * 70);
            var recordCount = 0;
            Object.values(clientGroup.records).forEach(function(arr) { recordCount += arr.length; });

            updateProgress(pct, 'Creating room for ' + clientName + '...',
                (c + 1) + ' of ' + totalClients + ' clients (' + recordCount + ' records)');

            // Create client space
            var clientSpaceId = await MatrixClient.createClientSpace(wizardData.orgSpaceId, clientName);

            // Create matter room
            var matterRoomId = await MatrixClient.createMatterRoom(clientSpaceId, clientName);

            // Write schemas
            var clientTableIds = Object.keys(clientGroup.records);
            for (var t = 0; t < clientTableIds.length; t++) {
                var tblId = clientTableIds[t];
                var tblMeta = wizardData.legacyTables[tblId] || { tableName: tblId };
                var isVisible = wizardData.clientVisibleTables.indexOf(tblId) !== -1;
                await MatrixClient.writeTableSchema(matterRoomId, tblId, tblMeta.tableName, tblMeta.icon, isVisible);

                var tblFields = wizardData.legacyFields[tblId] || {};
                var fids = Object.keys(tblFields);
                for (var f = 0; f < fids.length; f++) {
                    await MatrixClient.writeFieldSchema(matterRoomId, fids[f], tblFields[fids[f]]);
                    if (f % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }
            }

            // Write records
            for (var rt = 0; rt < clientTableIds.length; rt++) {
                var recs = clientGroup.records[clientTableIds[rt]];
                for (var ri = 0; ri < recs.length; ri++) {
                    await MatrixClient.writeRecord(matterRoomId, recs[ri].tableId, recs[ri].recordId, recs[ri].fields);
                    if (ri % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }
            }

            // Store room mapping
            config.clientRoomMap[clientName] = {
                spaceId: clientSpaceId,
                matterRoomId: matterRoomId,
                portalRoomId: null
            };
        }

        // Save bridge config
        MatrixBridge.setConfig(config);

        // Save config to org space
        await MatrixClient.sendStateEvent(
            wizardData.orgSpaceId,
            MatrixClient.EVENT_TYPES.BRIDGE_CONFIG,
            '',
            config
        );

        // Save locally
        MatrixClient.saveConfig({
            bridge: config,
            homeserverUrl: MatrixClient.getHomeserverUrl(),
            orgSpaceId: wizardData.orgSpaceId,
            userId: MatrixClient.getUserId()
        });

        updateProgress(100, 'Hydration complete!',
            totalClients + ' client rooms created, ' + allRecords.length + ' records written');

        // Show completion UI
        var body = document.getElementById('wizard-body');
        body.innerHTML =
            '<div class="wizard-success">' +
                'Successfully created ' + totalClients + ' client rooms with ' + allRecords.length + ' records.' +
            '</div>' +
            '<div class="wizard-info-box">' +
                '<strong>Bridge mode is active.</strong> The app will continue syncing from your existing Airtable data and routing updates to the appropriate Matrix rooms. ' +
                'When you\'re ready, you can sever the legacy connection from the admin panel.' +
            '</div>' +
            '<div style="text-align: center; padding-top: 12px; display: flex; gap: 12px; justify-content: center;">' +
                '<button class="btn-next" onclick="hideMatrixWizard(); showRoomManager();" style="background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-secondary);">Manage Rooms</button>' +
                '<button class="btn-next" onclick="wizardComplete()" style="background: var(--success-500); border-color: var(--success-500);">Open App</button>' +
            '</div>';

        // Hide footer buttons
        document.getElementById('wizard-footer').style.display = 'none';

    } catch (err) {
        console.error('[Wizard] Hydration failed:', err);
        updateProgress(0, 'Hydration failed');
        showWizardError('Hydration failed: ' + err.message);
        // Show back button
        document.getElementById('wizard-footer').style.display = 'flex';
        document.getElementById('wizard-back').style.display = '';
    }
}

// ============ Room Manager (Bulk Delete) ============

function showRoomManager() {
    var config = MatrixBridge.getConfig();
    var clientNames = Object.keys(config.clientRoomMap || {}).sort();

    if (clientNames.length === 0) {
        alert('No client rooms found.');
        return;
    }

    // Reset UI
    document.getElementById('rm-list-section').style.display = '';
    document.getElementById('rm-progress-section').style.display = 'none';
    document.getElementById('rm-result-section').style.display = 'none';
    document.getElementById('rm-footer').style.display = 'flex';
    document.getElementById('rm-delete-btn').disabled = true;
    document.getElementById('rm-delete-btn').textContent = 'Delete Selected';
    document.getElementById('rm-select-all').checked = false;
    document.getElementById('rm-selected-count').textContent = '0 selected';
    document.getElementById('rm-error').style.display = 'none';
    document.getElementById('rm-title').textContent = 'Manage Rooms';
    document.getElementById('rm-subtitle').textContent = 'Select client rooms to delete';

    // Populate client list
    var listEl = document.getElementById('rm-client-list');
    var html = '';
    clientNames.forEach(function(name) {
        var mapping = config.clientRoomMap[name];
        var roomCount = 1; // space
        if (mapping.matterRoomId) roomCount++;
        if (mapping.portalRoomId) roomCount++;
        html +=
            '<label class="rm-client-row">' +
                '<input type="checkbox" class="rm-client-cb" value="' + esc(name) + '" onchange="rmUpdateCount()">' +
                '<span>' + esc(name) + '</span>' +
                '<span class="rm-room-info">' + roomCount + ' room' + (roomCount !== 1 ? 's' : '') + '</span>' +
            '</label>';
    });
    listEl.innerHTML = html;

    document.getElementById('room-manager').classList.remove('hidden');
}

function hideRoomManager() {
    document.getElementById('room-manager').classList.add('hidden');
}

function rmToggleSelectAll(checked) {
    var cbs = document.querySelectorAll('.rm-client-cb');
    cbs.forEach(function(cb) { cb.checked = checked; });
    rmUpdateCount();
}

function rmUpdateCount() {
    var cbs = document.querySelectorAll('.rm-client-cb:checked');
    var count = cbs.length;
    document.getElementById('rm-selected-count').textContent = count + ' selected';
    document.getElementById('rm-delete-btn').disabled = count === 0;

    // Update select-all state
    var allCbs = document.querySelectorAll('.rm-client-cb');
    document.getElementById('rm-select-all').checked = allCbs.length > 0 && count === allCbs.length;
}

function rmGetSelectedClients() {
    var cbs = document.querySelectorAll('.rm-client-cb:checked');
    var names = [];
    cbs.forEach(function(cb) { names.push(cb.value); });
    return names;
}

function rmConfirmDelete() {
    var selected = rmGetSelectedClients();
    if (selected.length === 0) return;

    var msg = 'Are you sure you want to delete ' + selected.length + ' client room' +
        (selected.length !== 1 ? 's' : '') + '?\n\nThis will leave and forget:\n';

    var config = MatrixBridge.getConfig();
    var totalRooms = 0;
    selected.forEach(function(name) {
        var mapping = config.clientRoomMap[name];
        if (mapping) {
            var count = 1;
            if (mapping.matterRoomId) count++;
            if (mapping.portalRoomId) count++;
            totalRooms += count;
        }
    });

    msg += '- ' + totalRooms + ' total rooms (spaces, matter rooms, portal rooms)\n\nThis cannot be undone.';

    if (!confirm(msg)) return;

    rmExecuteDelete(selected);
}

async function rmExecuteDelete(clientNames) {
    // Switch to progress view
    document.getElementById('rm-list-section').style.display = 'none';
    document.getElementById('rm-progress-section').style.display = '';
    document.getElementById('rm-delete-btn').style.display = 'none';

    var progressEl = document.getElementById('rm-progress');
    var statusEl = document.getElementById('rm-status');
    var detailEl = document.getElementById('rm-detail');

    try {
        var result = await MatrixBridge.deleteClientRooms(clientNames, function(info) {
            if (info.phase === 'deleting') {
                var pct = info.total > 0 ? Math.round((info.completed / info.total) * 100) : 0;
                progressEl.style.width = pct + '%';
                statusEl.textContent = 'Deleting ' + info.clientName + '...';
                detailEl.textContent = info.completed + ' of ' + info.total + ' clients processed';
            } else if (info.phase === 'complete') {
                progressEl.style.width = '100%';
                statusEl.textContent = 'Deletion complete';
            }
        });

        // Show results
        document.getElementById('rm-progress-section').style.display = 'none';
        var resultEl = document.getElementById('rm-result-section');
        resultEl.style.display = '';

        var html = '<div class="wizard-success">' +
            'Successfully deleted ' + result.deleted + ' client room' + (result.deleted !== 1 ? 's' : '') + '.' +
            '</div>';

        if (result.failed.length > 0) {
            html += '<div class="wizard-error" style="display: block;">' +
                '<strong>' + result.failed.length + ' failed:</strong><br>';
            result.failed.forEach(function(f) {
                html += esc(f.clientName) + ': ' + esc(f.error) + '<br>';
            });
            html += '</div>';
        }

        var remaining = Object.keys(MatrixBridge.getConfig().clientRoomMap || {}).length;
        html += '<div class="wizard-info-box">' +
            '<strong>' + remaining + ' client room' + (remaining !== 1 ? 's' : '') + ' remaining.</strong> ' +
            'Bridge configuration has been updated.' +
            '</div>';

        resultEl.innerHTML = html;

        // Update footer
        document.getElementById('rm-footer').innerHTML =
            '<button class="btn-back" onclick="hideRoomManager()">Close</button>' +
            (remaining > 0 ?
                '<button class="btn-next" onclick="showRoomManager()" style="background: var(--primary-500); border-color: var(--primary-500);">Delete More</button>' :
                '');

    } catch (err) {
        document.getElementById('rm-progress-section').style.display = 'none';
        document.getElementById('rm-list-section').style.display = '';
        document.getElementById('rm-delete-btn').style.display = '';
        var errEl = document.getElementById('rm-error');
        errEl.style.display = 'block';
        errEl.textContent = 'Deletion failed: ' + err.message;
    }
}

function wizardComplete() {
    hideMatrixWizard();

    // Start bridge mode
    if (API_KEY && wizardData.aminoEndpoints) {
        MatrixBridge.startBridge(API_KEY, wizardData.aminoEndpoints);
    }

    // Show manage rooms button
    var rmBtn = document.getElementById('manage-rooms-btn');
    if (rmBtn) rmBtn.style.display = '';

    // Continue to normal app initialization
    initAuthScreen();
}

// ============ Matrix Status & Manual Room Publishing ============

// Track Matrix connection state in sidebar
function updateMatrixStatus() {
    var btn = document.getElementById('matrix-connect-btn');
    var icon = document.getElementById('matrix-status-icon');
    var label = document.getElementById('matrix-status-label');
    if (!btn) return;

    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        btn.classList.add('matrix-connected');
        icon.textContent = '\u25CF'; // filled circle
        label.textContent = session.userId ? session.userId.split(':')[0].replace('@', '') : 'Connected';
        btn.onclick = showMatrixMenu;
        btn.title = 'Matrix: Connected as ' + (session.userId || 'unknown');

        // Show manage rooms button if bridge config has rooms
        var mConfig = MatrixBridge.getConfig();
        if (mConfig && mConfig.clientRoomMap && Object.keys(mConfig.clientRoomMap).length > 0) {
            var rmBtn = document.getElementById('manage-rooms-btn');
            if (rmBtn) rmBtn.style.display = '';
        }
    } else {
        btn.classList.remove('matrix-connected');
        icon.textContent = '\u25CB'; // empty circle
        label.textContent = 'Connect Matrix';
        btn.onclick = function() { showSynapseLoginScreen(); };
        btn.title = 'Connect to Matrix for room sync';
    }
}

// Context menu for connected Matrix user
function showMatrixMenu() {
    var session = _loadSynapseSession();
    if (!session) return;

    // Simple menu via prompt-style - publish rooms or disconnect
    var choice = confirm(
        'Matrix: ' + (session.userId || 'Connected') + '\n\n' +
        'OK = Open Room Publisher\n' +
        'Cancel = Disconnect Matrix'
    );

    if (choice) {
        showRoomPublishModal();
    } else {
        if (confirm('Disconnect from Matrix? Your local data is not affected.')) {
            synapseLogout();
            updateMatrixStatus();
        }
    }
}

// ============ Room Publishing Modal ============

function showRoomPublishModal() {
    var modal = document.getElementById('room-publish-modal');
    modal.classList.remove('hidden');

    var session = _loadSynapseSession();
    var isConnected = session && session.accessToken;

    document.getElementById('room-publish-not-connected').style.display = isConnected ? 'none' : '';
    document.getElementById('room-publish-content').style.display = isConnected ? '' : 'none';
    document.getElementById('pub-publish-btn').style.display = isConnected ? '' : 'none';

    if (!isConnected) return;

    // Make sure MatrixClient has the session
    if (!MatrixClient.isLoggedIn()) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
    }

    // Check for existing org space
    var config = MatrixClient.loadConfig();
    if (config && config.orgSpaceId) {
        document.getElementById('pub-org-name').value = config.bridge ? config.bridge.name || '' : '';
        document.getElementById('pub-org-status').textContent = 'Existing org found';
        document.getElementById('pub-org-status').style.color = 'var(--success-500)';
    }

    // Populate table list
    var tableIds = Object.keys(META_TABLES);
    var listEl = document.getElementById('pub-table-list');
    var clientSelect = document.getElementById('pub-client-table');

    var html = '';
    var clientOpts = '<option value="">No client grouping</option>';

    tableIds.forEach(function(tid) {
        var t = META_TABLES[tid];
        var fieldCount = META_FIELDS[tid] ? Object.keys(META_FIELDS[tid]).length : 0;
        // Count records for this table from in-memory data
        var recordCount = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tid]) ? Object.keys(window.IN_MEMORY_DATA[tid]).length : 0;

        html +=
            '<label class="room-table-item" for="pub-tbl-' + esc(tid) + '">' +
                '<input type="checkbox" id="pub-tbl-' + esc(tid) + '" value="' + esc(tid) + '" checked>' +
                '<div class="table-info">' +
                    '<div class="table-name">' + esc(t.tableName || tid) + '</div>' +
                    '<div class="table-meta">' + fieldCount + ' fields, ' + recordCount + ' records</div>' +
                '</div>' +
                '<span class="pub-status local">Local</span>' +
            '</label>';

        clientOpts += '<option value="' + esc(tid) + '">' + esc(t.tableName || tid) + '</option>';
    });

    listEl.innerHTML = html;
    clientSelect.innerHTML = clientOpts;

    // Reset progress
    document.getElementById('pub-progress-section').style.display = 'none';
    document.getElementById('pub-publish-btn').disabled = false;
    document.getElementById('pub-publish-btn').textContent = 'Publish Selected';
}

function closeRoomPublishModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('room-publish-modal').classList.add('hidden');
}

function pubClientTableChanged() {
    var tableId = document.getElementById('pub-client-table').value;
    var fieldSelect = document.getElementById('pub-client-field');

    if (!tableId) {
        fieldSelect.disabled = true;
        fieldSelect.innerHTML = '<option value="">Select identifier field</option>';
        return;
    }

    fieldSelect.disabled = false;
    var fields = META_FIELDS[tableId] || {};
    var html = '<option value="">Select identifier field</option>';
    Object.keys(fields).forEach(function(fid) {
        var f = fields[fid];
        html += '<option value="' + esc(fid) + '">' + esc(f.fieldName || fid) + '</option>';
    });
    fieldSelect.innerHTML = html;
}

async function executeRoomPublish() {
    var btn = document.getElementById('pub-publish-btn');
    btn.disabled = true;
    btn.textContent = 'Publishing...';

    var progressSection = document.getElementById('pub-progress-section');
    var progressFill = document.getElementById('pub-progress-fill');
    var progressText = document.getElementById('pub-progress-text');
    progressSection.style.display = '';

    function updatePub(pct, text) {
        progressFill.style.width = pct + '%';
        progressText.textContent = text;
    }

    try {
        // Collect selected tables
        var selectedTables = [];
        document.querySelectorAll('#pub-table-list input[type="checkbox"]:checked').forEach(function(cb) {
            selectedTables.push(cb.value);
        });

        if (selectedTables.length === 0) {
            alert('Please select at least one table to publish.');
            btn.disabled = false;
            btn.textContent = 'Publish Selected';
            progressSection.style.display = 'none';
            return;
        }

        var orgName = document.getElementById('pub-org-name').value.trim() || 'My Organization';
        var clientTable = document.getElementById('pub-client-table').value;
        var clientField = document.getElementById('pub-client-field').value;

        updatePub(5, 'Syncing with Matrix...');

        // Ensure we have a Matrix sync
        await MatrixClient.initialSync();

        // Find or create org space
        updatePub(10, 'Setting up organization space...');
        var orgSpaceId = await MatrixClient.findOrgSpace();
        if (!orgSpaceId) {
            orgSpaceId = await MatrixClient.createOrgSpace(orgName);
        }

        // If no client grouping, publish tables as individual rooms under the org space
        if (!clientTable || !clientField) {
            updatePub(15, 'Publishing ' + selectedTables.length + ' tables as rooms...');

            for (var i = 0; i < selectedTables.length; i++) {
                var tid = selectedTables[i];
                var tMeta = META_TABLES[tid] || { tableName: tid };
                var pct = 15 + Math.round((i / selectedTables.length) * 80);
                updatePub(pct, 'Publishing ' + (tMeta.tableName || tid) + '...');

                // Create a room for this table
                var roomId = await MatrixClient.createRoom({
                    name: tMeta.tableName || tid,
                    preset: 'private_chat',
                    initialState: [{
                        type: 'm.room.history_visibility',
                        state_key: '',
                        content: { history_visibility: 'shared' }
                    }]
                });

                await MatrixClient.addChildToSpace(orgSpaceId, roomId);
                await MatrixClient.setRoomParentSpace(roomId, orgSpaceId);

                // Write table schema
                await MatrixClient.writeTableSchema(roomId, tid, tMeta.tableName, tMeta.icon, true);

                // Write field schemas
                var fields = META_FIELDS[tid] || {};
                var fids = Object.keys(fields);
                for (var f = 0; f < fids.length; f++) {
                    await MatrixClient.writeFieldSchema(roomId, fids[f], fields[fids[f]]);
                    if (f % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }

                // Write records from IndexedDB
                var records = await getRecordsForTableFromDB(tid);
                for (var r = 0; r < records.length; r++) {
                    await MatrixClient.writeRecord(roomId, tid, records[r].recordId, records[r].fields);
                    if (r % 5 === 4) await new Promise(function(r2) { setTimeout(r2, 200); });
                }
            }
        } else {
            // Client-grouped publishing: use the bridge mechanism
            updatePub(15, 'Loading records for grouping...');

            var allRecords = [];
            for (var i = 0; i < selectedTables.length; i++) {
                var records = await getRecordsForTableFromDB(selectedTables[i]);
                records.forEach(function(rec) {
                    allRecords.push({ tableId: selectedTables[i], recordId: rec.recordId, fields: rec.fields });
                });
            }

            updatePub(25, 'Grouping ' + allRecords.length + ' records by client...');

            MatrixBridge.setConfig({
                mode: 'bridge',
                orgSpaceId: orgSpaceId,
                clientTable: clientTable,
                clientIdentifierField: clientField,
                clientVisibleTables: selectedTables,
                linkedRecordTables: {},
                clientRoomMap: {},
                lastSyncCursor: 0
            });

            var result = await MatrixBridge.hydrateToMatrix(
                { tables: buildAmoTablesFromRecords(allRecords) },
                { tables: META_TABLES, fields: META_FIELDS },
                function(info) {
                    if (info.phase === 'hydrating_client') {
                        var pct = 25 + Math.round((info.completed / Math.max(info.total, 1)) * 70);
                        updatePub(pct, 'Creating room for ' + (info.clientName || '...') + ' (' + info.completed + '/' + info.total + ')');
                    }
                }
            );
        }

        // Save config locally
        MatrixClient.saveConfig({
            bridge: MatrixBridge.getConfig(),
            homeserverUrl: MatrixClient.getHomeserverUrl(),
            orgSpaceId: orgSpaceId,
            userId: MatrixClient.getUserId()
        });

        updatePub(100, 'Published successfully!');
        btn.textContent = 'Done';
        updateMatrixStatus();

        // Show manage rooms button
        var rmBtn = document.getElementById('manage-rooms-btn');
        if (rmBtn) rmBtn.style.display = '';

        // Close modal after a short delay
        setTimeout(function() { closeRoomPublishModal(); }, 1500);

    } catch (err) {
        console.error('[RoomPublish] Failed:', err);
        updatePub(0, 'Failed: ' + err.message);
        btn.disabled = false;
        btn.textContent = 'Retry';
    }
}

// Helper: get all records for a table from IndexedDB data store
async function getRecordsForTableFromDB(tableId) {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var index = store.index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = async function() {
            var records = req.result || [];
            // Decrypt if needed
            var result = [];
            for (var i = 0; i < records.length; i++) {
                var rec = records[i];
                if (encryptionEnabled && rec._encrypted) {
                    try { rec = await decryptRecordFromStorage(rec); } catch (e) { continue; }
                }
                result.push({ recordId: rec.recordId, fields: rec.fields || {} });
            }
            resolve(result);
        };
        req.onerror = function() { reject(req.error); };
    });
}

// Helper: convert flat record list to amo-style tables object
function buildAmoTablesFromRecords(records) {
    var tables = {};
    records.forEach(function(rec) {
        var key = 'airtable:' + rec.tableId;
        if (!tables[key]) tables[key] = [];
        var row = Object.assign({ record_id: rec.recordId }, rec.fields);
        tables[key].push(row);
    });
    return tables;
}

// ============ Matrix Mode Detection ============

// Check if Matrix mode should be offered or if we're already in Matrix mode
function checkMatrixMode() {
    var config = MatrixClient.loadConfig();
    if (config && config.orgSpaceId) {
        // Returning Matrix user  try to restore session
        if (MatrixClient.restoreSession()) {
            return 'active'; // Matrix session active, bridge may be running
        }
        return 'login'; // Config exists but session expired
    }
    return 'available'; // Matrix not configured, show option to set up
}

// ============ Workspace UI in Sidebar ============

// Render workspace tabs at top of sidebar
function renderWorkspaceTabs() {
    var sidebarHeader = document.querySelector('.sidebar-header');
    if (!sidebarHeader) return;

    // Remove existing workspace tabs
    var existingTabs = document.querySelector('.workspace-tabs');
    if (existingTabs) existingTabs.remove();

    var wsIds = Object.keys(WORKSPACES);
    if (wsIds.length === 0) return;

    var html = '<div class="workspace-tabs">';

    // "All" tab
    html += '<div class="workspace-tab' + (!currentWorkspace ? ' active' : '') + '" onclick="filterByWorkspace(null)">All</div>';

    // Workspace tabs
    wsIds.forEach(wid => {
        var ws = WORKSPACES[wid];
        var isActive = currentWorkspace === wid;
        html += '<div class="workspace-tab' + (isActive ? ' active' : '') + '" onclick="filterByWorkspace(\'' + esc(wid) + '\')">';
        html += esc(ws.workspaceName);
        html += '<span class="workspace-count">' + ws.viewIds.length + '</span>';
        html += '</div>';
    });

    // Add workspace button
    html += '<div class="workspace-add-btn" onclick="promptCreateWorkspace()" title="Create workspace">+</div>';

    html += '</div>';

    sidebarHeader.insertAdjacentHTML('afterend', html);
}

// Filter sidebar views by workspace
function filterByWorkspace(workspaceId) {
    currentWorkspace = workspaceId;
    renderSidebar();
}

// Prompt to create a new workspace
async function promptCreateWorkspace() {
    var name = prompt('Enter workspace name:');
    if (name) {
        await createWorkspace(name);
        renderWorkspaceTabs();
    }
}

// ============ Initialize Workspaces on Load ============

// Extend init to load workspaces and update Matrix status
var originalInit = init;
init = async function() {
    await originalInit();
    await loadWorkspaces();
    renderWorkspaceTabs();
    updateMatrixStatus();
};

// Keyboard handler for modals (Escape to close)
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        // Close room publish modal if open
        var pubModal = document.getElementById('room-publish-modal');
        if (pubModal && !pubModal.classList.contains('hidden')) {
            closeRoomPublishModal();
            return;
        }
        // Close Synapse login if open (non-blocking, just hides)
        var synapseScreen = document.getElementById('synapse-login-screen');
        if (synapseScreen && !synapseScreen.classList.contains('hidden')) {
            hideSynapseLoginScreen();
            return;
        }
        // Close room manager if open
        var rmPanel = document.getElementById('room-manager');
        if (rmPanel && !rmPanel.classList.contains('hidden')) {
            hideRoomManager();
            return;
        }
        // Close connect API modal if open
        var connectModal = document.getElementById('connect-api-modal');
        if (connectModal && connectModal.style.display !== 'none') {
            hideConnectApiModal();
            return;
        }
        // Close create view modal if open
        var modal = document.getElementById('create-view-modal');
        if (modal && modal.classList.contains('open')) {
            closeCreateViewModal();
        }
    }
});

// Keyboard handler for unlock screen
document.getElementById('unlock-password').onkeydown = (e) => { if (e.key === 'Enter') unlockWithPassword(); };
document.getElementById('setup-password').onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('setup-password-confirm').focus(); };
document.getElementById('setup-password-confirm').onkeydown = (e) => { if (e.key === 'Enter') setupEncryptionWithPassword(); };

// Initialize: skip Synapse gate  boot directly to encryption/auth
// Matrix login is now optional and accessible from the sidebar
(async function() {
    var encryptionReady = await initEncryption();
    if (encryptionReady) {
        initAuthScreen();
    }
    // If encryption is not ready, the unlock screen handlers will call initAuthScreen after unlock
})();
    </script>
</body>
</html>
