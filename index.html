<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DB Viewer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f5f5f5; color: #333; display: flex; height: 100vh; }

        /* Sidebar - Airtable dark style */
        .sidebar { width: 260px; background: #1d1f25; border-right: 1px solid #2d2f36; overflow-y: auto; flex-shrink: 0; }
        .sidebar-header { padding: 16px; border-bottom: 1px solid #2d2f36; }
        .sidebar-header h2 { color: #fff; font-size: 14px; font-weight: 600; }
        .sidebar div.table-item { padding: 8px 16px; cursor: pointer; font-size: 13px; color: #b3b3b3; display: flex; align-items: center; gap: 8px; }
        .sidebar div.table-item:hover { background: #2d2f36; color: #fff; }
        .sidebar div.table-item.active { background: #2d6cdf; color: #fff; }
        .sidebar div.table-item .count { margin-left: auto; font-size: 11px; color: #666; }
        .sidebar div.table-item.active .count { color: rgba(255,255,255,0.7); }
        .table-icon { width: 16px; height: 16px; background: #2d6cdf; border-radius: 3px; flex-shrink: 0; }

        /* Main content - Airtable light style */
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: #fff; }

        /* Toolbar */
        .toolbar { padding: 12px 20px; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; background: #fff; }
        .toolbar h1 { font-size: 18px; font-weight: 600; color: #333; flex: 1; }
        .btn { padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; color: #333; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 4px; }
        .btn:hover { background: #e8e8e8; }
        .btn-primary { background: #2d6cdf; border-color: #2d6cdf; color: #fff; }
        .btn-primary:hover { background: #2560c9; }

        /* Status bar */
        .status-bar { padding: 8px 20px; background: #fafafa; border-bottom: 1px solid #e0e0e0; font-size: 12px; color: #666; display: flex; align-items: center; gap: 12px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.synced { background: #20c933; }
        .status-dot.loading { background: #fcb400; }

        /* Table container */
        .table-container { flex: 1; overflow: auto; }

        /* Airtable-style table */
        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th { background: #f5f5f5; border-bottom: 2px solid #ddd; padding: 8px 12px; text-align: left; font-weight: 500; color: #333; position: sticky; top: 0; z-index: 10; white-space: nowrap; }
        th:first-child { width: 120px; color: #666; }
        td { border-bottom: 1px solid #eee; padding: 8px 12px; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: top; }
        tr:hover td { background: #f8f9fa; }
        tr.selected td { background: #e8f0fe; }

        /* Cell content styling */
        .cell-empty { color: #ccc; }
        .cell-array { color: #333; }
        .cell-array .tag { display: inline-block; background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; font-size: 12px; }
        .cell-link { color: #2d6cdf; text-decoration: none; }
        .cell-link:hover { text-decoration: underline; }
        .cell-number { font-family: "SF Mono", Monaco, monospace; }
        .cell-bool { padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; }
        .cell-bool.true { background: #d4edda; color: #155724; }
        .cell-bool.false { background: #f8d7da; color: #721c24; }

        /* Sortable headers */
        th.sortable { cursor: pointer; user-select: none; position: relative; }
        th.sortable:hover { background: #eaeaea; }
        th .sort-indicator { margin-left: 4px; font-size: 10px; color: #999; opacity: 0; transition: opacity 0.15s; }
        th.sortable:hover .sort-indicator { opacity: 0.5; }
        th.sorted .sort-indicator { opacity: 1; color: #2d6cdf; }
        th.sorted { background: #e8f0fe; }

        /* Toolbar buttons for view controls */
        .view-controls { display: flex; gap: 8px; align-items: center; }
        .view-btn { padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; color: #666; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.15s; }
        .view-btn:hover { background: #e8e8e8; border-color: #ccc; color: #333; }
        .view-btn.active { background: #e8f0fe; border-color: #2d6cdf; color: #2d6cdf; }
        .view-btn .badge { background: #2d6cdf; color: #fff; padding: 1px 6px; border-radius: 10px; font-size: 10px; font-weight: 600; }

        /* Airtable color badges for select fields */
        .color-badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 500; margin: 1px 2px 1px 0; white-space: nowrap; }
        .color-badge.blueLight { background: #D0E0FC; color: #2D7FF9; }
        .color-badge.cyanLight { background: #D0F0FD; color: #18BFFF; }
        .color-badge.tealLight { background: #C2F5E9; color: #06A09B; }
        .color-badge.greenLight { background: #D1F7C4; color: #20C933; }
        .color-badge.yellowLight { background: #FFEAB6; color: #9D8102; }
        .color-badge.orangeLight { background: #FEE2D5; color: #D74D26; }
        .color-badge.redLight { background: #FFDCE5; color: #F82B60; }
        .color-badge.pinkLight { background: #FFDAF6; color: #D53F8C; }
        .color-badge.purpleLight { background: #EDE2FE; color: #8B46FF; }
        .color-badge.grayLight { background: #EEEEEE; color: #666666; }

        /* Popover styles */
        .popover-container { position: relative; display: inline-block; }
        .popover { position: absolute; top: 100%; left: 0; z-index: 1000; background: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); min-width: 280px; max-height: 400px; display: none; }
        .popover.open { display: block; }
        .popover-header { padding: 12px 16px; border-bottom: 1px solid #eee; font-weight: 600; font-size: 13px; color: #333; display: flex; align-items: center; justify-content: space-between; }
        .popover-search { padding: 8px 12px; border-bottom: 1px solid #eee; }
        .popover-search input { width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; }
        .popover-search input:focus { outline: none; border-color: #2d6cdf; }
        .popover-body { max-height: 280px; overflow-y: auto; }
        .popover-item { padding: 8px 16px; display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px; }
        .popover-item:hover { background: #f5f5f5; }
        .popover-item.hidden-field { color: #999; }
        .popover-item input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }
        .popover-item label { flex: 1; cursor: pointer; }
        .popover-footer { padding: 8px 12px; border-top: 1px solid #eee; display: flex; gap: 8px; }
        .popover-footer button { flex: 1; padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; background: #f5f5f5; font-size: 12px; cursor: pointer; }
        .popover-footer button:hover { background: #e8e8e8; }

        /* Filter bar styles */
        .filter-bar { padding: 8px 20px; background: #fafafa; border-bottom: 1px solid #e0e0e0; display: none; }
        .filter-bar.active { display: block; }
        .filter-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
        .filter-row:last-child { margin-bottom: 0; }
        .filter-select { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; background: #fff; min-width: 120px; }
        .filter-input { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; min-width: 150px; }
        .filter-remove { padding: 4px 8px; border: none; background: none; color: #999; cursor: pointer; font-size: 16px; }
        .filter-remove:hover { color: #f44; }
        .filter-pills { display: flex; flex-wrap: wrap; gap: 6px; padding: 8px 20px; background: #fafafa; border-bottom: 1px solid #e0e0e0; }
        .filter-pill { display: flex; align-items: center; gap: 6px; padding: 4px 10px; background: #e8f0fe; border-radius: 16px; font-size: 12px; color: #2d6cdf; }
        .filter-pill button { border: none; background: none; color: #2d6cdf; cursor: pointer; font-size: 14px; padding: 0; line-height: 1; }
        .filter-pill button:hover { color: #1a4fa0; }
        .clear-filters { font-size: 12px; color: #666; cursor: pointer; padding: 4px 8px; }
        .clear-filters:hover { color: #333; text-decoration: underline; }

        /* Group header styles */
        .group-header { background: #f0f4f8; padding: 10px 16px; cursor: pointer; display: flex; align-items: center; gap: 10px; border-bottom: 1px solid #ddd; font-size: 14px; font-weight: 600; color: #333; user-select: none; }
        .group-header:hover { background: #e5eaf0; }
        .group-toggle { font-size: 12px; color: #666; transition: transform 0.2s; }
        .group-header.collapsed .group-toggle { transform: rotate(-90deg); }
        .group-count { font-size: 12px; font-weight: 400; color: #666; margin-left: 4px; }
        .group-value { display: flex; align-items: center; gap: 8px; }
        .group-rows { display: table-row-group; }
        .group-rows.collapsed { display: none; }
        .group-popover-item { padding: 10px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 10px; }
        .group-popover-item:hover { background: #f5f5f5; }
        .group-popover-item.active { background: #e8f0fe; color: #2d6cdf; }
        .group-popover-item input[type="radio"] { width: 16px; height: 16px; cursor: pointer; }

        /* History Button in Table */
        .history-btn { padding: 4px 8px; background: transparent; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 11px; color: #666; display: inline-flex; align-items: center; gap: 4px; transition: all 0.15s; }
        .history-btn:hover { background: #f5f5f5; border-color: #2d6cdf; color: #2d6cdf; }
        .history-btn svg { width: 12px; height: 12px; }

        /* Field History Modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .modal-overlay.open { opacity: 1; visibility: visible; }
        .modal { background: #fff; border-radius: 12px; width: 90%; max-width: 700px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,0.3); transform: translateY(20px); transition: transform 0.2s; }
        .modal-overlay.open .modal { transform: translateY(0); }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; }
        .modal-header h2 { font-size: 18px; font-weight: 600; color: #333; flex: 1; margin: 0; }
        .modal-header .record-id { font-size: 12px; color: #999; font-family: "SF Mono", Monaco, monospace; }
        .modal-close { width: 32px; height: 32px; border: none; background: #f5f5f5; border-radius: 6px; cursor: pointer; font-size: 18px; color: #666; display: flex; align-items: center; justify-content: center; }
        .modal-close:hover { background: #e8e8e8; color: #333; }
        .modal-body { flex: 1; overflow-y: auto; padding: 0; }
        .modal-empty { padding: 60px 20px; text-align: center; color: #666; }
        .modal-empty h3 { font-size: 16px; color: #333; margin-bottom: 8px; }
        .modal-toolbar { padding: 12px 24px; background: #fafafa; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; }
        .modal-toolbar select { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; background: #fff; }
        .modal-toolbar .history-count { font-size: 12px; color: #666; margin-left: auto; }

        /* History Timeline */
        .history-timeline { padding: 16px 0; }
        .history-item { padding: 16px 24px; border-bottom: 1px solid #f0f0f0; transition: background 0.15s; }
        .history-item:hover { background: #fafafa; }
        .history-item:last-child { border-bottom: none; }
        .history-item-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
        .history-field-name { font-weight: 600; color: #333; font-size: 14px; }
        .history-change-type { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: 4px; text-transform: uppercase; letter-spacing: 0.3px; }
        .history-change-type.created { background: #d1fae5; color: #059669; }
        .history-change-type.updated { background: #dbeafe; color: #1d4ed8; }
        .history-change-type.deleted { background: #fee2e2; color: #dc2626; }
        .history-timestamp { font-size: 12px; color: #999; margin-left: auto; }
        .history-event-id { font-size: 11px; color: #ccc; font-family: "SF Mono", Monaco, monospace; }
        .history-values { display: flex; gap: 12px; align-items: flex-start; flex-wrap: wrap; }
        .history-value-box { flex: 1; min-width: 200px; padding: 10px 12px; border-radius: 6px; font-size: 13px; }
        .history-value-box.old { background: #fef2f2; border: 1px solid #fecaca; }
        .history-value-box.new { background: #f0fdf4; border: 1px solid #bbf7d0; }
        .history-value-box.null { background: #f5f5f5; border: 1px solid #e0e0e0; color: #999; font-style: italic; }
        .history-value-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #999; margin-bottom: 4px; }
        .history-value-content { word-break: break-word; color: #333; }
        .history-arrow { color: #999; font-size: 16px; flex-shrink: 0; align-self: center; }

        /* Pagination */
        .pagination { padding: 12px 20px; border-top: 1px solid #e0e0e0; background: #fafafa; display: flex; align-items: center; gap: 12px; font-size: 13px; }
        .pagination button { padding: 6px 12px; background: #fff; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; }
        .pagination button:hover:not(:disabled) { background: #f5f5f5; }
        .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
        .pagination .page-info { color: #666; }

        /* Auth screen */
        #auth-screen { position: fixed; inset: 0; background: #1d1f25; display: flex; align-items: center; justify-content: center; z-index: 100; }
        .auth-box { background: #fff; border-radius: 8px; padding: 32px; width: 360px; box-shadow: 0 4px 24px rgba(0,0,0,0.3); }
        .auth-box h2 { font-size: 20px; margin-bottom: 8px; color: #333; }
        .auth-box p { font-size: 13px; color: #666; margin-bottom: 24px; }
        .auth-box input { width: 100%; padding: 10px 12px; background: #fff; border: 1px solid #ddd; border-radius: 6px; color: #333; font-size: 14px; margin-bottom: 12px; }
        .auth-box input:focus { outline: none; border-color: #2d6cdf; box-shadow: 0 0 0 3px rgba(45,108,223,0.1); }
        .auth-box button { width: 100%; padding: 10px; background: #2d6cdf; border: none; border-radius: 6px; color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; }
        .auth-box button:hover { background: #2560c9; }
        .auth-box button:disabled { background: #ccc; cursor: not-allowed; }
        .auth-box button.secondary { background: #f5f5f5; color: #333; }
        .auth-box button.secondary:hover { background: #e8e8e8; }
        .auth-error { color: #dc3545; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: #f8d7da; border-radius: 4px; display: none; }
        .auth-info { color: #666; font-size: 12px; margin-top: 16px; text-align: center; }
        .hidden { display: none !important; }

        /* Empty state */
        .empty-state { padding: 60px 20px; text-align: center; color: #666; }
        .empty-state h3 { font-size: 16px; margin-bottom: 8px; color: #333; }

        /* Loading states */
        .loading-state { padding: 60px 20px; text-align: center; color: #666; }
        .loading-state h3 { font-size: 16px; margin-bottom: 8px; color: #333; }
        .loading-spinner { display: inline-block; width: 24px; height: 24px; border: 3px solid #e0e0e0; border-top-color: #2d6cdf; border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Skeleton loading for table */
        .skeleton-row td { background: linear-gradient(90deg, #f0f0f0 25%, #e8e8e8 50%, #f0f0f0 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .skeleton-cell { height: 16px; background: #e0e0e0; border-radius: 4px; }

        /* Progress bar */
        .progress-bar { height: 3px; background: #e0e0e0; border-radius: 2px; overflow: hidden; margin-top: 4px; }
        .progress-fill { height: 100%; background: #2d6cdf; transition: width 0.3s ease; }

        /* Table loading indicator */
        .table-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .table-container { position: relative; }

        /* Schema Builder Styles */
        .schema-builder { display: flex; flex-direction: column; height: 100%; }
        .schema-tabs { display: flex; gap: 0; border-bottom: 2px solid #e0e0e0; background: #fafafa; padding: 0 20px; }
        .schema-tab { padding: 12px 24px; cursor: pointer; font-size: 13px; font-weight: 500; color: #666; border-bottom: 2px solid transparent; margin-bottom: -2px; transition: all 0.2s; display: flex; align-items: center; gap: 8px; }
        .schema-tab:hover { color: #333; background: #f0f0f0; }
        .schema-tab.active { color: #2d6cdf; border-bottom-color: #2d6cdf; background: #fff; }
        .schema-tab .badge { background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
        .schema-tab.active .badge { background: #2d6cdf; color: #fff; }

        .schema-content { flex: 1; overflow: auto; padding: 20px; background: #f5f5f5; }

        /* Schema Cards */
        .schema-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 16px; }
        .schema-card { background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); overflow: hidden; transition: box-shadow 0.2s, transform 0.2s; cursor: pointer; }
        .schema-card:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.15); transform: translateY(-2px); }
        .schema-card-header { padding: 16px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 12px; }
        .schema-card-icon { width: 40px; height: 40px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 18px; }
        .schema-card-icon.table { background: linear-gradient(135deg, #2d6cdf, #1e4fa8); color: #fff; }
        .schema-card-icon.field { background: linear-gradient(135deg, #20c933, #15961f); color: #fff; }
        .schema-card-icon.view { background: linear-gradient(135deg, #8b5cf6, #6d28d9); color: #fff; }
        .schema-card-title { font-size: 15px; font-weight: 600; color: #333; }
        .schema-card-id { font-size: 11px; color: #999; font-family: "SF Mono", Monaco, monospace; }
        .schema-card-body { padding: 16px; }
        .schema-card-meta { display: flex; flex-wrap: wrap; gap: 8px; }
        .schema-meta-item { font-size: 12px; color: #666; background: #f5f5f5; padding: 4px 10px; border-radius: 4px; }
        .schema-meta-item strong { color: #333; }

        /* Field Type Badge */
        .field-type-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 11px; font-weight: 500; padding: 4px 10px; border-radius: 4px; }
        .field-type-badge.text { background: #e8f0fe; color: #2d6cdf; }
        .field-type-badge.number { background: #fef3c7; color: #d97706; }
        .field-type-badge.select { background: #dbeafe; color: #1d4ed8; }
        .field-type-badge.date { background: #ede9fe; color: #7c3aed; }
        .field-type-badge.checkbox { background: #d1fae5; color: #059669; }
        .field-type-badge.link { background: #fee2e2; color: #dc2626; }
        .field-type-badge.attachment { background: #fce7f3; color: #db2777; }
        .field-type-badge.formula { background: #e0e7ff; color: #4338ca; }
        .field-type-badge.rollup { background: #ccfbf1; color: #0d9488; }
        .field-type-badge.lookup { background: #fef9c3; color: #ca8a04; }
        .field-type-badge.default { background: #f3f4f6; color: #6b7280; }

        /* View Type Badge */
        .view-type-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 11px; font-weight: 500; padding: 4px 10px; border-radius: 4px; }
        .view-type-badge.grid { background: #e8f0fe; color: #2d6cdf; }
        .view-type-badge.gallery { background: #fce7f3; color: #db2777; }
        .view-type-badge.kanban { background: #dbeafe; color: #1d4ed8; }
        .view-type-badge.calendar { background: #ede9fe; color: #7c3aed; }
        .view-type-badge.timeline { background: #d1fae5; color: #059669; }
        .view-type-badge.form { background: #fef3c7; color: #d97706; }
        .view-type-badge.default { background: #f3f4f6; color: #6b7280; }

        /* Schema List View */
        .schema-list { background: #fff; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .schema-list-header { display: grid; grid-template-columns: 1fr 1fr 150px 100px; padding: 12px 16px; background: #f9fafb; font-size: 11px; font-weight: 600; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #e5e7eb; }
        .schema-list-row { display: grid; grid-template-columns: 1fr 1fr 150px 100px; padding: 12px 16px; border-bottom: 1px solid #f3f4f6; align-items: center; cursor: pointer; transition: background 0.15s; }
        .schema-list-row:hover { background: #f9fafb; }
        .schema-list-row:last-child { border-bottom: none; }
        .schema-list-name { font-weight: 500; color: #333; }
        .schema-list-id { font-size: 12px; color: #9ca3af; font-family: "SF Mono", Monaco, monospace; }

        /* Toggle between grid/list view */
        .view-toggle { display: flex; background: #f3f4f6; border-radius: 6px; padding: 2px; }
        .view-toggle-btn { padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; color: #666; background: transparent; border: none; }
        .view-toggle-btn.active { background: #fff; color: #333; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }

        /* Mode toggle in sidebar */
        .sidebar-mode-toggle { padding: 12px 16px; border-bottom: 1px solid #2d2f36; }
        .mode-toggle-btn { width: 100%; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500; border: none; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s; }
        .mode-toggle-btn.schema { background: #8b5cf6; color: #fff; }
        .mode-toggle-btn.schema:hover { background: #7c3aed; }
        .mode-toggle-btn.data { background: #2d6cdf; color: #fff; }
        .mode-toggle-btn.data:hover { background: #2560c9; }

        /* Schema builder toolbar */
        .schema-toolbar { padding: 16px 20px; background: #fff; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 16px; }
        .schema-toolbar h1 { font-size: 18px; font-weight: 600; color: #333; margin: 0; }
        .schema-toolbar .spacer { flex: 1; }

        /* Empty state for schema */
        .schema-empty { text-align: center; padding: 60px 20px; }
        .schema-empty-icon { font-size: 48px; margin-bottom: 16px; opacity: 0.5; }
        .schema-empty h3 { font-size: 18px; color: #333; margin-bottom: 8px; }
        .schema-empty p { color: #666; font-size: 14px; }

        /* Table selector dropdown in schema builder */
        .table-selector { position: relative; }
        .table-selector-btn { padding: 8px 16px; background: #fff; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 8px; min-width: 200px; }
        .table-selector-btn:hover { border-color: #2d6cdf; }
        .table-selector-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: #fff; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; max-height: 300px; overflow-y: auto; display: none; }
        .table-selector-dropdown.open { display: block; }
        .table-selector-option { padding: 10px 16px; cursor: pointer; font-size: 13px; }
        .table-selector-option:hover { background: #f5f5f5; }
        .table-selector-option.active { background: #e8f0fe; color: #2d6cdf; }
    </style>
</head>
<body>
    <div id="auth-screen">
        <div class="auth-box">
            <h2>Amino Viewer</h2>
            <p>Connect to your Amino event stream</p>
            <div id="auth-error" class="auth-error"></div>
            <input type="password" id="api-key-input" placeholder="API Key" autocomplete="off">
            <input type="text" id="set-filter-input" placeholder="Filter by set (optional)" autocomplete="off">
            <button id="auth-submit">Connect</button>
            <button id="auth-clear" class="secondary hidden">Clear Local Data</button>
            <div id="auth-info" class="auth-info"></div>
        </div>
    </div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2>Amino Viewer</h2>
        </div>
        <div class="sidebar-mode-toggle">
            <button class="mode-toggle-btn schema" id="mode-toggle-btn" onclick="toggleMode()">
                <span id="mode-icon">&#9638;</span>
                <span id="mode-text">Schema Builder</span>
            </button>
        </div>
        <div id="table-list"></div>
    </div>

    <div class="main">
        <!-- Schema Builder View -->
        <div id="schema-view" class="schema-builder">
            <div class="schema-toolbar">
                <h1>Schema Builder</h1>
                <div class="spacer"></div>
                <div class="table-selector" id="table-selector-container" style="display: none;">
                    <button class="table-selector-btn" id="table-selector-btn" onclick="toggleTableSelector()">
                        <span id="selected-table-name">All Tables</span>
                        <span style="margin-left: auto;">&#9662;</span>
                    </button>
                    <div class="table-selector-dropdown" id="table-selector-dropdown"></div>
                </div>
                <button class="btn" onclick="manualSync()">Sync</button>
                <button class="btn" onclick="logout()">Logout</button>
            </div>
            <div class="schema-tabs">
                <div class="schema-tab active" id="tab-tables" onclick="showSchemaTab('tables')">
                    <span>Tables</span>
                    <span class="badge" id="tables-count">0</span>
                </div>
                <div class="schema-tab" id="tab-fields" onclick="showSchemaTab('fields')">
                    <span>Fields</span>
                    <span class="badge" id="fields-count">0</span>
                </div>
                <div class="schema-tab" id="tab-views" onclick="showSchemaTab('views')">
                    <span>Views</span>
                    <span class="badge" id="views-count">0</span>
                </div>
            </div>
            <div class="status-bar">
                <span class="status-dot" id="schema-status-dot"></span>
                <span id="schema-status-text">Ready</span>
                <div class="progress-bar" id="schema-progress-bar" style="display: none; flex: 1; max-width: 200px;">
                    <div class="progress-fill" id="schema-progress-fill" style="width: 0%"></div>
                </div>
                <span id="schema-status-detail" style="color: #999; font-size: 11px;"></span>
            </div>
            <div class="schema-content" id="schema-content">
                <!-- Schema cards will be rendered here -->
            </div>
        </div>

        <!-- Data Viewer View (hidden by default) -->
        <div id="data-view" style="display: none; flex-direction: column; height: 100%;">
            <div class="toolbar">
                <h1 id="title">Select a table</h1>
                <div class="view-controls">
                    <div class="popover-container">
                        <button class="view-btn" id="hide-fields-btn" onclick="toggleHideFieldsPopover()">
                            <span>Hide fields</span>
                            <span class="badge" id="hidden-count" style="display: none;">0</span>
                        </button>
                        <div class="popover" id="hide-fields-popover">
                            <div class="popover-header">
                                <span>Hide fields</span>
                            </div>
                            <div class="popover-search">
                                <input type="text" id="field-search" placeholder="Find a field" oninput="filterFieldList()">
                            </div>
                            <div class="popover-body" id="field-list"></div>
                            <div class="popover-footer">
                                <button onclick="showAllFields()">Show all</button>
                                <button onclick="hideAllFields()">Hide all</button>
                            </div>
                        </div>
                    </div>
                    <div class="popover-container">
                        <button class="view-btn" id="filter-btn" onclick="toggleFilterPopover()">
                            <span>Filter</span>
                            <span class="badge" id="filter-count" style="display: none;">0</span>
                        </button>
                        <div class="popover" id="filter-popover">
                            <div class="popover-header">
                                <span>Filter</span>
                            </div>
                            <div class="popover-body" id="filter-list" style="padding: 12px;"></div>
                            <div class="popover-footer">
                                <button onclick="addFilter()">+ Add filter</button>
                                <button onclick="clearAllFilters()">Clear all</button>
                            </div>
                        </div>
                    </div>
                    <div class="popover-container">
                        <button class="view-btn" id="group-btn" onclick="toggleGroupPopover()">
                            <span>Group</span>
                        </button>
                        <div class="popover" id="group-popover">
                            <div class="popover-header">
                                <span>Group by</span>
                            </div>
                            <div class="popover-body" id="group-field-list"></div>
                            <div class="popover-footer">
                                <button onclick="clearGroupBy()">Clear grouping</button>
                            </div>
                        </div>
                    </div>
                </div>
                <button class="btn" onclick="manualSync()">Sync</button>
                <button class="btn" onclick="logout()">Logout</button>
            </div>
            <div id="filter-pills-container" class="filter-pills" style="display: none;"></div>
            <div class="status-bar">
                <span class="status-dot" id="status-dot"></span>
                <span id="status-text">Ready</span>
                <div class="progress-bar" id="progress-bar" style="display: none; flex: 1; max-width: 200px;">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <span id="status-detail" style="color: #999; font-size: 11px;"></span>
            </div>
            <div class="table-container" id="table-container">
                <table id="table"></table>
            </div>
            <div class="pagination" id="pagination">
                <button id="prev-btn" onclick="prevPage()">Previous</button>
                <span class="page-info" id="page-info">Page 1</span>
                <button id="next-btn" onclick="nextPage()">Next</button>
            </div>
        </div>
    </div>

    <!-- Field History Modal -->
    <div class="modal-overlay" id="history-modal-overlay" onclick="closeHistoryModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 id="history-modal-title">Field History</h2>
                <span class="record-id" id="history-modal-record-id"></span>
                <button class="modal-close" onclick="closeHistoryModal()">&times;</button>
            </div>
            <div class="modal-toolbar">
                <label>Filter by field:</label>
                <select id="history-field-filter" onchange="filterHistoryByField()">
                    <option value="">All Fields</option>
                </select>
                <span class="history-count" id="history-count"></span>
            </div>
            <div class="modal-body" id="history-modal-body">
                <!-- History items will be rendered here -->
            </div>
        </div>
    </div>

    <script>
var API = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:nrIL-Oi-/aminostream';
var DB_NAME = 'aminostream';
var DB_VERSION = 5;
var PAGE_SIZE = 100;

var API_KEY = null;
var SET_FILTER = null;
var db = null;

// Only keep lightweight metadata in memory
var META_TABLES = {};
var META_FIELDS = {};
var META_VIEWS = {};

// Schema builder mode
var schemaMode = true; // Start in schema builder mode
var currentSchemaTab = 'tables'; // 'tables', 'fields', 'views'
var selectedSchemaTable = null; // Selected table in schema builder

var currentTable = null;
var currentPage = 0;
var currentRecordIds = [];
var totalRecords = 0;
var lastEventId = 0;
var pollInterval = null;

// View state for current table (sort, filter, group, hidden fields)
var currentViewState = null;

// ============ IndexedDB ============

function openDB() {
    return new Promise((resolve, reject) => {
        var req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve(req.result);
        req.onupgradeneeded = (e) => {
            var db = e.target.result;

            // Delete old stores if they exist
            if (db.objectStoreNames.contains('records')) {
                db.deleteObjectStore('records');
            }
            if (db.objectStoreNames.contains('meta')) {
                db.deleteObjectStore('meta');
            }

            // Data records: keyed by [tableId, recordId]
            if (!db.objectStoreNames.contains('data')) {
                var dataStore = db.createObjectStore('data', { keyPath: ['tableId', 'recordId'] });
                dataStore.createIndex('by_table', 'tableId');
            }

            // Table metadata
            if (!db.objectStoreNames.contains('tables')) {
                db.createObjectStore('tables', { keyPath: 'tableId' });
            }

            // Field metadata: keyed by [tableId, fieldId]
            if (!db.objectStoreNames.contains('fields')) {
                var fieldStore = db.createObjectStore('fields', { keyPath: ['tableId', 'fieldId'] });
                fieldStore.createIndex('by_table', 'tableId');
            }

            // View metadata: keyed by [tableId, viewId]
            if (!db.objectStoreNames.contains('views')) {
                var viewStore = db.createObjectStore('views', { keyPath: ['tableId', 'viewId'] });
                viewStore.createIndex('by_table', 'tableId');
            }

            // Sync state
            if (!db.objectStoreNames.contains('sync')) {
                db.createObjectStore('sync', { keyPath: 'key' });
            }

            // View state: stores sort, filter, group, hidden fields per table
            if (!db.objectStoreNames.contains('viewState')) {
                db.createObjectStore('viewState', { keyPath: 'tableId' });
            }

            // Field history: keyed by auto-increment, indexed by record and field
            if (!db.objectStoreNames.contains('fieldHistory')) {
                var historyStore = db.createObjectStore('fieldHistory', { keyPath: 'id', autoIncrement: true });
                historyStore.createIndex('by_record', ['tableId', 'recordId']);
                historyStore.createIndex('by_field', ['tableId', 'recordId', 'fieldId']);
                historyStore.createIndex('by_event', 'eventId');
            }
        };
    });
}

function getSyncMeta(key) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readonly');
        var req = tx.objectStore('sync').get(key);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
        req.onerror = () => reject(req.error);
    });
}

function setSyncMeta(key, value) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readwrite');
        tx.objectStore('sync').put({ key, value });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getAllTables() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readonly');
        var req = tx.objectStore('tables').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getFieldsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var index = tx.objectStore('fields').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getViewsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var index = tx.objectStore('views').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllViews() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var req = tx.objectStore('views').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllFields() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var req = tx.objectStore('fields').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Query schema elements by recordId prefix
function getSchemaByPrefix(prefix) {
    // Returns tables (tbl*), fields (fld*), or views (viw*) based on prefix
    return new Promise(async (resolve) => {
        var results = [];
        if (prefix === 'tbl') {
            var tables = await getAllTables();
            results = tables.filter(t => t.tableId && t.tableId.startsWith('tbl'));
        } else if (prefix === 'fld') {
            var fields = await getAllFields();
            results = fields.filter(f => f.fieldId && f.fieldId.startsWith('fld'));
        } else if (prefix === 'viw') {
            var views = await getAllViews();
            results = views.filter(v => v.viewId && v.viewId.startsWith('viw'));
        }
        resolve(results);
    });
}

function getRecordIdsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var index = tx.objectStore('data').index('by_table');
        var req = index.getAllKeys(tableId);
        req.onsuccess = () => {
            // Keys are [tableId, recordId], extract recordIds
            var recordIds = (req.result || []).map(k => k[1]);
            resolve(recordIds);
        };
        req.onerror = () => reject(req.error);
    });
}

function getRecordsByIds(tableId, recordIds) {
    return new Promise((resolve, reject) => {
        if (!recordIds.length) return resolve([]);
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var results = [];
        var pending = recordIds.length;

        recordIds.forEach(rid => {
            var req = store.get([tableId, rid]);
            req.onsuccess = () => {
                if (req.result) results.push(req.result);
                if (--pending === 0) resolve(results);
            };
            req.onerror = () => {
                if (--pending === 0) resolve(results);
            };
        });
    });
}

function saveTable(table) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readwrite');
        tx.objectStore('tables').put(table);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveField(field) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readwrite');
        tx.objectStore('fields').put(field);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveView(view) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readwrite');
        tx.objectStore('views').put(view);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveDataRecord(record) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readwrite');
        tx.objectStore('data').put(record);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveBatch(tables, fields, views, dataRecords) {
    return new Promise((resolve, reject) => {
        var stores = [];
        if (tables.length) stores.push('tables');
        if (fields.length) stores.push('fields');
        if (views.length) stores.push('views');
        if (dataRecords.length) stores.push('data');
        if (!stores.length) return resolve();

        var tx = db.transaction(stores, 'readwrite');

        tables.forEach(t => tx.objectStore('tables').put(t));
        fields.forEach(f => tx.objectStore('fields').put(f));
        views.forEach(v => tx.objectStore('views').put(v));
        dataRecords.forEach(d => tx.objectStore('data').put(d));

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function clearAllData() {
    return new Promise((resolve, reject) => {
        var stores = ['data', 'tables', 'fields', 'views', 'sync'];
        // Add viewState if it exists
        if (db.objectStoreNames.contains('viewState')) {
            stores.push('viewState');
        }
        // Add fieldHistory if it exists
        if (db.objectStoreNames.contains('fieldHistory')) {
            stores.push('fieldHistory');
        }
        var tx = db.transaction(stores, 'readwrite');
        tx.objectStore('data').clear();
        tx.objectStore('tables').clear();
        tx.objectStore('fields').clear();
        tx.objectStore('views').clear();
        tx.objectStore('sync').clear();
        if (db.objectStoreNames.contains('viewState')) {
            tx.objectStore('viewState').clear();
        }
        if (db.objectStoreNames.contains('fieldHistory')) {
            tx.objectStore('fieldHistory').clear();
        }
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// ============ View State ============

function getViewState(tableId) {
    return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('viewState')) {
            resolve(getDefaultViewState(tableId));
            return;
        }
        var tx = db.transaction('viewState', 'readonly');
        var req = tx.objectStore('viewState').get(tableId);
        req.onsuccess = () => {
            if (req.result) {
                resolve(req.result);
            } else {
                resolve(getDefaultViewState(tableId));
            }
        };
        req.onerror = () => resolve(getDefaultViewState(tableId));
    });
}

function setViewState(tableId, state) {
    return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('viewState')) {
            resolve();
            return;
        }
        state.tableId = tableId;
        var tx = db.transaction('viewState', 'readwrite');
        tx.objectStore('viewState').put(state);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getDefaultViewState(tableId) {
    return {
        tableId: tableId,
        sort: null,           // { fieldId: string, direction: 'asc' | 'desc' }
        filters: [],          // Array of filter objects
        groupBy: null,        // fieldId to group by
        expandedGroups: [],   // which groups are expanded
        hiddenFields: []      // array of hidden fieldIds
    };
}

// ============ Sorting ============

function sortRecords(records, fieldId, direction) {
    if (!fieldId || !direction) return records;

    var fields = META_FIELDS[currentTable] || {};
    var fieldMeta = fields[fieldId];
    var fieldType = fieldMeta ? (fieldMeta.fieldType || '').toLowerCase() : '';

    return records.slice().sort((a, b) => {
        var aVal = a.fields ? (a.fields[fieldId] ?? a.fields[fieldMeta?.fieldName]) : null;
        var bVal = b.fields ? (b.fields[fieldId] ?? b.fields[fieldMeta?.fieldName]) : null;

        var result = compareValues(aVal, bVal, fieldType);
        return direction === 'desc' ? -result : result;
    });
}

function compareValues(a, b, fieldType) {
    // Handle null/undefined
    if (a == null && b == null) return 0;
    if (a == null) return 1;  // nulls go to end
    if (b == null) return -1;

    // Handle arrays (take first element for comparison)
    if (Array.isArray(a)) a = a.length > 0 ? (a[0]?.name || a[0]?.filename || a[0]) : null;
    if (Array.isArray(b)) b = b.length > 0 ? (b[0]?.name || b[0]?.filename || b[0]) : null;

    // Handle objects
    if (typeof a === 'object' && a !== null) a = a.name || a.filename || a.email || JSON.stringify(a);
    if (typeof b === 'object' && b !== null) b = b.name || b.filename || b.email || JSON.stringify(b);

    // Type-specific comparison
    if (fieldType.includes('number') || fieldType === 'currency' || fieldType === 'percent' || fieldType === 'autonumber') {
        var aNum = parseFloat(a);
        var bNum = parseFloat(b);
        if (isNaN(aNum) && isNaN(bNum)) return 0;
        if (isNaN(aNum)) return 1;
        if (isNaN(bNum)) return -1;
        return aNum - bNum;
    }

    if (fieldType.includes('date') || fieldType === 'datetime' || fieldType === 'createdtime' || fieldType === 'lastmodifiedtime') {
        var aDate = new Date(a);
        var bDate = new Date(b);
        if (isNaN(aDate) && isNaN(bDate)) return 0;
        if (isNaN(aDate)) return 1;
        if (isNaN(bDate)) return -1;
        return aDate - bDate;
    }

    if (fieldType === 'checkbox') {
        var aBool = !!a;
        var bBool = !!b;
        return aBool === bBool ? 0 : (aBool ? -1 : 1);
    }

    // Default: string comparison
    var aStr = String(a).toLowerCase();
    var bStr = String(b).toLowerCase();
    return aStr.localeCompare(bStr);
}

async function toggleSort(fieldId) {
    if (!currentTable || !currentViewState) return;

    var currentSort = currentViewState.sort;

    if (currentSort && currentSort.fieldId === fieldId) {
        // Toggle direction or clear
        if (currentSort.direction === 'asc') {
            currentViewState.sort = { fieldId: fieldId, direction: 'desc' };
        } else {
            currentViewState.sort = null; // Clear sort
        }
    } else {
        // New sort
        currentViewState.sort = { fieldId: fieldId, direction: 'asc' };
    }

    // Save and re-render
    await setViewState(currentTable, currentViewState);
    currentPage = 0; // Reset to first page
    await renderTable();
}

// ============ Colors ============

// Airtable color name to CSS class mapping
var AIRTABLE_COLORS = {
    'blueLight': 'blueLight',
    'blueBright': 'blueLight',
    'blue': 'blueLight',
    'cyanLight': 'cyanLight',
    'cyanBright': 'cyanLight',
    'cyan': 'cyanLight',
    'tealLight': 'tealLight',
    'tealBright': 'tealLight',
    'teal': 'tealLight',
    'greenLight': 'greenLight',
    'greenBright': 'greenLight',
    'green': 'greenLight',
    'yellowLight': 'yellowLight',
    'yellowBright': 'yellowLight',
    'yellow': 'yellowLight',
    'orangeLight': 'orangeLight',
    'orangeBright': 'orangeLight',
    'orange': 'orangeLight',
    'redLight': 'redLight',
    'redBright': 'redLight',
    'red': 'redLight',
    'pinkLight': 'pinkLight',
    'pinkBright': 'pinkLight',
    'pink': 'pinkLight',
    'purpleLight': 'purpleLight',
    'purpleBright': 'purpleLight',
    'purple': 'purpleLight',
    'grayLight': 'grayLight',
    'grayBright': 'grayLight',
    'gray': 'grayLight'
};

// Color rotation for values without explicit colors
var COLOR_ROTATION = ['blueLight', 'greenLight', 'orangeLight', 'purpleLight', 'cyanLight', 'yellowLight', 'redLight', 'pinkLight', 'tealLight', 'grayLight'];

function getColorForValue(value, fieldId) {
    if (!currentTable || !fieldId) return 'grayLight';

    var fields = META_FIELDS[currentTable] || {};
    var fieldMeta = fields[fieldId];

    if (!fieldMeta || !fieldMeta.options || !fieldMeta.options.choices) {
        // No choices defined, use hash-based color
        return getHashColor(value);
    }

    var choices = fieldMeta.options.choices;
    var choice = choices.find(c => c.name === value || c.id === value);

    if (choice && choice.color) {
        return AIRTABLE_COLORS[choice.color] || getHashColor(value);
    }

    // Fallback: use position-based color
    var index = choices.findIndex(c => c.name === value || c.id === value);
    if (index >= 0) {
        return COLOR_ROTATION[index % COLOR_ROTATION.length];
    }

    return getHashColor(value);
}

function getHashColor(value) {
    if (!value) return 'grayLight';
    var hash = 0;
    var str = String(value);
    for (var i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    return COLOR_ROTATION[Math.abs(hash) % COLOR_ROTATION.length];
}

function formatColorBadge(value, fieldId) {
    if (value == null || value === '') return '<span class="cell-empty"></span>';

    if (Array.isArray(value)) {
        if (value.length === 0) return '<span class="cell-empty"></span>';
        return value.map(v => {
            var displayVal = typeof v === 'object' ? (v.name || v) : v;
            var colorClass = getColorForValue(displayVal, fieldId);
            return '<span class="color-badge ' + colorClass + '">' + esc(displayVal) + '</span>';
        }).join('');
    }

    var colorClass = getColorForValue(value, fieldId);
    return '<span class="color-badge ' + colorClass + '">' + esc(value) + '</span>';
}

// ============ Hide Fields ============

function toggleHideFieldsPopover() {
    closeAllPopovers('hide-fields-popover');
    var popover = document.getElementById('hide-fields-popover');
    popover.classList.toggle('open');
    if (popover.classList.contains('open')) {
        renderFieldList();
        document.getElementById('field-search').value = '';
    }
}

function renderFieldList(filterText) {
    if (!currentTable) return;

    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);
    var hiddenFields = currentViewState ? (currentViewState.hiddenFields || []) : [];
    var search = (filterText || '').toLowerCase();

    fieldIds.sort((a, b) => {
        var nameA = fields[a].fieldName || a;
        var nameB = fields[b].fieldName || b;
        return nameA.localeCompare(nameB);
    });

    var html = '';
    fieldIds.forEach(fid => {
        var fieldName = fields[fid].fieldName || fid;
        if (search && !fieldName.toLowerCase().includes(search)) return;

        var isHidden = hiddenFields.includes(fid);
        var itemClass = 'popover-item' + (isHidden ? ' hidden-field' : '');

        html += '<div class="' + itemClass + '" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<input type="checkbox" ' + (isHidden ? '' : 'checked') + ' onclick="event.stopPropagation(); toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<label>' + esc(fieldName) + '</label>';
        if (isHidden) html += '<span style="font-size: 11px; color: #999;">(hidden)</span>';
        html += '</div>';
    });

    if (!html) {
        html = '<div style="padding: 16px; color: #999; text-align: center;">No fields found</div>';
    }

    document.getElementById('field-list').innerHTML = html;
}

function filterFieldList() {
    var search = document.getElementById('field-search').value;
    renderFieldList(search);
}

async function toggleFieldVisibility(fieldId) {
    if (!currentTable || !currentViewState) return;

    var hiddenFields = currentViewState.hiddenFields || [];
    var index = hiddenFields.indexOf(fieldId);

    if (index >= 0) {
        hiddenFields.splice(index, 1); // Show field
    } else {
        hiddenFields.push(fieldId); // Hide field
    }

    currentViewState.hiddenFields = hiddenFields;
    await setViewState(currentTable, currentViewState);

    renderFieldList(document.getElementById('field-search').value);
    updateHiddenCount();
    await renderTable();
}

async function showAllFields() {
    if (!currentTable || !currentViewState) return;
    currentViewState.hiddenFields = [];
    await setViewState(currentTable, currentViewState);
    renderFieldList();
    updateHiddenCount();
    await renderTable();
}

async function hideAllFields() {
    if (!currentTable || !currentViewState) return;
    var fields = META_FIELDS[currentTable] || {};
    currentViewState.hiddenFields = Object.keys(fields);
    await setViewState(currentTable, currentViewState);
    renderFieldList();
    updateHiddenCount();
    await renderTable();
}

function updateHiddenCount() {
    var badge = document.getElementById('hidden-count');
    var btn = document.getElementById('hide-fields-btn');
    var count = currentViewState ? (currentViewState.hiddenFields || []).length : 0;

    if (count > 0) {
        badge.textContent = count;
        badge.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        badge.style.display = 'none';
        btn.classList.remove('active');
    }
}

function closeAllPopovers(except) {
    var popovers = document.querySelectorAll('.popover');
    popovers.forEach(p => {
        if (p.id !== except) p.classList.remove('open');
    });
}

// Close popovers when clicking outside
document.addEventListener('click', function(e) {
    if (!e.target.closest('.popover-container')) {
        closeAllPopovers();
    }
});

// ============ Filtering ============

// Filter operators by field type
var FILTER_OPERATORS = {
    text: [
        { value: 'contains', label: 'contains' },
        { value: 'notContains', label: 'does not contain' },
        { value: 'equals', label: 'equals' },
        { value: 'notEquals', label: 'does not equal' },
        { value: 'startsWith', label: 'starts with' },
        { value: 'endsWith', label: 'ends with' },
        { value: 'isEmpty', label: 'is empty' },
        { value: 'isNotEmpty', label: 'is not empty' }
    ],
    number: [
        { value: 'equals', label: '=' },
        { value: 'notEquals', label: '' },
        { value: 'gt', label: '>' },
        { value: 'lt', label: '<' },
        { value: 'gte', label: '' },
        { value: 'lte', label: '' },
        { value: 'isEmpty', label: 'is empty' },
        { value: 'isNotEmpty', label: 'is not empty' }
    ],
    select: [
        { value: 'is', label: 'is' },
        { value: 'isNot', label: 'is not' },
        { value: 'isEmpty', label: 'is empty' },
        { value: 'isNotEmpty', label: 'is not empty' }
    ],
    multiselect: [
        { value: 'hasAnyOf', label: 'has any of' },
        { value: 'hasAllOf', label: 'has all of' },
        { value: 'isEmpty', label: 'is empty' },
        { value: 'isNotEmpty', label: 'is not empty' }
    ],
    checkbox: [
        { value: 'isChecked', label: 'is checked' },
        { value: 'isNotChecked', label: 'is not checked' }
    ],
    date: [
        { value: 'is', label: 'is' },
        { value: 'isBefore', label: 'is before' },
        { value: 'isAfter', label: 'is after' },
        { value: 'isEmpty', label: 'is empty' },
        { value: 'isNotEmpty', label: 'is not empty' }
    ]
};

function getOperatorsForFieldType(fieldType) {
    if (!fieldType) return FILTER_OPERATORS.text;
    var type = fieldType.toLowerCase();

    if (type.includes('number') || type === 'currency' || type === 'percent' || type === 'autonumber') {
        return FILTER_OPERATORS.number;
    }
    if (type === 'singleselect') return FILTER_OPERATORS.select;
    if (type === 'multipleselects') return FILTER_OPERATORS.multiselect;
    if (type === 'checkbox') return FILTER_OPERATORS.checkbox;
    if (type.includes('date') || type === 'datetime' || type === 'createdtime' || type === 'lastmodifiedtime') {
        return FILTER_OPERATORS.date;
    }
    return FILTER_OPERATORS.text;
}

function toggleFilterPopover() {
    closeAllPopovers('filter-popover');
    var popover = document.getElementById('filter-popover');
    popover.classList.toggle('open');
    if (popover.classList.contains('open')) {
        renderFilterList();
    }
}

function renderFilterList() {
    if (!currentTable || !currentViewState) return;

    var filters = currentViewState.filters || [];
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);

    var html = '';

    if (filters.length === 0) {
        html = '<div style="color: #999; text-align: center; padding: 8px;">No filters active. Click "Add filter" to create one.</div>';
    } else {
        filters.forEach((filter, index) => {
            var fieldMeta = fields[filter.fieldId];
            var fieldType = fieldMeta ? fieldMeta.fieldType : 'text';
            var operators = getOperatorsForFieldType(fieldType);

            html += '<div class="filter-row" data-index="' + index + '">';

            // Field selector
            html += '<select class="filter-select" onchange="updateFilterField(' + index + ', this.value)">';
            fieldIds.forEach(fid => {
                var fname = fields[fid].fieldName || fid;
                html += '<option value="' + esc(fid) + '"' + (filter.fieldId === fid ? ' selected' : '') + '>' + esc(fname) + '</option>';
            });
            html += '</select>';

            // Operator selector
            html += '<select class="filter-select" onchange="updateFilterOperator(' + index + ', this.value)">';
            operators.forEach(op => {
                html += '<option value="' + esc(op.value) + '"' + (filter.operator === op.value ? ' selected' : '') + '>' + esc(op.label) + '</option>';
            });
            html += '</select>';

            // Value input (hide for isEmpty/isNotEmpty operators)
            if (!['isEmpty', 'isNotEmpty', 'isChecked', 'isNotChecked'].includes(filter.operator)) {
                if (fieldType && (fieldType.toLowerCase() === 'singleselect' || fieldType.toLowerCase() === 'multipleselects')) {
                    // Show choices dropdown
                    var choices = fieldMeta?.options?.choices || [];
                    html += '<select class="filter-select" onchange="updateFilterValue(' + index + ', this.value)">';
                    html += '<option value="">Select...</option>';
                    choices.forEach(c => {
                        var cname = c.name || c;
                        html += '<option value="' + esc(cname) + '"' + (filter.value === cname ? ' selected' : '') + '>' + esc(cname) + '</option>';
                    });
                    html += '</select>';
                } else {
                    html += '<input class="filter-input" type="text" value="' + esc(filter.value || '') + '" placeholder="Value" onchange="updateFilterValue(' + index + ', this.value)" onkeyup="if(event.key===\'Enter\')applyFiltersAndRender()">';
                }
            }

            html += '<button class="filter-remove" onclick="removeFilter(' + index + ')"></button>';
            html += '</div>';
        });
    }

    document.getElementById('filter-list').innerHTML = html;
}

function addFilter() {
    if (!currentTable || !currentViewState) return;

    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);
    if (fieldIds.length === 0) return;

    var firstField = fieldIds[0];
    var fieldType = fields[firstField]?.fieldType || 'text';
    var operators = getOperatorsForFieldType(fieldType);

    currentViewState.filters = currentViewState.filters || [];
    currentViewState.filters.push({
        id: 'filter_' + Date.now(),
        fieldId: firstField,
        operator: operators[0].value,
        value: ''
    });

    renderFilterList();
    updateFilterCount();
}

async function removeFilter(index) {
    if (!currentViewState) return;
    currentViewState.filters.splice(index, 1);
    await setViewState(currentTable, currentViewState);
    renderFilterList();
    renderFilterPills();
    updateFilterCount();
    await renderTable();
}

async function clearAllFilters() {
    if (!currentViewState) return;
    currentViewState.filters = [];
    await setViewState(currentTable, currentViewState);
    renderFilterList();
    renderFilterPills();
    updateFilterCount();
    await renderTable();
}

async function updateFilterField(index, fieldId) {
    if (!currentViewState || !currentViewState.filters[index]) return;

    var fields = META_FIELDS[currentTable] || {};
    var fieldType = fields[fieldId]?.fieldType || 'text';
    var operators = getOperatorsForFieldType(fieldType);

    currentViewState.filters[index].fieldId = fieldId;
    currentViewState.filters[index].operator = operators[0].value;
    currentViewState.filters[index].value = '';

    renderFilterList();
}

async function updateFilterOperator(index, operator) {
    if (!currentViewState || !currentViewState.filters[index]) return;
    currentViewState.filters[index].operator = operator;
    renderFilterList();
}

async function updateFilterValue(index, value) {
    if (!currentViewState || !currentViewState.filters[index]) return;
    currentViewState.filters[index].value = value;
}

async function applyFiltersAndRender() {
    if (!currentViewState) return;
    await setViewState(currentTable, currentViewState);
    renderFilterPills();
    updateFilterCount();
    currentPage = 0;
    await renderTable();
}

function updateFilterCount() {
    var badge = document.getElementById('filter-count');
    var btn = document.getElementById('filter-btn');
    var count = currentViewState ? (currentViewState.filters || []).length : 0;

    if (count > 0) {
        badge.textContent = count;
        badge.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        badge.style.display = 'none';
        btn.classList.remove('active');
    }
}

function renderFilterPills() {
    var container = document.getElementById('filter-pills-container');
    if (!currentViewState || !currentViewState.filters || currentViewState.filters.length === 0) {
        container.style.display = 'none';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};
    var html = '';

    currentViewState.filters.forEach((filter, index) => {
        var fieldName = fields[filter.fieldId]?.fieldName || filter.fieldId;
        var opLabel = filter.operator;
        var operators = getOperatorsForFieldType(fields[filter.fieldId]?.fieldType);
        var opObj = operators.find(o => o.value === filter.operator);
        if (opObj) opLabel = opObj.label;

        var text = fieldName + ' ' + opLabel;
        if (filter.value && !['isEmpty', 'isNotEmpty', 'isChecked', 'isNotChecked'].includes(filter.operator)) {
            text += ' "' + filter.value + '"';
        }

        html += '<div class="filter-pill">';
        html += '<span>' + esc(text) + '</span>';
        html += '<button onclick="removeFilter(' + index + ')"></button>';
        html += '</div>';
    });

    html += '<span class="clear-filters" onclick="clearAllFilters()">Clear all</span>';

    container.innerHTML = html;
    container.style.display = 'flex';
}

// Filter evaluation functions
function applyFilters(records, filters) {
    if (!filters || filters.length === 0) return records;

    return records.filter(record => {
        return filters.every(filter => evaluateFilter(record, filter));
    });
}

function evaluateFilter(record, filter) {
    var fields = META_FIELDS[currentTable] || {};
    var fieldMeta = fields[filter.fieldId];
    var value = record.fields ? record.fields[filter.fieldId] : null;

    // Also try by field name
    if (value === undefined && fieldMeta) {
        value = record.fields ? record.fields[fieldMeta.fieldName] : null;
    }

    var filterValue = filter.value;
    var op = filter.operator;

    // Handle null/undefined values
    if (op === 'isEmpty') {
        return value == null || value === '' || (Array.isArray(value) && value.length === 0);
    }
    if (op === 'isNotEmpty') {
        return value != null && value !== '' && !(Array.isArray(value) && value.length === 0);
    }
    if (op === 'isChecked') {
        return value === true;
    }
    if (op === 'isNotChecked') {
        return value !== true;
    }

    // Convert arrays for comparison
    var valueStr = Array.isArray(value) ? value.join(', ') : String(value || '');
    var valueLower = valueStr.toLowerCase();
    var filterLower = String(filterValue || '').toLowerCase();

    switch (op) {
        case 'contains':
            return valueLower.includes(filterLower);
        case 'notContains':
            return !valueLower.includes(filterLower);
        case 'equals':
        case 'is':
            if (typeof value === 'number') {
                return value === parseFloat(filterValue);
            }
            return valueLower === filterLower;
        case 'notEquals':
        case 'isNot':
            if (typeof value === 'number') {
                return value !== parseFloat(filterValue);
            }
            return valueLower !== filterLower;
        case 'startsWith':
            return valueLower.startsWith(filterLower);
        case 'endsWith':
            return valueLower.endsWith(filterLower);
        case 'gt':
            return parseFloat(value) > parseFloat(filterValue);
        case 'lt':
            return parseFloat(value) < parseFloat(filterValue);
        case 'gte':
            return parseFloat(value) >= parseFloat(filterValue);
        case 'lte':
            return parseFloat(value) <= parseFloat(filterValue);
        case 'isBefore':
            return new Date(value) < new Date(filterValue);
        case 'isAfter':
            return new Date(value) > new Date(filterValue);
        case 'hasAnyOf':
            if (!Array.isArray(value)) value = [value];
            return value.some(v => String(v).toLowerCase() === filterLower);
        case 'hasAllOf':
            if (!Array.isArray(value)) value = [value];
            return filterValue.split(',').every(fv =>
                value.some(v => String(v).toLowerCase() === fv.trim().toLowerCase())
            );
        default:
            return true;
    }
}

// ============ Grouping ============

function toggleGroupPopover() {
    closeAllPopovers('group-popover');
    var popover = document.getElementById('group-popover');
    popover.classList.toggle('open');
    if (popover.classList.contains('open')) {
        renderGroupFieldList();
    }
}

function renderGroupFieldList() {
    if (!currentTable) return;

    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);
    var groupByField = currentViewState ? currentViewState.groupBy : null;

    var html = '<div class="group-popover-item' + (!groupByField ? ' active' : '') + '" onclick="setGroupBy(null)">';
    html += '<input type="radio" name="group-field"' + (!groupByField ? ' checked' : '') + '>';
    html += '<label>No grouping</label>';
    html += '</div>';

    fieldIds.forEach(fid => {
        var fieldName = fields[fid].fieldName || fid;
        var isActive = groupByField === fid;

        html += '<div class="group-popover-item' + (isActive ? ' active' : '') + '" onclick="setGroupBy(\'' + esc(fid) + '\')">';
        html += '<input type="radio" name="group-field"' + (isActive ? ' checked' : '') + '>';
        html += '<label>' + esc(fieldName) + '</label>';
        html += '</div>';
    });

    document.getElementById('group-field-list').innerHTML = html;
}

async function setGroupBy(fieldId) {
    if (!currentTable || !currentViewState) return;

    currentViewState.groupBy = fieldId;
    currentViewState.expandedGroups = []; // Reset expanded groups

    await setViewState(currentTable, currentViewState);
    document.getElementById('group-popover').classList.remove('open');
    updateGroupButton();
    currentPage = 0;
    await renderTable();
}

async function clearGroupBy() {
    await setGroupBy(null);
}

function updateGroupButton() {
    var btn = document.getElementById('group-btn');
    var hasGroup = currentViewState && currentViewState.groupBy;
    if (hasGroup) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

function toggleGroupExpanded(groupKey) {
    if (!currentViewState) return;

    var expandedGroups = currentViewState.expandedGroups || [];
    var index = expandedGroups.indexOf(groupKey);

    if (index >= 0) {
        expandedGroups.splice(index, 1);
    } else {
        expandedGroups.push(groupKey);
    }

    currentViewState.expandedGroups = expandedGroups;
    setViewState(currentTable, currentViewState);

    // Toggle UI
    var header = document.querySelector('.group-header[data-group="' + CSS.escape(groupKey) + '"]');
    var rows = document.querySelector('.group-rows[data-group="' + CSS.escape(groupKey) + '"]');

    if (header && rows) {
        header.classList.toggle('collapsed');
        rows.classList.toggle('collapsed');
    }
}

function groupRecords(records, fieldId) {
    if (!fieldId) return { '': records };

    var fields = META_FIELDS[currentTable] || {};
    var fieldMeta = fields[fieldId];
    var groups = {};
    var emptyGroup = [];

    records.forEach(record => {
        var value = record.fields ? record.fields[fieldId] : null;
        // Also try by field name
        if (value === undefined && fieldMeta) {
            value = record.fields ? record.fields[fieldMeta.fieldName] : null;
        }

        if (value == null || value === '' || (Array.isArray(value) && value.length === 0)) {
            emptyGroup.push(record);
        } else if (Array.isArray(value)) {
            // For multi-select, record appears in each group
            value.forEach(v => {
                var groupKey = typeof v === 'object' ? (v.name || String(v)) : String(v);
                if (!groups[groupKey]) groups[groupKey] = [];
                groups[groupKey].push(record);
            });
        } else {
            var groupKey = typeof value === 'object' ? (value.name || String(value)) : String(value);
            if (!groups[groupKey]) groups[groupKey] = [];
            groups[groupKey].push(record);
        }
    });

    // Add empty group at the end
    if (emptyGroup.length > 0) {
        groups['(Empty)'] = emptyGroup;
    }

    return groups;
}

function formatGroupValue(groupKey, fieldId) {
    if (groupKey === '(Empty)') {
        return '<span style="color: #999; font-style: italic;">(Empty)</span>';
    }

    // Check if it's a select field to show colored badge
    if (fieldId && currentTable) {
        var fields = META_FIELDS[currentTable] || {};
        var fieldMeta = fields[fieldId];
        if (fieldMeta) {
            var fieldType = (fieldMeta.fieldType || '').toLowerCase();
            if (fieldType === 'singleselect' || fieldType === 'multipleselects' ||
                fieldType.includes('select')) {
                return formatColorBadge(groupKey, fieldId);
            }
        }
    }

    return esc(groupKey);
}

// ============ Field History ============

function saveFieldHistory(historyEntries) {
    return new Promise((resolve, reject) => {
        if (!historyEntries.length) return resolve();
        if (!db.objectStoreNames.contains('fieldHistory')) return resolve();
        var tx = db.transaction('fieldHistory', 'readwrite');
        var store = tx.objectStore('fieldHistory');
        historyEntries.forEach(entry => store.add(entry));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getFieldHistoryForRecord(tableId, recordId) {
    return new Promise((resolve, reject) => {
        if (!db.objectStoreNames.contains('fieldHistory')) {
            resolve([]);
            return;
        }
        var tx = db.transaction('fieldHistory', 'readonly');
        var index = tx.objectStore('fieldHistory').index('by_record');
        var req = index.getAll([tableId, recordId]);
        req.onsuccess = () => {
            // Sort by eventId descending (most recent first)
            var results = req.result || [];
            results.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
            resolve(results);
        };
        req.onerror = () => reject(req.error);
    });
}

function getLocalStats() {
    return new Promise(async (resolve) => {
        try {
            var tempDb = await openDB();
            var count = await new Promise((res, rej) => {
                var tx = tempDb.transaction('data', 'readonly');
                var req = tx.objectStore('data').count();
                req.onsuccess = () => res(req.result);
                req.onerror = () => res(0);
            });
            var lastId = await new Promise((res, rej) => {
                var tx = tempDb.transaction('sync', 'readonly');
                var req = tx.objectStore('sync').get('lastEventId');
                req.onsuccess = () => res(req.result ? req.result.value : 0);
                req.onerror = () => res(0);
            });
            tempDb.close();
            resolve({ count, lastId });
        } catch (e) {
            resolve({ count: 0, lastId: 0 });
        }
    });
}

// ============ Auth ============

document.getElementById('auth-submit').onclick = tryAuth;
document.getElementById('api-key-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('set-filter-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('auth-clear').onclick = clearLocalAndReset;

async function initAuthScreen() {
    var stats = await getLocalStats();
    var infoEl = document.getElementById('auth-info');
    var clearBtn = document.getElementById('auth-clear');

    if (stats.count > 0) {
        infoEl.textContent = 'Local cache: ' + stats.count.toLocaleString() + ' records';
        clearBtn.classList.remove('hidden');
    } else {
        infoEl.textContent = 'No local data';
        clearBtn.classList.add('hidden');
    }
}

async function clearLocalAndReset() {
    if (!confirm('Clear all local data?')) return;
    try {
        db = await openDB();
        await clearAllData();
        db.close();
        db = null;
    } catch (e) {
        console.error('Clear error:', e);
    }
    initAuthScreen();
}

async function tryAuth() {
    var key = document.getElementById('api-key-input').value.trim();
    if (!key) {
        showAuthError('Please enter an API key');
        return;
    }

    var btn = document.getElementById('auth-submit');
    btn.textContent = 'Connecting...';
    btn.disabled = true;
    document.getElementById('auth-error').style.display = 'none';

    API_KEY = key;
    SET_FILTER = document.getElementById('set-filter-input').value.trim() || null;

    try {
        await init();
    } catch (err) {
        console.error('Init error:', err);
        showAuthError('Connection failed: ' + err.message);
        btn.textContent = 'Connect';
        btn.disabled = false;
        return;
    }

    btn.textContent = 'Connect';
    btn.disabled = false;
}

function showAuthError(msg) {
    var el = document.getElementById('auth-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function hideAuthScreen() {
    document.getElementById('auth-screen').classList.add('hidden');
}

function showAuthScreen() {
    document.getElementById('auth-screen').classList.remove('hidden');
    if (pollInterval) clearInterval(pollInterval);
    initAuthScreen();
}

function logout() {
    if (pollInterval) clearInterval(pollInterval);
    API_KEY = null;
    SET_FILTER = null;
    showAuthScreen();
}

async function manualSync() {
    if (!API_KEY) return;
    await incrementalSync();
}

// ============ Data Processing ============

function parsePayload(payload) {
    if (typeof payload === 'string') {
        try { return JSON.parse(payload); } catch { return null; }
    }
    return payload;
}

async function processEvents(events) {
    if (!events || !Array.isArray(events)) return;

    var tables = [];
    var fields = [];
    var views = [];
    var dataRecords = [];
    var fieldHistoryEntries = [];
    var tableDataMap = {}; // tableId -> { recordId -> fields }

    for (var e of events) {
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;
        var eventId = e.id;
        var timestamp = Date.now();

        if (recordType === 'table') {
            // Tables: recordId starts with "tbl", set points to base
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            tables.push(tableData);
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            // Fields: recordId starts with "fld", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            fields.push(fieldData);
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            // Views: recordId starts with "viw", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            views.push(viewData);
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else {
            // Data record: recordId starts with "rec"
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) {
                tableDataMap[tableId][recordId] = {};
            }

            var state = tableDataMap[tableId][recordId];

            // Track field history for INS (insert/create)
            if (pfields.INS) {
                for (var fieldId in pfields.INS) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'created',
                        oldValue: null,
                        newValue: pfields.INS[fieldId]
                    });
                }
                Object.assign(state, pfields.INS);
            }

            // Track field history for ALT (alter/update)
            if (pfields.ALT) {
                for (var fieldId in pfields.ALT) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'updated',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.ALT[fieldId]
                    });
                }
                Object.assign(state, pfields.ALT);
            }

            // Track field history for NUL (nullify/delete)
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'deleted',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: null
                    });
                    delete state[fieldId];
                });
            }
        }

        if (e.id && e.id > lastEventId) {
            lastEventId = e.id;
        }
    }

    // Convert tableDataMap to dataRecords array
    for (var tableId in tableDataMap) {
        for (var recordId in tableDataMap[tableId]) {
            dataRecords.push({
                tableId,
                recordId,
                fields: tableDataMap[tableId][recordId]
            });
        }
    }

    // Save batch
    if (tables.length || fields.length || views.length || dataRecords.length) {
        await saveBatch(tables, fields, views, dataRecords);
    }

    // Save field history
    if (fieldHistoryEntries.length) {
        await saveFieldHistory(fieldHistoryEntries);
    }
}

function applyPayloadFields(target, payload) {
    if (!payload.fields) return;
    var fields = payload.fields;
    if (fields.INS) Object.assign(target, fields.INS);
    if (fields.ALT) Object.assign(target, fields.ALT);
    if (fields.NUL && Array.isArray(fields.NUL)) {
        fields.NUL.forEach(k => delete target[k]);
    }
}

// ============ Schema Builder UI ============

function toggleMode() {
    schemaMode = !schemaMode;
    var btn = document.getElementById('mode-toggle-btn');
    var icon = document.getElementById('mode-icon');
    var text = document.getElementById('mode-text');
    var schemaView = document.getElementById('schema-view');
    var dataView = document.getElementById('data-view');

    if (schemaMode) {
        btn.className = 'mode-toggle-btn schema';
        icon.innerHTML = '&#9638;';
        text.textContent = 'Schema Builder';
        schemaView.style.display = 'flex';
        dataView.style.display = 'none';
        renderSchemaBuilder();
    } else {
        btn.className = 'mode-toggle-btn data';
        icon.innerHTML = '&#9776;';
        text.textContent = 'Data Viewer';
        schemaView.style.display = 'none';
        dataView.style.display = 'flex';
        if (currentTable) {
            showTable(currentTable);
        }
    }
}

function showSchemaTab(tab) {
    currentSchemaTab = tab;

    // Update tab UI
    document.getElementById('tab-tables').className = 'schema-tab' + (tab === 'tables' ? ' active' : '');
    document.getElementById('tab-fields').className = 'schema-tab' + (tab === 'fields' ? ' active' : '');
    document.getElementById('tab-views').className = 'schema-tab' + (tab === 'views' ? ' active' : '');

    // Show/hide table selector for fields and views tabs
    var tableSelectorContainer = document.getElementById('table-selector-container');
    if (tab === 'fields' || tab === 'views') {
        tableSelectorContainer.style.display = 'block';
        renderTableSelector();
    } else {
        tableSelectorContainer.style.display = 'none';
    }

    renderSchemaContent();
}

function toggleTableSelector() {
    var dropdown = document.getElementById('table-selector-dropdown');
    dropdown.classList.toggle('open');
}

function selectSchemaTable(tableId) {
    selectedSchemaTable = tableId;
    var tableName = tableId ? (META_TABLES[tableId]?.tableName || tableId) : 'All Tables';
    document.getElementById('selected-table-name').textContent = tableName;
    document.getElementById('table-selector-dropdown').classList.remove('open');
    renderSchemaContent();
}

async function renderTableSelector() {
    var dropdown = document.getElementById('table-selector-dropdown');
    var tables = await getAllTables();

    // Also get tables from META_TABLES
    for (var tid in META_TABLES) {
        if (!tables.find(t => t.tableId === tid)) {
            tables.push(META_TABLES[tid]);
        }
    }

    tables.sort((a, b) => (a.tableName || a.tableId).localeCompare(b.tableName || b.tableId));

    var html = '<div class="table-selector-option' + (!selectedSchemaTable ? ' active' : '') + '" onclick="selectSchemaTable(null)">All Tables</div>';
    for (var table of tables) {
        var isActive = selectedSchemaTable === table.tableId;
        html += '<div class="table-selector-option' + (isActive ? ' active' : '') + '" onclick="selectSchemaTable(\'' + esc(table.tableId) + '\')">' + esc(table.tableName || table.tableId) + '</div>';
    }

    dropdown.innerHTML = html;
}

async function renderSchemaBuilder() {
    await updateSchemaCounts();
    renderSchemaContent();
}

async function updateSchemaCounts() {
    var tables = await getSchemaByPrefix('tbl');
    var fields = await getSchemaByPrefix('fld');
    var views = await getSchemaByPrefix('viw');

    document.getElementById('tables-count').textContent = tables.length;
    document.getElementById('fields-count').textContent = fields.length;
    document.getElementById('views-count').textContent = views.length;
}

async function renderSchemaContent() {
    var content = document.getElementById('schema-content');

    if (currentSchemaTab === 'tables') {
        await renderTablesTab(content);
    } else if (currentSchemaTab === 'fields') {
        await renderFieldsTab(content);
    } else if (currentSchemaTab === 'views') {
        await renderViewsTab(content);
    }
}

async function renderTablesTab(content) {
    var tables = await getSchemaByPrefix('tbl');

    if (tables.length === 0) {
        content.innerHTML = '<div class="schema-empty"><div class="schema-empty-icon">&#128451;</div><h3>No Tables Found</h3><p>Sync data to see your Airtable schema</p></div>';
        return;
    }

    // Sort by table name
    tables.sort((a, b) => (a.tableName || a.tableId).localeCompare(b.tableName || b.tableId));

    var html = '<div class="schema-grid">';
    for (var table of tables) {
        var fieldCount = META_FIELDS[table.tableId] ? Object.keys(META_FIELDS[table.tableId]).length : 0;
        var viewCount = META_VIEWS[table.tableId] ? Object.keys(META_VIEWS[table.tableId]).length : 0;

        html += '<div class="schema-card" onclick="viewTableSchema(\'' + esc(table.tableId) + '\')">';
        html += '<div class="schema-card-header">';
        html += '<div class="schema-card-icon table">&#128451;</div>';
        html += '<div>';
        html += '<div class="schema-card-title">' + esc(table.tableName || table.tableId) + '</div>';
        html += '<div class="schema-card-id">' + esc(table.tableId) + '</div>';
        html += '</div>';
        html += '</div>';
        html += '<div class="schema-card-body">';
        html += '<div class="schema-card-meta">';
        html += '<span class="schema-meta-item"><strong>' + fieldCount + '</strong> fields</span>';
        html += '<span class="schema-meta-item"><strong>' + viewCount + '</strong> views</span>';
        if (table.primaryFieldId) {
            html += '<span class="schema-meta-item">Primary: <strong>' + esc(table.primaryFieldId.slice(-8)) + '</strong></span>';
        }
        html += '</div>';
        html += '</div>';
        html += '</div>';
    }
    html += '</div>';

    content.innerHTML = html;
}

async function renderFieldsTab(content) {
    var fields = await getSchemaByPrefix('fld');

    // Filter by selected table
    if (selectedSchemaTable) {
        fields = fields.filter(f => f.tableId === selectedSchemaTable);
    }

    if (fields.length === 0) {
        var msg = selectedSchemaTable ? 'No fields found for this table' : 'No fields found';
        content.innerHTML = '<div class="schema-empty"><div class="schema-empty-icon">&#128203;</div><h3>' + msg + '</h3><p>Sync data to see your field definitions</p></div>';
        return;
    }

    // Sort by table, then field name
    fields.sort((a, b) => {
        var tableCompare = (a.tableId || '').localeCompare(b.tableId || '');
        if (tableCompare !== 0) return tableCompare;
        return (a.fieldName || a.fieldId).localeCompare(b.fieldName || b.fieldId);
    });

    var html = '<div class="schema-grid">';
    for (var field of fields) {
        var tableName = META_TABLES[field.tableId]?.tableName || field.tableId;
        var fieldTypeClass = getFieldTypeClass(field.fieldType);

        html += '<div class="schema-card" onclick="viewFieldDetails(\'' + esc(field.tableId) + '\', \'' + esc(field.fieldId) + '\')">';
        html += '<div class="schema-card-header">';
        html += '<div class="schema-card-icon field">&#128203;</div>';
        html += '<div>';
        html += '<div class="schema-card-title">' + esc(field.fieldName || field.fieldId) + '</div>';
        html += '<div class="schema-card-id">' + esc(field.fieldId) + '</div>';
        html += '</div>';
        html += '</div>';
        html += '<div class="schema-card-body">';
        html += '<div class="schema-card-meta">';
        html += '<span class="field-type-badge ' + fieldTypeClass + '">' + esc(field.fieldType || 'unknown') + '</span>';
        html += '<span class="schema-meta-item">Table: <strong>' + esc(tableName) + '</strong></span>';
        if (field.options && field.options.choices) {
            html += '<span class="schema-meta-item"><strong>' + field.options.choices.length + '</strong> choices</span>';
        }
        html += '</div>';
        html += '</div>';
        html += '</div>';
    }
    html += '</div>';

    content.innerHTML = html;
}

async function renderViewsTab(content) {
    var views = await getSchemaByPrefix('viw');

    // Filter by selected table
    if (selectedSchemaTable) {
        views = views.filter(v => v.tableId === selectedSchemaTable);
    }

    if (views.length === 0) {
        var msg = selectedSchemaTable ? 'No views found for this table' : 'No views found';
        content.innerHTML = '<div class="schema-empty"><div class="schema-empty-icon">&#128065;</div><h3>' + msg + '</h3><p>Sync data to see your view definitions</p></div>';
        return;
    }

    // Sort by table, then view name
    views.sort((a, b) => {
        var tableCompare = (a.tableId || '').localeCompare(b.tableId || '');
        if (tableCompare !== 0) return tableCompare;
        return (a.viewName || a.viewId).localeCompare(b.viewName || b.viewId);
    });

    var html = '<div class="schema-grid">';
    for (var view of views) {
        var tableName = META_TABLES[view.tableId]?.tableName || view.tableId;
        var viewTypeClass = getViewTypeClass(view.viewType);

        html += '<div class="schema-card" onclick="viewViewDetails(\'' + esc(view.tableId) + '\', \'' + esc(view.viewId) + '\')">';
        html += '<div class="schema-card-header">';
        html += '<div class="schema-card-icon view">&#128065;</div>';
        html += '<div>';
        html += '<div class="schema-card-title">' + esc(view.viewName || view.viewId) + '</div>';
        html += '<div class="schema-card-id">' + esc(view.viewId) + '</div>';
        html += '</div>';
        html += '</div>';
        html += '<div class="schema-card-body">';
        html += '<div class="schema-card-meta">';
        html += '<span class="view-type-badge ' + viewTypeClass + '">' + esc(view.viewType || 'grid') + '</span>';
        html += '<span class="schema-meta-item">Table: <strong>' + esc(tableName) + '</strong></span>';
        html += '</div>';
        html += '</div>';
        html += '</div>';
    }
    html += '</div>';

    content.innerHTML = html;
}

function getFieldTypeClass(fieldType) {
    if (!fieldType) return 'default';
    var type = fieldType.toLowerCase();
    if (type.includes('text') || type.includes('string') || type === 'singlelinetext' || type === 'multilinetext' || type === 'richtext') return 'text';
    if (type.includes('number') || type === 'currency' || type === 'percent' || type === 'autonumber') return 'number';
    if (type.includes('select') || type === 'singleselect' || type === 'multipleselects') return 'select';
    if (type.includes('date') || type === 'datetime' || type === 'createdtime' || type === 'lastmodifiedtime') return 'date';
    if (type === 'checkbox') return 'checkbox';
    if (type.includes('link') || type === 'multiplerecordlinks') return 'link';
    if (type === 'attachment' || type === 'multipleattachments') return 'attachment';
    if (type === 'formula') return 'formula';
    if (type === 'rollup') return 'rollup';
    if (type === 'lookup' || type === 'multiplelookupvalues') return 'lookup';
    return 'default';
}

function getViewTypeClass(viewType) {
    if (!viewType) return 'default';
    var type = viewType.toLowerCase();
    if (type === 'grid') return 'grid';
    if (type === 'gallery') return 'gallery';
    if (type === 'kanban') return 'kanban';
    if (type === 'calendar') return 'calendar';
    if (type === 'timeline') return 'timeline';
    if (type === 'form') return 'form';
    return 'default';
}

function viewTableSchema(tableId) {
    // Switch to fields tab filtered by this table
    selectedSchemaTable = tableId;
    showSchemaTab('fields');
}

function viewFieldDetails(tableId, fieldId) {
    // Could show a modal with field details in the future
    var field = META_FIELDS[tableId]?.[fieldId];
    if (field) {
        console.log('Field details:', field);
        alert('Field: ' + (field.fieldName || fieldId) + '\nType: ' + (field.fieldType || 'unknown') + '\nID: ' + fieldId);
    }
}

function viewViewDetails(tableId, viewId) {
    // Could show a modal with view details in the future
    var view = META_VIEWS[tableId]?.[viewId];
    if (view) {
        console.log('View details:', view);
        alert('View: ' + (view.viewName || viewId) + '\nType: ' + (view.viewType || 'grid') + '\nID: ' + viewId);
    }
}

function updateSchemaStatus(msg, isSynced, progress, detail) {
    var dot = document.getElementById('schema-status-dot');
    var text = document.getElementById('schema-status-text');
    var progressBar = document.getElementById('schema-progress-bar');
    var progressFill = document.getElementById('schema-progress-fill');
    var statusDetail = document.getElementById('schema-status-detail');

    if (dot) dot.className = 'status-dot ' + (isSynced ? 'synced' : 'loading');
    if (text) text.textContent = msg;

    if (progressBar && progressFill) {
        if (typeof progress === 'number' && progress >= 0) {
            progressBar.style.display = 'block';
            progressFill.style.width = Math.min(100, progress) + '%';
        } else {
            progressBar.style.display = 'none';
        }
    }

    if (statusDetail) statusDetail.textContent = detail || '';
}

// ============ UI ============

async function renderSidebar() {
    var tableList = document.getElementById('table-list');
    tableList.innerHTML = '';

    var tables = await getAllTables();

    // Also get tables from META_TABLES (in-memory from current session)
    for (var tid in META_TABLES) {
        if (!tables.find(t => t.tableId === tid)) {
            tables.push(META_TABLES[tid]);
        }
    }

    tables.sort((a, b) => (a.tableName || a.tableId).localeCompare(b.tableName || b.tableId));

    for (var table of tables) {
        var tableId = table.tableId;
        var tableName = table.tableName || tableId;

        var div = document.createElement('div');
        div.className = 'table-item' + (tableId === currentTable ? ' active' : '');
        div.innerHTML = '<span class="table-icon"></span>' + esc(tableName) + '<span class="count" id="count-' + tableId + '"></span>';
        div.onclick = ((t) => () => showTable(t))(tableId);
        tableList.appendChild(div);
    }

    // Update counts asynchronously
    for (var table of tables) {
        getRecordIdsForTable(table.tableId).then(((tid) => (ids) => {
            var el = document.getElementById('count-' + tid);
            if (el) el.textContent = ids.length.toLocaleString();
        })(table.tableId));
    }
}

function updateStatus(msg, isSynced, progress, detail) {
    var dot = document.getElementById('status-dot');
    var text = document.getElementById('status-text');
    var progressBar = document.getElementById('progress-bar');
    var progressFill = document.getElementById('progress-fill');
    var statusDetail = document.getElementById('status-detail');

    dot.className = 'status-dot ' + (isSynced ? 'synced' : 'loading');
    text.textContent = msg;

    if (typeof progress === 'number' && progress >= 0) {
        progressBar.style.display = 'block';
        progressFill.style.width = Math.min(100, progress) + '%';
    } else {
        progressBar.style.display = 'none';
    }

    statusDetail.textContent = detail || '';
}

async function showTable(tableId) {
    currentTable = tableId;
    currentPage = 0;

    var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
    var tableName = table.tableName || tableId;

    document.getElementById('title').textContent = tableName;

    // Update sidebar
    document.querySelectorAll('.table-item').forEach(el => el.classList.remove('active'));
    var activeItem = [...document.querySelectorAll('.table-item')].find(el => el.textContent.includes(tableName));
    if (activeItem) activeItem.classList.add('active');

    // Show loading state immediately
    showTableLoading('Loading table structure...');

    // Load view state (sort, filters, etc.)
    currentViewState = await getViewState(tableId);

    // Update UI state for view controls
    updateHiddenCount();
    updateFilterCount();
    updateGroupButton();

    // Load fields first (table structure)
    var fields = await getFieldsForTable(tableId);
    META_FIELDS[tableId] = {};
    fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

    // Show table headers immediately with skeleton rows (even before data loads)
    renderTableHeaders();

    // Update status (don't overwrite table headers with loading spinner)
    updateStatus('Loading records...', false, null, null);

    // Load record IDs
    currentRecordIds = await getRecordIdsForTable(tableId);
    totalRecords = currentRecordIds.length;

    // Now render full table with data
    await renderTable();
}

function showTableLoading(message) {
    var container = document.getElementById('table-container');
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>' + esc(message) + '</h3></div>';
    document.getElementById('pagination').style.display = 'none';
}

function renderTableHeaders() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);

    if (fieldIds.length === 0) {
        // No fields yet, show loading
        return;
    }

    var colList = [];
    var colNames = {};
    fieldIds.forEach(fid => {
        colList.push(fid);
        colNames[fid] = fields[fid].fieldName || fid;
    });

    // Build table with headers and skeleton rows
    var html = '<table id="table"><thead><tr><th>ID</th>';
    colList.forEach(col => {
        html += '<th title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    // Add skeleton loading rows
    for (var i = 0; i < 5; i++) {
        html += '<tr class="skeleton-row"><td><div class="skeleton-cell" style="width: 60px;"></div></td>';
        colList.forEach(() => {
            html += '<td><div class="skeleton-cell" style="width: ' + (60 + Math.random() * 80) + 'px;"></div></td>';
        });
        html += '</tr>';
    }

    html += '</tbody></table>';
    container.innerHTML = html;
}

async function renderTable() {
    if (!currentTable) return;

    var tableEl = document.getElementById('table');

    // Get ALL records for the table (needed for sorting/filtering)
    var allRecords = await getRecordsByIds(currentTable, currentRecordIds);

    // Apply filters if set
    if (currentViewState && currentViewState.filters && currentViewState.filters.length > 0) {
        allRecords = applyFilters(allRecords, currentViewState.filters);
    }

    // Apply sorting if set
    if (currentViewState && currentViewState.sort) {
        allRecords = sortRecords(allRecords, currentViewState.sort.fieldId, currentViewState.sort.direction);
    }

    // Update totalRecords after filtering
    totalRecords = allRecords.length;

    // Update filter UI
    renderFilterPills();
    updateFilterCount();

    if (allRecords.length === 0) {
        tableEl.innerHTML = '';
        document.getElementById('table-container').innerHTML = '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        document.getElementById('pagination').style.display = 'none';
        return;
    }

    // Paginate the sorted results
    var pageRecords = allRecords.slice(currentPage * PAGE_SIZE, (currentPage + 1) * PAGE_SIZE);

    document.getElementById('table-container').innerHTML = '<table id="table"></table>';
    tableEl = document.getElementById('table');

    // Get columns (excluding hidden fields)
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);
    var hiddenFields = currentViewState ? (currentViewState.hiddenFields || []) : [];

    var colList = [];
    var colNames = {};

    if (fieldIds.length > 0) {
        fieldIds.forEach(fid => {
            if (!hiddenFields.includes(fid)) {
                colList.push(fid);
                colNames[fid] = fields[fid].fieldName || fid;
            }
        });
    } else {
        // Discover from data
        var colSet = {};
        allRecords.forEach(r => {
            if (r.fields) Object.keys(r.fields).forEach(k => {
                if (!hiddenFields.includes(k)) colSet[k] = true;
            });
        });
        colList = Object.keys(colSet).sort();
        colList.forEach(c => colNames[c] = c);
    }

    // Update hidden count badge
    updateHiddenCount();

    // Build table with sortable headers
    var currentSort = currentViewState ? currentViewState.sort : null;
    var html = '<thead><tr><th style="width: 70px;">Actions</th><th>ID</th>';
    colList.forEach(col => {
        var isSorted = currentSort && currentSort.fieldId === col;
        var sortClass = 'sortable' + (isSorted ? ' sorted' : '');
        var sortIndicator = '';
        if (isSorted) {
            sortIndicator = currentSort.direction === 'asc' ? ' ' : ' ';
        } else {
            sortIndicator = ' ';
        }
        html += '<th class="' + sortClass + '" title="' + esc(col) + '" onclick="toggleSort(\'' + esc(col) + '\')">';
        html += esc(colNames[col]);
        html += '<span class="sort-indicator">' + sortIndicator + '</span>';
        html += '</th>';
    });
    html += '</tr></thead>';

    // Check if grouping is enabled
    var groupByField = currentViewState ? currentViewState.groupBy : null;
    var expandedGroups = currentViewState ? (currentViewState.expandedGroups || []) : [];

    if (groupByField) {
        // Grouped rendering - no pagination within groups for simplicity
        var groups = groupRecords(allRecords, groupByField);
        var groupKeys = Object.keys(groups).sort((a, b) => {
            if (a === '(Empty)') return 1;
            if (b === '(Empty)') return -1;
            return a.localeCompare(b);
        });

        groupKeys.forEach(groupKey => {
            var groupRecords = groups[groupKey];
            var isCollapsed = !expandedGroups.includes(groupKey);
            var colSpan = colList.length + 1;

            // Group header row (colspan + 1 for actions column)
            html += '<tbody><tr class="group-header' + (isCollapsed ? ' collapsed' : '') + '" data-group="' + esc(groupKey) + '" onclick="toggleGroupExpanded(\'' + esc(groupKey.replace(/'/g, "\\'")) + '\')">';
            html += '<td colspan="' + (colSpan + 1) + '">';
            html += '<span class="group-toggle"></span>';
            html += '<span class="group-value">';
            html += formatGroupValue(groupKey, groupByField);
            html += '</span>';
            html += '<span class="group-count">(' + groupRecords.length + ')</span>';
            html += '</td></tr></tbody>';

            // Group records
            html += '<tbody class="group-rows' + (isCollapsed ? ' collapsed' : '') + '" data-group="' + esc(groupKey) + '">';
            groupRecords.forEach(record => {
                var rid = record.recordId;
                var row = record.fields || {};
                html += '<tr>';
                // History button
                html += '<td><button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="View field history">';
                html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
                html += 'History</button></td>';
                html += '<td>' + esc(rid.slice(-8)) + '</td>';
                colList.forEach(col => {
                    var value = row[col];
                    if (value === undefined) value = row[colNames[col]];
                    html += '<td>' + formatCell(value, col) + '</td>';
                });
                html += '</tr>';
            });
            html += '</tbody>';
        });

        // Hide pagination when grouped
        document.getElementById('pagination').style.display = 'none';
    } else {
        // Normal pagination rendering
        html += '<tbody>';
        pageRecords.forEach(record => {
            var rid = record.recordId;
            var row = record.fields || {};
            html += '<tr>';
            // History button
            html += '<td><button class="history-btn" onclick="openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="View field history">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
            html += 'History</button></td>';
            html += '<td>' + esc(rid.slice(-8)) + '</td>';
            colList.forEach(col => {
                var value = row[col];
                if (value === undefined) value = row[colNames[col]];
                html += '<td>' + formatCell(value, col) + '</td>';
            });
            html += '</tr>';
        });
        html += '</tbody>';
    }

    tableEl.innerHTML = html;

    // Update pagination
    updatePagination();
    updateStatus('Up to date', true, null, totalRecords.toLocaleString() + ' records');
}

function formatCell(v, fieldId) {
    if (v == null || v === '') {
        return '<span class="cell-empty"></span>';
    }

    // Check if this is a select field - use color badges
    if (fieldId && currentTable) {
        var fields = META_FIELDS[currentTable] || {};
        var fieldMeta = fields[fieldId];
        if (fieldMeta) {
            var fieldType = (fieldMeta.fieldType || '').toLowerCase();
            if (fieldType === 'singleselect' || fieldType === 'multipleselects' ||
                fieldType.includes('select')) {
                return formatColorBadge(v, fieldId);
            }
        }
    }

    if (Array.isArray(v)) {
        if (v.length === 0) return '<span class="cell-empty"></span>';

        // Check if it's an array of objects (linked records, attachments, etc.)
        if (typeof v[0] === 'object' && v[0] !== null) {
            var items = v.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return '<span class="cell-array">' + items.map(i => '<span class="tag">' + esc(i) + '</span>').join('') + '</span>';
        }

        // Simple array - join with commas
        return '<span class="cell-array">' + v.map(i => '<span class="tag">' + esc(String(i)) + '</span>').join('') + '</span>';
    }

    if (typeof v === 'object') {
        // Single object
        if (v.name) return esc(v.name);
        if (v.filename) return esc(v.filename);
        if (v.email) return esc(v.email);
        if (v.url) return '<a class="cell-link" href="' + esc(v.url) + '" target="_blank">' + esc(v.url.slice(0, 40)) + '</a>';
        return esc(JSON.stringify(v).slice(0, 50));
    }

    if (typeof v === 'boolean') {
        return '<span class="cell-bool ' + v + '">' + (v ? 'Yes' : 'No') + '</span>';
    }

    if (typeof v === 'number') {
        return '<span class="cell-number">' + v.toLocaleString() + '</span>';
    }

    // String - check for URLs
    var str = String(v);
    if (str.startsWith('http://') || str.startsWith('https://')) {
        return '<a class="cell-link" href="' + esc(str) + '" target="_blank">' + esc(str.slice(0, 50)) + '</a>';
    }

    return esc(str);
}

function updatePagination() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    var start = currentPage * PAGE_SIZE + 1;
    var end = Math.min((currentPage + 1) * PAGE_SIZE, totalRecords);

    document.getElementById('page-info').textContent = start + '-' + end + ' of ' + totalRecords.toLocaleString();
    document.getElementById('prev-btn').disabled = currentPage === 0;
    document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
    document.getElementById('pagination').style.display = totalRecords > PAGE_SIZE ? 'flex' : 'none';
}

function prevPage() {
    if (currentPage > 0) {
        currentPage--;
        renderTable();
    }
}

function nextPage() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    if (currentPage < totalPages - 1) {
        currentPage++;
        renderTable();
    }
}

// ============ API ============

async function fetchPage(page, afterId) {
    var url = API + '?page=' + page + '&per_page=500';
    if (API_KEY) url += '&apiKey=' + encodeURIComponent(API_KEY);
    if (afterId) url += '&id=' + afterId;
    if (SET_FILTER) url += '&set=' + encodeURIComponent(SET_FILTER);

    var res = await fetch(url);

    if (res.status === 401 || res.status === 403) {
        throw new Error('Invalid API key');
    }

    var data = await res.json();

    if (!res.ok) {
        throw new Error(data.message || data.error || 'HTTP ' + res.status);
    }

    var events = Array.isArray(data) ? data : (data.items || data.data || []);
    var hasMore = Array.isArray(data) ? events.length >= 500 : !!data.nextPage;
    var nextPage = Array.isArray(data) ? page + 1 : data.nextPage;

    return { events, hasMore, nextPage };
}

async function fullSync() {
    var page = 1;
    var eventsLoaded = 0;
    var tablesFound = 0;
    var fieldsFound = 0;
    var viewsFound = 0;
    var recordsFound = 0;

    while (true) {
        // Show progress with estimates (assume ~50 pages max for progress bar)
        var progressPct = Math.min(95, (page / 50) * 100);
        var detail = tablesFound + ' tables, ' + fieldsFound + ' fields, ' + viewsFound + ' views, ' + recordsFound.toLocaleString() + ' records';
        updateStatus('Syncing page ' + page + '...', false, progressPct, detail);
        updateSchemaStatus('Syncing page ' + page + '...', false, progressPct, detail);

        var result = await fetchPage(page, null);
        if (!result.events || result.events.length === 0) break;

        eventsLoaded += result.events.length;
        result.events.sort((a, b) => (a.id || 0) - (b.id || 0));

        // Count what we're processing for feedback
        for (var e of result.events) {
            var payload = parsePayload(e.payload);
            if (payload && payload._set === 'table') tablesFound++;
            else if (payload && payload._set === 'field') fieldsFound++;
            else if (payload && payload._set === 'view') viewsFound++;
            else recordsFound++;
        }

        await processEvents(result.events);

        // Update sidebar after EVERY page to show tables/fields as they arrive
        await renderSidebar();

        // Update schema builder if in schema mode
        if (schemaMode) {
            await updateSchemaCounts();
            await renderSchemaContent();
        }

        // If in data mode and table is selected, refresh the view
        if (!schemaMode) {
            if (!currentTable && Object.keys(META_TABLES).length > 0) {
                var firstTable = Object.keys(META_TABLES)[0];
                await showTable(firstTable);
            } else if (currentTable) {
                // Refresh current table view to show new data
                currentRecordIds = await getRecordIdsForTable(currentTable);
                totalRecords = currentRecordIds.length;
                await renderTable();
            }
        }

        if (!result.hasMore) break;
        page = result.nextPage || page + 1;
        if (page > 500) break;
    }

    await setSyncMeta('lastEventId', lastEventId);
    var finalDetail = tablesFound + ' tables, ' + fieldsFound + ' fields, ' + viewsFound + ' views, ' + recordsFound.toLocaleString() + ' records';
    updateStatus('Synced ' + eventsLoaded.toLocaleString() + ' events', true, null, finalDetail);
    updateSchemaStatus('Synced ' + eventsLoaded.toLocaleString() + ' events', true, null, finalDetail);
}

async function incrementalSync() {
    try {
        updateStatus('Checking for updates...', false, null, null);
        updateSchemaStatus('Checking for updates...', false, null, null);

        var result = await fetchPage(1, lastEventId);

        if (result.events && result.events.length > 0) {
            updateStatus('Processing ' + result.events.length + ' new events...', false, null, null);
            updateSchemaStatus('Processing ' + result.events.length + ' new events...', false, null, null);
            result.events.sort((a, b) => (a.id || 0) - (b.id || 0));
            await processEvents(result.events);
            await setSyncMeta('lastEventId', lastEventId);

            updateStatus('Updating views...', false, null, null);
            await renderSidebar();

            // Update schema builder if in schema mode
            if (schemaMode) {
                await updateSchemaCounts();
                await renderSchemaContent();
            }

            // Update data view if in data mode
            if (!schemaMode && currentTable) {
                currentRecordIds = await getRecordIdsForTable(currentTable);
                totalRecords = currentRecordIds.length;
                await renderTable();
            }

            updateStatus('Up to date', true, null, result.events.length + ' events synced');
            updateSchemaStatus('Up to date', true, null, result.events.length + ' events synced');
        } else {
            updateStatus('Up to date', true, null, null);
            updateSchemaStatus('Up to date', true, null, null);
        }
    } catch (err) {
        console.error('Sync error:', err);
        updateStatus('Sync error: ' + err.message, false, null, null);
        updateSchemaStatus('Sync error: ' + err.message, false, null, null);
    }
}

// ============ Init ============

async function init() {
    META_TABLES = {};
    META_FIELDS = {};
    META_VIEWS = {};
    currentTable = null;
    currentPage = 0;
    currentRecordIds = [];
    totalRecords = 0;
    lastEventId = 0;
    schemaMode = true; // Start in schema builder mode

    db = await openDB();

    updateStatus('Loading local data...', false, null, null);
    updateSchemaStatus('Loading local data...', false, null, null);

    var storedLastId = await getSyncMeta('lastEventId');
    var tables = await getAllTables();
    var fields = await getAllFields();
    var views = await getAllViews();

    // Load metadata into memory
    tables.forEach(t => META_TABLES[t.tableId] = t);
    fields.forEach(f => {
        if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
        META_FIELDS[f.tableId][f.fieldId] = f;
    });
    views.forEach(v => {
        if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
        META_VIEWS[v.tableId][v.viewId] = v;
    });

    hideAuthScreen();

    // Always start with schema builder view
    document.getElementById('schema-view').style.display = 'flex';
    document.getElementById('data-view').style.display = 'none';

    if (tables.length > 0) {
        updateSchemaStatus('Found ' + tables.length + ' tables', false, null, 'Loading schema...');
        await renderSidebar();
        await renderSchemaBuilder();

        lastEventId = storedLastId || 0;
        await incrementalSync();
    } else {
        updateSchemaStatus('Starting initial sync...', false, 0, 'Fetching data from server...');
        await renderSidebar();
        await fullSync();
        await renderSidebar();
        await renderSchemaBuilder();
    }

    updateStatus('Up to date', true, null, null);
    updateSchemaStatus('Up to date', true, null, null);

    if (pollInterval) clearInterval(pollInterval);
    pollInterval = setInterval(incrementalSync, 60000);
}

// ============ Field History Modal ============

var currentHistoryData = [];
var currentHistoryRecordId = null;
var currentHistoryTableId = null;

async function openHistoryModal(tableId, recordId) {
    currentHistoryTableId = tableId;
    currentHistoryRecordId = recordId;

    // Set modal title
    var tableName = META_TABLES[tableId]?.tableName || tableId;
    document.getElementById('history-modal-title').textContent = 'Field History - ' + tableName;
    document.getElementById('history-modal-record-id').textContent = recordId;

    // Show modal with loading state
    var overlay = document.getElementById('history-modal-overlay');
    var body = document.getElementById('history-modal-body');
    body.innerHTML = '<div class="modal-empty"><div class="loading-spinner"></div><h3>Loading history...</h3></div>';
    overlay.classList.add('open');

    // Fetch history data
    try {
        currentHistoryData = await getFieldHistoryForRecord(tableId, recordId);
        renderHistoryModal();
    } catch (err) {
        console.error('Error loading history:', err);
        body.innerHTML = '<div class="modal-empty"><h3>Error loading history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closeHistoryModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('history-modal-overlay').classList.remove('open');
    currentHistoryData = [];
    currentHistoryRecordId = null;
    currentHistoryTableId = null;
}

function renderHistoryModal() {
    var body = document.getElementById('history-modal-body');
    var filterSelect = document.getElementById('history-field-filter');
    var countEl = document.getElementById('history-count');

    if (!currentHistoryData || currentHistoryData.length === 0) {
        body.innerHTML = '<div class="modal-empty"><h3>No history available</h3><p>Field changes will appear here after the next sync</p></div>';
        filterSelect.innerHTML = '<option value="">All Fields</option>';
        countEl.textContent = '0 changes';
        return;
    }

    // Build field filter options
    var fieldIds = [...new Set(currentHistoryData.map(h => h.fieldId))];
    var fields = META_FIELDS[currentHistoryTableId] || {};

    var filterHtml = '<option value="">All Fields</option>';
    fieldIds.forEach(fid => {
        var fieldName = fields[fid]?.fieldName || fid;
        filterHtml += '<option value="' + esc(fid) + '">' + esc(fieldName) + '</option>';
    });
    filterSelect.innerHTML = filterHtml;

    // Get selected filter
    var selectedField = filterSelect.value;
    var filteredData = selectedField
        ? currentHistoryData.filter(h => h.fieldId === selectedField)
        : currentHistoryData;

    countEl.textContent = filteredData.length + ' change' + (filteredData.length !== 1 ? 's' : '');

    // Render history items
    var html = '<div class="history-timeline">';

    for (var item of filteredData) {
        var fieldName = fields[item.fieldId]?.fieldName || item.fieldId;
        var changeTypeClass = item.changeType || 'updated';
        var timestamp = item.timestamp ? formatTimestamp(item.timestamp) : 'Unknown time';

        html += '<div class="history-item">';
        html += '<div class="history-item-header">';
        html += '<span class="history-field-name">' + esc(fieldName) + '</span>';
        html += '<span class="history-change-type ' + changeTypeClass + '">' + changeTypeClass + '</span>';
        html += '<span class="history-timestamp">' + esc(timestamp) + '</span>';
        html += '<span class="history-event-id">Event #' + (item.eventId || '?') + '</span>';
        html += '</div>';

        html += '<div class="history-values">';

        // Old value
        if (item.changeType !== 'created') {
            html += '<div class="history-value-box ' + (item.oldValue === null ? 'null' : 'old') + '">';
            html += '<div class="history-value-label">Previous</div>';
            html += '<div class="history-value-content">' + formatHistoryValue(item.oldValue) + '</div>';
            html += '</div>';
            html += '<span class="history-arrow">&#8594;</span>';
        }

        // New value
        html += '<div class="history-value-box ' + (item.newValue === null ? 'null' : 'new') + '">';
        html += '<div class="history-value-label">' + (item.changeType === 'created' ? 'Initial Value' : 'New Value') + '</div>';
        html += '<div class="history-value-content">' + formatHistoryValue(item.newValue) + '</div>';
        html += '</div>';

        html += '</div>'; // .history-values
        html += '</div>'; // .history-item
    }

    html += '</div>';
    body.innerHTML = html;
}

function filterHistoryByField() {
    renderHistoryModal();
}

function formatTimestamp(ts) {
    if (!ts) return 'Unknown';
    var date = new Date(ts);
    var now = new Date();
    var diff = now - date;

    // If less than 24 hours, show relative time
    if (diff < 86400000) {
        if (diff < 60000) return 'Just now';
        if (diff < 3600000) return Math.floor(diff / 60000) + ' min ago';
        return Math.floor(diff / 3600000) + ' hour' + (Math.floor(diff / 3600000) !== 1 ? 's' : '') + ' ago';
    }

    // Otherwise show date and time
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatHistoryValue(value) {
    if (value === null || value === undefined) {
        return '<span style="color: #999; font-style: italic;">empty</span>';
    }

    if (Array.isArray(value)) {
        if (value.length === 0) return '<span style="color: #999; font-style: italic;">empty array</span>';

        // Check if it's an array of objects
        if (typeof value[0] === 'object' && value[0] !== null) {
            var items = value.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return items.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(i) + '</span>').join('');
        }

        return value.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(String(i)) + '</span>').join('');
    }

    if (typeof value === 'object') {
        if (value.name) return esc(value.name);
        if (value.filename) return esc(value.filename);
        if (value.email) return esc(value.email);
        return esc(JSON.stringify(value).slice(0, 100));
    }

    if (typeof value === 'boolean') {
        return '<span style="padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; ' +
            (value ? 'background: #d4edda; color: #155724;' : 'background: #f8d7da; color: #721c24;') + '">' +
            (value ? 'Yes' : 'No') + '</span>';
    }

    if (typeof value === 'number') {
        return '<span style="font-family: monospace;">' + value.toLocaleString() + '</span>';
    }

    return esc(String(value));
}

// Keyboard handler for modal
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        var overlay = document.getElementById('history-modal-overlay');
        if (overlay && overlay.classList.contains('open')) {
            closeHistoryModal();
        }
    }
});

function esc(s) {
    if (s == null) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

initAuthScreen();
    </script>
</body>
</html>
