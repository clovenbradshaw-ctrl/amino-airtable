<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DB Viewer</title>
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <style>
        /* ===== Noema Design System - CSS Variables ===== */
        :root {
            /* Color Palette */
            --primary-50: #eff6ff;
            --primary-100: #dbeafe;
            --primary-200: #bfdbfe;
            --primary-300: #93c5fd;
            --primary-400: #60a5fa;
            --primary-500: #3b82f6;
            --primary-600: #2563eb;
            --primary-700: #1d4ed8;
            --primary-800: #1e40af;

            --gray-50: #f8fafc;
            --gray-100: #f1f5f9;
            --gray-200: #e2e8f0;
            --gray-300: #cbd5e1;
            --gray-400: #94a3b8;
            --gray-500: #64748b;
            --gray-600: #475569;
            --gray-700: #334155;
            --gray-800: #1e293b;
            --gray-900: #0f172a;
            --gray-950: #020617;

            --success-500: #22c55e;
            --success-600: #16a34a;
            --warning-500: #f59e0b;
            --warning-600: #d97706;
            --danger-500: #ef4444;
            --danger-600: #dc2626;

            /* Amino brand tokens */
            --amino-blue: #3b82f6;
            --amino-green: #22c55e;
            --amino-slate-300: #cbd5e1;
            --amino-focus-ring: rgba(59, 130, 246, 0.24);

            /* Semantic Colors - Dark Theme Default */
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --bg-elevated: #1e293b;
            --bg-hover: rgba(255, 255, 255, 0.06);
            --bg-active: rgba(255, 255, 255, 0.1);

            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --text-disabled: #475569;

            --border-primary: #334155;
            --border-secondary: #475569;

            /* Sizing */
            --sidebar-width: 288px;
            --header-height: 52px;
            --tab-bar-height: 38px;
            --status-bar-height: 28px;

            /* Typography */
            --font-sans: 'Inter', 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Consolas', monospace;

            /* Transitions */
            --transition-fast: 0.1s ease;
            --transition-normal: 0.2s ease;
            --transition-slow: 0.3s ease;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            --shadow-xl: 0 20px 60px rgba(0, 0, 0, 0.6);

            /* Radii */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --radius-xl: 12px;
        }

        /* Light Theme Override */
        html.light-theme {
            --bg-primary: #ffffff;
            --bg-secondary: #f1f5f9;
            --bg-tertiary: #e2e8f0;
            --bg-elevated: #ffffff;
            --bg-hover: rgba(0, 0, 0, 0.06);
            --bg-active: rgba(0, 0, 0, 0.10);

            --text-primary: #0f172a;
            --text-secondary: #1e293b;
            --text-muted: #475569;
            --text-disabled: #94a3b8;

            --border-primary: #cbd5e1;
            --border-secondary: #94a3b8;

            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.12);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.18);
            --shadow-xl: 0 20px 60px rgba(0, 0, 0, 0.22);
        }

        /* Light theme: fix hardcoded bright colors for readability on light backgrounds */
        html.light-theme .cell-bool.true { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .cell-bool.false { background: rgba(220, 38, 38, 0.12); color: #dc2626; }

        html.light-theme .cell-array .tag { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .cell-link { color: #2563eb; }
        html.light-theme .cell-date { color: #475569; }

        /* History change type badges */
        html.light-theme .history-change-type.created { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .history-change-type.updated { background: rgba(37, 99, 235, 0.12); color: #2563eb; }
        html.light-theme .history-change-type.deleted { background: rgba(220, 38, 38, 0.12); color: #dc2626; }
        html.light-theme .history-actor { background: rgba(217, 119, 6, 0.12); color: #b45309; }
        html.light-theme .history-device { background: rgba(13, 148, 136, 0.12); color: #0d9488; }
        html.light-theme .history-source { background: rgba(100, 116, 139, 0.12); color: #64748b; }

        /* Sync status badges */
        html.light-theme .sync-status-badge.synced { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .sync-status-badge.syncing { background: rgba(217, 119, 6, 0.12); color: #b45309; }
        html.light-theme .sync-status-badge.error { background: rgba(220, 38, 38, 0.12); color: #dc2626; }
        html.light-theme .sync-status-badge.queued { background: rgba(234, 88, 12, 0.12); color: #c2410c; }
        html.light-theme .sync-result-badge.queued { background: rgba(234, 88, 12, 0.10); color: #c2410c; }
        html.light-theme .queue-count-badge { background: rgba(234, 88, 12, 0.15); color: #c2410c; }
        html.light-theme .sync-status-card.queue-highlight { border-color: rgba(234, 88, 12, 0.3); background: rgba(234, 88, 12, 0.04); }
        html.light-theme .sync-status-card.queue-highlight .card-value { color: #c2410c; }
        html.light-theme .sync-status-card.queue-highlight .card-label { color: #c2410c; }

        /* Sync type badges */
        html.light-theme .sync-history-table .sync-type-badge.incremental { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .sync-history-table .sync-type-badge.full { background: rgba(124, 58, 237, 0.10); color: #7c3aed; }
        html.light-theme .sync-history-table .sync-type-badge.snapshot { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .sync-history-table .sync-type-badge.error { background: rgba(220, 38, 38, 0.10); color: #dc2626; }
        html.light-theme .sync-history-table .sync-type-badge.edit { background: rgba(14, 165, 233, 0.10); color: #0284c7; }
        html.light-theme .sync-result-badge.success { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .sync-result-badge.error { background: rgba(220, 38, 38, 0.10); color: #dc2626; }

        /* Events table badges */
        html.light-theme .events-table .event-set { color: #2563eb; background: rgba(37, 99, 235, 0.10); }
        html.light-theme .events-table .event-record-id { color: #15803d; background: rgba(22, 163, 74, 0.10); }
        html.light-theme .events-table .event-type-badge.data { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .events-table .event-type-badge.INS { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .events-table .event-type-badge.ALT { background: rgba(217, 119, 6, 0.10); color: #b45309; }
        html.light-theme .events-table .event-type-badge.NUL { background: rgba(220, 38, 38, 0.10); color: #dc2626; }
        html.light-theme .events-table .event-type-badge.SYN { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .events-table .event-type-badge.table { background: rgba(217, 119, 6, 0.10); color: #b45309; }
        html.light-theme .events-table .event-type-badge.field { background: rgba(124, 58, 237, 0.10); color: #7c3aed; }
        html.light-theme .events-table .event-type-badge.view { background: rgba(219, 39, 119, 0.10); color: #be185d; }
        html.light-theme .events-table .event-type-badge.viewconfig { background: rgba(124, 58, 237, 0.10); color: #7c3aed; }
        html.light-theme .events-table .event-type-badge.current { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .events-table .field-op-badge.INS { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .events-table .field-op-badge.ALT { background: rgba(217, 119, 6, 0.10); color: #b45309; }
        html.light-theme .events-table .field-op-badge.NUL { background: rgba(220, 38, 38, 0.10); color: #dc2626; }
        html.light-theme .events-table .field-op-badge.SYN { background: rgba(37, 99, 235, 0.10); color: #2563eb; }

        /* JSON syntax highlighting */
        html.light-theme .json-key { color: #7c3aed; }
        html.light-theme .json-string { color: #15803d; }
        html.light-theme .json-number { color: #2563eb; }
        html.light-theme .json-boolean { color: #dc2626; }

        /* Payload field colors */
        html.light-theme .payload-field-name { color: #7c3aed; }
        html.light-theme .payload-field-value.string { color: #15803d; }
        html.light-theme .payload-field-value.number { color: #2563eb; }
        html.light-theme .payload-field-value.boolean { color: #dc2626; }
        html.light-theme .payload-field-value.array { color: #7c3aed; }
        html.light-theme .payload-field-value.object { color: #0e7490; }
        html.light-theme .payload-op-label.INS { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .payload-op-label.ALT { background: rgba(217, 119, 6, 0.12); color: #b45309; }
        html.light-theme .payload-op-label.NUL { background: rgba(220, 38, 38, 0.12); color: #dc2626; }

        /* Sync feed line colors */
        html.light-theme .sync-feed-line.info { color: #2563eb; }
        html.light-theme .sync-feed-line.success { color: #15803d; }
        html.light-theme .sync-feed-line.error { color: #dc2626; }
        html.light-theme .sync-feed-line.warn { color: #b45309; }

        /* Sync activity log */
        html.light-theme .sync-activity-log .log-line.info .message { color: #2563eb; }
        html.light-theme .sync-activity-log .log-line.success .message { color: #15803d; }
        html.light-theme .sync-activity-log .log-line.error .message { color: #dc2626; }
        html.light-theme .sync-activity-log .log-line.warn .message { color: #b45309; }

        /* Error/success/warning text */
        html.light-theme .auth-error { color: #dc2626; background: rgba(220, 38, 38, 0.08); border-color: rgba(220, 38, 38, 0.25); }
        html.light-theme .synapse-login-box .synapse-error { color: #dc2626; background: rgba(220, 38, 38, 0.08); border-color: rgba(220, 38, 38, 0.25); }
        html.light-theme .unlock-error { color: #dc2626; background: rgba(220, 38, 38, 0.08); border-color: rgba(220, 38, 38, 0.25); }
        html.light-theme .wizard-error { color: #dc2626; background: rgba(220, 38, 38, 0.08); border-color: rgba(220, 38, 38, 0.25); }
        html.light-theme .wizard-success { color: #15803d; background: rgba(22, 163, 74, 0.08); border-color: rgba(22, 163, 74, 0.25); }

        /* View tags */
        html.light-theme .view-tag { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .view-tag.workspace { background: rgba(217, 119, 6, 0.10); color: #b45309; }

        /* View type badges */
        html.light-theme .view-type-badge.schema { background: rgba(124, 58, 237, 0.12); color: #7c3aed; }
        html.light-theme .view-type-badge.grid { background: rgba(37, 99, 235, 0.12); color: #2563eb; }

        /* Historical notice */
        html.light-theme .historical-notice { background: rgba(217, 119, 6, 0.08); border-color: rgba(217, 119, 6, 0.3); color: #92400e; }
        html.light-theme .pit-modal-header .pit-event-badge { background: rgba(217, 119, 6, 0.12); color: #b45309; }

        /* Profile sync history */
        html.light-theme .profile-sync-history-type.created { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .profile-sync-history-type.updated { background: rgba(37, 99, 235, 0.12); color: #2563eb; }
        html.light-theme .profile-sync-history-type.deleted { background: rgba(220, 38, 38, 0.12); color: #dc2626; }
        html.light-theme .profile-sync-history-actor { background: rgba(217, 119, 6, 0.12); color: #b45309; }
        html.light-theme .profile-sync-history-device { background: rgba(13, 148, 136, 0.12); color: #0d9488; }
        html.light-theme .profile-sync-history-source { background: rgba(100, 116, 139, 0.12); color: #64748b; }
        html.light-theme .profile-sync-history-value.old { background: rgba(220, 38, 38, 0.06); color: #991b1b; }
        html.light-theme .profile-sync-history-value.new { background: rgba(22, 163, 74, 0.06); color: #166534; }
        html.light-theme .record-history-event-operator.INS { background: rgba(22, 163, 74, 0.12); color: #15803d; }
        html.light-theme .record-history-event-operator.ALT { background: rgba(37, 99, 235, 0.12); color: #2563eb; }
        html.light-theme .record-history-event-operator.NUL { background: rgba(220, 38, 38, 0.12); color: #dc2626; }
        html.light-theme .record-history-event-operator.SYN { background: rgba(147, 51, 234, 0.12); color: #7c3aed; }

        /* Context menu danger */
        html.light-theme .view-context-menu-item.danger { color: #dc2626; }
        html.light-theme .view-context-menu-item.danger:hover { background: rgba(220, 38, 38, 0.08); }
        html.light-theme .filter-remove-btn:hover { background: rgba(220, 38, 38, 0.08); color: #dc2626; }
        html.light-theme .sort-remove-btn:hover { background: rgba(220, 38, 38, 0.08); color: #dc2626; }

        /* Active view items and primary accent adjustments */
        html.light-theme .view-control-btn.active { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .table-view-item.active { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .browser-tab.active .tab-icon { color: #2563eb; }
        html.light-theme .profile-tab.active { color: #2563eb; }
        html.light-theme .row-height-option.selected { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .row-height-option.selected svg { color: #2563eb; }
        html.light-theme .view-selector-option.active { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .fields-btn .fields-count { background: rgba(37, 99, 235, 0.10); color: #2563eb; }

        /* Loading progress container */
        html.light-theme .loading-progress-container { background: rgba(0, 0, 0, 0.03); }
        html.light-theme .loading-note { background: rgba(0, 0, 0, 0.03); }

        /* ===== Base Reset & Layout ===== */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ===== Custom Scrollbars ===== */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border-secondary); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        * { scrollbar-width: thin; scrollbar-color: var(--border-secondary) transparent; }

        /* ===== Sidebar ===== */
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-track { background: transparent; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border-primary); border-radius: 3px; }
        .sidebar::-webkit-scrollbar-thumb:hover { background: var(--border-secondary); }

        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            overflow-y: auto;
            flex-shrink: 0;
            font-family: var(--font-sans);
            display: flex;
            flex-direction: column;
            contain: layout style;
            will-change: contents;
        }
        .sidebar-header { padding: 16px; border-bottom: 1px solid var(--border-primary); }
        .sidebar-header-top { display: flex; align-items: center; gap: 10px; margin-bottom: 14px; }
        .sidebar-logo {
            width: 28px; height: 28px; border-radius: 8px;
            background: linear-gradient(135deg, var(--primary-500) 0%, #8b5cf6 100%);
            display: flex; align-items: center; justify-content: center;
        }
        .sidebar-logo svg { width: 14px; height: 14px; color: #fff; }
        .sidebar-header h2 { color: var(--text-primary); font-size: 15px; font-weight: 600; letter-spacing: -0.01em; }

        /* Sidebar Search */
        .sidebar-search { position: relative; }
        .sidebar-search-icon { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: var(--text-muted); pointer-events: none; }
        .sidebar-search-icon svg { width: 14px; height: 14px; }
        .sidebar-search input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: 9px 44px 9px 36px;
            font-size: 13px;
            color: var(--text-primary);
            transition: all var(--transition-fast);
        }
        .sidebar-search input::placeholder { color: var(--text-muted); }
        .sidebar-search input:focus {
            outline: none;
            border-color: var(--primary-500);
            background: var(--bg-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
        }
        .sidebar-search-shortcut {
            position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
            font-size: 10px; color: var(--text-muted);
            background: var(--bg-tertiary); padding: 3px 6px;
            border-radius: var(--radius-sm); border: 1px solid var(--border-primary);
            font-family: system-ui, sans-serif;
        }

        /* Section Headers */
        .sidebar-section-header {
            display: flex; align-items: center; gap: 8px;
            padding: 10px 16px; font-size: 11px; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.05em;
            color: var(--text-muted); cursor: pointer;
            transition: color var(--transition-fast); user-select: none;
        }
        .sidebar-section-header:hover { color: var(--text-secondary); }
        .sidebar-section-header:active { color: var(--text-primary); background: var(--bg-hover); transition: background-color 0.05s, color 0.05s; border-radius: var(--radius-sm); }
        .sidebar-section-header svg { width: 12px; height: 12px; transition: transform 0.2s; }
        .sidebar-section-header.collapsed svg { transform: rotate(-90deg); }
        .sidebar-section-header .section-icon { opacity: 0.8; }
        .sidebar-section-header .section-count { margin-left: auto; font-weight: 400; color: var(--text-muted); }

        .sidebar-divider { height: 1px; background: var(--border-primary); margin: 8px 16px; }

        /* Fast sidebar search: hide structural elements via CSS class on container */
        #table-list.sidebar-searching > .sidebar-section-header,
        #table-list.sidebar-searching > .sidebar-divider { display: none; }
        #table-list .sidebar-search-hidden { display: none !important; }

        /* Table Items */
        .table-wrapper { contain: layout style; }
        .sidebar div.table-item {
            padding: 9px 12px; margin: 2px 8px; border-radius: var(--radius-lg);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
            display: flex; align-items: center; gap: 10px;
            transition: background-color var(--transition-fast), color var(--transition-fast); position: relative;
        }
        .sidebar div.table-item:hover { background: var(--bg-hover); color: var(--text-primary); }
        .sidebar div.table-item:active { background: var(--bg-active); color: var(--text-primary); transition: background-color 0.05s, color 0.05s; }
        .sidebar div.table-item.active {
            background: var(--bg-tertiary); color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }
        .sidebar div.table-item.active::before {
            content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%);
            width: 3px; height: 20px; border-radius: 0 2px 2px 0;
            background: var(--type-color, var(--primary-500));
        }
        .sidebar div.table-item .table-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .sidebar div.table-item .count { font-size: 11px; color: var(--text-muted); font-variant-numeric: tabular-nums; }
        .sidebar div.table-item.active .count { color: var(--text-secondary); }
        .sidebar div.table-item:hover .count { color: var(--text-secondary); }

        /* Table Type Icons */
        .table-icon {
            width: 20px; height: 20px; border-radius: 5px; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
        }
        .table-icon svg { width: 12px; height: 12px; }
        .table-icon.type-events { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .table-icon.type-operational { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
        .table-icon.type-collection { background: rgba(139, 92, 246, 0.2); color: #8b5cf6; }
        .table-icon.type-reference { background: rgba(16, 185, 129, 0.2); color: #10b981; }
        .table-icon.type-dev { background: rgba(107, 114, 128, 0.2); color: #9ca3af; }
        .table-icon.type-room { background: rgba(99, 102, 241, 0.2); color: #6366f1; }

        /* Room meta (room ID shown under name) */
        .room-meta { font-size: 10px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 140px; opacity: 0.7; }

        /* Count Bar */
        .count-bar-wrapper { display: flex; align-items: center; gap: 6px; min-width: 54px; justify-content: flex-end; }
        .count-bar { height: 4px; border-radius: 2px; transition: all var(--transition-fast); opacity: 0.6; }
        .count-value { font-size: 11px; font-variant-numeric: tabular-nums; min-width: 28px; text-align: right; }

        /* Pin Button */
        .pin-btn {
            padding: 4px; border-radius: var(--radius-sm); background: transparent;
            border: none; cursor: pointer; opacity: 0;
            transition: all var(--transition-fast);
            display: flex; align-items: center; justify-content: center;
        }
        .pin-btn svg { width: 12px; height: 12px; color: var(--text-muted); }
        .pin-btn:hover svg { color: #f59e0b; }
        .pin-btn.pinned { opacity: 1; }
        .pin-btn.pinned svg { color: #f59e0b; fill: #f59e0b; }
        .sidebar div.table-item:hover .pin-btn { opacity: 1; }

        /* Expand Arrow */
        .sidebar div.table-item .expand-arrow {
            font-size: 10px; color: var(--text-muted);
            transition: transform 0.2s; padding: 4px;
        }
        .sidebar div.table-item.expanded .expand-arrow { transform: rotate(90deg); }
        .sidebar div.table-item:hover .expand-arrow { color: var(--text-secondary); }

        /* Table Views List */
        .table-views-list {
            display: none;
            background: var(--bg-primary);
            margin: 0 8px; border-radius: 0 0 var(--radius-lg) var(--radius-lg);
            contain: content;
        }
        .table-views-list.expanded { display: block; }
        .table-view-item {
            padding: 7px 12px 7px 40px; cursor: pointer;
            font-size: 12px; color: var(--text-muted);
            display: flex; align-items: center; gap: 8px;
            transition: background-color var(--transition-fast), color var(--transition-fast);
            margin: 1px 4px; border-radius: var(--radius-md);
        }
        .table-view-item:hover { background: var(--bg-hover); color: var(--text-primary); }
        .table-view-item:active { background: var(--bg-active); color: var(--text-primary); transition: background-color 0.05s, color 0.05s; }
        .table-view-item.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .table-view-item.active:active { background: rgba(59, 130, 246, 0.25); }
        .table-view-item .view-icon { font-size: 12px; width: 16px; text-align: center; color: var(--text-muted); }
        .table-view-item:hover .view-icon, .table-view-item.active .view-icon { color: inherit; }
        .table-view-item .view-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .table-view-item .view-name-input {
            flex: 1; background: var(--bg-primary); border: 1px solid var(--primary-500);
            border-radius: var(--radius-sm); color: var(--text-primary);
            font-size: 12px; padding: 3px 8px; outline: none; min-width: 0;
        }
        .table-view-item .view-name-input:focus { border-color: var(--primary-400); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }
        .table-view-default { color: var(--text-muted); font-style: italic; }

        /* Sidebar Footer - Theme Toggle */
        .sidebar-footer {
            margin-top: auto; padding: 12px 16px;
            border-top: 1px solid var(--border-primary);
            display: flex; flex-wrap: wrap; align-items: center; gap: 8px;
        }
        .theme-toggle-btn {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 10px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            color: var(--text-secondary); font-size: 12px; cursor: pointer;
            transition: all var(--transition-fast); flex: 1;
        }
        .theme-toggle-btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--border-secondary); }

        /* Matrix connection status */
        .theme-toggle-btn.matrix-connected { border-color: var(--success-500); color: var(--success-500); }
        .theme-toggle-btn.matrix-connected:hover { background: rgba(34,197,94,0.1); }

        /* ===== Room Publishing Modal ===== */
        .room-publish-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; display: flex; align-items: center; justify-content: center; }
        .room-publish-modal.hidden { display: none !important; }
        .room-publish-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 24px; width: 480px; max-height: 80vh; overflow-y: auto; box-shadow: var(--shadow-xl); }
        .room-publish-box h2 { font-size: 18px; margin-bottom: 4px; color: var(--text-primary); }
        .room-publish-box .pub-subtitle { font-size: 13px; color: var(--text-muted); margin-bottom: 20px; }
        .room-publish-section { margin-bottom: 16px; }
        .room-publish-section h3 { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .room-table-item { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); margin-bottom: 6px; cursor: pointer; transition: all var(--transition-fast); }
        .room-table-item:hover { border-color: var(--primary-500); background: var(--bg-hover); }
        .room-table-item input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--primary-500); flex-shrink: 0; }
        .room-table-item .table-info { flex: 1; }
        .room-table-item .table-info .table-name { font-size: 13px; font-weight: 500; color: var(--text-primary); }
        .room-table-item .table-info .table-meta { font-size: 11px; color: var(--text-muted); }
        .room-table-item .pub-status { font-size: 11px; padding: 2px 8px; border-radius: 10px; font-weight: 500; }
        .room-table-item .pub-status.local { background: var(--bg-tertiary); color: var(--text-muted); border: 1px solid var(--border-primary); }
        .room-table-item .pub-status.published { background: rgba(34,197,94,0.15); color: var(--success-500); }
        .pub-actions { display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end; }
        .pub-actions button { padding: 8px 16px; border-radius: var(--radius-md); font-size: 13px; font-weight: 500; cursor: pointer; transition: all var(--transition-fast); }
        .pub-btn-cancel { background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-secondary); }
        .pub-btn-cancel:hover { background: var(--bg-hover); }
        .pub-btn-publish { background: var(--primary-500); border: none; color: #fff; }
        .pub-btn-publish:hover { background: var(--primary-600); }
        .pub-btn-publish:disabled { background: var(--gray-600); cursor: not-allowed; }
        .pub-progress { margin-top: 12px; }
        .pub-progress-bar { height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; }
        .pub-progress-fill { height: 100%; background: var(--primary-500); transition: width 0.3s ease; }
        .pub-progress-text { font-size: 12px; color: var(--text-muted); margin-top: 6px; }
        /* ===== Main Content Area ===== */
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: var(--bg-primary); }

        /* ===== Browser Tab Bar ===== */
        .tab-bar {
            display: flex; align-items: stretch;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-primary);
            height: var(--tab-bar-height); padding: 0 4px;
            gap: 2px; position: relative; user-select: none;
            flex-shrink: 0;
        }
        .tab-bar::before {
            content: ''; position: absolute; bottom: 0; left: 0; right: 0;
            height: 1px; background: var(--border-primary);
        }
        .tab-bar-tabs {
            display: flex; align-items: flex-end; flex: 1;
            overflow-x: auto; overflow-y: hidden;
            scrollbar-width: none; gap: 1px; padding-top: 6px;
        }
        .tab-bar-tabs::-webkit-scrollbar { display: none; }

        .browser-tab {
            display: flex; align-items: center; gap: 8px;
            min-width: 120px; max-width: 240px; height: 32px;
            padding: 0 12px; background: var(--bg-secondary);
            border: 1px solid var(--border-primary); border-bottom: none;
            border-radius: var(--radius-md) var(--radius-md) 0 0;
            color: var(--text-secondary); font-size: 13px;
            cursor: pointer; position: relative;
            transition: var(--transition-fast); flex-shrink: 0;
        }
        .browser-tab:hover { background: var(--bg-elevated); color: var(--text-primary); }
        .browser-tab:hover .tab-close { opacity: 1; }
        .browser-tab.active {
            background: var(--bg-primary); color: var(--text-primary);
            border-color: var(--primary-500); border-top-width: 2px;
            z-index: 1; font-weight: 600;
            box-shadow: inset 0 2px 0 0 var(--primary-500);
        }
        .browser-tab.active::after {
            content: ''; position: absolute; bottom: -1px; left: 0; right: 0;
            height: 2px; background: var(--bg-primary);
        }

        .tab-icon {
            display: flex; align-items: center; justify-content: center;
            width: 16px; height: 16px; font-size: 14px;
            flex-shrink: 0; color: var(--text-muted);
        }
        .browser-tab.active .tab-icon { color: var(--primary-400); }

        .tab-title {
            flex: 1; white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis; font-weight: 500;
        }

        .tab-close {
            display: flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; border-radius: var(--radius-sm);
            color: var(--text-muted); opacity: 0;
            transition: var(--transition-fast); flex-shrink: 0; cursor: pointer;
            background: none; border: none; font-size: 14px;
        }
        .tab-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .tab-close:active { background: var(--danger-500); color: white; }
        .browser-tab.active .tab-close { opacity: 0.7; }
        .browser-tab.active .tab-close:hover { opacity: 1; color: var(--text-primary); }

        .tab-count {
            font-size: 11px; color: var(--text-muted);
            background: var(--bg-tertiary); padding: 1px 6px;
            border-radius: var(--radius-sm); margin-left: 4px; flex-shrink: 0;
        }
        .browser-tab.active .tab-count { background: var(--bg-secondary); color: var(--text-secondary); }

        .tab-bar-new-tab {
            display: flex; align-items: center; justify-content: center;
            width: 28px; height: 28px; margin: auto 4px;
            background: transparent; border: none;
            border-radius: var(--radius-md); color: var(--text-muted);
            cursor: pointer; transition: var(--transition-fast); flex-shrink: 0;
            font-size: 18px;
        }
        .tab-bar-new-tab:hover { background: var(--bg-hover); color: var(--text-primary); }
        .tab-bar-new-tab:active { background: var(--bg-active); }

        /* ===== Toolbar ===== */
        .toolbar {
            padding: 12px 20px; border-bottom: 1px solid var(--border-primary);
            display: flex; align-items: center; gap: 12px;
            background: var(--bg-secondary);
        }
        .toolbar h1 { font-size: 18px; font-weight: 600; color: var(--text-primary); flex: 1; }
        .btn {
            padding: 6px 12px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            color: var(--text-secondary); font-size: 12px; cursor: pointer;
            display: flex; align-items: center; gap: 4px;
            transition: all var(--transition-fast);
        }
        .btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--border-secondary); }
        .btn-primary { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .btn-primary:hover { background: var(--primary-600); }

        /* ===== Status Bar ===== */
        .status-bar {
            padding: 8px 20px; background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            font-size: 12px; color: var(--text-muted);
            display: flex; align-items: center; gap: 12px;
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.synced { background: var(--success-500); }
        .status-dot.loading { background: var(--warning-500); }

        /* Sync Toggle */
        .sync-toggle-wrapper { display: flex; align-items: center; gap: 6px; margin-left: 8px; padding-left: 12px; border-left: 1px solid var(--border-primary); }

        /* Sync Feed */
        .sync-feed-btn { background: none; border: none; padding: 2px 6px; cursor: pointer; font-size: 11px; color: var(--text-muted); border-radius: 3px; margin-left: 4px; }
        .sync-feed-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .sync-feed-btn.has-activity { color: var(--primary-500); }
        .sync-feed-panel {
            position: fixed; bottom: 60px; right: 20px; width: 420px; max-height: 300px;
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg); box-shadow: var(--shadow-lg);
            z-index: 1000; display: none; flex-direction: column;
            font-family: var(--font-mono);
        }
        .sync-feed-panel.visible { display: flex; }
        .sync-feed-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid var(--border-primary); color: var(--text-primary); font-size: 12px; font-weight: 500; }
        .sync-feed-header-left { display: flex; align-items: center; gap: 8px; }
        .sync-feed-status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-muted); }
        .sync-feed-status-dot.active { background: var(--success-500); animation: pulse 2s infinite; }
        .sync-feed-status-dot.error { background: var(--danger-500); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .sync-feed-close { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 16px; padding: 0 4px; }
        .sync-feed-close:hover { color: var(--text-primary); }
        .sync-feed-body { flex: 1; overflow-y: auto; padding: 8px 0; max-height: 240px; }
        .sync-feed-line { padding: 2px 12px; font-size: 11px; line-height: 1.6; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .sync-feed-line.info { color: #7ec8e3; }
        .sync-feed-line.success { color: var(--success-500); }
        .sync-feed-line.error { color: var(--danger-500); }
        .sync-feed-line.warn { color: var(--warning-500); }
        .sync-feed-line .timestamp { color: var(--text-disabled); margin-right: 8px; }
        .sync-feed-line .prefix { color: var(--text-muted); }
        .sync-feed-empty { padding: 20px; text-align: center; color: var(--text-disabled); font-size: 11px; }
        .sync-feed-footer { padding: 8px 12px; border-top: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; font-size: 10px; color: var(--text-disabled); }
        .sync-feed-footer button { background: var(--bg-tertiary); border: none; color: var(--text-muted); font-size: 10px; padding: 4px 8px; border-radius: 3px; cursor: pointer; }
        .sync-feed-footer button:hover { background: var(--bg-hover); color: var(--text-primary); }

        /* ===== Sync Banner (top of main content) ===== */
        .sync-banner {
            display: none; align-items: center; gap: 10px;
            padding: 8px 20px; font-size: 12px;
            background: linear-gradient(90deg, color-mix(in srgb, var(--primary-500) 12%, transparent), color-mix(in srgb, var(--primary-500) 6%, transparent));
            border-bottom: 1px solid color-mix(in srgb, var(--primary-500) 25%, var(--border-primary));
            color: var(--text-secondary); overflow: hidden; position: relative;
        }
        .sync-banner.visible { display: flex; }
        .sync-banner.error {
            background: linear-gradient(90deg, color-mix(in srgb, var(--danger-500) 10%, transparent), color-mix(in srgb, var(--danger-500) 4%, transparent));
            border-bottom-color: color-mix(in srgb, var(--danger-500) 25%, var(--border-primary));
        }
        .sync-banner-spinner {
            width: 14px; height: 14px; border: 2px solid color-mix(in srgb, var(--primary-500) 30%, transparent);
            border-top-color: var(--primary-500); border-radius: 50%; animation: spin 0.8s linear infinite; flex-shrink: 0;
        }
        .sync-banner.error .sync-banner-spinner { display: none; }
        .sync-banner-icon { flex-shrink: 0; font-size: 14px; }
        .sync-banner-text { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .sync-banner-progress { width: 120px; height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; flex-shrink: 0; }
        .sync-banner-progress-fill { height: 100%; background: var(--primary-500); border-radius: 2px; transition: width 0.3s ease; width: 0%; }
        .sync-banner-dismiss { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 14px; padding: 0 2px; flex-shrink: 0; }
        .sync-banner-dismiss:hover { color: var(--text-primary); }

        /* ===== Table Loading Overlay (shown over table during filter/sort) ===== */
        .table-loading-overlay {
            position: absolute; inset: 0; z-index: 5;
            background: color-mix(in srgb, var(--bg-primary) 75%, transparent);
            display: none; align-items: center; justify-content: center;
            backdrop-filter: blur(1px); animation: fadeIn 0.1s ease-out;
        }
        .table-loading-overlay.visible { display: flex; }
        .table-loading-overlay-content { text-align: center; color: var(--text-muted); }
        .table-loading-overlay-content .loading-spinner { margin-bottom: 8px; }
        .table-loading-overlay-content p { font-size: 12px; margin: 0; }

        /* ===== Offline Queue Badge ===== */
        .offline-badge {
            display: none; align-items: center; gap: 5px;
            padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 500;
            background: color-mix(in srgb, var(--warning-500) 15%, transparent);
            color: var(--warning-500); border: 1px solid color-mix(in srgb, var(--warning-500) 30%, transparent);
            cursor: pointer; white-space: nowrap;
        }
        .offline-badge.visible { display: inline-flex; }
        .offline-badge-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--warning-500); animation: pulse 2s infinite; }
        .offline-badge.syncing { background: color-mix(in srgb, var(--primary-500) 15%, transparent); color: var(--primary-500); border-color: color-mix(in srgb, var(--primary-500) 30%, transparent); }
        .offline-badge.syncing .offline-badge-dot { background: var(--primary-500); }

        /* ===== Improved sync status indicator in status bar ===== */
        .sync-status-indicator {
            display: inline-flex; align-items: center; gap: 5px;
            padding: 2px 8px; border-radius: 10px; font-size: 11px; cursor: pointer;
            transition: background 0.15s ease;
        }
        .sync-status-indicator:hover { background: var(--bg-hover); }
        .sync-status-indicator .sync-status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--success-500); flex-shrink: 0; }
        .sync-status-indicator .sync-status-dot.syncing { background: var(--primary-500); animation: pulse 1.5s infinite; }
        .sync-status-indicator .sync-status-dot.error { background: var(--danger-500); }
        .sync-status-indicator .sync-status-dot.offline { background: var(--text-muted); }
        .sync-status-indicator .sync-status-label { color: var(--text-muted); }

        /* ===== Table Container ===== */
        .table-container { flex: 1; overflow: auto; }

        /* ===== Table ===== */
        table { min-width: 100%; border-collapse: collapse; font-size: 13px; }
        th {
            background: var(--bg-secondary); border-bottom: 2px solid var(--border-primary);
            padding: 8px 12px; text-align: left; font-weight: 500;
            color: var(--text-secondary); position: sticky; top: 0; z-index: 10; white-space: nowrap;
        }
        th:first-child { width: 66px; min-width: 66px; color: var(--text-muted); text-align: center; padding: 8px 4px; }
        td:first-child { width: 66px; min-width: 66px; text-align: center; padding: 8px 4px; }
        td {
            border-bottom: 1px solid var(--border-primary);
            padding: 8px 12px; max-width: 300px; overflow: hidden;
            text-overflow: ellipsis; white-space: nowrap; vertical-align: top;
            color: var(--text-secondary);
        }
        tbody tr:nth-child(even) td { background: rgba(148, 163, 184, 0.04); }
        html.light-theme tbody tr:nth-child(even) td { background: rgba(148, 163, 184, 0.06); }
        tr:hover td { background: var(--bg-hover); }
        tr.selected td { background: rgba(59, 130, 246, 0.15); }

        /* Cell Styling */
        .cell-empty { color: var(--text-disabled); }
        .cell-array { color: var(--text-secondary); }
        .cell-array .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; font-size: 12px; font-weight: 500; }
        .cell-array .tag { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .tag-c0 { background: rgba(59, 130, 246, 0.15) !important; color: #60a5fa !important; }
        .tag-c1 { background: rgba(34, 197, 94, 0.15) !important; color: #4ade80 !important; }
        .tag-c2 { background: rgba(251, 146, 60, 0.15) !important; color: #fb923c !important; }
        .tag-c3 { background: rgba(168, 85, 247, 0.15) !important; color: #a78bfa !important; }
        .tag-c4 { background: rgba(236, 72, 153, 0.15) !important; color: #f472b6 !important; }
        .tag-c5 { background: rgba(20, 184, 166, 0.15) !important; color: #2dd4bf !important; }
        .tag-c6 { background: rgba(245, 158, 11, 0.15) !important; color: #fbbf24 !important; }
        .tag-c7 { background: rgba(239, 68, 68, 0.15) !important; color: #f87171 !important; }
        .tag-c8 { background: rgba(99, 102, 241, 0.15) !important; color: #818cf8 !important; }
        .tag-c9 { background: rgba(6, 182, 212, 0.15) !important; color: #22d3ee !important; }
        html.light-theme .tag-c0 { background: rgba(37, 99, 235, 0.10) !important; color: #2563eb !important; }
        html.light-theme .tag-c1 { background: rgba(22, 163, 74, 0.10) !important; color: #16a34a !important; }
        html.light-theme .tag-c2 { background: rgba(234, 88, 12, 0.10) !important; color: #ea580c !important; }
        html.light-theme .tag-c3 { background: rgba(147, 51, 234, 0.10) !important; color: #9333ea !important; }
        html.light-theme .tag-c4 { background: rgba(219, 39, 119, 0.10) !important; color: #db2777 !important; }
        html.light-theme .tag-c5 { background: rgba(13, 148, 136, 0.10) !important; color: #0d9488 !important; }
        html.light-theme .tag-c6 { background: rgba(217, 119, 6, 0.10) !important; color: #d97706 !important; }
        html.light-theme .tag-c7 { background: rgba(220, 38, 38, 0.10) !important; color: #dc2626 !important; }
        html.light-theme .tag-c8 { background: rgba(79, 70, 229, 0.10) !important; color: #4f46e5 !important; }
        html.light-theme .tag-c9 { background: rgba(8, 145, 178, 0.10) !important; color: #0891b2 !important; }
        .cell-link { color: var(--primary-400); text-decoration: none; }
        .cell-link:hover { text-decoration: underline; }
        .cell-date { white-space: nowrap; color: var(--text-secondary); }
        .cell-number { font-family: var(--font-mono); }
        .cell-bool { padding: 2px 8px; border-radius: var(--radius-sm); font-size: 11px; font-weight: 500; }
        .cell-bool.true { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .cell-bool.false { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Primary field column (Airtable-style frozen first data column) */
        th.primary-field-col {
            position: sticky; left: 66px; z-index: 11;
            background: var(--bg-secondary); font-weight: 600; color: var(--text-primary);
            border-right: 2px solid var(--border-primary);
        }
        td.primary-field-cell {
            position: sticky; left: 66px; z-index: 2;
            background: var(--bg-primary); font-weight: 500; color: var(--text-primary);
            border-right: 2px solid var(--border-primary);
        }
        tbody tr:nth-child(even) td.primary-field-cell { background: color-mix(in srgb, var(--bg-primary) 96%, var(--text-muted)); }
        html.light-theme tbody tr:nth-child(even) td.primary-field-cell { background: color-mix(in srgb, var(--bg-primary) 94%, var(--text-muted)); }
        tr:hover td.primary-field-cell { background: var(--bg-hover); }
        th:first-child { position: sticky; left: 0; z-index: 12; background: var(--bg-secondary); }
        td:first-child { position: sticky; left: 0; z-index: 2; background: var(--bg-primary); }
        tbody tr:nth-child(even) td:first-child { background: color-mix(in srgb, var(--bg-primary) 96%, var(--text-muted)); }
        html.light-theme tbody tr:nth-child(even) td:first-child { background: color-mix(in srgb, var(--bg-primary) 94%, var(--text-muted)); }
        tr:hover td:first-child { background: var(--bg-hover); }

        /* Row number cell (Airtable-style) */
        .row-number-cell {
            position: relative; cursor: default; color: var(--text-muted); font-size: 12px;
            user-select: none; -webkit-user-select: none;
        }
        .row-number-cell .row-num { display: block; }
        .row-number-cell .row-expand-btn {
            display: none; position: absolute; inset: 0;
            align-items: center; justify-content: center;
            background: transparent; border: none; cursor: pointer; color: var(--primary-400);
            padding: 0; margin: 0;
        }
        .row-number-cell .row-expand-btn svg { width: 16px; height: 16px; }
        tr:hover .row-number-cell .row-num { display: none; }
        tr:hover .row-number-cell .row-expand-btn { display: flex; }
        tr:hover .row-number-cell .row-expand-btn:hover { color: var(--primary-500); }

        /* Inline Cell Editing */
        td.inline-editable { cursor: text; position: relative; }
        td.inline-editable:hover:not(.inline-editing) {
            background: rgba(59, 130, 246, 0.06);
            outline: 1px solid rgba(59, 130, 246, 0.25); outline-offset: -1px;
        }
        td.inline-editable:hover:not(.inline-editing)::after {
            content: '';
            position: absolute; right: 6px; top: 50%; transform: translateY(-50%);
            width: 14px; height: 14px; opacity: 0.35; pointer-events: none;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7'/%3E%3Cpath d='M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z'/%3E%3C/svg%3E") no-repeat center/contain;
        }
        td.inline-editing { padding: 0; overflow: visible; white-space: normal; }
        td.inline-editing::after { display: none; }
        td.inline-editing .inline-edit-input,
        td.inline-editing select.inline-edit-input {
            width: 100%; background: var(--bg-primary); color: var(--text-primary);
            border: 2px solid var(--primary-500); border-radius: 0;
            padding: 6px 11px; font-size: 13px; font-family: inherit;
            outline: none; box-sizing: border-box; resize: vertical;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            min-height: 34px;
        }
        td.inline-editing select.inline-edit-input { cursor: pointer; padding-right: 24px; appearance: auto; }
        td.inline-editing input[type="date"].inline-edit-input,
        td.inline-editing input[type="datetime-local"].inline-edit-input {
            cursor: text; color-scheme: dark;
        }
        html.light-theme td.inline-editing input[type="date"].inline-edit-input,
        html.light-theme td.inline-editing input[type="datetime-local"].inline-edit-input { color-scheme: light; }
        td.inline-editing .inline-edit-checkbox { margin: 8px 12px; width: 16px; height: 16px; cursor: pointer; accent-color: var(--primary-500); }
        td.inline-editable.cell-focused:not(.inline-editing) {
            outline: 2px solid var(--primary-500); outline-offset: -2px;
            background: rgba(59, 130, 246, 0.06);
        }

        /* Computed field cells  shared behavior (read-only, non-editable) */
        td.cell-computed { cursor: default; color: var(--text-secondary); }

        /* Formula field cells (purple) */
        td.cell-formula { cursor: default; color: var(--text-secondary); }
        td.cell-formula:hover { background: rgba(124, 58, 237, 0.06); outline: none; }
        td.cell-formula:hover::after { display: none; }
        td.cell-formula.cell-focused {
            outline: 2px solid rgba(124, 58, 237, 0.5); outline-offset: -2px;
            background: rgba(124, 58, 237, 0.06);
        }

        /* Lookup field cells (blue) */
        td.cell-lookup { cursor: default; color: var(--text-secondary); }
        td.cell-lookup:hover { background: rgba(2, 132, 199, 0.06); outline: none; }
        td.cell-lookup:hover::after { display: none; }
        td.cell-lookup.cell-focused {
            outline: 2px solid rgba(2, 132, 199, 0.5); outline-offset: -2px;
            background: rgba(2, 132, 199, 0.06);
        }

        /* Rollup field cells (amber) */
        td.cell-rollup { cursor: default; color: var(--text-secondary); }
        td.cell-rollup:hover { background: rgba(217, 119, 6, 0.06); outline: none; }
        td.cell-rollup:hover::after { display: none; }
        td.cell-rollup.cell-focused {
            outline: 2px solid rgba(217, 119, 6, 0.5); outline-offset: -2px;
            background: rgba(217, 119, 6, 0.06);
        }

        /* Read-only (non-computed) field cells */
        td.cell-readonly { cursor: default; color: var(--text-secondary); }
        td.cell-readonly:hover { background: rgba(148, 163, 184, 0.06); outline: none; }
        td.cell-readonly:hover::after { display: none; }
        td.cell-readonly.cell-focused {
            outline: 2px solid rgba(148, 163, 184, 0.4); outline-offset: -2px;
            background: rgba(148, 163, 184, 0.06);
        }

        /* Formula icon in column headers */
        th .formula-icon {
            display: inline-flex; align-items: center; margin-left: 4px;
            color: var(--text-muted); vertical-align: middle;
        }
        th .formula-icon svg { width: 12px; height: 12px; }

        /* Lookup icon in column headers (blue) */
        th .lookup-icon {
            display: inline-flex; align-items: center; margin-left: 4px;
            color: #38bdf8; vertical-align: middle;
        }
        th .lookup-icon svg { width: 12px; height: 12px; }
        html.light-theme th .lookup-icon { color: #0284c7; }

        /* Rollup icon in column headers (amber) */
        th .rollup-icon {
            display: inline-flex; align-items: center; margin-left: 4px;
            color: #fbbf24; vertical-align: middle;
        }
        th .rollup-icon svg { width: 12px; height: 12px; }
        html.light-theme th .rollup-icon { color: #d97706; }

        /* Read-only icon in column headers (lock icon) */
        th .readonly-icon {
            display: inline-flex; align-items: center; margin-left: 4px;
            color: var(--text-muted); vertical-align: middle;
        }
        th .readonly-icon svg { width: 11px; height: 11px; }

        /* Display name icon in column headers */
        th .display-name-icon {
            display: inline-flex; align-items: center; margin-left: 4px;
            color: #3b82f6; vertical-align: middle;
        }
        th .display-name-icon svg { width: 12px; height: 12px; }
        html.light-theme th .display-name-icon { color: #2563eb; }

        /* Formula badge on profile field cards */
        .profile-field-name .formula-badge {
            font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px;
            color: #a78bfa; background: rgba(124, 58, 237, 0.2);
            padding: 1px 5px; border-radius: 3px; margin-left: auto; cursor: pointer;
        }
        .profile-field-name .formula-badge:hover { background: rgba(124, 58, 237, 0.35); }
        html.light-theme .profile-field-name .formula-badge { color: #7c3aed; background: rgba(124, 58, 237, 0.12); }
        html.light-theme .profile-field-name .formula-badge:hover { background: rgba(124, 58, 237, 0.22); }

        /* Lookup badge on profile field cards (blue) */
        .profile-field-name .lookup-badge {
            font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px;
            color: #38bdf8; background: rgba(2, 132, 199, 0.2);
            padding: 1px 5px; border-radius: 3px; margin-left: auto; cursor: pointer;
        }
        .profile-field-name .lookup-badge:hover { background: rgba(2, 132, 199, 0.35); }
        html.light-theme .profile-field-name .lookup-badge { color: #0284c7; background: rgba(2, 132, 199, 0.12); }
        html.light-theme .profile-field-name .lookup-badge:hover { background: rgba(2, 132, 199, 0.22); }

        /* Rollup badge on profile field cards (amber) */
        .profile-field-name .rollup-badge {
            font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px;
            color: #fbbf24; background: rgba(217, 119, 6, 0.2);
            padding: 1px 5px; border-radius: 3px; margin-left: auto; cursor: pointer;
        }
        .profile-field-name .rollup-badge:hover { background: rgba(217, 119, 6, 0.35); }
        html.light-theme .profile-field-name .rollup-badge { color: #d97706; background: rgba(217, 119, 6, 0.12); }
        html.light-theme .profile-field-name .rollup-badge:hover { background: rgba(217, 119, 6, 0.22); }

        /* Read-only badge on profile field cards */
        .profile-field-name .readonly-badge {
            font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px;
            color: var(--text-muted); background: rgba(148, 163, 184, 0.2);
            padding: 1px 5px; border-radius: 3px; margin-left: auto;
        }
        html.light-theme .profile-field-name .readonly-badge { color: #64748b; background: rgba(100, 116, 139, 0.12); }

        /* Formula field value in profile (read-only look) */
        .profile-field-value.formula-readonly { cursor: default; }
        .profile-field-value.formula-readonly:hover { background: none; }

        /* Read-only field value in profile */
        .profile-field-value.field-readonly { cursor: default; }
        .profile-field-value.field-readonly:hover { background: none; }

        /* Formula info popover */
        .formula-info-popover {
            position: fixed; z-index: 10000;
            background: var(--bg-elevated); border: 1px solid var(--border-secondary);
            border-radius: var(--radius-lg); padding: 14px 16px;
            box-shadow: var(--shadow-lg); min-width: 240px; max-width: 400px;
        }
        .formula-info-popover .formula-info-header {
            font-size: 11px; font-weight: 600; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.4px; margin-bottom: 8px;
            display: flex; align-items: center; gap: 6px;
        }
        .formula-info-popover .formula-info-header svg { width: 14px; height: 14px; color: #a78bfa; }
        .formula-info-popover .formula-info-type {
            font-size: 12px; color: #a78bfa; background: rgba(124, 58, 237, 0.15);
            padding: 2px 8px; border-radius: var(--radius-sm); display: inline-block; margin-bottom: 8px;
        }
        .formula-info-popover .formula-info-expression {
            font-family: var(--font-mono); font-size: 12px; color: var(--text-primary);
            background: var(--bg-primary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); padding: 8px 10px; white-space: pre-wrap;
            word-break: break-word; max-height: 200px; overflow-y: auto;
        }
        .formula-info-popover .formula-info-note {
            font-size: 11px; color: var(--text-muted); margin-top: 8px;
        }
        html.light-theme .formula-info-popover .formula-info-header svg { color: #7c3aed; }
        html.light-theme .formula-info-popover .formula-info-type { color: #7c3aed; background: rgba(124, 58, 237, 0.1); }

        /* Pagination (Airtable-style footer) */
        .pagination {
            padding: 8px 20px; border-top: 1px solid var(--border-primary);
            background: var(--bg-secondary); display: flex; align-items: center;
            gap: 8px; font-size: 13px; min-height: 36px;
        }
        .pagination .record-total {
            font-size: 13px; color: var(--text-secondary); font-weight: 500;
            margin-right: auto;
        }
        .pagination .record-total strong { color: var(--text-primary); font-weight: 600; }
        .pagination button {
            padding: 4px 8px; background: transparent;
            border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            cursor: pointer; color: var(--text-muted);
            transition: all var(--transition-fast); display: inline-flex; align-items: center;
        }
        .pagination button svg { width: 16px; height: 16px; }
        .pagination button:hover:not(:disabled) { background: var(--bg-hover); color: var(--text-primary); border-color: var(--primary-500); }
        .pagination button:disabled { opacity: 0.35; cursor: not-allowed; }
        .pagination .page-info { color: var(--text-muted); font-size: 12px; }
        /* ===== Auth Screen ===== */
        #auth-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 100; }
        #auth-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .auth-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 360px; box-shadow: var(--shadow-xl); }
        .auth-box h2 { font-size: 20px; margin-bottom: 8px; color: var(--text-primary); }
        .auth-box p { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .auth-box input { width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .auth-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .auth-box button { width: 100%; padding: 10px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; transition: background var(--transition-fast); }
        .auth-box button:hover { background: var(--primary-600); }
        .auth-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .auth-box button.secondary { background: var(--bg-tertiary); color: var(--text-secondary); }
        .auth-box button.secondary:hover { background: var(--bg-hover); }
        .auth-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-sm); display: none; }
        .auth-info { color: var(--text-muted); font-size: 12px; margin-top: 16px; text-align: center; }

        /* Synapse Login Screen */
        #synapse-login-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 105; }
        #synapse-login-screen.hidden { display: none !important; }
        #synapse-login-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .synapse-login-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 360px; box-shadow: var(--shadow-xl); }
        .synapse-login-box h2 { font-size: 20px; margin-bottom: 8px; color: var(--text-primary); }
        .synapse-login-box p { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .synapse-login-box input { width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .synapse-login-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .synapse-login-box button { width: 100%; padding: 10px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; font-weight: 500; transition: background var(--transition-fast); }
        .synapse-login-box button:hover { background: var(--primary-600); }
        .synapse-login-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .synapse-login-box .synapse-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-sm); display: none; }
        .synapse-login-box label { display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 4px; font-weight: 500; }

        /* Offline Unlock Screen */
        #offline-unlock-screen { position: fixed; inset: 0; background: var(--bg-primary); display: none; align-items: center; justify-content: center; z-index: 106; }
        #offline-unlock-screen.visible { display: flex; }
        #offline-unlock-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .offline-unlock-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 360px; box-shadow: var(--shadow-xl); }
        .offline-unlock-box h2 { font-size: 20px; margin-bottom: 8px; color: var(--text-primary); }
        .offline-unlock-box p { font-size: 13px; color: var(--text-muted); margin-bottom: 16px; }
        .offline-unlock-box .offline-user-badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); font-size: 13px; color: var(--text-secondary); margin-bottom: 16px; }
        .offline-unlock-box .offline-user-badge svg { width: 14px; height: 14px; color: var(--text-muted); }
        .offline-unlock-box input { width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .offline-unlock-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .offline-unlock-box button { width: 100%; padding: 10px; border: none; border-radius: var(--radius-md); font-size: 14px; cursor: pointer; font-weight: 500; transition: background var(--transition-fast); }
        .offline-unlock-box button.primary { background: var(--primary-500); color: #fff; }
        .offline-unlock-box button.primary:hover { background: var(--primary-600); }
        .offline-unlock-box button.primary:disabled { background: var(--gray-600); cursor: not-allowed; }
        .offline-unlock-box button.secondary { background: transparent; color: var(--text-muted); margin-top: 8px; border: 1px solid var(--border-primary); }
        .offline-unlock-box button.secondary:hover { background: var(--bg-hover); color: var(--text-secondary); }
        .offline-unlock-box .unlock-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-sm); display: none; }
        .offline-unlock-box .offline-badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; background: rgba(245, 158, 11, 0.15); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: var(--radius-sm); font-size: 12px; color: #f59e0b; margin-bottom: 16px; font-weight: 500; }
        .offline-unlock-box .offline-badge svg { width: 12px; height: 12px; }
        .offline-unlock-box .offline-last-synced { font-size: 11px; color: var(--text-muted); margin-top: 12px; text-align: center; }

        /* Offline Mode Banner */
        #offline-mode-banner { display: none; align-items: center; justify-content: center; gap: 8px; padding: 6px 16px; background: rgba(245, 158, 11, 0.12); border-bottom: 1px solid rgba(245, 158, 11, 0.25); font-size: 12px; color: #f59e0b; font-weight: 500; flex-shrink: 0; }
        #offline-mode-banner.visible { display: flex; }
        #offline-mode-banner svg { width: 14px; height: 14px; }
        #offline-mode-banner .offline-reconnect-btn { padding: 3px 10px; background: rgba(245, 158, 11, 0.2); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: var(--radius-sm); color: #f59e0b; font-size: 11px; cursor: pointer; font-weight: 500; transition: background var(--transition-fast); }
        #offline-mode-banner .offline-reconnect-btn:hover { background: rgba(245, 158, 11, 0.3); }
        html.light-theme #offline-mode-banner { background: rgba(217, 119, 6, 0.08); border-bottom-color: rgba(217, 119, 6, 0.2); color: #b45309; }
        html.light-theme #offline-mode-banner .offline-reconnect-btn { background: rgba(217, 119, 6, 0.1); border-color: rgba(217, 119, 6, 0.25); color: #b45309; }

        /* ===== Home Screen ===== */
        #home-app {
            display: none;
            flex-direction: column;
            flex: 1;
            overflow-y: auto;
            background: #F1F5F9;
            font-family: 'DM Sans', -apple-system, sans-serif;
            --h-brand: #2563EB;
            --h-brand-hover: #1D4ED8;
            --h-brand-light: #DBEAFE;
            --h-brand-mid: #93C5FD;
            --h-brand-subtle: #EFF6FF;
            --h-accent: #10B981;
            --h-accent-light: #D1FAE5;
            --h-warn: #F59E0B;
            --h-warn-light: #FEF3C7;
            --h-warn-dark: #92400E;
            --h-danger: #EF4444;
            --h-danger-light: #FEE2E2;
            --h-danger-dark: #991B1B;
            --h-text: #1E293B;
            --h-text-secondary: #475569;
            --h-text-muted: #64748B;
            --h-text-light: #94A3B8;
            --h-text-faint: #CBD5E1;
            --h-border: #E2E8F0;
            --h-border-hover: #CBD5E1;
            --h-bg: #F1F5F9;
            --h-bg-warm: #F8FAFC;
            --h-surface: #FFFFFF;
            --h-mono: 'JetBrains Mono', monospace;
            --h-radius: 8px;
            --h-radius-lg: 12px;
            --h-radius-full: 999px;
            --h-shadow-sm: 0 1px 2px rgba(0,0,0,.04);
            --h-shadow: 0 1px 3px rgba(0,0,0,.06), 0 1px 2px rgba(0,0,0,.04);
            --h-shadow-md: 0 4px 6px -1px rgba(0,0,0,.06), 0 2px 4px -2px rgba(0,0,0,.04);
            --h-transition: 150ms ease;
            -webkit-font-smoothing: antialiased;
            color: var(--h-text);
        }
        #home-app.visible { display: flex; }

        #home-app .routes-home {
            padding: 28px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        #home-app .routes-home-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        #home-app .routes-home-header h1 {
            font-size: 28px;
            line-height: 1.2;
            margin-bottom: 6px;
        }
        #home-app .routes-home-header p {
            font-size: 14px;
            color: var(--h-text-muted);
            max-width: 780px;
        }
        #home-app .routes-home-avatar {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            background: var(--h-brand-light);
            color: var(--h-brand);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            flex-shrink: 0;
        }
        #home-app .routes-home-cards {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 14px;
        }
        #home-app .routes-card {
            text-align: left;
            border: 1px solid var(--h-border);
            background: var(--h-surface);
            border-radius: var(--h-radius-lg);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            cursor: pointer;
            transition: transform var(--h-transition), box-shadow var(--h-transition), border-color var(--h-transition);
            color: var(--h-text);
            font-family: 'DM Sans', -apple-system, sans-serif;
        }
        #home-app .routes-card:hover {
            border-color: var(--h-brand-mid);
            box-shadow: var(--h-shadow-md);
            transform: translateY(-1px);
        }
        #home-app .routes-card h3 { font-size: 17px; }
        #home-app .routes-card p { font-size: 13px; color: var(--h-text-muted); line-height: 1.45; }
        #home-app .routes-card span { margin-top: auto; font-size: 13px; color: var(--h-brand); font-weight: 600; }
        #home-app .routes-card-icon { font-size: 22px; }
        #home-app .routes-home-stats {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            border: 1px solid var(--h-border);
            border-radius: var(--h-radius-lg);
            overflow: hidden;
            background: var(--h-surface);
        }
        #home-app .routes-stat {
            padding: 16px;
            border: 0;
            border-right: 1px solid var(--h-border);
            text-align: left;
            width: 100%;
            background: transparent;
            color: inherit;
            cursor: pointer;
            transition: background var(--h-transition);
        }
        #home-app .routes-stat:hover,
        #home-app .routes-stat:focus-visible {
            background: rgba(21, 34, 55, .04);
            outline: none;
        }
        #home-app .routes-stat:last-child { border-right: 0; }
        #home-app .routes-stat-value { font-size: 24px; font-weight: 700; }
        #home-app .routes-stat-label {
            margin-top: 3px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: .05em;
            color: var(--h-text-light);
            font-weight: 600;
        }

        /*  Home Utility Bar  */
        #home-app .utilbar {
            background: var(--h-text);
            padding: 0 24px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        #home-app .utilbar-left { display: flex; gap: 2px; }
        #home-app .utilbar-right { display: flex; align-items: center; gap: 8px; }
        #home-app .util-link {
            font-size: 11px; font-weight: 500; color: rgba(255,255,255,.6);
            text-decoration: none; padding: 4px 10px; border-radius: var(--h-radius-full);
            transition: all var(--h-transition); cursor: pointer;
            display: flex; align-items: center; gap: 4px;
            background: none; border: none; font-family: 'DM Sans', sans-serif;
        }
        #home-app .util-link:hover { color: white; background: rgba(255,255,255,.1); }
        #home-app .util-link svg { width: 12px; height: 12px; opacity: .7; }
        #home-app .util-search-btn {
            font-size: 11px; font-weight: 600; color: white;
            background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.15);
            padding: 4px 14px; border-radius: var(--h-radius-full);
            cursor: pointer; font-family: 'DM Sans', sans-serif;
            display: flex; align-items: center; gap: 6px;
            transition: all var(--h-transition);
        }
        #home-app .util-search-btn:hover { background: rgba(255,255,255,.2); }
        #home-app .util-search-btn kbd {
            font-family: var(--h-mono); font-size: 10px;
            background: rgba(255,255,255,.15); padding: 1px 5px;
            border-radius: 3px;
        }
        #home-app .util-avatar {
            width: 24px; height: 24px; border-radius: 50%;
            background: var(--h-brand); color: white;
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; font-weight: 700; cursor: pointer;
            margin-left: 4px;
        }

        /*  Home Main Nav  */
        #home-app .mainnav {
            background: var(--h-surface);
            border-bottom: 1px solid var(--h-border);
            padding: 0 24px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        #home-app .mainnav-left { display: flex; align-items: center; gap: 20px; }
        #home-app .nav-logo {
            display: flex; align-items: center; gap: 9px;
            text-decoration: none; margin-right: 8px;
        }
        #home-app .nav-logo .logo-mark {
            width: 32px; height: 32px; border-radius: 8px;
            background: linear-gradient(135deg, #92703A 0%, #B8923E 50%, #D4A843 100%);
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 15px; font-weight: 800;
            letter-spacing: -.02em;
            box-shadow: 0 1px 3px rgba(146,112,58,.3);
        }
        #home-app .nav-logo-text {
            display: flex; flex-direction: column; line-height: 1.15;
        }
        #home-app .nav-logo-text .firm { font-size: 14px; font-weight: 700; color: var(--h-text); letter-spacing: -.01em; }
        #home-app .nav-logo-text .sub { font-size: 10px; font-weight: 500; color: var(--h-text-light); letter-spacing: .02em; text-transform: uppercase; }
        #home-app .nav-divider { width: 1px; height: 28px; background: var(--h-border); }
        #home-app .nav-links { display: flex; gap: 2px; }
        #home-app .nav-link {
            font-family: 'DM Sans', sans-serif; font-size: 13px; font-weight: 500;
            padding: 8px 14px; border-radius: var(--h-radius);
            border: none; background: transparent; color: var(--h-text-muted);
            cursor: pointer; transition: all var(--h-transition);
            display: flex; align-items: center; gap: 7px;
            text-decoration: none;
        }
        #home-app .nav-link:hover { background: var(--h-bg); color: var(--h-text-secondary); }
        #home-app .nav-link.active { background: var(--h-brand-subtle); color: var(--h-brand); }
        #home-app .nav-link svg { width: 16px; height: 16px; flex-shrink: 0; }
        #home-app .nav-link .nav-badge {
            font-size: 10px; font-weight: 700; background: var(--h-danger);
            color: white; padding: 1px 6px; border-radius: var(--h-radius-full);
            min-width: 18px; text-align: center;
        }
        #home-app .mainnav-right { display: flex; align-items: center; gap: 8px; }
        #home-app .quick-action {
            font-family: 'DM Sans', sans-serif; font-size: 12px; font-weight: 600;
            padding: 7px 14px; border-radius: var(--h-radius);
            border: none; cursor: pointer; transition: all var(--h-transition);
            display: flex; align-items: center; gap: 6px;
        }
        #home-app .quick-action.primary { background: var(--h-brand); color: white; }
        #home-app .quick-action.primary:hover { background: var(--h-brand-hover); }
        #home-app .quick-action.secondary {
            background: var(--h-surface); color: var(--h-text-secondary);
            border: 1px solid var(--h-border);
        }
        #home-app .quick-action.secondary:hover { background: var(--h-bg); border-color: var(--h-border-hover); }
        #home-app .quick-action svg { width: 14px; height: 14px; }

        /*  Home Page Content (three-column)  */
        #home-app .page-content {
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 1fr 380px;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
            animation: home-fadeUp .3s ease both;
            flex: 1;
            overflow: hidden;
            width: 100%;
        }
        @keyframes home-fadeUp {
            from { opacity: 0; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /*  Panel Cards  */
        #home-app .panel {
            background: var(--h-surface);
            border: 1px solid var(--h-border);
            border-radius: var(--h-radius-lg);
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 220px);
            min-height: 0;
        }
        #home-app .panel-header {
            padding: 16px 18px 12px;
            border-bottom: 1px solid var(--h-border);
            flex-shrink: 0;
        }
        #home-app .panel-title {
            font-size: 14px; font-weight: 700; color: var(--h-text);
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 10px;
        }
        #home-app .panel-title .panel-count {
            font-size: 11px; font-weight: 500; color: var(--h-text-light);
            background: var(--h-bg); padding: 2px 8px; border-radius: var(--h-radius-full);
        }
        #home-app .panel-search {
            width: 100%; font-family: 'DM Sans', sans-serif; font-size: 12px;
            padding: 8px 12px 8px 32px; border: 1px solid var(--h-border);
            border-radius: var(--h-radius); background: var(--h-bg-warm);
            outline: none; color: var(--h-text); transition: all var(--h-transition);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='13' height='13' viewBox='0 0 24 24' fill='none' stroke='%2394A3B8' stroke-width='2' stroke-linecap='round'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: 10px center;
        }
        #home-app .panel-search:focus { border-color: var(--h-brand); background: var(--h-surface); box-shadow: 0 0 0 2px var(--h-brand-light); }
        #home-app .panel-body {
            flex: 1; overflow-y: auto; padding: 6px;
            scrollbar-width: thin;
            scrollbar-color: var(--h-border) transparent;
        }

        /*  Case Note / Comm Cards  */
        #home-app .note-card {
            padding: 14px 14px;
            border-radius: var(--h-radius);
            cursor: pointer;
            transition: all var(--h-transition);
            border: 1px solid transparent;
            margin-bottom: 2px;
        }
        #home-app .note-card:hover { background: var(--h-brand-subtle); border-color: var(--h-brand-light); }
        #home-app .note-card.unread { background: var(--h-brand-subtle); border-color: var(--h-brand-light); }
        #home-app .note-card-header {
            display: flex; align-items: flex-start; justify-content: space-between;
            margin-bottom: 6px;
        }
        #home-app .note-card-name { font-size: 13px; font-weight: 600; color: var(--h-text); }
        #home-app .note-card-time { font-size: 11px; color: var(--h-text-light); white-space: nowrap; margin-left: 8px; }
        #home-app .note-card-type {
            font-size: 11px; font-weight: 500; color: var(--h-text-muted);
            margin-bottom: 5px;
        }
        #home-app .note-card-preview {
            font-size: 12px; color: var(--h-text-muted); line-height: 1.5;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
            overflow: hidden;
        }
        #home-app .note-card-tags { display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap; }
        #home-app .tag {
            font-size: 10px; font-weight: 600; padding: 2px 8px;
            border-radius: var(--h-radius-full); letter-spacing: .01em;
        }
        #home-app .tag-blue { background: var(--h-brand-light); color: #1E40AF; }
        #home-app .tag-green { background: var(--h-accent-light); color: #065F46; }
        #home-app .tag-amber { background: var(--h-warn-light); color: var(--h-warn-dark); }
        #home-app .tag-red { background: var(--h-danger-light); color: var(--h-danger-dark); }
        #home-app .tag-outline { background: transparent; border: 1px solid var(--h-border); color: var(--h-text-muted); }
        #home-app .comm-icon {
            display: inline-flex; align-items: center; gap: 4px;
            font-size: 11px; color: var(--h-text-light); margin-bottom: 5px;
        }
        #home-app .comm-icon svg { width: 12px; height: 12px; }
        #home-app .note-divider {
            height: 1px; background: var(--h-border); margin: 2px 14px;
        }

        /*  Calendar Panel  */
        #home-app .cal-panel-header {
            padding: 14px 18px;
            border-bottom: 1px solid var(--h-border);
            flex-shrink: 0;
        }
        #home-app .cal-date-row {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 10px;
        }
        #home-app .cal-date-title { font-size: 14px; font-weight: 700; color: var(--h-text); }
        #home-app .cal-date-sub { font-size: 11px; color: var(--h-text-light); font-weight: 400; margin-top: 1px; }
        #home-app .cal-nav { display: flex; align-items: center; gap: 4px; }
        #home-app .cal-nav-btn {
            width: 28px; height: 28px; border-radius: 6px;
            border: 1px solid var(--h-border); background: var(--h-surface);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: var(--h-text-muted); font-size: 13px;
            transition: all var(--h-transition); font-family: 'DM Sans', sans-serif;
        }
        #home-app .cal-nav-btn:hover { background: var(--h-bg); }
        #home-app .cal-today-btn {
            font-family: 'DM Sans', sans-serif; font-size: 11px; font-weight: 600;
            padding: 4px 10px; border-radius: 6px;
            border: 1px solid var(--h-border); background: var(--h-surface);
            color: var(--h-text-secondary); cursor: pointer;
            transition: all var(--h-transition);
        }
        #home-app .cal-today-btn:hover { background: var(--h-bg); }
        #home-app .cal-search {
            width: 100%; font-family: 'DM Sans', sans-serif; font-size: 12px;
            padding: 7px 12px 7px 30px; border: 1px solid var(--h-border);
            border-radius: var(--h-radius); background: var(--h-bg-warm);
            outline: none; color: var(--h-text); transition: all var(--h-transition);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394A3B8' stroke-width='2' stroke-linecap='round'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: 10px center;
        }
        #home-app .cal-search:focus { border-color: var(--h-brand); background: var(--h-surface); box-shadow: 0 0 0 2px var(--h-brand-light); }
        #home-app .cal-body {
            flex: 1; overflow-y: auto; position: relative;
            scrollbar-width: thin;
            scrollbar-color: var(--h-border) transparent;
        }
        #home-app .cal-grid { position: relative; }
        #home-app .cal-hour-row {
            display: flex; align-items: flex-start;
            min-height: 52px;
            border-bottom: 1px solid var(--h-bg);
        }
        #home-app .cal-hour-label {
            width: 52px; flex-shrink: 0;
            font-size: 10px; font-weight: 500; color: var(--h-text-light);
            text-align: right; padding: 2px 10px 0 0;
            font-family: var(--h-mono);
        }
        #home-app .cal-hour-content {
            flex: 1; min-height: 52px; position: relative;
            border-left: 1px solid var(--h-border);
            padding: 2px 8px;
        }
        #home-app .cal-event {
            padding: 6px 10px; border-radius: 6px;
            margin-bottom: 3px; cursor: pointer;
            transition: all var(--h-transition);
            border-left: 3px solid;
        }
        #home-app .cal-event:hover { transform: translateX(2px); }
        #home-app .cal-event.blue { background: var(--h-brand-subtle); border-color: var(--h-brand); }
        #home-app .cal-event.green { background: #ECFDF5; border-color: var(--h-accent); }
        #home-app .cal-event.amber { background: var(--h-warn-light); border-color: var(--h-warn); }
        #home-app .cal-event.red { background: var(--h-danger-light); border-color: var(--h-danger); }
        #home-app .cal-event-name { font-size: 12px; font-weight: 600; color: var(--h-text); }
        #home-app .cal-event-detail { font-size: 10px; color: var(--h-text-muted); margin-top: 1px; }
        #home-app .cal-now-line {
            position: absolute; left: 52px; right: 0;
            height: 2px; background: var(--h-danger);
            z-index: 5; pointer-events: none;
        }
        #home-app .cal-now-line::before {
            content: ''; position: absolute; left: -4px; top: -3px;
            width: 8px; height: 8px; border-radius: 50%;
            background: var(--h-danger);
        }

        /*  Home Scrollbar  */
        #home-app .panel-body::-webkit-scrollbar,
        #home-app .cal-body::-webkit-scrollbar { width: 5px; }
        #home-app .panel-body::-webkit-scrollbar-thumb,
        #home-app .cal-body::-webkit-scrollbar-thumb { background: var(--h-border); border-radius: 10px; }
        #home-app .panel-body::-webkit-scrollbar-track,
        #home-app .cal-body::-webkit-scrollbar-track { background: transparent; }

        /*  Home Responsive  */
        @media (max-width: 1200px) {
            #home-app .page-content {
                grid-template-columns: 1fr 1fr;
            }
            #home-app .page-content .panel:nth-child(3) {
                grid-column: 1 / -1;
            }
        }
        @media (max-width: 720px) {
            #home-app .page-content {
                grid-template-columns: 1fr;
                padding: 12px;
            }
            #home-app .mainnav { padding: 0 12px; height: auto; flex-wrap: wrap; gap: 8px; padding: 8px 12px; }
            #home-app .nav-links { flex-wrap: wrap; }
            #home-app .mainnav-right { display: none; }
            #home-app .panel { max-height: 500px; }
        }

        /* ===== File Header Bar ===== */
        .file-header {
            display: none;
            width: 100%;
            height: 36px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            flex-shrink: 0;
            z-index: 51;
        }
        .file-header.visible { display: flex; }
        .file-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-muted);
        }
        .file-header-role {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        .file-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-header-theme-btn {
            padding: 3px 10px;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            background: transparent;
            color: var(--text-muted);
            font-size: 11px;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: background var(--transition-fast), color var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .file-header-theme-btn:hover { background: var(--bg-hover); color: var(--text-primary); }

        /* ===== App Navigation Bar ===== */
        .app-nav {
            display: none;
            width: 100%;
            height: 44px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            align-items: center;
            padding: 0 16px;
            gap: 2px;
            flex-shrink: 0;
            z-index: 50;
        }
        .app-nav.visible { display: flex; }
        .app-nav-btn {
            padding: 6px 16px;
            border: none;
            border-radius: var(--radius-md);
            background: transparent;
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 500;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: background var(--transition-fast), color var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }
        .app-nav-btn:hover { background: var(--bg-hover); color: var(--text-secondary); }
        .app-nav-btn.active { background: var(--bg-active); color: var(--text-primary); }
        .app-nav-btn svg { width: 16px; height: 16px; }
        .app-nav-spacer { flex: 1; }
        .app-nav-user {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .app-nav-user-role {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .app-nav-user-role.admin { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .app-nav-user-role.staff { background: rgba(34, 197, 94, 0.15); color: var(--success-500); }
        .app-nav-logout {
            padding: 4px 10px;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            background: transparent;
            color: var(--text-muted);
            font-size: 12px;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: background var(--transition-fast), color var(--transition-fast);
        }
        .app-nav-logout:hover { background: rgba(239, 68, 68, 0.1); color: var(--danger-500); border-color: var(--danger-500); }

        /* App content wrapper - holds sidebar + main or settings */
        .app-content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ===== Forms Sub-App ===== */
        #forms-app {
            display: none;
            flex: 1;
            overflow-y: auto;
            background: var(--bg-primary);
            font-family: var(--font-sans);
        }
        #forms-app.visible { display: flex; flex-direction: column; }

        .forms-topbar {
            display: flex; align-items: center; justify-content: space-between;
            padding: 24px 32px 0;
            flex-shrink: 0;
        }
        .forms-topbar-left h1 {
            font-size: 22px; font-weight: 700; color: var(--text-primary); margin: 0;
        }
        .forms-topbar-left p {
            font-size: 13px; color: var(--text-muted); margin: 4px 0 0;
        }
        .forms-new-btn {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 8px 16px;
            background: var(--primary-500); color: #fff;
            border: none; border-radius: var(--radius-md);
            font-size: 13px; font-weight: 600; cursor: pointer;
            transition: background var(--transition-fast);
        }
        .forms-new-btn:hover { background: var(--primary-600); }
        .forms-new-btn svg { width: 14px; height: 14px; }

        .forms-toolbar {
            display: flex; align-items: center; gap: 10px;
            padding: 16px 32px;
            flex-shrink: 0;
        }
        .forms-search {
            flex: 1; max-width: 320px;
            padding: 7px 12px 7px 32px;
            background: var(--bg-secondary); color: var(--text-primary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            font-size: 13px; font-family: var(--font-sans);
            outline: none; transition: border-color var(--transition-fast);
        }
        .forms-search:focus { border-color: var(--primary-500); }
        .forms-search-wrap {
            position: relative; flex: 1; max-width: 320px;
        }
        .forms-search-wrap svg {
            position: absolute; left: 10px; top: 50%; transform: translateY(-50%);
            width: 14px; height: 14px; color: var(--text-muted); pointer-events: none;
        }
        .forms-filter-select {
            padding: 7px 10px; background: var(--bg-secondary); color: var(--text-primary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            font-size: 13px; font-family: var(--font-sans);
            cursor: pointer; outline: none;
        }
        .forms-filter-select:focus { border-color: var(--primary-500); }

        .forms-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
            padding: 0 32px 32px;
            flex: 1; overflow-y: auto;
            align-content: start;
        }

        .forms-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: 20px;
            cursor: pointer;
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
            display: flex; flex-direction: column; gap: 12px;
        }
        .forms-card:hover {
            border-color: var(--primary-500);
            box-shadow: 0 0 0 1px var(--primary-500), var(--shadow-md);
        }
        .forms-card-header {
            display: flex; align-items: flex-start; justify-content: space-between;
        }
        .forms-card-title {
            font-size: 15px; font-weight: 600; color: var(--text-primary);
            line-height: 1.3;
        }
        .forms-card-status {
            display: inline-flex; align-items: center;
            padding: 2px 8px; border-radius: 10px;
            font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.03em;
            flex-shrink: 0;
        }
        .forms-card-status.draft { background: rgba(245, 158, 11, 0.15); color: var(--warning-500); }
        .forms-card-status.published { background: rgba(34, 197, 94, 0.15); color: var(--success-500); }

        .forms-card-table {
            display: inline-flex; align-items: center; gap: 5px;
            font-size: 12px; color: var(--text-muted);
        }
        .forms-card-table svg { width: 12px; height: 12px; flex-shrink: 0; }

        .forms-card-meta {
            display: flex; align-items: center; gap: 12px;
            font-size: 12px; color: var(--text-muted);
            margin-top: auto;
        }
        .forms-card-meta-item {
            display: inline-flex; align-items: center; gap: 4px;
        }
        .forms-card-meta-item svg { width: 12px; height: 12px; }

        .forms-card-actions {
            display: flex; gap: 4px; opacity: 0;
            transition: opacity var(--transition-fast);
        }
        .forms-card:hover .forms-card-actions { opacity: 1; }
        .forms-card-action-btn {
            padding: 4px; border: none; background: transparent;
            color: var(--text-muted); cursor: pointer; border-radius: var(--radius-sm);
            transition: color var(--transition-fast), background var(--transition-fast);
        }
        .forms-card-action-btn:hover { color: var(--text-primary); background: var(--bg-hover); }
        .forms-card-action-btn svg { width: 14px; height: 14px; }

        .forms-empty {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 80px 32px; text-align: center;
            flex: 1;
        }
        .forms-empty-icon {
            width: 64px; height: 64px;
            background: var(--bg-secondary); border-radius: 16px;
            display: flex; align-items: center; justify-content: center;
            margin-bottom: 16px;
        }
        .forms-empty-icon svg { width: 32px; height: 32px; color: var(--text-muted); }
        .forms-empty h2 {
            font-size: 18px; font-weight: 600; color: var(--text-primary); margin: 0 0 8px;
        }
        .forms-empty p {
            font-size: 14px; color: var(--text-muted); margin: 0 0 24px;
            max-width: 400px; line-height: 1.5;
        }

        /* Create Form Modal */
        .forms-create-modal {
            display: none; position: fixed; inset: 0; z-index: 1002;
            background: rgba(0,0,0,0.6);
            align-items: center; justify-content: center;
        }
        .forms-create-modal.open { display: flex; }
        .forms-create-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl);
            width: 480px; max-width: 90vw;
            box-shadow: var(--shadow-xl);
            animation: formModalIn 0.2s ease;
        }
        @keyframes formModalIn {
            from { transform: translateY(12px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .forms-create-modal-header {
            padding: 20px 24px 0;
        }
        .forms-create-modal-header h2 {
            font-size: 17px; font-weight: 700; color: var(--text-primary); margin: 0;
        }
        .forms-create-modal-header p {
            font-size: 13px; color: var(--text-muted); margin: 4px 0 0;
        }
        .forms-create-modal-body {
            padding: 20px 24px;
            display: flex; flex-direction: column; gap: 16px;
        }
        .forms-create-field label {
            display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary);
            margin-bottom: 6px;
        }
        .forms-create-field input,
        .forms-create-field select,
        .forms-create-field textarea {
            width: 100%; padding: 8px 12px;
            background: var(--bg-primary); color: var(--text-primary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            font-size: 13px; font-family: var(--font-sans);
            outline: none; transition: border-color var(--transition-fast);
        }
        .forms-create-field input:focus,
        .forms-create-field select:focus,
        .forms-create-field textarea:focus { border-color: var(--primary-500); }
        .forms-create-field textarea { resize: vertical; min-height: 60px; }
        .forms-create-modal-footer {
            padding: 16px 24px;
            display: flex; justify-content: flex-end; gap: 8px;
            border-top: 1px solid var(--border-primary);
        }
        .forms-create-modal-footer .btn-cancel {
            padding: 8px 16px; background: transparent; color: var(--text-secondary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            font-size: 13px; cursor: pointer;
        }
        .forms-create-modal-footer .btn-cancel:hover { background: var(--bg-hover); }
        .forms-create-modal-footer .btn-create {
            padding: 8px 20px; background: var(--primary-500); color: #fff;
            border: none; border-radius: var(--radius-md);
            font-size: 13px; font-weight: 600; cursor: pointer;
        }
        .forms-create-modal-footer .btn-create:hover { background: var(--primary-600); }
        .forms-create-modal-footer .btn-create:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Form builder canvas placeholder */
        .forms-builder {
            display: none; flex: 1; flex-direction: column; overflow: hidden;
        }
        .forms-builder.visible { display: flex; }
        .forms-builder-topbar {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 24px;
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-secondary);
            flex-shrink: 0;
        }
        .forms-builder-topbar-left {
            display: flex; align-items: center; gap: 12px;
        }
        .forms-builder-back {
            padding: 6px; border: none; background: transparent;
            color: var(--text-muted); cursor: pointer; border-radius: var(--radius-sm);
        }
        .forms-builder-back:hover { color: var(--text-primary); background: var(--bg-hover); }
        .forms-builder-back svg { width: 18px; height: 18px; }
        .forms-builder-title {
            font-size: 15px; font-weight: 600; color: var(--text-primary);
        }
        .forms-builder-subtitle {
            font-size: 12px; color: var(--text-muted); margin-left: 8px;
        }
        .forms-builder-topbar-right { display: flex; gap: 8px; }
        .forms-builder-btn {
            padding: 6px 14px; border-radius: var(--radius-md);
            font-size: 13px; font-weight: 500; cursor: pointer;
            border: 1px solid var(--border-primary); background: transparent;
            color: var(--text-secondary); transition: all var(--transition-fast);
        }
        .forms-builder-btn:hover { background: var(--bg-hover); }
        .forms-builder-btn.primary {
            background: var(--primary-500); color: #fff; border-color: var(--primary-500);
        }
        .forms-builder-btn.primary:hover { background: var(--primary-600); }

        .forms-builder-layout {
            display: flex; flex: 1; overflow: hidden;
        }
        .forms-builder-sidebar {
            width: 260px; border-right: 1px solid var(--border-primary);
            background: var(--bg-secondary); overflow-y: auto; flex-shrink: 0;
            padding: 16px;
        }
        .forms-builder-sidebar-title {
            font-size: 11px; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 12px;
        }
        .forms-builder-field-item {
            display: flex; align-items: center; gap: 8px;
            padding: 8px 10px;
            border-radius: var(--radius-md);
            font-size: 13px; color: var(--text-secondary);
            cursor: pointer; transition: background var(--transition-fast);
        }
        .forms-builder-field-item:hover { background: var(--bg-hover); }
        .forms-builder-field-item.active { background: var(--bg-active); color: var(--text-primary); }
        .forms-builder-field-item .field-icon {
            width: 16px; height: 16px; color: var(--text-muted); flex-shrink: 0;
        }
        .forms-builder-field-item .field-added {
            margin-left: auto; color: var(--success-500); font-size: 11px;
        }

        .forms-builder-canvas {
            flex: 1; overflow-y: auto; padding: 32px;
            display: flex; flex-direction: column; align-items: center;
        }
        .forms-builder-preview {
            width: 100%; max-width: 640px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: 32px;
        }
        .forms-builder-preview-title {
            font-size: 20px; font-weight: 700; color: var(--text-primary); margin-bottom: 4px;
        }
        .forms-builder-preview-desc {
            font-size: 14px; color: var(--text-muted); margin-bottom: 24px;
        }
        .forms-builder-preview-field {
            margin-bottom: 20px;
        }
        .forms-builder-preview-field label {
            display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary);
            margin-bottom: 6px;
        }
        .forms-builder-preview-field label .required { color: var(--danger-500); }
        .forms-builder-preview-field input,
        .forms-builder-preview-field select,
        .forms-builder-preview-field textarea {
            width: 100%; padding: 9px 12px;
            background: var(--bg-primary); color: var(--text-primary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            font-size: 14px; font-family: var(--font-sans); outline: none;
        }
        .forms-builder-preview-field .field-help {
            font-size: 12px; color: var(--text-muted); margin-top: 4px;
        }
        .forms-builder-preview-submit {
            padding: 10px 24px;
            background: var(--primary-500); color: #fff;
            border: none; border-radius: var(--radius-md);
            font-size: 14px; font-weight: 600; cursor: pointer;
            margin-top: 8px;
        }
        .forms-builder-preview-submit:hover { background: var(--primary-600); }

        .forms-builder-config {
            width: 280px; border-left: 1px solid var(--border-primary);
            background: var(--bg-secondary); overflow-y: auto; flex-shrink: 0;
            padding: 16px;
        }
        .forms-builder-config-title {
            font-size: 11px; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 12px;
        }
        .forms-builder-config-field {
            margin-bottom: 14px;
        }
        .forms-builder-config-field label {
            display: block; font-size: 12px; font-weight: 600; color: var(--text-secondary);
            margin-bottom: 4px;
        }
        .forms-builder-config-field input,
        .forms-builder-config-field select,
        .forms-builder-config-field textarea {
            width: 100%; padding: 6px 10px;
            background: var(--bg-primary); color: var(--text-primary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            font-size: 12px; font-family: var(--font-sans); outline: none;
        }
        .forms-builder-config-toggle {
            display: flex; align-items: center; justify-content: space-between;
            padding: 6px 0;
        }
        .forms-builder-config-toggle label {
            font-size: 13px; color: var(--text-secondary); margin: 0;
        }
        .forms-builder-config-toggle input[type="checkbox"] {
            width: auto;
        }

        /* ===== Settings Sub-App ===== */
        #settings-app {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 32px 48px;
            background: var(--bg-primary);
        }
        #settings-app.visible { display: block; }
        .settings-header {
            margin-bottom: 32px;
        }
        .settings-header h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .settings-header p {
            font-size: 14px;
            color: var(--text-muted);
        }
        .settings-tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--border-primary);
            margin-bottom: 24px;
        }
        .settings-tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 500;
            font-family: var(--font-sans);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: color var(--transition-fast), border-color var(--transition-fast);
        }
        .settings-tab:hover { color: var(--text-secondary); }
        .settings-tab.active { color: var(--primary-400); border-bottom-color: var(--primary-400); }
        .settings-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin-bottom: 24px;
        }
        .settings-section h2 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .settings-section-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 20px;
        }

        /* Settings: Users & Roles Table */
        .settings-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .settings-table th {
            text-align: left;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-muted);
            font-weight: 500;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .settings-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-primary);
            vertical-align: middle;
        }
        .settings-table tr:last-child td { border-bottom: none; }
        .settings-table tr:hover td { background: var(--bg-hover); }
        .settings-table .user-id {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-secondary);
        }
        .settings-table .role-badge {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .settings-table .role-badge.admin { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .settings-table .role-badge.staff { background: rgba(34, 197, 94, 0.15); color: var(--success-500); }
        .settings-table .role-badge.client { background: rgba(245, 158, 11, 0.15); color: var(--warning-500); }
        .settings-table .role-badge.default { background: var(--bg-tertiary); color: var(--text-muted); }
        .settings-role-select {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 12px;
            font-family: var(--font-sans);
            cursor: pointer;
        }
        .settings-role-select:focus { outline: none; border-color: var(--primary-500); }

        /* Settings: Room Access Table */
        .settings-room-access {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .settings-room-access th {
            text-align: left;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-muted);
            font-weight: 500;
            font-size: 12px;
        }
        .settings-room-access td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-primary);
            vertical-align: middle;
        }
        .settings-room-access tr:last-child td { border-bottom: none; }
        .settings-room-access .room-name {
            font-weight: 500;
        }
        .settings-room-access .room-id {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            display: block;
            margin-top: 2px;
        }
        .settings-access-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--primary-500);
        }
        .settings-action-btn {
            padding: 6px 14px;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 12px;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        .settings-action-btn:hover { background: var(--bg-hover); }
        .settings-action-btn.primary {
            background: var(--primary-500);
            border-color: var(--primary-500);
            color: #fff;
        }
        .settings-action-btn.primary:hover { background: var(--primary-600); }
        .settings-action-btn.danger {
            color: var(--danger-500);
            border-color: var(--danger-500);
        }
        .settings-action-btn.danger:hover { background: rgba(239, 68, 68, 0.1); }
        .settings-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Preference toggle rows */
        .settings-pref-row {
            padding: 12px 0;
            border-bottom: 1px solid var(--border-primary);
        }
        .settings-pref-row:last-child { border-bottom: none; }
        .settings-toggle-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            gap: 16px;
        }
        .settings-toggle-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .settings-toggle-text strong {
            font-size: 13px;
            color: var(--text-primary);
            font-weight: 500;
        }
        .settings-toggle-desc {
            font-size: 12px;
            color: var(--text-muted);
        }
        .settings-toggle-checkbox {
            display: none;
        }
        .settings-toggle-switch {
            position: relative;
            width: 36px;
            min-width: 36px;
            height: 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            transition: background 0.2s, border-color 0.2s;
        }
        .settings-toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: var(--text-muted);
            border-radius: 50%;
            transition: transform 0.2s, background 0.2s;
        }
        .settings-toggle-checkbox:checked + .settings-toggle-switch {
            background: var(--primary-500);
            border-color: var(--primary-500);
        }
        .settings-toggle-checkbox:checked + .settings-toggle-switch::after {
            transform: translateX(16px);
            background: #fff;
        }
        /* Settings: Profile form */
        .settings-profile-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        .settings-profile-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 180px;
        }
        .settings-profile-field label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        .settings-profile-field input {
            padding: 7px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            font-family: var(--font-sans);
        }
        .settings-profile-field input:focus {
            outline: none;
            border-color: var(--primary-500);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        .settings-profile-save-btn {
            padding: 7px 18px;
            background: var(--primary-500);
            border: none;
            border-radius: var(--radius-sm);
            color: #fff;
            font-size: 13px;
            font-family: var(--font-sans);
            font-weight: 500;
            cursor: pointer;
            transition: background var(--transition-fast);
            white-space: nowrap;
        }
        .settings-profile-save-btn:hover { background: var(--primary-600); }
        .settings-profile-save-btn:disabled { background: var(--gray-600); cursor: not-allowed; }
        /* Settings: Table Relationships */
        .settings-rel-graph-container {
            position: relative;
            width: 100%;
            height: 420px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            overflow: hidden;
        }
        .settings-rel-graph-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .settings-rel-graph-empty {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 13px;
        }
        .settings-rel-legend {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-bottom: 16px;
            font-size: 12px;
            color: var(--text-muted);
        }
        .settings-rel-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .settings-rel-legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
        .settings-rel-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .settings-rel-table th {
            text-align: left;
            padding: 8px 12px;
            border-bottom: 2px solid var(--border-primary);
            color: var(--text-muted);
            font-weight: 500;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .settings-rel-table td {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-primary);
            vertical-align: middle;
        }
        .settings-rel-table tr:last-child td { border-bottom: none; }
        .settings-rel-table tr:hover td { background: var(--bg-hover); }
        .settings-rel-table .rel-table-name {
            font-weight: 500;
        }
        .settings-rel-table .rel-field-name {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-secondary);
        }
        .settings-rel-table .rel-cardinality-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.2px;
        }
        .settings-rel-table .rel-cardinality-badge.many-to-many {
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
        }
        .settings-rel-table .rel-cardinality-badge.one-to-many {
            background: rgba(59, 130, 246, 0.15);
            color: var(--primary-400);
        }
        .settings-rel-table .rel-cardinality-badge.one-to-one {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success-500);
        }
        .settings-rel-primary-star {
            color: var(--warning-500);
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            transition: opacity 0.15s;
        }
        .settings-rel-primary-star:hover { opacity: 0.7; }
        .settings-rel-primary-star.inactive {
            color: var(--text-muted);
            opacity: 0.3;
        }
        .settings-rel-primary-star.inactive:hover { opacity: 0.6; }
        .settings-rel-edit-btn {
            padding: 3px 10px;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            background: transparent;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
        }
        .settings-rel-edit-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .settings-rel-detail-row {
            background: var(--bg-secondary);
        }
        .settings-rel-detail-row td {
            padding: 12px;
        }
        .settings-rel-detail-form {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            max-width: 600px;
        }
        .settings-rel-detail-form label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.4px;
            display: block;
            margin-bottom: 4px;
        }
        .settings-rel-detail-form input,
        .settings-rel-detail-form select {
            width: 100%;
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 12px;
            font-family: var(--font-sans);
        }
        .settings-rel-detail-form input:focus,
        .settings-rel-detail-form select:focus {
            outline: none;
            border-color: var(--primary-500);
        }
        .settings-rel-detail-actions {
            grid-column: 1 / -1;
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }
        .settings-rel-stats {
            display: flex;
            gap: 24px;
            margin-bottom: 20px;
        }
        .settings-rel-stat {
            text-align: center;
        }
        .settings-rel-stat-value {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .settings-rel-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.4px;
        }
        .settings-rel-arrow {
            color: var(--text-muted);
            margin: 0 4px;
        }
        .settings-toast {
            padding: 10px 16px;
            border-radius: var(--radius-md);
            font-size: 13px;
            margin-bottom: 16px;
            display: none;
        }
        .settings-toast.success {
            display: block;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: var(--success-500);
        }
        .settings-toast.error {
            display: block;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--danger-500);
        }
        .settings-toast.info {
            display: block;
            background: rgba(59, 130, 246, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: var(--primary-400);
        }
        .settings-loading {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            font-size: 13px;
            padding: 16px 0;
        }
        .settings-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-primary);
            border-top-color: var(--primary-500);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Settings: Invite User Form */
        .settings-invite-form {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-primary);
        }
        .settings-invite-form h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .settings-invite-form p {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 16px;
        }
        .settings-invite-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        .settings-invite-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 140px;
        }
        .settings-invite-field label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        .settings-invite-field input,
        .settings-invite-field select {
            padding: 7px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            font-family: var(--font-sans);
        }
        .settings-invite-field input:focus,
        .settings-invite-field select:focus {
            outline: none;
            border-color: var(--primary-500);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        .settings-invite-btn {
            padding: 7px 18px;
            background: var(--primary-500);
            border: none;
            border-radius: var(--radius-sm);
            color: #fff;
            font-size: 13px;
            font-family: var(--font-sans);
            font-weight: 500;
            cursor: pointer;
            transition: background var(--transition-fast);
            white-space: nowrap;
        }
        .settings-invite-btn:hover { background: var(--primary-600); }
        .settings-invite-btn:disabled { background: var(--gray-600); cursor: not-allowed; }

        /* Room Assignment Modal (post-invite) */
        .room-assign-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1100; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .room-assign-modal.open { opacity: 1; visibility: visible; }
        .room-assign-modal .room-assign-content { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 90%; max-width: 520px; max-height: 80vh; display: flex; flex-direction: column; box-shadow: var(--shadow-xl); transform: translateY(20px); transition: transform 0.2s; }
        .room-assign-modal.open .room-assign-content { transform: translateY(0); }
        .room-assign-header { padding: 20px 24px 12px; border-bottom: 1px solid var(--border-primary); }
        .room-assign-header h2 { font-size: 16px; font-weight: 600; color: var(--text-primary); margin: 0 0 4px; }
        .room-assign-header p { font-size: 12px; color: var(--text-muted); margin: 0; }
        .room-assign-header .room-assign-user-badge { display: inline-block; margin-top: 8px; padding: 3px 10px; background: var(--bg-tertiary); border-radius: var(--radius-sm); font-size: 12px; color: var(--primary-400); font-family: var(--font-mono); }
        .room-assign-toolbar { padding: 10px 24px; display: flex; gap: 8px; align-items: center; border-bottom: 1px solid var(--border-primary); }
        .room-assign-toolbar button { padding: 4px 10px; font-size: 11px; border: 1px solid var(--border-primary); background: var(--bg-tertiary); color: var(--text-secondary); border-radius: var(--radius-sm); cursor: pointer; font-family: var(--font-sans); }
        .room-assign-toolbar button:hover { background: var(--bg-hover); color: var(--text-primary); }
        .room-assign-toolbar .room-assign-count { margin-left: auto; font-size: 11px; color: var(--text-muted); }
        .room-assign-list { flex: 1; overflow-y: auto; padding: 8px 0; }
        .room-assign-item { display: flex; align-items: center; gap: 10px; padding: 8px 24px; cursor: pointer; transition: background var(--transition-fast); }
        .room-assign-item:hover { background: var(--bg-hover); }
        .room-assign-item input[type="checkbox"] { accent-color: var(--primary-500); width: 16px; height: 16px; cursor: pointer; }
        .room-assign-item label { flex: 1; cursor: pointer; font-size: 13px; color: var(--text-primary); }
        .room-assign-item .room-assign-id { font-size: 11px; color: var(--text-disabled); font-family: var(--font-mono); }
        .room-assign-footer { padding: 14px 24px; border-top: 1px solid var(--border-primary); display: flex; gap: 8px; justify-content: flex-end; }
        .room-assign-footer button { padding: 7px 18px; border-radius: var(--radius-sm); font-size: 13px; font-family: var(--font-sans); font-weight: 500; cursor: pointer; transition: background var(--transition-fast); }
        .room-assign-footer .room-assign-skip { background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-secondary); }
        .room-assign-footer .room-assign-skip:hover { background: var(--bg-hover); }
        .room-assign-footer .room-assign-confirm { background: var(--primary-500); border: none; color: #fff; }
        .room-assign-footer .room-assign-confirm:hover { background: var(--primary-600); }
        .room-assign-footer .room-assign-confirm:disabled { background: var(--gray-600); cursor: not-allowed; }
        .room-assign-status { padding: 0 24px 10px; font-size: 12px; color: var(--text-muted); display: none; }
        .room-assign-status.visible { display: block; }
        .room-assign-internal-note { padding: 8px 24px; font-size: 11px; color: var(--success-500); background: rgba(34, 197, 94, 0.06); border-bottom: 1px solid var(--border-primary); display: none; }
        .room-assign-internal-note.visible { display: block; }

        /* Login: Password Reset */
        .synapse-login-box .synapse-forgot-link {
            display: block;
            margin-top: 12px;
            text-align: center;
            font-size: 13px;
            color: var(--primary-400);
            cursor: pointer;
            text-decoration: none;
        }
        .synapse-login-box .synapse-forgot-link:hover { text-decoration: underline; }
        #synapse-reset-form {
            display: none;
        }
        #synapse-reset-form .synapse-reset-step {
            display: none;
        }
        #synapse-reset-form .synapse-reset-step.active {
            display: block;
        }
        .synapse-login-box .synapse-back-link {
            display: block;
            margin-top: 12px;
            text-align: center;
            font-size: 13px;
            color: var(--text-muted);
            cursor: pointer;
        }
        .synapse-login-box .synapse-back-link:hover { color: var(--text-secondary); }
        .synapse-login-box .synapse-info {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 16px;
            line-height: 1.5;
        }
        .synapse-login-box .synapse-success {
            color: var(--success-500);
            font-size: 13px;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: var(--radius-sm);
            display: none;
        }

        /* ============ Interface App ============ */
        #interface-app {
            display: none;
            flex: 1;
            flex-direction: column;
            overflow: hidden;
            /* Warm theme matching Softr sample */
            background: #f0f4f8;
            color: #232120;
            font-family: Inter, system-ui, -apple-system, sans-serif;
            --iface-accent: #a77653;
            --iface-accent-hover: #8f6243;
            --iface-accent-dark: #644631;
            --iface-bg: #f0f4f8;
            --iface-surface: #ffffff;
            --iface-border: #d9e0e8;
            --iface-text: #232120;
            --iface-text-secondary: #4b5563;
            --iface-text-muted: #6b7280;
            --iface-text-light: #94a3b8;
            --iface-brand: #a77653;
            --iface-brand-subtle: rgba(167, 118, 83, 0.08);
            --iface-blue: #2563eb;
            --iface-green: #10b981;
            --iface-danger: #ef4444;
            --iface-radius: 10px;
        }
        #interface-app.visible { display: flex; }

        /* Branded main navigation bar (Softr-style) */
        .iface-mainnav {
            display: flex; align-items: center; justify-content: space-between;
            height: 60px; min-height: 60px;
            padding: 0 20px;
            background: var(--iface-surface);
            border-bottom: 1px solid var(--iface-border);
            flex-shrink: 0;
        }
        .iface-mainnav-left { display: flex; align-items: center; gap: 16px; flex: 1; min-width: 0; }
        .iface-mainnav-right { display: flex; align-items: center; gap: 10px; flex-shrink: 0; }
        .iface-nav-logo {
            display: flex; align-items: center; gap: 9px;
            text-decoration: none; cursor: pointer; flex-shrink: 0;
        }
        .iface-logo-mark {
            width: 32px; height: 32px; border-radius: 8px;
            background: linear-gradient(135deg, #92703A 0%, #B8923E 50%, #D4A843 100%);
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 15px; font-weight: 800;
            letter-spacing: -.02em;
            box-shadow: 0 1px 3px rgba(146,112,58,.3);
        }
        .iface-logo-text { display: flex; flex-direction: column; line-height: 1.15; }
        .iface-logo-firm { font-size: 14px; font-weight: 700; color: var(--iface-text); letter-spacing: -.01em; }
        .iface-logo-sub { font-size: 10px; font-weight: 500; color: var(--iface-text-muted); letter-spacing: .02em; text-transform: uppercase; }
        .iface-nav-divider { width: 1px; height: 28px; background: var(--iface-border); flex-shrink: 0; }

        /* Quick action buttons in nav */
        .iface-quick-action {
            font-family: inherit; font-size: 12px; font-weight: 600;
            padding: 7px 14px; border-radius: 8px;
            border: none; cursor: pointer; transition: all 150ms ease;
            display: flex; align-items: center; gap: 6px; white-space: nowrap;
        }
        .iface-quick-action.primary { background: var(--iface-accent); color: white; }
        .iface-quick-action.primary:hover { background: var(--iface-accent-hover); }
        .iface-quick-action.secondary {
            background: var(--iface-surface); color: var(--iface-text-secondary);
            border: 1px solid var(--iface-border);
        }
        .iface-quick-action.secondary:hover { background: #f8fafc; border-color: #cbd5e1; }
        .iface-quick-action svg { width: 14px; height: 14px; }

        .iface-edit-toggle {
            display: none; padding: 5px 12px; font-size: 12px; font-weight: 600;
            border: 1px solid var(--iface-border); border-radius: 8px;
            background: transparent; color: var(--iface-text-secondary); cursor: pointer;
            transition: all 150ms ease;
        }
        .iface-edit-toggle:hover { background: rgba(0,0,0,0.04); color: var(--iface-text); }
        .iface-edit-toggle.active { background: var(--iface-accent); color: #fff; border-color: var(--iface-accent); }
        .iface-edit-toggle.is-admin { display: inline-flex; }
        .iface-global-search {
            width: 180px; padding: 7px 12px; font-size: 12px;
            background: #f8fafc; border: 1px solid var(--iface-border);
            border-radius: 8px; color: var(--iface-text); outline: none;
            font-family: inherit;
        }
        .iface-global-search::placeholder { color: var(--iface-text-light); }
        .iface-global-search:focus { border-color: var(--iface-accent); box-shadow: 0 0 0 2px rgba(167,118,83,0.15); background: white; }

        .command-palette-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            backdrop-filter: blur(2px);
            z-index: 12000;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 10vh 16px 24px;
        }
        .command-palette-overlay.hidden { display: none; }
        .command-palette-panel {
            width: min(760px, 100%);
            border-radius: 14px;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }
        .command-palette-input {
            width: 100%;
            border: 0;
            border-bottom: 1px solid var(--border-primary);
            background: transparent;
            color: var(--text-primary);
            font-size: 15px;
            padding: 14px 16px;
            outline: none;
        }
        .command-palette-results { max-height: 52vh; overflow: auto; }
        .command-palette-item {
            width: 100%;
            border: 0;
            border-bottom: 1px solid var(--border-primary);
            background: transparent;
            color: var(--text-primary);
            text-align: left;
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }
        .command-palette-item:hover { background: var(--bg-tertiary); }
        .command-palette-item:last-child { border-bottom: 0; }
        .command-palette-item-title { font-size: 13px; font-weight: 600; }
        .command-palette-item-meta { font-size: 12px; color: var(--text-muted); margin-top: 3px; }
        .command-palette-item-type {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
            white-space: nowrap;
            align-self: center;
        }
        .command-palette-empty { padding: 20px 16px; font-size: 13px; color: var(--text-muted); }

        /* Interface page tabs (inside mainnav) */
        .iface-page-tabs {
            display: flex; align-items: center; gap: 2px;
            padding: 0; min-height: 38px; overflow-x: auto;
            background: transparent; border: none;
        }
        .iface-page-tabs::-webkit-scrollbar { display: none; }
        .iface-page-tab {
            padding: 8px 14px; font-size: 13px; font-weight: 500;
            color: var(--iface-text-muted); cursor: pointer; border: none; background: none;
            border-bottom: 2px solid transparent; white-space: nowrap;
            transition: all 150ms ease; border-radius: 8px;
        }
        .iface-page-tab:hover { color: var(--iface-text-secondary); background: rgba(0,0,0,0.04); }
        .iface-page-tab.active { color: var(--iface-accent); background: var(--iface-brand-subtle); border-bottom-color: transparent; }
        .iface-page-tab-wrap { display: inline-flex; align-items: center; gap: 4px; }
        .iface-page-access-btn {
            display: none;
            border: 1px solid var(--border-primary);
            background: transparent;
            color: var(--text-muted);
            border-radius: var(--radius-sm);
            font-size: 10px;
            line-height: 1;
            padding: 3px 5px;
            cursor: pointer;
        }
        .iface-page-access-btn.is-admin { display: inline-flex; }
        .iface-page-access-btn:hover { color: var(--text-primary); border-color: var(--primary-500); }
        .iface-page-access-pill {
            display: inline-flex;
            align-items: center;
            padding: 2px 6px;
            font-size: 10px;
            border-radius: 9999px;
            color: var(--text-muted);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
        }
        .iface-add-page-btn {
            padding: 4px 10px; font-size: 18px; color: var(--text-muted);
            cursor: pointer; border: none; background: none; display: none;
        }
        .iface-add-page-btn.is-admin { display: inline-flex; }
        .iface-add-page-btn:hover { color: var(--text-primary); }

        /* Interface page container */
        .iface-page-container {
            flex: 1; overflow-y: auto; padding: 0;
            background: var(--iface-bg, #f0f4f8);
        }
        html.light-theme .iface-page-container { background: #f0f4f8; }

        .iface-page { display: none; flex-direction: column; min-height: 100%; }
        .iface-page.active { display: flex; }

        /* Client page layout tuning */
        .iface-page[data-page-id="clients"] {
            padding: 16px 20px 20px;
            min-height: 0;
            height: 100%;
        }

        /* Quick links grid */
        .iface-quick-links {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 12px; padding: 20px 24px;
        }
        .iface-quick-link {
            display: flex; flex-direction: column; align-items: center; gap: 8px;
            padding: 16px 8px; background: var(--iface-surface);
            border: 1px solid var(--iface-border); border-radius: var(--iface-radius);
            cursor: pointer; text-decoration: none; color: var(--iface-text);
            transition: all 150ms ease; font-size: 12px; font-weight: 500;
            text-align: center;
        }
        .iface-quick-link:hover { border-color: var(--iface-accent); transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
        .iface-quick-link-icon {
            width: 40px; height: 40px; border-radius: 8px;
            background: var(--iface-accent); color: #fff;
            display: flex; align-items: center; justify-content: center; font-size: 18px;
        }

        /* Section headers */
        .iface-section {
            padding: 20px 24px 8px; display: flex; align-items: center; justify-content: space-between;
        }
        .iface-section-title { font-size: 16px; font-weight: 600; color: var(--iface-text); }
        .iface-section-actions { display: flex; gap: 8px; }

        /* Block containers - warm card style */
        .iface-block {
            margin: 0 24px 16px; background: var(--iface-surface);
            border: 1px solid var(--iface-border); border-radius: var(--iface-radius);
            overflow: hidden; position: relative;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        .iface-block-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 16px; border-bottom: 1px solid var(--iface-border);
        }
        .iface-block-title { font-size: 14px; font-weight: 600; color: var(--iface-text); }
        .iface-block-search {
            width: 180px; padding: 5px 10px; font-size: 12px;
            background: #f8fafc; border: 1px solid var(--iface-border);
            border-radius: 8px; color: var(--iface-text); outline: none;
            font-family: inherit;
        }
        .iface-block-search::placeholder { color: var(--iface-text-light); }
        .iface-block-search:focus { border-color: var(--iface-accent); }
        .iface-block-body { padding: 0; max-height: 400px; overflow-y: auto; }

        /* Card list (for case notes, communications) */
        .iface-card-list { display: flex; flex-direction: column; }
        .iface-card {
            display: flex; align-items: flex-start; gap: 12px;
            padding: 12px 16px; border-bottom: 1px dashed #edf0f4;
            cursor: pointer; transition: background 150ms ease;
        }
        .iface-card:last-child { border-bottom: none; }
        .iface-card:hover { background: rgba(167,118,83,0.04); }
        .iface-card-icon { width: 32px; height: 32px; border-radius: 50%; background: rgba(167,118,83,0.1); color: var(--iface-accent); display: flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 14px; }
        .iface-card-content { flex: 1; min-width: 0; }
        .iface-card-title { font-size: 13px; font-weight: 600; color: var(--iface-text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .iface-card-subtitle { font-size: 12px; color: var(--iface-text-muted); margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .iface-card-meta { font-size: 11px; color: var(--iface-text-light); margin-top: 4px; }

        /* Case notes widget (inbox layout) */
        .iface-case-notes-widget { max-height: none; padding: 0; }
        .iface-case-notes-controls { padding: 14px 16px; border-bottom: 1px solid var(--border-primary); display: grid; gap: 10px; }
        .iface-case-notes-actions { display: flex; flex-wrap: wrap; gap: 8px; }
        .iface-case-notes-actions button, .iface-case-notes-pager button, .iface-case-note-link-btn { padding: 7px 10px; border-radius: var(--radius-sm); border: 1px solid var(--border-primary); background: var(--bg-primary); color: var(--text-primary); cursor: pointer; }
        .iface-case-notes-actions button:hover, .iface-case-notes-pager button:hover, .iface-case-note-link-btn:hover { background: var(--bg-hover); }
        .iface-case-notes-actions button:disabled, .iface-case-notes-pager button:disabled { opacity: 0.5; cursor: not-allowed; }
        .iface-case-notes-status { font-size: 12px; color: var(--text-muted); }
        .iface-case-notes-error { font-size: 12px; color: var(--danger-500); }
        .iface-case-notes-pager { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; font-size: 12px; color: var(--text-muted); }
        .iface-case-notes-list { display: grid; gap: 10px; padding: 12px 16px 16px; }
        .iface-case-note-item { border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 12px; background: var(--bg-primary); }
        .iface-case-note-top { display: flex; justify-content: space-between; gap: 10px; font-size: 13px; color: var(--text-primary); }
        .iface-case-note-left { min-width: 0; }
        .iface-case-note-right { color: var(--text-muted); font-size: 12px; }
        .iface-case-note-join-key { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); overflow-wrap: anywhere; }
        .iface-case-note-client-name { margin-top: 4px; font-weight: 600; color: var(--text-primary); }
        .iface-case-note-desc { margin-top: 8px; font-size: 13px; line-height: 1.4; white-space: pre-wrap; color: var(--text-primary); }
        .iface-case-note-meta { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
        .iface-case-note-pill { padding: 4px 8px; border: 1px solid var(--border-primary); border-radius: 999px; font-size: 11px; color: var(--text-muted); }
        .iface-case-note-link-btn { margin-top: 10px; }
        .iface-case-note-unlinked { margin-top: 10px; font-size: 12px; color: var(--text-disabled); }
        @media (max-width: 1000px) { .iface-case-notes-grid { grid-template-columns: 1fr 1fr; } }
        @media (max-width: 680px) { .iface-case-notes-grid { grid-template-columns: 1fr; } }

        /* Data table */
        .iface-table-wrapper { overflow-x: auto; }
        .iface-page[data-page-id="clients"] .iface-data-table-block {
            display: flex;
            flex: 1;
            flex-direction: column;
            min-height: 0;
            margin: 0;
        }
        .iface-page[data-page-id="clients"] .iface-data-table-block .iface-block-body {
            display: flex;
            flex: 1;
            flex-direction: column;
            max-height: none;
            min-height: 0;
        }
        .iface-page[data-page-id="clients"] .iface-data-table-block .iface-table-wrapper {
            flex: 1;
            min-height: 0;
            overflow: auto;
        }
        .iface-table {
            width: 100%; border-collapse: collapse; font-size: 13px;
            table-layout: fixed;
        }
        .iface-table th {
            text-align: left; padding: 8px 12px; font-weight: 600; font-size: 12px;
            color: var(--iface-text-secondary); background: #f6f2ef;
            border-bottom: 1px solid var(--iface-border); white-space: nowrap;
            position: sticky; top: 0; z-index: 1; cursor: pointer; user-select: none;
            text-transform: uppercase; letter-spacing: 0.03em;
        }
        .iface-table th:hover { color: var(--iface-text); }
        .iface-table td {
            padding: 8px 12px; border-bottom: 1px solid #edf0f4;
            color: var(--iface-text); white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis;
        }
        .iface-table tr:hover td { background: rgba(167,118,83,0.04); }
        .iface-table tr:last-child td { border-bottom: none; }
        .iface-table tr { cursor: pointer; }

        /* Responsive mainnav */
        @media (max-width: 900px) {
            .iface-mainnav { flex-wrap: wrap; height: auto; padding: 8px 14px; gap: 6px; }
            .iface-mainnav-left { flex-wrap: wrap; }
            .iface-logo-text { display: none; }
            .iface-nav-divider { display: none; }
            .iface-quick-action span:not(svg) { display: none; }
            .iface-global-search { width: 140px; }
        }
        @media (max-width: 600px) {
            .iface-quick-action { display: none; }
            .iface-mainnav-right { gap: 6px; }
        }

        /* Responsive table: hide less important columns at smaller breakpoints */
        @media (max-width: 1200px) {
            .iface-table th[data-col="country"],
            .iface-table td[data-col="country"],
            .iface-table th[data-col="email"],
            .iface-table td[data-col="email"],
            .iface-table th[data-col="event-info"],
            .iface-table td[data-col="event-info"] { display: none; }
        }
        @media (max-width: 900px) {
            .iface-table th[data-col="a-"],
            .iface-table td[data-col="a-"],
            .iface-table th[data-col="dob-age"],
            .iface-table td[data-col="dob-age"],
            .iface-table th[data-col="ich-atty"],
            .iface-table td[data-col="ich-atty"],
            .iface-table th[data-col="mch-atty"],
            .iface-table td[data-col="mch-atty"],
            .iface-table th[data-col="case-manager"],
            .iface-table td[data-col="case-manager"] { display: none; }
            .iface-table th, .iface-table td { padding: 6px 8px; font-size: 12px; }
            .iface-page[data-page-id="clients"] { padding: 12px 10px 14px; }
        }
        @media (max-width: 480px) {
            .iface-table th[data-col="phone"],
            .iface-table td[data-col="phone"] { display: none; }
            .iface-table th, .iface-table td { padding: 6px 6px; font-size: 11px; }
            .iface-page[data-page-id="clients"] { padding: 8px 6px 10px; }
            .iface-filters { padding: 8px 10px; gap: 6px; }
            .iface-filter-dropdown { font-size: 11px; padding: 4px 6px; }
            .iface-block-header { flex-wrap: wrap; }
            .iface-block-search { width: 100%; }
        }

        /* Status badges */
        .iface-badge {
            display: inline-block; padding: 2px 8px; font-size: 11px; font-weight: 600;
            border-radius: 999px; white-space: nowrap;
        }
        .iface-badge-green { background: #ecfdf3; color: #0f766e; border: 1px solid #8fd3b2; }
        .iface-badge-red { background: #fef2f2; color: #dc2626; border: 1px solid #fca5a5; }
        .iface-badge-yellow { background: #fffbeb; color: #92400e; border: 1px solid #fcd34d; }
        .iface-badge-blue { background: #eff6ff; color: #1d4ed8; border: 1px solid #93c5fd; }
        .iface-badge-gray { background: #eef2f7; color: #4b5563; border: 1px solid #d7dfe8; }

        /* Filters bar */
        .iface-filters {
            display: flex; align-items: center; gap: 8px; padding: 12px 16px;
            border-bottom: 1px solid var(--iface-border); flex-wrap: wrap;
        }
        .iface-filter-dropdown {
            padding: 5px 10px; font-size: 12px; border: 1px solid var(--iface-border);
            border-radius: 8px; background: white;
            color: var(--iface-text); cursor: pointer; outline: none; font-family: inherit;
        }
        .iface-filter-dropdown:focus { border-color: var(--iface-accent); }

        /* Column layout blocks (side-by-side) */
        .iface-columns { display: grid; grid-template-columns: 1fr 1fr; gap: 0; padding: 0 24px 16px; }
        .iface-columns .iface-block { margin: 0; }
        .iface-columns .iface-block:first-child { border-radius: var(--iface-radius) 0 0 var(--iface-radius); border-right: none; }
        .iface-columns .iface-block:last-child { border-radius: 0 var(--iface-radius) var(--iface-radius) 0; }
        @media (max-width: 768px) {
            .iface-columns { grid-template-columns: 1fr; }
            .iface-columns .iface-block { border-radius: var(--iface-radius) !important; border-right: 1px solid var(--iface-border) !important; margin-bottom: 12px; }
        }

        /* Tabs inside blocks */
        .iface-tab-bar {
            display: flex; gap: 0; border-bottom: 1px solid var(--iface-border);
            background: #f8fafc;
        }
        .iface-tab-btn {
            padding: 10px 20px; font-size: 13px; font-weight: 500;
            color: var(--iface-text-muted); cursor: pointer; border: none; background: none;
            border-bottom: 2px solid transparent;
            transition: all var(--transition-fast);
        }
        .iface-tab-btn:hover { color: var(--text-secondary); }
        .iface-tab-btn.active { color: var(--primary-500); border-bottom-color: var(--primary-500); }
        .iface-tab-panel { display: none; }
        .iface-tab-panel.active { display: block; }

        /* Calendar / event timeline */
        .iface-timeline { padding: 12px 16px; }
        .iface-timeline-item {
            display: flex; gap: 12px; padding: 10px 0;
            border-bottom: 1px solid var(--border-primary);
        }
        .iface-timeline-item:last-child { border-bottom: none; }
        .iface-timeline-time { min-width: 60px; font-size: 12px; font-weight: 600; color: var(--text-muted); padding-top: 2px; }
        .iface-timeline-content { flex: 1; }
        .iface-timeline-title { font-size: 13px; font-weight: 600; color: var(--text-primary); }
        .iface-timeline-detail { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
        .iface-timeline-badges { display: flex; gap: 6px; margin-top: 4px; flex-wrap: wrap; }

        /* Google Calendar embed block */
        .gcal-container { display: flex; width: 100%; min-height: 860px; }
        .gcal-sidebar { width: 25%; background: var(--bg-secondary); border-right: 1px solid var(--border-primary); padding: 16px; overflow-y: auto; max-height: 860px; }
        .gcal-sidebar h4 { margin: 0 0 8px; font-size: 13px; font-weight: 600; color: var(--text-primary); }
        .gcal-sidebar-note { margin: -2px 0 10px; font-size: 11px; color: var(--text-muted); }
        .gcal-sidebar-search { width: 100%; padding: 7px 10px; border-radius: var(--radius-md); border: 1px solid var(--border-primary); background: var(--bg-primary); color: var(--text-primary); font-size: 12px; margin-bottom: 12px; }
        .gcal-sidebar-search:focus { outline: none; border-color: var(--amino-blue); box-shadow: 0 0 0 3px var(--amino-focus-ring); }
        .gcal-main { width: 75%; padding: 16px; overflow-y: auto; }
        .gcal-active-bar { display: flex; flex-wrap: wrap; gap: 6px; min-height: 42px; border: 2px dashed var(--border-secondary); padding: 8px; border-radius: 8px; background: var(--bg-primary); }
        .gcal-chip-pool { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 12px; }
        .gcal-chip { display: inline-flex; align-items: center; padding: 4px 10px; font-size: 12px; border-radius: 9999px; cursor: grab; user-select: none; transition: opacity 0.15s; font-weight: 500; }
        .gcal-chip.dragging { opacity: 0.4; }
        .gcal-bulk-buttons { display: flex; gap: 6px; margin-top: 12px; flex-wrap: wrap; }
        .gcal-bulk-buttons button {
            padding: 5px 10px; font-size: 11px; border: 1px solid var(--border-primary);
            background: var(--bg-primary); color: var(--text-secondary); cursor: pointer;
            border-radius: var(--radius-sm); transition: all var(--transition-fast);
        }
        .gcal-bulk-buttons button:hover { background: var(--primary-500); color: #fff; border-color: var(--primary-500); }
        .gcal-controls { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
        .gcal-controls button {
            padding: 6px 12px; font-size: 12px; border: 1px solid var(--border-primary);
            background: var(--bg-secondary); color: var(--text-secondary); cursor: pointer;
            border-radius: var(--radius-sm); transition: all var(--transition-fast);
        }
        .gcal-controls button:hover { background: var(--primary-500); color: #fff; border-color: var(--primary-500); }
        .gcal-date-picker { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; }
        .gcal-date-picker label { font-size: 12px; color: var(--text-muted); }
        .gcal-date-picker input[type=date] {
            padding: 5px 8px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            font-size: 12px; background: var(--bg-primary); color: var(--text-primary);
        }
        .gcal-iframes { display: flex; flex-direction: column; gap: 16px; }
        .gcal-iframe-wrapper { position: relative; width: 100%; }
        .gcal-calendar-iframe { width: 100%; height: 800px; border: 0; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .gcal-person-wrapper { flex: 1; display: flex; flex-direction: column; height: 800px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow: hidden; }
        .gcal-person-wrapper h4 { margin: 0; padding: 8px 12px; background: var(--primary-500); color: #fff; font-size: 13px; text-align: center; }
        .gcal-spinner-overlay { position: absolute; inset: 0; background: rgba(255,255,255,0.7); display: flex; align-items: center; justify-content: center; z-index: 2; }
        html:not(.light-theme) .gcal-spinner-overlay { background: rgba(0,0,0,0.4); }
        .gcal-spinner { width: 28px; height: 28px; border: 4px solid var(--border-primary); border-top: 4px solid var(--primary-500); border-radius: 50%; animation: gcal-spin 1s linear infinite; }
        @keyframes gcal-spin { to { transform: rotate(360deg); } }

        /* Empty state */
        .iface-empty {
            padding: 40px 20px; text-align: center; color: var(--text-muted); font-size: 13px;
        }
        .iface-empty svg { width: 40px; height: 40px; opacity: 0.3; margin-bottom: 8px; }

        /* Loading skeleton */
        .iface-skeleton {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-hover) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: iface-shimmer 1.5s infinite;
            border-radius: var(--radius-sm); height: 14px; margin: 4px 0;
        }
        @keyframes iface-shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Admin edit mode overlay on blocks */
        .iface-editing .iface-block { outline: 2px dashed var(--primary-400); outline-offset: 2px; }
        .iface-block-drag-handle {
            display: none; position: absolute; top: 4px; right: 4px;
            padding: 4px 8px; font-size: 11px; background: var(--primary-500);
            color: #fff; border-radius: var(--radius-sm); cursor: grab; z-index: 2;
        }
        .iface-editing .iface-block-drag-handle { display: inline-flex; }
        .iface-editing .iface-quick-link { outline: 1px dashed var(--primary-400); outline-offset: 1px; }

        /* Block action buttons (admin) */
        .iface-block-actions {
            display: none; gap: 4px; align-items: center;
        }
        .iface-editing .iface-block-actions { display: flex; }
        .iface-block-action-btn {
            padding: 3px 8px; font-size: 11px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); background: var(--bg-primary);
            color: var(--text-muted); cursor: pointer;
        }
        .iface-block-action-btn:hover { color: var(--text-primary); border-color: var(--primary-500); }
        .iface-block-action-btn.danger:hover { color: var(--danger-500); border-color: var(--danger-500); }

        /* Admin table settings panel */
        .iface-table-settings-btn {
            padding: 4px 10px; font-size: 12px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); background: var(--bg-primary);
            color: var(--text-muted); cursor: pointer; display: inline-flex; align-items: center; gap: 4px;
        }
        .iface-table-settings-btn:hover { border-color: var(--primary-500); color: var(--text-primary); }
        .iface-table-settings-btn svg { width: 13px; height: 13px; }
        .iface-table-settings-panel {
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg); padding: 16px; margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            color: var(--text-primary);
        }
        .iface-table-settings-panel h4 { margin: 0 0 12px 0; font-size: 13px; color: var(--text-primary); }
        .iface-table-settings-section { margin-bottom: 12px; }
        .iface-table-settings-section label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; display: block; margin-bottom: 4px; }
        .iface-col-list { list-style: none; padding: 0; margin: 0; }
        .iface-col-list li {
            display: flex; align-items: center; gap: 8px; padding: 4px 8px;
            font-size: 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
            margin-bottom: 3px; background: var(--bg-primary);
        }
        .iface-col-list li:hover { background: var(--bg-hover); }
        .iface-col-list .col-move-btns { display: flex; gap: 2px; margin-left: auto; }
        .iface-col-list .col-move-btn {
            padding: 1px 5px; font-size: 10px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); background: var(--bg-primary); color: var(--text-muted);
            cursor: pointer; line-height: 1;
        }
        .iface-col-list .col-move-btn:hover { border-color: var(--primary-500); color: var(--primary-500); }
        .iface-col-remove-btn {
            padding: 1px 5px; font-size: 10px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); background: var(--bg-primary); color: var(--text-muted);
            cursor: pointer; line-height: 1;
        }
        .iface-col-remove-btn:hover { border-color: var(--danger-500); color: var(--danger-500); }
        .iface-settings-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .iface-settings-row select, .iface-settings-row input {
            padding: 4px 8px; font-size: 12px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); background: var(--bg-primary); color: var(--text-primary);
        }
        .iface-settings-save-btn {
            padding: 5px 14px; font-size: 12px; border: none; border-radius: var(--radius-sm);
            background: var(--primary-500); color: #fff; cursor: pointer; font-weight: 500;
        }
        .iface-settings-save-btn:hover { background: var(--primary-600); }
        .iface-add-col-row { display: flex; gap: 4px; margin-top: 6px; }
        .iface-add-col-row select { flex: 1; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); padding: 4px 8px; font-size: 12px; }
        .iface-add-col-btn {
            padding: 3px 10px; font-size: 11px; border: 1px solid var(--primary-500);
            border-radius: var(--radius-sm); background: var(--bg-primary); color: var(--primary-500);
            cursor: pointer;
        }
        .iface-add-col-btn:hover { background: var(--primary-50, var(--bg-hover)); }

        /* Pagination */
        .iface-pagination {
            display: flex; align-items: center; justify-content: space-between;
            padding: 8px 16px; border-top: 1px solid var(--border-primary);
            font-size: 12px; color: var(--text-muted);
        }
        .iface-pagination-btns { display: flex; gap: 4px; }
        .iface-page-btn {
            padding: 4px 10px; font-size: 12px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); background: var(--bg-primary);
            color: var(--text-secondary); cursor: pointer;
        }
        .iface-page-btn:hover { border-color: var(--primary-500); }
        .iface-page-btn:disabled { opacity: 0.4; cursor: default; }
        .iface-page-btn:disabled:hover { border-color: var(--border-primary); }

        /* ============ Revamped Interface Design System ============ */

        .iface-synced-badge {
            display: flex; align-items: center; gap: 5px;
            font-size: 11px; font-weight: 500; color: #0f766e;
            background: #ecfdf3; padding: 4px 10px;
            border-radius: 999px; border: 1px solid #8fd3b2;
        }
        .iface-synced-badge::before {
            content: ''; width: 6px; height: 6px; border-radius: 50%;
            background: #10b981;
        }
        .iface-topbar-avatar {
            width: 30px; height: 30px; border-radius: 50%;
            background: var(--iface-accent); color: white;
            display: flex; align-items: center; justify-content: center;
            font-size: 12px; font-weight: 600; cursor: pointer;
        }

        /* Revamped page container */
        .iface-page-content {
            padding: 32px 24px; max-width: 1240px; margin: 0 auto;
            animation: iface-fadeUp .35s ease both;
        }
        .iface-page-content.full-width { max-width: none; }
        @keyframes iface-fadeUp {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Welcome greeting */
        .iface-welcome-greeting { margin-bottom: 32px; }
        .iface-welcome-greeting h1 {
            font-size: 26px; font-weight: 700; letter-spacing: -.02em;
            color: var(--iface-text); margin-bottom: 4px;
        }
        .iface-welcome-greeting h1 span { color: var(--iface-accent); }
        .iface-welcome-greeting p { font-size: 14px; color: var(--iface-text-muted); }

        /* Action cards */
        .iface-action-cards {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 16px; margin-bottom: 28px;
        }
        .iface-action-card {
            background: var(--iface-surface); border: 1px solid var(--iface-border);
            border-radius: var(--iface-radius); padding: 24px;
            cursor: pointer; transition: all 0.2s ease;
            display: flex; flex-direction: column; gap: 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        .iface-action-card:hover { border-color: var(--iface-accent); box-shadow: 0 4px 12px rgba(0,0,0,0.08); transform: translateY(-1px); }
        .iface-action-card .acard-icon {
            width: 44px; height: 44px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px;
        }
        .iface-action-card .acard-icon.blue { background: rgba(37,99,235,0.08); color: #2563eb; }
        .iface-action-card .acard-icon.green { background: rgba(16,185,129,0.08); color: #10b981; }
        .iface-action-card .acard-icon.slate { background: #f1f5f9; color: var(--iface-text-muted); }
        .iface-action-card h3 { font-size: 15px; font-weight: 600; color: var(--iface-text); }
        .iface-action-card p { font-size: 13px; color: var(--iface-text-muted); line-height: 1.5; }
        .iface-action-card .acard-arrow {
            font-size: 13px; color: var(--iface-accent); font-weight: 500;
            display: flex; align-items: center; gap: 4px; margin-top: auto;
            opacity: 0; transition: opacity 150ms ease;
        }
        .iface-action-card:hover .acard-arrow { opacity: 1; }

        /* Stats row */
        .iface-stats-row {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 0; margin-bottom: 28px;
            background: var(--iface-surface); border: 1px solid var(--iface-border);
            border-radius: var(--iface-radius); overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        .iface-stat-cell {
            padding: 20px 24px; text-align: center;
            border-right: 1px solid var(--iface-border);
            cursor: pointer; transition: background 150ms ease;
        }
        .iface-stat-cell:last-child { border-right: none; }
        .iface-stat-cell:hover { background: rgba(167,118,83,0.04); }
        .iface-stat-cell .stat-num {
            font-size: 28px; font-weight: 700; color: var(--iface-text);
            letter-spacing: -.02em; margin-bottom: 2px;
        }
        .iface-stat-cell .stat-num.green { color: #10b981; }
        .iface-stat-cell .stat-label {
            font-size: 11px; font-weight: 600; color: var(--iface-text-muted);
            text-transform: uppercase; letter-spacing: .06em;
        }

        /* Recent section (hearings, clients) */
        .iface-recent-section h2 {
            font-size: 15px; font-weight: 600; margin-bottom: 14px;
            color: var(--iface-text); display: flex; align-items: center; gap: 8px;
        }
        .iface-recent-section h2 .count {
            font-size: 11px; font-weight: 500; color: var(--iface-text-muted);
            background: #eef2f7; padding: 2px 8px; border-radius: 999px;
        }
        .iface-recent-list {
            background: var(--iface-surface); border: 1px solid var(--iface-border);
            border-radius: var(--iface-radius); overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        .iface-recent-item {
            padding: 14px 20px;
            display: flex; align-items: center; justify-content: space-between;
            border-bottom: 1px solid #edf0f4;
            cursor: pointer; transition: background 150ms ease;
        }
        .iface-recent-item:last-child { border-bottom: none; }
        .iface-recent-item:hover { background: rgba(167,118,83,0.04); }
        .iface-recent-item-left { display: flex; align-items: center; gap: 12px; }
        .iface-ri-avatar {
            width: 34px; height: 34px; border-radius: 50%;
            background: rgba(167,118,83,0.1); color: var(--iface-accent);
            display: flex; align-items: center; justify-content: center;
            font-size: 13px; font-weight: 600;
        }

        /* ====== Inbox-style Case Notes ====== */
        .iface-inbox {
            display: flex; height: 100%; min-height: 500px; overflow: hidden;
        }
        .iface-inbox-list {
            width: 320px; min-width: 280px; max-width: 380px;
            border-right: 1px solid var(--iface-border);
            overflow-y: auto; background: #fafbfc;
            display: flex; flex-direction: column;
        }
        .iface-inbox-list-header {
            padding: 14px 16px; border-bottom: 1px solid var(--iface-border);
            font-size: 14px; font-weight: 700; color: var(--iface-text);
            position: sticky; top: 0; background: #fafbfc; z-index: 1;
            display: flex; align-items: center; justify-content: space-between;
        }
        .iface-inbox-list-header .inbox-count {
            font-size: 11px; font-weight: 500; color: var(--iface-text-muted);
            background: #eef2f7; padding: 2px 8px; border-radius: 999px;
        }
        .iface-inbox-item {
            padding: 12px 16px; cursor: pointer;
            border-bottom: 1px solid #edf0f4;
            transition: background 100ms ease;
        }
        .iface-inbox-item:hover { background: rgba(167,118,83,0.04); }
        .iface-inbox-item.active { background: var(--iface-brand-subtle); border-left: 3px solid var(--iface-accent); }
        .iface-inbox-item-name { font-size: 13px; font-weight: 600; color: var(--iface-text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .iface-inbox-item-preview { font-size: 12px; color: var(--iface-text-muted); margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .iface-inbox-item-time { font-size: 11px; color: var(--iface-text-light); margin-top: 3px; }
        .iface-inbox-detail {
            flex: 1; overflow-y: auto; display: flex; flex-direction: column;
        }
        .iface-inbox-detail-header {
            padding: 16px 20px; border-bottom: 1px solid var(--iface-border);
            position: sticky; top: 0; background: white; z-index: 1;
        }
        .iface-inbox-detail-header h3 { font-size: 16px; font-weight: 600; color: var(--iface-text); margin-bottom: 4px; }
        .iface-inbox-detail-header .inbox-meta { font-size: 12px; color: var(--iface-text-muted); }
        .iface-inbox-messages {
            flex: 1; overflow-y: auto; padding: 16px 20px;
            display: flex; flex-direction: column;
        }
        .iface-inbox-msg {
            padding: 14px 16px; background: #f8fafc; border-radius: 10px;
            border: 1px solid #edf0f4; margin-bottom: 10px; max-width: 85%;
        }
        .iface-inbox-msg.own { align-self: flex-end; background: rgba(167,118,83,0.06); border-color: rgba(167,118,83,0.15); }
        .iface-inbox-msg-header { display: flex; justify-content: space-between; margin-bottom: 6px; }
        .iface-inbox-msg-author { font-size: 12px; font-weight: 600; color: var(--iface-text); }
        .iface-inbox-msg-time { font-size: 11px; color: var(--iface-text-light); }
        .iface-inbox-msg-body { font-size: 13px; line-height: 1.5; color: var(--iface-text); white-space: pre-wrap; }
        .iface-inbox-msg-tags { display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap; }
        .iface-inbox-msg-tag { font-size: 10px; padding: 2px 8px; border-radius: 999px; background: #eef2f7; color: #4b5563; border: 1px solid #d7dfe8; }
        @media (max-width: 768px) {
            .iface-inbox { flex-direction: column; }
            .iface-inbox-list { width: 100%; max-width: none; max-height: 240px; border-right: none; border-bottom: 1px solid var(--iface-border); }
        }
        }
        .iface-ri-info h4 { font-size: 14px; font-weight: 500; color: var(--text-primary); }
        .iface-ri-info p { font-size: 12px; color: var(--text-muted); margin-top: 1px; }
        .iface-recent-item-right { display: flex; align-items: center; gap: 10px; }

        /* Badges */
        .iface-badge-green { background: rgba(34,197,94,0.12); color: #16a34a; }
        html:not(.light-theme) .iface-badge-green { background: rgba(34,197,94,0.15); color: #22c55e; }
        .iface-badge-amber { background: rgba(245,158,11,0.12); color: #92400e; }
        html:not(.light-theme) .iface-badge-amber { background: rgba(245,158,11,0.15); color: #f59e0b; }
        .iface-badge-red { background: rgba(239,68,68,0.12); color: #991b1b; }
        html:not(.light-theme) .iface-badge-red { background: rgba(239,68,68,0.15); color: #ef4444; }
        .iface-badge-blue { background: rgba(59,130,246,0.12); color: #1e40af; }
        html:not(.light-theme) .iface-badge-blue { background: rgba(59,130,246,0.15); color: #60a5fa; }
        .iface-badge-outline {
            background: transparent; border: 1px solid var(--border-primary);
            color: var(--text-muted); font-weight: 500;
        }
        .iface-date-tag { font-size: 12px; color: var(--text-muted); white-space: nowrap; }

        /* Activity log */
        .iface-activity-log { margin-top: 28px; }
        .iface-activity-log h2 {
            font-size: 15px; font-weight: 600; margin-bottom: 14px; color: var(--text-primary);
        }
        .iface-log-item {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 0; font-size: 13px; color: var(--text-secondary);
        }
        .iface-log-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
        .iface-log-dot.green { background: var(--success-500); }
        .iface-log-dot.blue { background: var(--primary-500); }
        .iface-log-time { color: var(--text-muted); font-size: 12px; margin-left: auto; }

        /* Clients page header */
        .iface-clients-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 16px;
        }
        .iface-clients-header h2 { font-size: 17px; font-weight: 600; color: var(--text-primary); }
        .iface-clients-header h2 .muted { color: var(--text-muted); font-weight: 400; font-size: 14px; }
        .iface-clients-header-actions { display: flex; gap: 8px; }

        .iface-client-graph-block {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl);
            padding: 16px;
            margin-top: 16px;
        }
        .iface-client-graph-toolbar {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }
        .iface-client-graph-toolbar label {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 600;
            letter-spacing: 0.02em;
        }
        .iface-client-graph-select {
            min-width: 240px;
            max-width: 420px;
            font-size: 13px;
            padding: 8px 10px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            outline: none;
        }
        .iface-client-graph-select:focus { border-color: var(--primary-500); }
        .iface-client-graph-summary {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 10px;
        }
        .iface-client-graph-canvas-wrap {
            width: 100%;
            height: 460px;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            overflow: hidden;
            background:
                radial-gradient(circle at 25% 20%, rgba(59,130,246,0.10), transparent 55%),
                radial-gradient(circle at 80% 75%, rgba(34,197,94,0.08), transparent 50%),
                var(--bg-primary);
        }
        .iface-client-graph-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .iface-btn-secondary {
            font-family: var(--font-sans); font-size: 13px; font-weight: 500;
            padding: 7px 14px; border-radius: var(--radius-md);
            border: 1px solid var(--border-primary); background: var(--bg-secondary);
            color: var(--text-secondary); cursor: pointer; transition: all var(--transition-fast);
            display: flex; align-items: center; gap: 5px;
        }
        .iface-btn-secondary:hover { border-color: var(--border-secondary); background: var(--bg-tertiary); }
        .iface-btn-primary {
            font-family: var(--font-sans); font-size: 13px; font-weight: 500;
            padding: 7px 14px; border-radius: var(--radius-md);
            border: 1px solid var(--primary-500); background: var(--primary-500);
            color: #fff; cursor: pointer; transition: all var(--transition-fast);
            display: flex; align-items: center; gap: 5px;
        }
        .iface-btn-primary:hover { background: var(--primary-600); border-color: var(--primary-600); }

        /* Filter pills */
        .iface-filter-bar {
            display: flex; align-items: center; gap: 6px;
            margin-bottom: 16px; flex-wrap: wrap;
        }
        .iface-filter-pill {
            font-family: var(--font-sans); font-size: 12px; font-weight: 500;
            padding: 5px 12px; border-radius: 999px;
            border: 1px solid var(--border-primary); background: var(--bg-secondary);
            color: var(--text-muted); cursor: pointer; transition: all var(--transition-fast);
            display: flex; align-items: center; gap: 5px;
        }
        .iface-filter-pill:hover { border-color: var(--border-secondary); }
        .iface-filter-pill:focus-visible { outline: none; box-shadow: 0 0 0 3px var(--amino-focus-ring); }
        .iface-filter-pill.active {
            background: rgba(59,130,246,0.12); border-color: var(--primary-300);
            color: var(--primary-500); font-weight: 600;
        }
        .iface-filter-pill .pill-label { color: var(--text-muted); font-weight: 500; }
        .iface-filter-pill .pill-value { color: var(--text-secondary); font-weight: 500; }
        .iface-filter-pill.active .pill-label { color: var(--primary-500); opacity: .7; }
        .iface-filter-pill svg { width: 12px; height: 12px; }
        .iface-filter-clear {
            font-family: var(--font-sans); font-size: 12px; font-weight: 500;
            color: var(--text-muted); background: none; border: none;
            cursor: pointer; padding: 5px 8px; margin-left: 4px;
        }
        .iface-filter-clear:hover { color: var(--danger-500); }

        /* Revamped data table */
        .iface-table-revamp {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            table-layout: fixed;
        }
        .iface-table-revamp thead th {
            text-align: left; padding: 10px 16px;
            font-size: 12px; font-weight: 600; color: var(--text-muted);
            background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary);
            position: sticky; top: 0; z-index: 10;
            letter-spacing: .01em; white-space: nowrap;
            cursor: pointer; user-select: none;
        }
        .iface-table-revamp thead th:hover { color: var(--text-primary); }
        .iface-table-revamp tbody tr {
            border-bottom: 1px solid var(--border-primary);
            cursor: pointer; transition: background var(--transition-fast);
        }
        .iface-table-revamp tbody tr:nth-child(even) { background: var(--bg-primary); }
        .iface-table-revamp tbody tr:hover { background: var(--bg-hover) !important; box-shadow: inset 3px 0 0 var(--amino-blue); }
        .iface-table-revamp tbody tr:last-child { border-bottom: none; }
        .iface-table-revamp td {
            padding: 11px 16px; color: var(--text-primary);
            vertical-align: middle; white-space: nowrap;
            overflow: hidden; text-overflow: ellipsis; max-width: 240px;
        }
        .iface-table-revamp td .client-name { font-weight: 500; }
        .iface-table-revamp th[data-col="client-name"],
        .iface-table-revamp td[data-col="client-name"],
        .iface-table-revamp th[data-col="name"],
        .iface-table-revamp td[data-col="name"] { min-width: 180px; max-width: 360px; }
        .iface-table-revamp td .cell-muted { color: var(--iface-text-muted, var(--text-muted)); font-size: 12px; }
        .iface-table-revamp td .cell-empty { color: var(--iface-text-light, #94a3b8); }
        .iface-table-revamp td .cell-array .tag { background: rgba(167,118,83,0.1); color: var(--iface-accent, #a77653); border-radius: 999px; }
        .iface-table-revamp td .date-primary { font-size: 13px; color: var(--iface-text, var(--text-primary)); }
        .iface-table-revamp td .date-relative { font-size: 11px; color: var(--iface-text-muted, var(--text-muted)); margin-top: 1px; }
        .iface-table-revamp td .status-dot {
            display: inline-block; width: 7px; height: 7px;
            border-radius: 50%; margin-right: 6px; vertical-align: middle;
        }
        .iface-table-revamp td .status-dot.green { background: var(--success-500); }
        .iface-table-revamp td .status-dot.amber { background: var(--warning-500); }
        .iface-table-revamp td .status-dot.red { background: var(--danger-500); }
        .iface-table-revamp td .status-dot.slate { background: var(--text-muted); }

        /*  Revamp table responsive: progressive column hiding  */
        @media (max-width: 1400px) {
            .iface-table-revamp th[data-col="last-modified-by"],
            .iface-table-revamp td[data-col="last-modified-by"],
            .iface-table-revamp th[data-col="email"],
            .iface-table-revamp td[data-col="email"] { display: none; }
        }
        @media (max-width: 1200px) {
            .iface-table-revamp th[data-col="country"],
            .iface-table-revamp td[data-col="country"],
            .iface-table-revamp th[data-col="event-info"],
            .iface-table-revamp td[data-col="event-info"],
            .iface-table-revamp th[data-col="phone"],
            .iface-table-revamp td[data-col="phone"] { display: none; }
        }
        @media (max-width: 1024px) {
            .iface-page[data-page-id="clients"] .iface-page-content.full-width {
                padding: 20px 14px 16px;
            }
            .iface-clients-header {
                flex-wrap: wrap;
                gap: 10px;
                align-items: flex-start;
            }
            .iface-clients-header h2 {
                flex: 1 1 220px;
            }
            .iface-clients-header-actions {
                flex: 1 1 320px;
                width: 100%;
            }
            .iface-clients-header-actions .iface-block-search {
                flex: 1;
                min-width: 180px;
                width: auto !important;
                margin-right: 0 !important;
            }
            .iface-table-revamp thead th,
            .iface-table-revamp td {
                padding: 9px 12px;
            }
            .iface-table-revamp th[data-col="a-"],
            .iface-table-revamp td[data-col="a-"],
            .iface-table-revamp th[data-col="last-modified"],
            .iface-table-revamp td[data-col="last-modified"] { display: none; }
        }
        @media (max-width: 768px) {
            .iface-table-revamp th[data-col="dob-age"],
            .iface-table-revamp td[data-col="dob-age"],
            .iface-table-revamp th[data-col="ich-atty"],
            .iface-table-revamp td[data-col="ich-atty"],
            .iface-table-revamp th[data-col="mch-atty"],
            .iface-table-revamp td[data-col="mch-atty"],
            .iface-table-revamp th[data-col="case-manager"],
            .iface-table-revamp td[data-col="case-manager"] { display: none; }
            .iface-table-revamp { table-layout: auto; }
            .iface-table-revamp thead th,
            .iface-table-revamp td {
                padding: 8px 10px;
                font-size: 12px;
            }
        }
        @media (max-width: 640px) {
            .iface-page[data-page-id="clients"] .iface-page-content.full-width {
                padding: 14px 8px 12px;
            }
            .iface-clients-header h2 {
                font-size: 15px;
            }
            .iface-clients-header h2 .muted {
                display: block;
                margin-top: 2px;
                font-size: 12px;
            }
            .iface-clients-header-actions {
                flex-wrap: wrap;
                gap: 6px;
            }
            .iface-clients-header-actions > * {
                width: 100%;
            }
            .iface-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .iface-table-revamp thead th,
            .iface-table-revamp td {
                padding: 8px 10px;
                font-size: 12px;
            }
            .iface-table-revamp td {
                max-width: 180px;
            }
            .iface-table-revamp th[data-col="next-event"],
            .iface-table-revamp td[data-col="next-event"] { display: none; }
        }
        @media (max-width: 480px) {
            .iface-table-revamp thead th,
            .iface-table-revamp td {
                padding: 6px 8px;
                font-size: 11px;
            }
            .iface-table-revamp td {
                max-width: 140px;
            }
        }

        /* Events page layout */
        .iface-events-layout {
            display: grid; grid-template-columns: 240px 1fr; gap: 20px;
        }
        .iface-events-sidebar {
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl); padding: 16px;
            height: fit-content; position: sticky; top: 110px;
        }
        .iface-events-sidebar-search {
            font-family: var(--font-sans); font-size: 12px;
            width: 100%; padding: 7px 10px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-md); background: var(--bg-primary);
            outline: none; margin-bottom: 12px; color: var(--text-primary);
        }
        .iface-events-sidebar-search::placeholder { color: var(--text-muted); }
        .iface-events-sidebar-search:focus { border-color: var(--primary-500); }
        .iface-sidebar-group-title {
            font-size: 10px; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: .08em;
            padding: 8px 0 4px; display: flex; align-items: center; justify-content: space-between;
        }
        .iface-sidebar-toggle {
            font-size: 10px; color: var(--primary-500); font-weight: 500;
            background: none; border: none; cursor: pointer; font-family: var(--font-sans);
        }
        .iface-attorney-row {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 4px; border-radius: 6px; cursor: pointer;
            transition: background var(--transition-fast);
        }
        .iface-attorney-row:hover { background: var(--bg-hover); }
        .iface-attorney-check {
            width: 16px; height: 16px; border-radius: 4px;
            border: 1.5px solid var(--border-secondary); flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            transition: all var(--transition-fast);
        }
        .iface-attorney-check.checked { background: var(--primary-500); border-color: var(--primary-500); }
        .iface-attorney-check.checked::after {
            content: '\2713'; color: white; font-size: 10px; font-weight: 700;
        }
        .iface-attorney-name-side { font-size: 13px; font-weight: 400; color: var(--text-secondary); }
        .iface-attorney-row.active .iface-attorney-name-side { color: var(--text-primary); font-weight: 500; }

        /* Events main area */
        .iface-events-main {
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl); overflow: hidden;
        }
        .iface-cal-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 16px 20px; border-bottom: 1px solid var(--border-primary);
        }
        .iface-cal-header-left { display: flex; align-items: center; gap: 12px; }
        .iface-cal-nav-btn {
            font-family: var(--font-sans); width: 30px; height: 30px; border-radius: 6px;
            border: 1px solid var(--border-primary); background: var(--bg-secondary);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: var(--text-muted); font-size: 14px;
            transition: all var(--transition-fast);
        }
        .iface-cal-nav-btn:hover { background: var(--bg-hover); border-color: var(--border-secondary); }
        .iface-cal-month { font-size: 16px; font-weight: 600; color: var(--text-primary); }
        .iface-cal-header-right { display: flex; gap: 4px; }
        .iface-view-btn {
            font-family: var(--font-sans); font-size: 12px; font-weight: 500;
            padding: 5px 12px; border-radius: 999px;
            border: 1px solid transparent; background: transparent;
            color: var(--text-muted); cursor: pointer; transition: all var(--transition-fast);
        }
        .iface-view-btn:hover { background: var(--bg-hover); }
        .iface-view-btn.active { background: rgba(59,130,246,0.12); color: var(--primary-500); border-color: var(--primary-300); }

        /* Calendar filters bar */
        .iface-cal-filters {
            display: flex; gap: 4px; padding: 10px 20px; border-bottom: 1px solid var(--border-primary);
            background: var(--bg-tertiary);
        }
        .iface-cal-filter-btn {
            font-family: var(--font-sans); font-size: 12px; font-weight: 500;
            padding: 4px 12px; border-radius: 999px;
            border: none; background: transparent;
            color: var(--text-muted); cursor: pointer;
        }
        .iface-cal-filter-btn.active { background: var(--bg-secondary); color: var(--text-primary); box-shadow: var(--shadow-sm); }

        /* Agenda items */
        .iface-agenda-list { padding: 0; }
        .iface-agenda-day {
            padding: 12px 20px 4px;
            font-size: 12px; font-weight: 600; color: var(--text-muted);
            background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary);
            letter-spacing: .02em;
        }
        .iface-agenda-day.today { color: var(--primary-500); }
        .iface-agenda-item {
            display: flex; align-items: flex-start; gap: 12px;
            padding: 14px 20px; border-bottom: 1px solid var(--border-primary);
            cursor: pointer; transition: background var(--transition-fast);
        }
        .iface-agenda-item:hover { background: var(--bg-hover); }
        .iface-agenda-time {
            font-size: 12px; font-weight: 500; color: var(--text-muted);
            min-width: 70px; padding-top: 1px;
            font-family: var(--font-mono);
        }
        .iface-agenda-bar {
            width: 3px; border-radius: 2px; min-height: 36px; flex-shrink: 0;
        }
        .iface-agenda-bar.blue { background: var(--primary-500); }
        .iface-agenda-bar.green { background: var(--success-500); }
        .iface-agenda-bar.amber { background: var(--warning-500); }
        .iface-agenda-bar.red { background: var(--danger-500); }
        .iface-agenda-content h4 {
            font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 2px;
        }
        .iface-agenda-content p { font-size: 12px; color: var(--text-muted); }
        .iface-agenda-content .agenda-tags { display: flex; gap: 4px; margin-top: 5px; flex-wrap: wrap; }

        /* Breadcrumb */
        .iface-breadcrumb {
            font-size: 12px; color: var(--text-muted); margin-bottom: 18px;
            display: flex; align-items: center; gap: 6px;
        }
        .iface-breadcrumb a {
            color: var(--text-muted); text-decoration: none; cursor: pointer;
        }
        .iface-breadcrumb a:hover { color: var(--primary-500); }
        .iface-breadcrumb .sep { color: var(--border-primary); }

        /* Two-column layout for home page */
        .iface-home-columns {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
        }
        @media (max-width: 768px) {
            .iface-action-cards { grid-template-columns: 1fr; }
            .iface-stats-row { grid-template-columns: repeat(2, 1fr); }
            .iface-home-columns { grid-template-columns: 1fr; }
            .iface-events-layout { grid-template-columns: 1fr; }
        }

        /*  Interface app: comprehensive mobile improvements  */
        @media (max-width: 640px) {
            .iface-mainnav {
                height: auto; min-height: 48px;
                padding: 8px 12px; gap: 8px; flex-wrap: wrap;
            }
            .iface-mainnav-left { flex-wrap: wrap; gap: 8px; }
            .iface-logo-text { display: none; }
            .iface-nav-divider { display: none; }
            .iface-quick-action span:not(svg) { display: none; }
            .iface-quick-action { padding: 6px 10px; }
            .iface-global-search { width: 120px; font-size: 11px; padding: 6px 10px; }
            .iface-edit-toggle { font-size: 11px; padding: 4px 8px; }
            .iface-page-tabs {
                gap: 0; padding: 0 8px;
                -ms-overflow-style: none; scrollbar-width: none;
            }
            .iface-page-tab { padding: 6px 10px; font-size: 12px; }
            .iface-filter-bar {
                overflow-x: auto; flex-wrap: nowrap;
                -webkit-overflow-scrolling: touch;
                -ms-overflow-style: none; scrollbar-width: none;
                padding-bottom: 4px;
            }
            .iface-filter-bar::-webkit-scrollbar { display: none; }
            .iface-filter-pill { flex-shrink: 0; font-size: 11px; padding: 4px 10px; }
            .iface-pagination { flex-wrap: wrap; gap: 6px; padding: 10px 12px; }
            .iface-pagination span { font-size: 11px; }
        }
        @media (max-width: 480px) {
            .iface-mainnav-right { gap: 4px; }
            .iface-global-search { width: 100px; }
            .iface-quick-action.secondary { display: none; }
        }

        .hidden { display: none !important; }

        /* Unlock Screen */
        #unlock-screen { position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 110; }
        #unlock-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .unlock-box { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); padding: 32px; width: 400px; box-shadow: var(--shadow-xl); }
        .unlock-box h2 { font-size: 22px; margin-bottom: 8px; color: var(--text-primary); display: flex; align-items: center; gap: 10px; }
        .unlock-box h2 .lock-icon { font-size: 24px; }
        .unlock-box .subtitle { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }
        .unlock-box input { width: 100%; padding: 12px 14px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 14px; margin-bottom: 12px; }
        .unlock-box input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
        .unlock-box button { width: 100%; padding: 12px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; transition: background var(--transition-fast); }
        .unlock-box button:hover { background: var(--primary-600); }
        .unlock-box button:disabled { background: var(--gray-600); cursor: not-allowed; }
        .unlock-box button.secondary { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-primary); }
        .unlock-box button.secondary:hover { background: var(--bg-hover); }
        .unlock-box button.passkey-btn { background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; gap: 8px; }
        .unlock-box button.passkey-btn:hover { background: var(--bg-hover); }
        .unlock-box button.passkey-btn .passkey-icon { font-size: 18px; }
        .unlock-error { color: #f87171; font-size: 13px; margin-bottom: 12px; padding: 10px 12px; background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-md); display: none; }
        .unlock-divider { display: flex; align-items: center; gap: 12px; margin: 16px 0; color: var(--text-muted); font-size: 12px; }
        .unlock-divider::before, .unlock-divider::after { content: ''; flex: 1; height: 1px; background: var(--border-primary); }
        .unlock-info { color: var(--text-muted); font-size: 12px; margin-top: 16px; text-align: center; line-height: 1.5; }
        .unlock-info a { color: var(--primary-400); text-decoration: none; }
        .unlock-info a:hover { text-decoration: underline; }
        .setup-section { margin-bottom: 20px; }
        .setup-section label { display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500; }
        .password-strength { height: 4px; background: var(--bg-tertiary); border-radius: 2px; margin-top: -8px; margin-bottom: 12px; overflow: hidden; }
        .password-strength-fill { height: 100%; transition: width 0.2s, background 0.2s; width: 0%; }
        .password-strength-fill.weak { background: var(--danger-500); width: 33%; }
        .password-strength-fill.medium { background: var(--warning-500); width: 66%; }
        .password-strength-fill.strong { background: var(--success-500); width: 100%; }
        .security-note { background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 12px; margin-bottom: 16px; font-size: 12px; color: var(--text-secondary); line-height: 1.5; }
        .security-note strong { color: var(--text-primary); }

        /* Empty & Loading States */
        .empty-state { padding: 60px 20px; text-align: center; color: var(--text-muted); }
        .empty-state h3 { font-size: 16px; margin-bottom: 8px; color: var(--text-primary); }
        .loading-state { padding: 60px 20px; text-align: center; color: var(--text-muted); animation: fadeIn 0.15s ease-out; }
        .loading-state h3 { font-size: 16px; margin-bottom: 8px; color: var(--text-primary); }
        .loading-spinner { display: inline-block; width: 24px; height: 24px; border: 3px solid var(--border-primary); border-top-color: var(--primary-500); border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Skeleton Loading */
        .skeleton-row td { background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .skeleton-cell { height: 16px; background: var(--border-primary); border-radius: var(--radius-sm); }

        /* Progress Bar */
        .progress-bar { height: 3px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; margin-top: 4px; }
        .progress-fill { height: 100%; background: var(--primary-500); transition: width 0.3s ease; }
        .table-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .table-container { position: relative; }

        /* ===== View Controls Bar ===== */
        .view-controls-bar { display: flex; align-items: center; gap: 4px; padding: 8px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); }
        .view-control-wrapper { position: relative; }
        .view-control-btn {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 10px; background: transparent; border: none;
            border-radius: var(--radius-sm); cursor: pointer; font-size: 13px;
            color: var(--text-secondary); transition: all var(--transition-fast);
        }
        .view-control-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .view-control-btn.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-control-btn svg { flex-shrink: 0; }
        .control-count { background: var(--primary-500); color: #fff; font-size: 10px; font-weight: 600; padding: 1px 5px; border-radius: 8px; min-width: 16px; text-align: center; }
        .view-controls-spacer { flex: 1; }

        /* View Search */
        .view-search-wrapper { position: relative; display: flex; align-items: center; }
        .view-search-wrapper .search-icon { position: absolute; left: 10px; color: var(--text-muted); pointer-events: none; }
        .view-search-input {
            padding: 6px 10px 6px 32px; border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm); font-size: 13px; width: 180px;
            background: var(--bg-tertiary); color: var(--text-primary);
            transition: all var(--transition-fast);
        }
        .view-search-input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15); width: 220px; }
        .view-search-input::placeholder { color: var(--text-muted); }

        /* View Control Dropdowns */
        .view-control-dropdown {
            position: absolute; top: 100%; left: 0; margin-top: 4px;
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg); box-shadow: var(--shadow-lg);
            z-index: 100; min-width: 280px; display: none;
        }
        .view-control-dropdown.open { display: block; }
        .dropdown-section { padding: 0; }
        .dropdown-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid var(--border-primary); background: var(--bg-tertiary); border-radius: var(--radius-lg) var(--radius-lg) 0 0; }
        .dropdown-header span { font-size: 13px; font-weight: 600; color: var(--text-primary); }
        .dropdown-action-btn { background: transparent; border: none; color: var(--primary-400); font-size: 12px; cursor: pointer; padding: 4px 8px; border-radius: var(--radius-sm); }
        .dropdown-action-btn:hover { background: rgba(59, 130, 246, 0.15); }

        /* Filter Dropdown */
        .filter-list { padding: 12px 16px; max-height: 300px; overflow-y: auto; }
        .empty-filters, .empty-sorts { color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px 0; }
        .filter-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .filter-row:last-child { border-bottom: none; }
        .filter-row select, .filter-row input { padding: 6px 8px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; background: var(--bg-tertiary); color: var(--text-primary); }
        .filter-row select { min-width: 100px; }
        .filter-row input { flex: 1; min-width: 80px; }
        .filter-remove-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 4px; border-radius: var(--radius-sm); }
        .filter-remove-btn:hover { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Filter dropdown  wider for nested groups */
        .filter-dropdown { min-width: 520px; max-width: 680px; }
        .filter-list { max-height: 420px; }

        /* Filter Groups (nested AND/OR) */
        .filter-group { border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 8px; margin: 4px 0; background: var(--bg-secondary); }
        .filter-group .filter-group { background: var(--bg-tertiary); border-color: var(--border-secondary); }
        .filter-group .filter-group .filter-group { background: var(--bg-primary); }
        .filter-group-header { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .filter-group-logic-toggle { display: inline-flex; align-items: center; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); overflow: hidden; font-size: 11px; font-weight: 600; }
        .filter-group-logic-toggle button { background: var(--bg-tertiary); border: none; padding: 3px 10px; cursor: pointer; color: var(--text-muted); transition: all var(--transition-fast); }
        .filter-group-logic-toggle button.active { background: rgba(99, 102, 241, 0.2); color: #818cf8; }
        .filter-group-logic-toggle button:hover:not(.active) { background: var(--bg-primary); color: var(--text-secondary); }
        .filter-group-actions { display: flex; gap: 4px; margin-left: auto; }
        .filter-group-add-btn { background: transparent; border: none; color: var(--primary-400); font-size: 11px; cursor: pointer; padding: 2px 6px; border-radius: var(--radius-sm); white-space: nowrap; }
        .filter-group-add-btn:hover { background: rgba(59, 130, 246, 0.15); }
        .filter-group-remove-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 2px 6px; border-radius: var(--radius-sm); font-size: 12px; }
        .filter-group-remove-btn:hover { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .filter-group-conditions { display: flex; flex-direction: column; gap: 2px; }
        .filter-row .filter-logic-label { font-size: 11px; color: var(--text-muted); font-weight: 600; min-width: 32px; text-align: center; text-transform: uppercase; }

        /* Sort Dropdown */
        .sort-list { padding: 12px 16px; max-height: 300px; overflow-y: auto; }
        .sort-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .sort-row:last-child { border-bottom: none; }
        .sort-row select { padding: 6px 8px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; flex: 1; background: var(--bg-tertiary); color: var(--text-primary); }
        .sort-direction-btns { display: flex; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); overflow: hidden; }
        .sort-direction-btn { padding: 6px 10px; background: var(--bg-tertiary); border: none; cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .sort-direction-btn.active { background: var(--primary-500); color: #fff; }
        .sort-direction-btn:first-child { border-right: 1px solid var(--border-primary); }
        .sort-remove-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 4px; border-radius: var(--radius-sm); }
        .sort-remove-btn:hover { background: rgba(239, 68, 68, 0.15); color: #f87171; }

        /* Group & Color Dropdown */
        .group-options, .color-options { padding: 8px 0; max-height: 400px; overflow-y: auto; }
        .group-option, .color-option { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; font-size: 13px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .group-option:hover, .color-option:hover { background: var(--bg-hover); }
        .group-option .check-mark, .color-option .check-mark { color: var(--primary-400); font-size: 14px; width: 16px; visibility: hidden; }
        .group-option.selected .check-mark, .color-option.selected .check-mark, .group-option.none-selected .check-mark, .color-option.none-selected .check-mark { visibility: visible; }

        /* Dropdown Search */
        .dropdown-search-wrapper { padding: 8px 12px; border-bottom: 1px solid var(--border-primary); }
        .dropdown-search-input { width: 100%; padding: 8px 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 13px; box-sizing: border-box; background: var(--bg-tertiary); color: var(--text-primary); }
        .dropdown-search-input:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15); }
        .dropdown-search-input::placeholder { color: var(--text-muted); }

        /* Grouped Table */
        .group-header-row td { background: var(--bg-secondary); font-weight: 600; padding: 10px 12px !important; border-top: 1px solid var(--border-primary); cursor: pointer; user-select: none; }
        .group-header-row:hover td { background: var(--bg-hover); }
        .group-header-row .group-toggle { display: inline-flex; align-items: center; gap: 8px; color: var(--text-primary); }
        .group-header-row .group-toggle svg { width: 16px; height: 16px; transition: transform 0.2s; color: var(--text-muted); }
        .group-header-row.collapsed .group-toggle svg { transform: rotate(-90deg); }
        .group-header-row .group-name { font-size: 13px; }
        .group-header-row .group-count { font-size: 12px; color: var(--text-muted); font-weight: 400; margin-left: 8px; }
        .group-row.hidden { display: none; }

        /* Color By Row Styling */
        tr[data-color-idx] td { transition: background 0.15s; }
        tr[data-color-idx="0"] td { background: rgba(59, 130, 246, 0.12); }
        tr[data-color-idx="1"] td { background: rgba(16, 185, 129, 0.12); }
        tr[data-color-idx="2"] td { background: rgba(245, 158, 11, 0.12); }
        tr[data-color-idx="3"] td { background: rgba(239, 68, 68, 0.12); }
        tr[data-color-idx="4"] td { background: rgba(139, 92, 246, 0.12); }
        tr[data-color-idx="5"] td { background: rgba(236, 72, 153, 0.12); }
        tr[data-color-idx="6"] td { background: rgba(6, 182, 212, 0.12); }
        tr[data-color-idx="7"] td { background: rgba(249, 115, 22, 0.12); }
        tr[data-color-idx="8"] td { background: rgba(34, 197, 94, 0.12); }
        tr[data-color-idx="9"] td { background: rgba(168, 85, 247, 0.12); }
        tr[data-color-idx="10"] td { background: rgba(14, 165, 233, 0.12); }
        tr[data-color-idx="11"] td { background: rgba(251, 146, 60, 0.12); }
        tr[data-color-idx="12"] td { background: rgba(52, 211, 153, 0.12); }
        tr[data-color-idx="13"] td { background: rgba(244, 63, 94, 0.12); }
        tr[data-color-idx="14"] td { background: rgba(99, 102, 241, 0.12); }
        tr[data-color-idx="15"] td { background: rgba(217, 70, 239, 0.12); }
        tr[data-color-idx="16"] td { background: rgba(20, 184, 166, 0.12); }
        tr[data-color-idx="17"] td { background: rgba(234, 179, 8, 0.12); }
        tr[data-color-idx="18"] td { background: rgba(248, 113, 113, 0.12); }
        tr[data-color-idx="19"] td { background: rgba(96, 165, 250, 0.12); }
        /* Color swatch dots in dropdown */
        .color-option .color-swatch { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }

        /* Record count badge next to Filter */
        .record-count-badge { font-size: 11px; color: var(--text-muted); margin-left: 4px; font-weight: 400; }
        .record-count-badge.filtered { color: var(--primary-400); }

        /* Row Height */
        .row-height-option { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; font-size: 13px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .row-height-option:hover { background: var(--bg-hover); }
        .row-height-option.selected { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .row-height-option svg { color: var(--text-muted); }
        .row-height-option.selected svg { color: var(--primary-400); }
        table.row-height-short td { padding: 4px 12px; }
        table.row-height-medium td { padding: 8px 12px; }
        table.row-height-tall td { padding: 14px 12px; }
        table.row-height-extra-tall td { padding: 20px 12px; white-space: normal; }
        /* ===== Modals ===== */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .modal-overlay.open { opacity: 1; visibility: visible; }
        .modal { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 90%; max-width: 700px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: var(--shadow-xl); transform: translateY(20px); transition: transform 0.2s; }
        .modal-overlay.open .modal { transform: translateY(0); }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .modal-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); flex: 1; margin: 0; }
        .modal-header .record-id { font-size: 12px; color: var(--text-muted); font-family: var(--font-mono); }
        .history-view-record-btn { display: flex; align-items: center; gap: 6px; padding: 6px 12px; border: 1px solid var(--border-primary); background: var(--bg-tertiary); border-radius: var(--radius-md); cursor: pointer; font-size: 12px; font-weight: 500; color: var(--text-secondary); transition: all 0.15s; white-space: nowrap; }
        .history-view-record-btn:hover { background: var(--bg-hover); color: var(--primary-400); border-color: var(--primary-400); }
        .modal-close { width: 32px; height: 32px; border: none; background: var(--bg-tertiary); border-radius: var(--radius-md); cursor: pointer; font-size: 18px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .modal-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .modal-body { flex: 1; overflow-y: auto; padding: 0; }
        .modal-empty { padding: 60px 20px; text-align: center; color: var(--text-muted); }
        .modal-empty h3 { font-size: 16px; color: var(--text-primary); margin-bottom: 8px; }

        /* History Timeline */
        .history-timeline { padding: 16px 0; }
        .history-item { padding: 16px 24px; border-bottom: 1px solid var(--border-primary); transition: background var(--transition-fast); }
        .history-item:hover { background: var(--bg-hover); }
        .history-item:last-child { border-bottom: none; }
        .history-item-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
        .history-field-name { font-weight: 600; color: var(--text-primary); font-size: 14px; }
        .history-change-type { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: var(--radius-sm); text-transform: uppercase; letter-spacing: 0.3px; }
        .history-change-type.created { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .history-change-type.updated { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .history-change-type.deleted { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .history-actor { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: var(--radius-sm); background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .history-device { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: var(--radius-sm); background: rgba(20, 184, 166, 0.15); color: #2dd4bf; }
        .history-source { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: var(--radius-sm); background: rgba(100, 116, 139, 0.15); color: #94a3b8; text-transform: capitalize; }
        .history-timestamp { font-size: 12px; color: var(--text-muted); margin-left: auto; }
        .history-event-id { font-size: 11px; color: var(--text-disabled); font-family: var(--font-mono); }
        .history-values { display: flex; gap: 12px; align-items: flex-start; flex-wrap: wrap; }
        .history-value-box { flex: 1; min-width: 200px; padding: 10px 12px; border-radius: var(--radius-md); font-size: 13px; }
        .history-value-box.old { background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); }
        .history-value-box.new { background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); }
        .history-value-box.null { background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-muted); font-style: italic; }
        .history-value-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin-bottom: 4px; }
        .history-value-content { word-break: break-word; color: var(--text-secondary); }
        .history-arrow { color: var(--text-muted); font-size: 16px; flex-shrink: 0; align-self: center; }
        .history-btn { padding: 4px 8px; background: transparent; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: inline-flex; align-items: center; gap: 4px; transition: all var(--transition-fast); }
        .history-btn:hover { background: var(--bg-hover); border-color: var(--primary-500); color: var(--primary-400); }
        .history-btn svg { width: 12px; height: 12px; }
        .history-item-actions { display: flex; gap: 8px; margin-top: 10px; }
        .history-revert-btn { padding: 5px 12px; background: transparent; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 12px; color: var(--text-muted); font-weight: 500; transition: all var(--transition-fast); display: inline-flex; align-items: center; gap: 6px; }
        .history-revert-btn:hover { background: var(--primary-500); border-color: var(--primary-500); color: white; }
        .history-revert-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .history-revert-btn svg { width: 14px; height: 14px; }

        /* Modal Toolbar */
        .modal-toolbar { padding: 12px 24px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .modal-toolbar select { padding: 6px 10px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 13px; background: var(--bg-secondary); color: var(--text-primary); }
        .modal-toolbar .history-count { font-size: 12px; color: var(--text-muted); margin-left: auto; }

        /* View Selector */
        .view-selector { position: relative; display: flex; align-items: center; gap: 8px; }
        .view-selector-btn { padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 8px; min-width: 140px; transition: border-color var(--transition-fast); color: var(--text-secondary); }
        .view-selector-btn:hover { border-color: var(--primary-500); }
        .view-selector-btn .view-icon { font-size: 14px; }
        .view-selector-btn .view-name { flex: 1; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .view-selector-btn .dropdown-arrow { font-size: 10px; color: var(--text-muted); }
        .view-selector-dropdown { position: absolute; top: 100%; left: 0; margin-top: 4px; min-width: 200px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 100; max-height: 300px; overflow-y: auto; display: none; }
        .view-selector-dropdown.open { display: block; }
        .view-selector-dropdown-header { padding: 10px 12px; font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border-primary); background: var(--bg-tertiary); }
        .view-selector-option { padding: 10px 12px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 10px; transition: background var(--transition-fast); color: var(--text-secondary); }
        .view-selector-option:hover { background: var(--bg-hover); }
        .view-selector-option.active { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-selector-option .view-type-icon { width: 20px; text-align: center; }
        .view-selector-option .view-option-name { flex: 1; }
        .view-selector-option .view-check { color: var(--primary-400); font-size: 14px; }

        /* Fields Button & Dropdown */
        .fields-btn { padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 6px; transition: all var(--transition-fast); color: var(--text-secondary); }
        .fields-btn:hover { border-color: var(--primary-500); color: var(--text-primary); }
        .fields-btn .fields-icon { font-size: 14px; }
        .fields-btn .fields-count { background: rgba(59, 130, 246, 0.15); color: var(--primary-400); padding: 2px 6px; border-radius: 10px; font-size: 11px; font-weight: 600; }
        .fields-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; width: 340px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 100; display: none; }
        .fields-dropdown.open { display: block; }
        .fields-dropdown-header { padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; }
        .fields-dropdown-header h3 { font-size: 14px; font-weight: 600; color: var(--text-primary); margin: 0; }
        .fields-dropdown-actions { display: flex; gap: 8px; }
        .fields-dropdown-actions button { padding: 4px 8px; font-size: 11px; background: transparent; border: none; color: var(--primary-400); cursor: pointer; border-radius: var(--radius-sm); }
        .fields-dropdown-actions button:hover { background: rgba(59, 130, 246, 0.15); }
        .fields-search-container { padding: 8px 12px; border-bottom: 1px solid var(--border-primary); }
        .fields-search-input { width: 100%; padding: 6px 10px; font-size: 13px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); outline: none; box-sizing: border-box; }
        .fields-search-input::placeholder { color: var(--text-muted); }
        .fields-search-input:focus { border-color: var(--primary-500); }
        .fields-dropdown-list { max-height: 450px; overflow-y: auto; padding: 8px 0; }
        .fields-dropdown-item.drag-over-above { box-shadow: inset 0 2px 0 0 var(--primary-500); }
        .fields-dropdown-item.drag-over-below { box-shadow: inset 0 -2px 0 0 var(--primary-500); }
        .fields-dropdown-item { padding: 8px 16px; display: flex; align-items: center; gap: 10px; cursor: pointer; transition: background var(--transition-fast); user-select: none; }
        .fields-dropdown-item:hover { background: var(--bg-hover); }
        .fields-dropdown-item.dragging { background: rgba(59, 130, 246, 0.15); opacity: 0.8; }
        .fields-dropdown-item .field-drag-handle { cursor: grab; color: var(--text-disabled); font-size: 12px; padding: 2px; }
        .fields-dropdown-item .field-drag-handle:hover { color: var(--text-muted); }
        .fields-dropdown-item .field-checkbox { width: 18px; height: 18px; border: 2px solid var(--border-secondary); border-radius: var(--radius-sm); display: flex; align-items: center; justify-content: center; transition: all var(--transition-fast); flex-shrink: 0; }
        .fields-dropdown-item .field-checkbox.checked { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .fields-dropdown-item .field-checkbox .check-icon { font-size: 12px; display: none; }
        .fields-dropdown-item .field-checkbox.checked .check-icon { display: block; }
        .fields-dropdown-item .field-info { flex: 1; min-width: 0; }
        .fields-dropdown-item .field-name { font-size: 13px; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .fields-dropdown-item .field-type { font-size: 11px; color: var(--text-muted); }
        .fields-dropdown-item .field-move-btns { display: flex; flex-direction: column; gap: 2px; opacity: 0; transition: opacity var(--transition-fast); }
        .fields-dropdown-item:hover .field-move-btns { opacity: 1; }
        .fields-dropdown-item .field-move-btn { width: 18px; height: 14px; border: none; background: var(--bg-tertiary); border-radius: 3px; cursor: pointer; font-size: 10px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .fields-dropdown-item .field-move-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .fields-dropdown-footer { padding: 10px 16px; border-top: 1px solid var(--border-primary); background: var(--bg-tertiary); font-size: 11px; color: var(--text-muted); }
        .toolbar-views { display: flex; align-items: center; gap: 8px; position: relative; }
        /* ===== Loading Overlay ===== */
        #loading-overlay {
            position: fixed; inset: 0;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            display: flex; align-items: center; justify-content: center; z-index: 200;
        }
        #loading-overlay.fading-out { opacity: 0; transition: opacity 0.4s ease; pointer-events: none; }
        .loading-content { text-align: center; max-width: 400px; padding: 40px; }
        .loading-logo { width: 80px; height: 80px; margin: 0 auto 24px; position: relative; }
        .loading-logo-inner {
            width: 100%; height: 100%; border-radius: 20px;
            background: linear-gradient(135deg, var(--primary-500) 0%, #7c3aed 100%);
            animation: pulse-glow 2s ease-in-out infinite;
            display: flex; align-items: center; justify-content: center;
            font-size: 36px; color: white;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.4); transform: scale(1); }
            50% { box-shadow: 0 0 40px rgba(124, 58, 237, 0.6); transform: scale(1.05); }
        }
        .loading-title { font-size: 24px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; }
        .loading-subtitle { font-size: 14px; color: var(--text-muted); margin-bottom: 32px; line-height: 1.5; }
        .loading-progress-container { background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 20px; margin-bottom: 24px; }
        .loading-progress-bar { height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden; margin-bottom: 16px; position: relative; }
        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-500), #7c3aed, var(--primary-500));
            background-size: 200% 100%; border-radius: 3px;
            transition: width 0.3s ease; animation: shimmer-progress 1.5s linear infinite;
        }
        @keyframes shimmer-progress { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .loading-status { font-size: 13px; color: var(--text-secondary); margin-bottom: 4px; }
        .loading-detail { font-size: 12px; color: var(--text-muted); font-family: var(--font-mono); }
        .loading-time-estimate { font-size: 11px; color: var(--text-muted); margin-top: 8px; min-height: 16px; }
        .loading-table-progress { font-size: 12px; color: var(--text-muted); font-family: var(--font-mono); margin-top: 4px; min-height: 16px; }
        .loading-speed { font-size: 11px; color: var(--primary-500); margin-top: 8px; min-height: 16px; font-family: var(--font-mono); }
        .loading-progress-activity { position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; border-radius: 3px; }
        .loading-progress-activity::after {
            content: ''; position: absolute; top: 0; left: -100%; height: 100%; width: 50%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: activity-sweep 1.2s ease-in-out infinite;
        }
        @keyframes activity-sweep { 0% { left: -50%; } 100% { left: 100%; } }
        .loading-facts { display: flex; justify-content: center; gap: 24px; margin-bottom: 24px; }
        .loading-fact { text-align: center; }
        .loading-fact-value { font-size: 28px; font-weight: 700; color: var(--text-primary); line-height: 1; }
        .loading-fact-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }
        .loading-note { font-size: 12px; color: var(--text-muted); background: rgba(255, 255, 255, 0.03); border: 1px solid var(--border-primary); padding: 12px 16px; border-radius: var(--radius-lg); border-left: 3px solid var(--primary-500); }
        .loading-note strong { color: var(--text-secondary); }
        .loading-skip-section { margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border-primary); }
        .loading-skip-text { font-size: 12px; color: var(--text-muted); margin-bottom: 12px; }
        .loading-skip-btn { background: transparent; border: 1px solid var(--border-secondary); color: var(--text-secondary); padding: 10px 20px; border-radius: var(--radius-md); font-size: 13px; cursor: pointer; transition: all 0.2s; }
        .loading-skip-btn:hover { background: var(--bg-hover); border-color: var(--text-muted); color: var(--text-primary); }
        .loading-skip-btn:active { transform: scale(0.98); }
        .loading-particles { position: absolute; inset: 0; overflow: hidden; pointer-events: none; }
        .particle { position: absolute; width: 4px; height: 4px; background: rgba(59, 130, 246, 0.3); border-radius: 50%; animation: float-up 8s ease-in-out infinite; }
        .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
        .particle:nth-child(2) { left: 20%; animation-delay: 1s; }
        .particle:nth-child(3) { left: 30%; animation-delay: 2s; }
        .particle:nth-child(4) { left: 40%; animation-delay: 3s; }
        .particle:nth-child(5) { left: 50%; animation-delay: 4s; }
        .particle:nth-child(6) { left: 60%; animation-delay: 5s; }
        .particle:nth-child(7) { left: 70%; animation-delay: 6s; }
        .particle:nth-child(8) { left: 80%; animation-delay: 7s; }
        .particle:nth-child(9) { left: 90%; animation-delay: 0.5s; }
        .particle:nth-child(10) { left: 15%; animation-delay: 2.5s; }
        @keyframes float-up {
            0%, 100% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(90vh) scale(1); }
            90% { opacity: 1; transform: translateY(10vh) scale(1); }
            100% { transform: translateY(0) scale(0); opacity: 0; }
        }

        /* Refresh & Save Indicators */
        .refresh-indicator { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text-muted); padding: 2px 8px; border-radius: var(--radius-sm); transition: all 0.3s; }
        .refresh-indicator.syncing { color: var(--primary-400); background: rgba(59, 130, 246, 0.1); }
        .refresh-indicator .refresh-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); transition: all 0.3s; }
        .refresh-indicator.syncing .refresh-dot { background: var(--primary-500); animation: pulse-dot 1s ease-in-out infinite; }
        @keyframes pulse-dot { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.5); opacity: 0.5; } }

        /* Airtable sync button states */
        #airtable-sync-btn.syncing { color: var(--primary-400); border-color: var(--primary-500); }
        #airtable-sync-btn.syncing #sync-icon { animation: spin-sync 1s linear infinite; }
        #airtable-sync-btn.cooldown { opacity: 0.6; cursor: default; }
        #airtable-sync-btn.cooldown:hover { background: var(--bg-tertiary); color: var(--text-secondary); border-color: var(--border-primary); }
        @keyframes spin-sync { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .view-save-indicator { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text-muted); padding: 4px 10px; border-radius: var(--radius-sm); transition: all 0.3s; margin-left: 8px; }
        .view-save-indicator.dirty { color: var(--warning-500); background: rgba(245, 158, 11, 0.1); }
        .view-save-indicator.saving { color: var(--primary-400); background: rgba(59, 130, 246, 0.1); }
        .view-save-indicator.saved { color: var(--success-500); background: rgba(34, 197, 94, 0.1); }
        .view-save-indicator .save-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }
        .view-save-indicator.saving .save-dot { animation: pulse-dot 1s ease-in-out infinite; }
        .view-save-btn { padding: 4px 10px; background: var(--primary-500); color: #fff; border: none; border-radius: var(--radius-sm); font-size: 11px; cursor: pointer; margin-left: 4px; transition: all var(--transition-fast); }
        .view-save-btn:hover { background: var(--primary-600); }
        .view-save-btn:disabled { background: var(--gray-600); cursor: not-allowed; }

        /* View Folders */
        .table-view-folder { padding: 6px 16px 6px 36px; cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 8px; transition: all var(--transition-fast); user-select: none; }
        .table-view-folder:hover { background: var(--bg-hover); color: var(--text-primary); }
        .table-view-folder .folder-icon { font-size: 12px; transition: transform 0.2s; }
        .table-view-folder.expanded .folder-icon { transform: rotate(90deg); }
        .table-view-folder .folder-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .table-view-folder .folder-actions { display: none; gap: 4px; }
        .table-view-folder:hover .folder-actions { display: flex; }
        .table-view-folder .folder-action-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 2px 4px; font-size: 10px; border-radius: 3px; }
        .table-view-folder .folder-action-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .folder-views-list { max-height: 0; overflow: hidden; transition: max-height 0.25s ease-out; }
        .folder-views-list.expanded { max-height: 500px; }
        .folder-views-list .table-view-item { padding-left: 52px; }
        .table-view-add-btn { padding: 6px 16px 6px 44px; cursor: pointer; font-size: 12px; color: var(--text-disabled); display: flex; align-items: center; gap: 8px; transition: all var(--transition-fast); }
        .table-view-add-btn:hover { background: var(--bg-hover); color: var(--primary-400); }
        .table-view-add-btn .add-icon { font-size: 14px; color: var(--primary-400); }
        .folder-name-input { background: var(--bg-tertiary); border: 1px solid var(--primary-500); color: var(--text-primary); padding: 4px 8px; font-size: 12px; border-radius: var(--radius-sm); width: 120px; }
        .folder-name-input:focus { outline: none; border-color: var(--primary-400); }

        /* Context Menu */
        .view-context-menu { position: fixed; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 1000; min-width: 160px; padding: 4px 0; display: none; }
        .view-context-menu.open { display: block; }
        .view-context-menu-item { padding: 8px 16px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 8px; color: var(--text-secondary); }
        .view-context-menu-item:hover { background: var(--bg-hover); }
        .view-context-menu-item.danger { color: #f87171; }
        .view-context-menu-item.danger:hover { background: rgba(239, 68, 68, 0.15); }
        .view-context-menu-separator { height: 1px; background: var(--border-primary); margin: 4px 0; }

        /* Column Drag */
        th.dragging { opacity: 0.5; background: rgba(59, 130, 246, 0.15) !important; }
        th.drag-over { border-left: 3px solid var(--primary-500); }
        th { cursor: grab; }
        th:active { cursor: grabbing; }
        th:first-child { cursor: default; }

        /* Schema View */
        .schema-view-container { padding: 20px; display: flex; flex-wrap: wrap; gap: 16px; overflow-y: auto; }
        .schema-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 320px; max-height: 500px; overflow: hidden; box-shadow: var(--shadow-sm); transition: box-shadow 0.2s, transform 0.2s; display: flex; flex-direction: column; }
        .schema-card:hover { box-shadow: var(--shadow-md); transform: translateY(-2px); }
        .schema-card-header { padding: 16px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; }
        .schema-card-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); background: var(--bg-primary); padding: 4px 8px; border-radius: var(--radius-sm); }
        .schema-card-actions { display: flex; gap: 8px; }
        .schema-card-body { padding: 0; overflow-y: auto; flex: 1; }
        .schema-field-row { padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; flex-direction: column; gap: 4px; }
        .schema-field-row:last-child { border-bottom: none; }
        .schema-field-name { font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.3px; }
        .schema-field-value { font-size: 13px; color: var(--text-primary); word-break: break-word; }
        .schema-field-value.empty { color: var(--text-disabled); font-style: italic; }
        /* ===== Create View Modal ===== */
        .create-view-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1001; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .create-view-modal.open { opacity: 1; visibility: visible; }
        .create-view-modal-content { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 400px; max-width: 90%; box-shadow: var(--shadow-xl); transform: translateY(20px); transition: transform 0.2s; }
        .create-view-modal.open .create-view-modal-content { transform: translateY(0); }
        .create-view-modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border-primary); }
        .create-view-modal-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); margin: 0 0 4px 0; }
        .create-view-modal-header p { font-size: 13px; color: var(--text-muted); margin: 0; }
        .create-view-modal-body { padding: 24px; }
        .create-view-field { margin-bottom: 16px; }
        .create-view-field label { display: block; font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 6px; }
        .create-view-field input, .create-view-field select { width: 100%; padding: 10px 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); font-size: 14px; background: var(--bg-tertiary); color: var(--text-primary); }
        .create-view-field input:focus, .create-view-field select:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .create-view-modal-footer { padding: 16px 24px; border-top: 1px solid var(--border-primary); display: flex; justify-content: flex-end; gap: 12px; background: var(--bg-tertiary); border-radius: 0 0 var(--radius-xl) var(--radius-xl); }
        .create-view-modal-footer button { padding: 10px 20px; border-radius: var(--radius-md); font-size: 14px; font-weight: 500; cursor: pointer; transition: all var(--transition-fast); }
        .create-view-modal-footer .btn-cancel { background: var(--bg-secondary); border: 1px solid var(--border-primary); color: var(--text-muted); }
        .create-view-modal-footer .btn-cancel:hover { background: var(--bg-hover); }
        .create-view-modal-footer .btn-create { background: var(--primary-500); border: 1px solid var(--primary-500); color: #fff; }
        .create-view-modal-footer .btn-create:hover { background: var(--primary-600); }

        /* Share View Modal */
        .share-options { display: flex; flex-direction: column; gap: 8px; }
        .share-option { display: flex; align-items: flex-start; gap: 12px; padding: 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); cursor: pointer; transition: all var(--transition-fast); }
        .share-option:hover { background: var(--bg-hover); }
        .share-option input[type="radio"] { margin-top: 4px; accent-color: var(--primary-500); }
        .share-option-icon { font-size: 20px; line-height: 1; flex-shrink: 0; }
        .share-option-text { display: flex; flex-direction: column; gap: 2px; }
        .share-option-text strong { font-size: 14px; color: var(--text-primary); font-weight: 500; }
        .share-option-text span { font-size: 12px; color: var(--text-muted); }
        .share-option:has(input:checked) { border-color: var(--primary-500); background: rgba(59, 130, 246, 0.05); }
        .share-users-list { max-height: 200px; overflow-y: auto; border: 1px solid var(--border-primary); border-radius: var(--radius-md); }
        .share-users-loading { padding: 12px; text-align: center; font-size: 13px; color: var(--text-muted); }
        .share-user-item { display: flex; align-items: center; gap: 10px; padding: 8px 12px; cursor: pointer; transition: background var(--transition-fast); }
        .share-user-item:hover { background: var(--bg-hover); }
        .share-user-item input[type="checkbox"] { accent-color: var(--primary-500); }
        .share-user-item .user-name { font-size: 13px; color: var(--text-primary); }
        .share-user-item .user-id { font-size: 11px; color: var(--text-muted); }
        .share-view-owner { font-size: 12px; color: var(--text-muted); margin-bottom: 12px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: var(--radius-md); }

        /* ===== Case Note Creation Modal ===== */
        .case-note-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1001; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .case-note-modal.open { opacity: 1; visibility: visible; }
        .case-note-modal-content { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); width: 560px; max-width: 94%; max-height: 85vh; display: flex; flex-direction: column; box-shadow: var(--shadow-xl); transform: translateY(20px); transition: transform 0.2s; }
        .case-note-modal.open .case-note-modal-content { transform: translateY(0); }
        .case-note-modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between; }
        .case-note-modal-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); margin: 0; }
        .case-note-modal-body { flex: 1; overflow-y: auto; padding: 24px; }
        .case-note-field { margin-bottom: 16px; }
        .case-note-field label { display: block; font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 6px; }
        .case-note-field input, .case-note-field select, .case-note-field textarea { width: 100%; padding: 10px 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); font-size: 14px; background: var(--bg-tertiary); color: var(--text-primary); font-family: var(--font-sans); box-sizing: border-box; }
        .case-note-field input:focus, .case-note-field select:focus, .case-note-field textarea:focus { outline: none; border-color: var(--primary-500); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15); }
        .case-note-field textarea { min-height: 100px; resize: vertical; }
        .case-note-field .field-hint { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
        .case-note-row { display: flex; gap: 16px; }
        .case-note-row .case-note-field { flex: 1; }
        .case-note-modal-footer { padding: 16px 24px; border-top: 1px solid var(--border-primary); display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); border-radius: 0 0 var(--radius-xl) var(--radius-xl); }
        .case-note-modal-footer .case-note-status { font-size: 12px; color: var(--text-muted); }
        .case-note-modal-footer .case-note-actions { display: flex; gap: 12px; }
        .case-note-modal-footer button { padding: 10px 20px; border-radius: var(--radius-md); font-size: 14px; font-weight: 500; cursor: pointer; transition: all var(--transition-fast); }
        .case-note-modal-footer .btn-cancel { background: var(--bg-secondary); border: 1px solid var(--border-primary); color: var(--text-muted); }
        .case-note-modal-footer .btn-cancel:hover { background: var(--bg-hover); }
        .case-note-modal-footer .btn-save { background: var(--primary-500); border: 1px solid var(--primary-500); color: #fff; }
        .case-note-modal-footer .btn-save:hover { background: var(--primary-600); }
        .case-note-modal-footer .btn-save:disabled { opacity: 0.5; cursor: not-allowed; }

        /* View Sharing Badge in Sidebar */
        .view-sharing-badge { font-size: 11px; margin-left: auto; flex-shrink: 0; opacity: 0.6; }
        .view-sharing-badge.shared { opacity: 0.8; color: var(--primary-400); }

        /* View Tags */
        .view-tags { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; }
        .view-tag { font-size: 10px; padding: 2px 6px; border-radius: 10px; background: rgba(59, 130, 246, 0.15); color: var(--primary-400); }
        .view-tag.workspace { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .table-view-item .view-tags { padding-left: 24px; }

        /* Workspace Tabs */
        .workspace-tabs { display: flex; gap: 4px; padding: 8px 16px; background: var(--bg-primary); border-bottom: 1px solid var(--border-primary); }
        .workspace-tab { padding: 6px 12px; font-size: 12px; color: var(--text-muted); border-radius: var(--radius-sm); cursor: pointer; transition: all var(--transition-fast); }
        .workspace-tab:hover { background: var(--bg-hover); color: var(--text-primary); }
        .workspace-tab.active { background: var(--primary-500); color: #fff; }
        .workspace-tab .workspace-count { margin-left: 6px; font-size: 10px; background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 8px; }
        .workspace-add-btn { padding: 6px 8px; font-size: 12px; color: var(--text-muted); cursor: pointer; }
        .workspace-add-btn:hover { color: var(--primary-400); }

        /* Nested Views */
        .table-view-item.nested-level-1 { padding-left: 60px; }
        .table-view-item.nested-level-2 { padding-left: 76px; }
        .table-view-item.nested-level-3 { padding-left: 92px; }
        .view-nest-indicator { font-size: 10px; color: var(--text-muted); margin-right: 4px; }
        .view-type-badge { font-size: 9px; padding: 2px 5px; border-radius: 3px; background: var(--bg-tertiary); color: var(--text-muted); margin-left: auto; }
        .view-type-badge.schema { background: rgba(124, 58, 237, 0.3); color: #a78bfa; }
        .view-type-badge.grid { background: rgba(59, 130, 246, 0.3); color: #60a5fa; }

        /* Events Sidebar Items */
        .events-section-header { padding: 12px 16px 8px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); border-bottom: 1px solid var(--border-primary); }
        .sidebar div.table-item.events-item { margin: 2px 8px; border-radius: var(--radius-lg); background: transparent; border: none; }
        .sidebar div.table-item.events-item .table-icon { background: rgba(245, 158, 11, 0.15); border-radius: 5px; }
        .sidebar div.table-item.events-item .table-icon svg { color: #d97706; }
        .sidebar div.table-item.events-item:hover { background: var(--bg-hover); }
        .sidebar div.table-item.events-item:active { background: rgba(139, 92, 246, 0.15); transition: background-color 0.05s; }
        .sidebar div.table-item.events-item.active { background: rgba(139, 92, 246, 0.15); }
        .sidebar div.table-item.events-item.active::before { background: #8b5cf6; }

        .sidebar div.table-item.sync-status-item { margin: 2px 8px; border-radius: var(--radius-lg); background: transparent; border: none; }
        .sidebar div.table-item.sync-status-item .table-icon { background: rgba(16, 185, 129, 0.15); border-radius: 5px; }
        .sidebar div.table-item.sync-status-item .table-icon svg { color: #10b981; }
        .sidebar div.table-item.sync-status-item:hover { background: var(--bg-hover); }
        .sidebar div.table-item.sync-status-item:active { background: rgba(16, 185, 129, 0.15); transition: background-color 0.05s; }
        .sidebar div.table-item.sync-status-item.active { background: rgba(16, 185, 129, 0.15); }
        .sidebar div.table-item.sync-status-item.active::before { background: #10b981; }

        /* ===== Sync Status View ===== */
        .sync-status-view { padding: 24px; max-width: 1200px; }
        .sync-status-header { display: flex; align-items: center; gap: 12px; margin-bottom: 24px; }
        .sync-status-header h2 { font-size: 18px; font-weight: 600; color: var(--text-primary); }
        .sync-status-header .sync-status-badge { font-size: 11px; font-weight: 600; padding: 3px 10px; border-radius: 12px; }
        .sync-status-badge.synced { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-status-badge.syncing { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .sync-status-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-status-badge.queued { background: rgba(251, 146, 60, 0.15); color: #fb923c; }
        .sync-status-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; margin-bottom: 24px; }
        .sync-status-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 18px; }
        .sync-status-card .card-label { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 6px; }
        .sync-status-card .card-value { font-size: 22px; font-weight: 600; color: var(--text-primary); }
        .sync-status-card .card-sub { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
        .sync-status-section { margin-bottom: 24px; }
        .sync-status-section h3 { font-size: 14px; font-weight: 600; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .sync-status-section h3 .section-dot { width: 8px; height: 8px; border-radius: 50%; }
        .sync-status-section h3 .section-dot.green { background: #10b981; }
        .sync-status-section h3 .section-dot.amber { background: #f59e0b; }
        .sync-status-section h3 .section-dot.red { background: #ef4444; }

        .sync-history-table { width: 100%; border-collapse: collapse; font-size: 13px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); overflow: hidden; }
        .sync-history-table th { background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); padding: 10px 14px; text-align: left; font-weight: 600; color: var(--text-secondary); font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; }
        .sync-history-table td { border-bottom: 1px solid var(--border-primary); padding: 10px 14px; color: var(--text-secondary); }
        .sync-history-table tr:last-child td { border-bottom: none; }
        .sync-history-table tr:hover td { background: var(--bg-hover); }
        .sync-history-table .sync-type-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: var(--radius-sm); text-transform: uppercase; }
        .sync-history-table .sync-type-badge.incremental { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .sync-history-table .sync-type-badge.full { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .sync-history-table .sync-type-badge.snapshot { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-history-table .sync-type-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-history-table .sync-type-badge.edit { background: rgba(14, 165, 233, 0.15); color: #38bdf8; }
        .sync-result-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: var(--radius-sm); }
        .sync-result-badge.success { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .sync-result-badge.error { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .sync-result-badge.no-change { background: var(--bg-tertiary); color: var(--text-muted); }
        .sync-result-badge.queued { background: rgba(251, 146, 60, 0.15); color: #fb923c; }
        .sync-result-badge.syncing { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .queue-count-badge { display: inline-flex; align-items: center; justify-content: center; min-width: 20px; height: 20px; padding: 0 6px; border-radius: 10px; background: rgba(251, 146, 60, 0.2); color: #fb923c; font-size: 11px; font-weight: 700; margin-left: 6px; }
        .sync-status-card.queue-highlight { border-color: rgba(251, 146, 60, 0.4); background: rgba(251, 146, 60, 0.05); }
        .sync-status-card.queue-highlight .card-value { color: #fb923c; }
        .sync-status-card.queue-highlight .card-label { color: #fb923c; }
        .sync-poll-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .sync-poll-controls .btn-poll { display: inline-flex; align-items: center; gap: 6px; padding: 8px 16px; border-radius: var(--radius-lg); border: 1px solid var(--border-primary); background: var(--bg-secondary); font-size: 13px; font-weight: 500; color: var(--text-secondary); cursor: pointer; transition: all var(--transition-fast); }
        .sync-poll-controls .btn-poll:hover { background: var(--bg-hover); border-color: var(--border-secondary); }
        .sync-poll-controls .btn-poll.primary { background: var(--success-500); color: #fff; border-color: var(--success-500); }
        .sync-poll-controls .btn-poll.primary:hover { background: var(--success-600); }
        .sync-poll-controls .btn-poll:disabled { opacity: 0.5; cursor: not-allowed; }
        .snapshot-export-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }
        .sync-activity-log { background: var(--bg-primary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 16px; max-height: 300px; overflow-y: auto; font-family: var(--font-mono); font-size: 12px; line-height: 1.6; }
        .sync-activity-log .log-line { color: var(--text-muted); }
        .sync-activity-log .log-line .timestamp { color: var(--text-disabled); margin-right: 8px; }
        .sync-activity-log .log-line.info .message { color: #60a5fa; }
        .sync-activity-log .log-line.success .message { color: #34d399; }
        .sync-activity-log .log-line.error .message { color: #f87171; }
        .sync-activity-log .log-line.warn .message { color: #fbbf24; }
        .sync-activity-log .log-empty { color: var(--text-disabled); text-align: center; padding: 20px; }
        /* ===== Matrix Rooms View ===== */
        .matrix-rooms-view { padding: 24px; max-width: 1200px; }
        .matrix-rooms-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(340px, 1fr)); gap: 12px; }
        .matrix-room-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 16px; transition: border-color var(--transition-fast), background var(--transition-fast); cursor: default; }
        .matrix-room-card:hover { border-color: var(--border-secondary); background: var(--bg-hover); }
        .matrix-room-card.space { border-left: 3px solid #8b5cf6; }
        .matrix-room-card.room { border-left: 3px solid #6366f1; }
        .matrix-room-card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .matrix-room-card-icon { width: 32px; height: 32px; border-radius: var(--radius-md); display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
        .matrix-room-card-icon.space-icon { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .matrix-room-card-icon.room-icon { background: rgba(99, 102, 241, 0.15); color: #818cf8; }
        .matrix-room-card-name { font-size: 13px; font-weight: 600; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; min-width: 0; }
        .matrix-room-card-type { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: var(--radius-sm); text-transform: uppercase; flex-shrink: 0; }
        .matrix-room-card-type.space { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .matrix-room-card-type.room { background: rgba(99, 102, 241, 0.15); color: #818cf8; }
        .matrix-room-card-type.dm { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
        .matrix-room-card-topic { font-size: 12px; color: var(--text-muted); margin-bottom: 8px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .matrix-room-card-meta { display: flex; gap: 12px; font-size: 11px; color: var(--text-disabled); flex-wrap: wrap; }
        .matrix-room-card-meta span { display: flex; align-items: center; gap: 4px; }
        .matrix-room-card-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-disabled); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-top: 6px; }
        .matrix-rooms-section { margin-bottom: 20px; }
        .matrix-rooms-section h3 { font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .matrix-rooms-section h3 .section-count { font-weight: 400; color: var(--text-muted); }
        .matrix-rooms-filter { display: flex; gap: 8px; margin-bottom: 20px; align-items: center; }
        .matrix-rooms-filter input { flex: 1; max-width: 360px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 8px 12px; font-size: 13px; color: var(--text-primary); font-family: inherit; }
        .matrix-rooms-filter input:focus { outline: none; border-color: var(--primary-400); }
        .matrix-rooms-filter .filter-btn { padding: 6px 14px; border-radius: var(--radius-md); border: 1px solid var(--border-primary); background: var(--bg-secondary); font-size: 12px; font-weight: 500; color: var(--text-muted); cursor: pointer; transition: all var(--transition-fast); }
        .matrix-rooms-filter .filter-btn:hover { border-color: var(--border-secondary); color: var(--text-secondary); }
        .matrix-rooms-filter .filter-btn.active { background: rgba(99, 102, 241, 0.15); color: #818cf8; border-color: rgba(99, 102, 241, 0.3); }
        /* ===== Events Table ===== */
        .events-table { min-width: 100%; border-collapse: collapse; font-size: 13px; }
        .events-table th { background: var(--bg-secondary); border-bottom: 2px solid var(--border-primary); padding: 10px 12px; text-align: left; font-weight: 500; color: var(--text-secondary); position: sticky; top: 0; z-index: 10; white-space: nowrap; }
        .events-table td { border-bottom: 1px solid var(--border-primary); padding: 10px 12px; vertical-align: top; }
        .events-table tr:hover td { background: var(--bg-hover); }
        .events-table .event-id { font-family: var(--font-mono); font-size: 12px; color: var(--text-muted); }
        .events-table .event-timestamp { font-size: 12px; color: var(--text-muted); white-space: nowrap; }
        .events-table .event-set { font-family: var(--font-mono); font-size: 11px; color: var(--primary-400); background: rgba(59, 130, 246, 0.15); padding: 2px 6px; border-radius: var(--radius-sm); display: inline-block; max-width: 150px; overflow: hidden; text-overflow: ellipsis; }
        .events-table .event-record-id { font-family: var(--font-mono); font-size: 11px; color: #4ade80; background: rgba(34, 197, 94, 0.15); padding: 2px 6px; border-radius: var(--radius-sm); display: inline-block; }
        .events-table .event-type-badge { font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); }
        .events-table .event-type-badge.data { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .event-type-badge.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .event-type-badge.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .event-type-badge.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .events-table .event-type-badge.SYN { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .event-type-badge.table { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .event-type-badge.field { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .events-table .event-type-badge.view { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
        .events-table .event-type-badge.viewconfig { background: rgba(124, 58, 237, 0.15); color: #a78bfa; }
        .events-table .event-type-badge.current { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .field-op-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); margin-right: 4px; }
        .events-table .field-op-badge.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .events-table .field-op-badge.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .events-table .field-op-badge.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .events-table .field-op-badge.SYN { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .events-table .field-op-badge .field-count { font-weight: 400; opacity: 0.8; }
        .events-table .event-details { white-space: nowrap; }
        .events-table .current-state-row { background: rgba(34, 197, 94, 0.05); }
        .events-table .event-id.current-state { color: var(--text-disabled); }

        /* New Event Indicators */
        .events-table tr.new-event td { background: rgba(34, 197, 94, 0.05); }
        .events-table tr.new-event:hover td { background: rgba(34, 197, 94, 0.1); }
        .new-event-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: var(--radius-sm); background: var(--success-500); color: #fff; text-transform: uppercase; letter-spacing: 0.5px; margin-left: 6px; animation: pulse-new 2s ease-in-out infinite; }
        @keyframes pulse-new { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .new-events-divider { position: relative; padding: 8px 0; }
        .new-events-divider td { background: rgba(34, 197, 94, 0.1) !important; border-bottom: 2px solid var(--success-500); text-align: center; padding: 8px 12px; }
        .new-events-divider-text { display: inline-flex; align-items: center; gap: 8px; color: var(--success-500); font-size: 11px; font-weight: 600; }
        .new-events-divider-text::before, .new-events-divider-text::after { content: ''; display: inline-block; width: 40px; height: 1px; background: var(--success-500); }

        /* Payload Preview */
        .payload-preview-container { max-width: 400px; }
        .payload-preview { font-family: var(--font-mono); font-size: 11px; color: var(--text-secondary); background: var(--bg-tertiary); padding: 6px 10px; border-radius: var(--radius-sm); max-height: 60px; overflow: hidden; cursor: pointer; position: relative; transition: all 0.2s; border: 1px solid var(--border-primary); }
        .payload-preview:hover { background: var(--bg-hover); border-color: var(--border-secondary); }
        .payload-preview.expanded { max-height: none; white-space: pre-wrap; word-break: break-all; }
        .payload-expand-btn { position: absolute; bottom: 4px; right: 4px; font-size: 10px; color: var(--primary-400); background: var(--bg-secondary); padding: 2px 6px; border-radius: 3px; border: 1px solid var(--border-primary); cursor: pointer; }
        .payload-preview.expanded .payload-expand-btn { position: static; display: block; margin-top: 8px; }

        /* JSON Syntax Highlighting */
        .json-key { color: #a78bfa; }
        .json-string { color: #4ade80; }
        .json-number { color: #60a5fa; }
        .json-boolean { color: #f87171; }
        .json-null { color: var(--text-muted); font-style: italic; }

        /* Payload Fields */
        .payload-fields { }
        .payload-op-group { margin-bottom: 6px; }
        .payload-op-group:last-child { margin-bottom: 0; }
        .payload-op-label { display: inline-block; font-size: 9px; font-weight: 600; padding: 1px 5px; border-radius: 3px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        .payload-op-label.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .payload-op-label.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .payload-op-label.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .payload-field-row { display: flex; gap: 8px; padding: 2px 0; border-bottom: 1px solid var(--border-primary); }
        .payload-field-row:last-child { border-bottom: none; }
        .payload-field-name { color: #a78bfa; font-weight: 500; min-width: 80px; flex-shrink: 0; }
        .payload-field-value { color: var(--text-secondary); word-break: break-word; }
        .payload-field-value.string { color: #4ade80; }
        .payload-field-value.number { color: #60a5fa; }
        .payload-field-value.boolean { color: #f87171; }
        .payload-field-value.null { color: var(--text-muted); font-style: italic; }
        .payload-field-value.array { color: #a78bfa; }
        .payload-field-value.object { color: #22d3ee; }
        .payload-raw-toggle { font-size: 10px; color: var(--text-muted); cursor: pointer; margin-top: 6px; }
        .payload-raw-toggle:hover { color: var(--primary-400); text-decoration: underline; }

        /* Event Actions */
        .event-actions { display: flex; gap: 6px; }
        .event-action-btn { padding: 4px 8px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: inline-flex; align-items: center; gap: 4px; transition: all var(--transition-fast); white-space: nowrap; }
        .event-action-btn:hover { background: var(--bg-hover); border-color: var(--primary-500); color: var(--primary-400); }
        .event-action-btn.primary { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .event-action-btn.primary:hover { background: var(--primary-600); }

        /* Infinite Scroll */
        .events-load-more { display: flex; align-items: center; justify-content: center; padding: 20px; gap: 10px; color: var(--text-muted); font-size: 13px; }
        .events-load-more .loading-spinner-small { width: 20px; height: 20px; border: 2px solid var(--border-primary); border-top-color: var(--primary-500); border-radius: 50%; animation: spin 0.8s linear infinite; }
        .events-end-message { text-align: center; padding: 20px; color: var(--text-muted); font-size: 12px; border-top: 1px solid var(--border-primary); }

        /* Events Tab Bar */
        .events-tab-bar { display: flex; gap: 0; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); padding: 0 20px; position: sticky; top: 0; z-index: 11; }
        .events-tab { padding: 10px 20px; font-size: 13px; font-weight: 500; color: var(--text-muted); cursor: pointer; border-bottom: 2px solid transparent; transition: color 0.15s, border-color 0.15s; user-select: none; }
        .events-tab:hover { color: var(--text-secondary); }
        .events-tab.active { color: var(--text-primary); border-bottom-color: var(--primary-500); }
        .room-access-layout { display: flex; flex-direction: column; gap: 14px; padding: 16px 20px; }
        .room-access-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
        .room-access-meta { font-size: 12px; color: var(--text-muted); }
        .room-access-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(330px, 1fr)); gap: 12px; }
        .room-access-card { border: 1px solid var(--border-primary); border-radius: var(--radius-md); background: var(--bg-secondary); padding: 12px; display: flex; flex-direction: column; gap: 8px; }
        .room-access-title { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
        .room-access-name { font-weight: 600; color: var(--text-primary); }
        .room-access-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); word-break: break-all; }
        .room-access-badges { display: flex; gap: 6px; flex-wrap: wrap; }
        .room-access-badge { font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); text-transform: uppercase; letter-spacing: 0.04em; }
        .room-access-badge.space { background: rgba(124, 58, 237, 0.15); color: #a78bfa; }
        .room-access-badge.table { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .room-access-badge.timeline { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .room-access-summary { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 6px; font-size: 12px; }
        .room-access-summary .label { color: var(--text-muted); }
        .room-access-summary .value { color: var(--text-secondary); font-family: var(--font-mono); }
        .room-access-preview { margin-top: 4px; border-top: 1px solid var(--border-primary); padding-top: 8px; }
        .room-access-preview h4 { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 6px; }
        .room-access-preview-item { font-size: 11px; color: var(--text-secondary); line-height: 1.4; border-left: 2px solid var(--border-secondary); padding-left: 8px; margin-bottom: 6px; word-break: break-word; }
        .room-access-preview-item:last-child { margin-bottom: 0; }

        /* Changelog styles */
        .changelog-list { padding: 0; }
        .changelog-entry { display: flex; gap: 16px; padding: 14px 20px; border-bottom: 1px solid var(--border-primary); transition: background 0.1s; }
        .changelog-entry:hover { background: var(--bg-hover); }
        .changelog-timeline { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; padding-top: 3px; }
        .changelog-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
        .changelog-dot.INS { background: #4ade80; }
        .changelog-dot.ALT { background: #fbbf24; }
        .changelog-dot.NUL { background: #f87171; }
        .changelog-dot.SYN { background: #60a5fa; }
        .changelog-line { width: 2px; flex: 1; background: var(--border-primary); margin-top: 4px; }
        .changelog-content { flex: 1; min-width: 0; }
        .changelog-header { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 6px; }
        .changelog-op { font-size: 11px; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-sm); }
        .changelog-op.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .changelog-op.ALT { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .changelog-op.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .changelog-op.SYN { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .changelog-table-badge { font-size: 11px; color: var(--primary-400); background: rgba(59, 130, 246, 0.12); padding: 2px 8px; border-radius: var(--radius-sm); }
        .changelog-record-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); }
        .changelog-record-link { text-decoration: none; cursor: pointer; transition: color 0.15s, background 0.15s; padding: 1px 4px; border-radius: var(--radius-sm); }
        .changelog-record-link:hover { color: var(--primary-400); background: rgba(59, 130, 246, 0.10); text-decoration: underline; }
        .changelog-source-badge { font-size: 10px; font-weight: 500; padding: 2px 6px; border-radius: var(--radius-sm); background: rgba(100, 116, 139, 0.15); color: #94a3b8; text-transform: capitalize; margin-left: 4px; }
        .changelog-time { font-size: 11px; color: var(--text-muted); margin-left: auto; white-space: nowrap; }
        .changelog-fields { display: flex; flex-direction: column; gap: 3px; }
        .changelog-field { font-size: 12px; color: var(--text-secondary); display: flex; align-items: baseline; gap: 6px; }
        .changelog-field-name { font-weight: 500; color: var(--text-primary); flex-shrink: 0; }
        .changelog-field-value { color: var(--text-secondary); word-break: break-word; overflow: hidden; text-overflow: ellipsis; max-width: 400px; }
        .changelog-field-arrow { color: var(--text-muted); flex-shrink: 0; }
        .changelog-actor { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
        .changelog-empty { text-align: center; padding: 60px 20px; color: var(--text-muted); }
        .changelog-empty h3 { font-size: 15px; margin-bottom: 6px; color: var(--text-secondary); }
        .changelog-empty p { font-size: 13px; }

        /* Light theme overrides for changelog */
        html.light-theme .changelog-dot.INS { background: #16a34a; }
        html.light-theme .changelog-dot.ALT { background: #d97706; }
        html.light-theme .changelog-dot.NUL { background: #dc2626; }
        html.light-theme .changelog-dot.SYN { background: #2563eb; }
        html.light-theme .changelog-op.INS { background: rgba(22, 163, 74, 0.10); color: #15803d; }
        html.light-theme .changelog-op.ALT { background: rgba(217, 119, 6, 0.10); color: #b45309; }
        html.light-theme .changelog-op.NUL { background: rgba(220, 38, 38, 0.10); color: #dc2626; }
        html.light-theme .changelog-op.SYN { background: rgba(37, 99, 235, 0.10); color: #2563eb; }
        html.light-theme .changelog-table-badge { color: #2563eb; background: rgba(37, 99, 235, 0.10); }
        html.light-theme .changelog-record-link:hover { color: #2563eb; background: rgba(37, 99, 235, 0.08); }
        html.light-theme .changelog-source-badge { background: rgba(100, 116, 139, 0.12); color: #64748b; }

        /* Point in Time Modal */
        .pit-modal { max-width: 900px; width: 95%; }
        .pit-modal-header { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .pit-modal-header .pit-info { flex: 1; }
        .pit-modal-header .pit-event-badge { font-size: 11px; background: rgba(245, 158, 11, 0.15); color: #fbbf24; padding: 4px 8px; border-radius: var(--radius-sm); font-family: var(--font-mono); }
        .pit-modal-header .pit-timestamp { font-size: 12px; color: var(--text-muted); }

        /* Historical Notice */
        .historical-notice { display: flex; align-items: center; gap: 8px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: var(--radius-md); padding: 10px 14px; margin: 0 24px 12px 24px; font-size: 12px; color: #fbbf24; }
        .historical-notice svg { flex-shrink: 0; }
        .historical-notice-text { line-height: 1.4; }
        .historical-notice-text strong { font-weight: 600; }
        .history-modal .historical-notice { margin: 12px 16px; }

        .pit-record-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); margin: 16px 24px; overflow: hidden; }
        .pit-record-header { background: var(--bg-tertiary); padding: 12px 16px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; }
        .pit-record-header .pit-table-name { font-weight: 600; color: var(--text-primary); }
        .pit-record-header .pit-record-id { font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); }
        .pit-record-header .pit-go-to-table { margin-left: auto; }
        .pit-record-fields { padding: 16px; }
        .pit-field-row { display: flex; padding: 8px 0; border-bottom: 1px solid var(--border-primary); }
        .pit-field-row:last-child { border-bottom: none; }
        .pit-field-name { width: 180px; flex-shrink: 0; font-weight: 500; color: var(--text-primary); font-size: 13px; }
        .pit-field-value { flex: 1; font-size: 13px; color: var(--text-secondary); word-break: break-word; }
        .pit-empty-state { padding: 40px 20px; text-align: center; color: var(--text-muted); }
        .pit-record-actions { padding: 12px 16px; border-top: 1px solid var(--border-primary); display: flex; gap: 8px; justify-content: flex-end; }
        .pit-revert-btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 16px; border: none; border-radius: var(--radius-sm); font-size: 12px; font-weight: 600; cursor: pointer; background: rgba(245, 158, 11, 0.15); color: #fbbf24; transition: background 0.15s; }
        .pit-revert-btn:hover { background: rgba(245, 158, 11, 0.3); }
        .pit-revert-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .pit-revert-confirm { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .pit-revert-confirm:hover { background: rgba(239, 68, 68, 0.3); }

        /* Events View Controls */
        .events-controls { padding: 12px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .events-filter-group { display: flex; align-items: center; gap: 8px; }
        .events-filter-group label { font-size: 12px; color: var(--text-muted); font-weight: 500; }
        .events-filter-group select, .events-filter-group input { padding: 6px 10px; border: 1px solid var(--border-primary); border-radius: var(--radius-sm); font-size: 12px; background: var(--bg-tertiary); color: var(--text-primary); }
        .events-filter-group input { width: 150px; }
        .events-stats { margin-left: auto; font-size: 12px; color: var(--text-muted); }
        .events-actions { display: flex; gap: 8px; margin-left: 12px; }
        .events-actions .btn { padding: 5px 10px; font-size: 11px; }
        .events-actions .btn svg { width: 14px; height: 14px; }
        .import-status { position: fixed; bottom: 20px; right: 20px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 16px 20px; box-shadow: var(--shadow-lg); z-index: 1000; min-width: 280px; }
        .import-status.success { border-color: var(--success-500); }
        .import-status.error { border-color: var(--danger-500); }
        .import-status-title { font-weight: 600; font-size: 14px; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
        .import-status-title.success { color: var(--success-500); }
        .import-status-title.error { color: var(--danger-500); }
        .import-status-details { font-size: 12px; color: var(--text-muted); }
        .import-progress { margin-top: 8px; height: 4px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; }
        .import-progress-bar { height: 100%; background: var(--primary-500); transition: width 0.3s; }
        /* ===== Record Profile Panel ===== */
        .record-profile-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .record-profile-overlay.open { opacity: 1; visibility: visible; }
        .record-profile-panel { position: fixed; top: 0; right: 0; bottom: 0; width: 600px; max-width: 90vw; background: var(--bg-secondary); box-shadow: var(--shadow-xl); transform: translateX(100%); transition: transform 0.25s ease-out; display: flex; flex-direction: column; z-index: 1001; border-left: 1px solid var(--border-primary); }
        .record-profile-overlay.open .record-profile-panel { transform: translateX(0); }
        .profile-header { padding: 16px 20px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; background: var(--bg-tertiary); }
        .profile-header h2 { font-size: 16px; font-weight: 600; color: var(--text-primary); margin: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .profile-header .profile-view-name { flex: 1; font-size: 11px; color: var(--text-muted); background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); padding: 3px 8px; border-radius: var(--radius-sm); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .profile-header .profile-view-name:empty { display: none; }
        .profile-header .profile-record-id { font-size: 11px; color: var(--text-muted); font-family: var(--font-mono); }
        .profile-close { width: 32px; height: 32px; border: none; background: var(--bg-secondary); border-radius: var(--radius-md); cursor: pointer; font-size: 18px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; }
        .profile-close:hover { background: var(--bg-hover); color: var(--text-primary); }
        .profile-tabs { display: flex; border-bottom: 1px solid var(--border-primary); background: var(--bg-secondary); padding: 0 20px; }
        .profile-tab { padding: 12px 16px; font-size: 13px; font-weight: 500; color: var(--text-muted); cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -1px; transition: all var(--transition-fast); }
        .profile-tab:hover { color: var(--text-primary); }
        .profile-tab.active { color: var(--primary-400); border-bottom-color: var(--primary-500); }
        .profile-tab-content { display: none; flex: 1; overflow-y: auto; }
        .profile-tab-content.active { display: flex; flex-direction: column; }

        .profile-sync-history-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; text-align: center; color: var(--text-muted); flex: 1; }
        .profile-sync-history-empty svg { width: 48px; height: 48px; color: var(--text-disabled); margin-bottom: 16px; }
        .profile-sync-history-empty h3 { font-size: 16px; font-weight: 500; color: var(--text-primary); margin: 0 0 8px 0; }
        .profile-sync-history-empty p { font-size: 13px; color: var(--text-muted); margin: 0; }
        .profile-sync-history-list { padding: 16px 20px; }
        .profile-sync-history-item { padding: 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); margin-bottom: 8px; background: var(--bg-primary); }
        .profile-sync-history-item:last-child { margin-bottom: 0; }
        .profile-sync-history-item-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .profile-sync-history-field { font-weight: 500; color: var(--text-primary); font-size: 13px; }
        .profile-sync-history-type { font-size: 11px; padding: 2px 6px; border-radius: 3px; font-weight: 500; }
        .profile-sync-history-type.created { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .profile-sync-history-type.updated { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .profile-sync-history-type.deleted { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .profile-sync-history-type.synced { background: rgba(168, 85, 247, 0.15); color: #c084fc; }
        .profile-sync-history-sender { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: rgba(168, 85, 247, 0.15); color: #c084fc; font-weight: 500; }
        .profile-sync-history-actor { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: rgba(251, 191, 36, 0.15); color: #fbbf24; font-weight: 500; }
        .profile-sync-history-device { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: rgba(20, 184, 166, 0.15); color: #2dd4bf; font-weight: 500; }
        .profile-sync-history-source { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: rgba(100, 116, 139, 0.15); color: #94a3b8; font-weight: 500; text-transform: capitalize; }
        .profile-sync-history-time { margin-left: auto; font-size: 11px; color: var(--text-muted); }
        .profile-sync-history-values { display: flex; gap: 12px; font-size: 12px; }
        .profile-sync-history-value { flex: 1; padding: 6px 8px; border-radius: var(--radius-sm); word-break: break-word; }
        .profile-sync-history-value.old { background: rgba(239, 68, 68, 0.1); color: #fca5a5; }
        .profile-sync-history-value.new { background: rgba(34, 197, 94, 0.1); color: #86efac; }
        .profile-sync-history-value-label { font-size: 10px; font-weight: 500; text-transform: uppercase; margin-bottom: 2px; opacity: 0.7; }

        /* Record History (raw event stream) */
        .record-history-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; text-align: center; color: var(--text-muted); flex: 1; }
        .record-history-empty svg { width: 48px; height: 48px; color: var(--text-disabled); margin-bottom: 16px; }
        .record-history-empty h3 { font-size: 16px; font-weight: 500; color: var(--text-primary); margin: 0 0 8px 0; }
        .record-history-empty p { font-size: 13px; color: var(--text-muted); margin: 0; }
        .record-history-header { padding: 12px 20px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 8px; background: var(--bg-secondary); }
        .record-history-header .record-history-count { font-size: 12px; color: var(--text-muted); }
        .record-history-header .record-history-refresh-btn { padding: 4px 10px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); margin-left: auto; }
        .record-history-header .record-history-refresh-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .record-history-list { padding: 12px 20px; overflow-y: auto; flex: 1; }
        .record-history-event { padding: 12px; border: 1px solid var(--border-primary); border-radius: var(--radius-md); margin-bottom: 8px; background: var(--bg-primary); transition: border-color 0.15s; }
        .record-history-event:hover { border-color: var(--border-secondary); }
        .record-history-event:last-child { margin-bottom: 0; }
        .record-history-event-header { display: flex; align-items: center; gap: 6px; margin-bottom: 8px; flex-wrap: wrap; }
        .record-history-event-id { font-size: 11px; font-weight: 600; color: var(--text-muted); font-family: var(--font-mono, monospace); }
        .record-history-event-operator { font-size: 11px; padding: 2px 6px; border-radius: 3px; font-weight: 500; }
        .record-history-event-operator.INS { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .record-history-event-operator.ALT { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .record-history-event-operator.NUL { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .record-history-event-operator.SYN { background: rgba(168, 85, 247, 0.15); color: #c084fc; }
        .record-history-event-set { font-size: 11px; padding: 2px 6px; border-radius: 3px; background: rgba(100, 116, 139, 0.15); color: #94a3b8; font-weight: 500; }
        .record-history-event-uuid { font-size: 10px; color: var(--text-disabled); font-family: var(--font-mono, monospace); max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .record-history-event-time { margin-left: auto; font-size: 11px; color: var(--text-muted); white-space: nowrap; }
        .record-history-event-payload { font-size: 12px; background: var(--bg-secondary); border-radius: var(--radius-sm); padding: 8px 10px; max-height: 120px; overflow-y: auto; word-break: break-word; font-family: var(--font-mono, monospace); line-height: 1.5; cursor: pointer; transition: max-height 0.2s; }
        .record-history-event-payload.expanded { max-height: none; }
        .record-history-event-actions { display: flex; gap: 6px; margin-top: 8px; }
        .record-history-event-actions button { padding: 3px 8px; font-size: 11px; border-radius: var(--radius-sm); border: 1px solid var(--border-primary); background: var(--bg-tertiary); color: var(--text-muted); cursor: pointer; display: flex; align-items: center; gap: 4px; }
        .record-history-event-actions button:hover { background: var(--bg-hover); color: var(--text-primary); }
        .record-history-event-actions button svg { width: 12px; height: 12px; }

        /* Profile Toolbar */
        .profile-toolbar { padding: 10px 20px; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; gap: 8px; flex-wrap: wrap; background: var(--bg-secondary); }
        .profile-toolbar-label { font-size: 12px; color: var(--text-muted); }
        .profile-layout-btn { padding: 4px 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .profile-layout-btn:hover { background: var(--bg-hover); }
        .profile-layout-btn.active { background: var(--primary-500); border-color: var(--primary-500); color: #fff; }
        .profile-toolbar-spacer { flex: 1; }
        .profile-add-block-btn { padding: 4px 10px; background: var(--bg-secondary); border: 1px dashed var(--border-secondary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); }
        .profile-add-block-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-configure-btn { padding: 4px 10px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 11px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; }
        .profile-configure-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }

        /* Profile Body */
        .profile-body { flex: 1; overflow-y: auto; padding: 16px 20px; }
        .profile-source-banner { display: flex; align-items: center; gap: 8px; padding: 10px 16px; margin-bottom: 12px; border-radius: var(--radius-md); font-size: 12px; font-weight: 500; }
        .profile-source-banner.room-history { background: rgba(245, 158, 11, 0.12); color: #fbbf24; border: 1px solid rgba(245, 158, 11, 0.25); }
        html.light-theme .profile-source-banner.room-history { background: rgba(217, 119, 6, 0.08); color: #92400e; border-color: rgba(217, 119, 6, 0.2); }
        .profile-block { margin-bottom: 16px; border: 1px solid var(--border-primary); border-radius: var(--radius-lg); background: var(--bg-primary); }
        .profile-block-header { padding: 8px 12px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); border-radius: var(--radius-lg) var(--radius-lg) 0 0; display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text-muted); }
        .profile-block-header .block-drag-handle { cursor: grab; color: var(--text-disabled); }
        .profile-block-header .block-drag-handle:hover { color: var(--text-muted); }
        .profile-block-header .block-title { flex: 1; font-weight: 500; color: var(--text-primary); }
        .profile-block-header .block-cols-select { padding: 2px 6px; border: 1px solid var(--border-primary); border-radius: 3px; font-size: 11px; background: var(--bg-secondary); color: var(--text-secondary); }
        .profile-block-header .block-remove-btn { background: none; border: none; color: var(--text-disabled); cursor: pointer; padding: 2px; }
        .profile-block-header .block-remove-btn:hover { color: var(--danger-500); }
        .profile-block-content { padding: 12px; }
        .profile-field-grid { display: grid; gap: 12px; }
        .profile-field-grid.cols-1 { grid-template-columns: 1fr; }
        .profile-field-grid.cols-2 { grid-template-columns: 1fr 1fr; }
        .profile-field-grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }

        .profile-field-card { background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 10px 12px; transition: all var(--transition-fast); }
        .profile-field-card:hover { border-color: var(--border-secondary); }
        .profile-field-card.dragging { opacity: 0.5; border-color: var(--primary-500); }
        .profile-field-card.drag-over { border-color: var(--primary-500); background: rgba(59, 130, 246, 0.1); }
        .profile-field-name { font-size: 11px; font-weight: 500; color: var(--text-muted); margin-bottom: 4px; display: flex; align-items: center; gap: 6px; }
        .profile-field-name .field-drag-handle { cursor: grab; color: var(--text-disabled); font-size: 10px; }
        .profile-field-name .field-drag-handle:hover { color: var(--text-muted); }
        .profile-field-value { font-size: 13px; color: var(--text-primary); word-break: break-word; cursor: pointer; padding: 2px 4px; margin: -2px -4px; border-radius: var(--radius-sm); transition: background var(--transition-fast); }
        .profile-field-value:hover:not(.editing) { background: var(--bg-hover); }
        .configure-mode .profile-field-value { cursor: default; }
        .configure-mode .profile-field-value:hover { background: none; }
        .profile-field-value.empty { color: var(--text-disabled); font-style: italic; }
        .profile-field-value.editing { padding: 0; margin: 0; background: none; }
        .profile-edit-input { width: 100%; background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-secondary); border-radius: var(--radius-sm); padding: 4px 8px; font-size: 13px; font-family: inherit; outline: none; box-sizing: border-box; resize: vertical; }
        .profile-edit-input:focus { border-color: var(--primary-500, #3b82f6); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        .profile-edit-checkbox { width: 16px; height: 16px; cursor: pointer; }

        /* Profile Navigation */
        .profile-nav { padding: 12px 20px; border-top: 1px solid var(--border-primary); display: flex; align-items: center; gap: 12px; background: var(--bg-tertiary); }
        .profile-nav-btn { padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; transition: all var(--transition-fast); }
        .profile-nav-btn:hover:not(:disabled) { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .profile-nav-info { flex: 1; text-align: center; font-size: 12px; color: var(--text-muted); }
        .profile-nav-history { padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-sm); cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; }
        .profile-nav-history:hover { border-color: var(--primary-500); color: var(--primary-400); }

        /* Profile Configure Mode */
        .profile-body.configure-mode .profile-field-card { cursor: move; border-style: dashed; }
        .profile-body.configure-mode .profile-field-card .field-drag-handle { display: inline; }
        .profile-body:not(.configure-mode) .profile-field-card .field-drag-handle { display: none; }
        .profile-body.configure-mode .profile-block-header .block-drag-handle { display: inline; }
        .profile-body:not(.configure-mode) .profile-block-header .block-drag-handle { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header .block-cols-select { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header .block-remove-btn { display: none; }
        .profile-body:not(.configure-mode) .profile-block-header { display: none; }
        .profile-body:not(.configure-mode) .profile-block { border: none; background: transparent; }
        .profile-body:not(.configure-mode) .profile-block-content { padding: 0; }
        .profile-body:not(.configure-mode) .profile-block { margin-bottom: 0; }

        /* Add Field to Block */
        .profile-add-field-btn { width: 100%; padding: 8px; background: var(--bg-secondary); border: 1px dashed var(--border-secondary); border-radius: var(--radius-md); cursor: pointer; font-size: 12px; color: var(--text-muted); margin-top: 8px; }
        .profile-add-field-btn:hover { border-color: var(--primary-500); color: var(--primary-400); }
        .profile-body:not(.configure-mode) .profile-add-field-btn { display: none; }
        .profile-field-picker { position: fixed; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 1100; width: 240px; max-height: 300px; overflow-y: auto; }
        .profile-field-picker-header { padding: 10px 12px; border-bottom: 1px solid var(--border-primary); font-size: 12px; font-weight: 600; color: var(--text-primary); }
        .profile-field-picker-item { padding: 8px 12px; cursor: pointer; font-size: 13px; color: var(--text-secondary); display: flex; align-items: center; gap: 8px; }
        .profile-field-picker-item:hover { background: var(--bg-hover); }
        .profile-field-picker-item .field-type-badge { font-size: 10px; color: var(--text-muted); background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; }

        /* ===== Matrix Setup Wizard ===== */
        #matrix-wizard {
            position: fixed; inset: 0; background: var(--bg-primary);
            display: flex; align-items: center; justify-content: center;
            z-index: 150;
        }
        #matrix-wizard.hidden { display: none; }
        .wizard-container {
            background: var(--bg-secondary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl); padding: 0; width: 540px; max-width: 95vw;
            max-height: 90vh; overflow-y: auto; box-shadow: var(--shadow-xl);
        }
        .wizard-header {
            padding: 28px 32px 0; text-align: center;
        }
        .wizard-header h2 { font-size: 22px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; }
        .wizard-header p { font-size: 13px; color: var(--text-muted); margin-bottom: 0; }
        .wizard-steps {
            display: flex; justify-content: center; gap: 8px;
            padding: 20px 32px 0; margin-bottom: 0;
        }
        .wizard-step-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--border-secondary); transition: all 0.2s;
        }
        .wizard-step-dot.active { background: var(--primary-500); transform: scale(1.2); }
        .wizard-step-dot.completed { background: var(--success-500); }
        .wizard-body { padding: 24px 32px; }
        .wizard-body .form-group { margin-bottom: 18px; }
        .wizard-body .form-group label {
            display: block; font-size: 13px; font-weight: 500;
            color: var(--text-secondary); margin-bottom: 6px;
        }
        .wizard-body .form-group label .label-hint {
            font-weight: 400; color: var(--text-muted); font-size: 12px;
        }
        .wizard-body input[type="text"],
        .wizard-body input[type="password"],
        .wizard-body select {
            width: 100%; padding: 10px 12px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
            color: var(--text-primary); font-size: 14px; box-sizing: border-box;
        }
        .wizard-body input:focus, .wizard-body select:focus {
            outline: none; border-color: var(--primary-500);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        .wizard-body .checkbox-group {
            display: flex; flex-direction: column; gap: 8px;
            max-height: 200px; overflow-y: auto;
            padding: 8px; background: var(--bg-tertiary);
            border: 1px solid var(--border-primary); border-radius: var(--radius-md);
        }
        .wizard-body .checkbox-item {
            display: flex; align-items: center; gap: 10px;
            padding: 6px 8px; border-radius: var(--radius-sm);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
        }
        .wizard-body .checkbox-item:hover { background: var(--bg-hover); }
        .wizard-body .checkbox-item input[type="checkbox"] {
            width: 16px; height: 16px; accent-color: var(--primary-500);
        }
        .wizard-body .linked-record-row {
            display: flex; align-items: center; gap: 8px;
            padding: 8px 0; border-bottom: 1px solid var(--border-primary);
        }
        .wizard-body .linked-record-row:last-child { border-bottom: none; }
        .wizard-body .linked-record-row .table-name {
            min-width: 120px; font-size: 13px; font-weight: 500; color: var(--text-primary);
        }
        .wizard-body .linked-record-row select { flex: 1; }
        .wizard-footer {
            padding: 16px 32px 28px; display: flex; justify-content: space-between; gap: 12px;
        }
        .wizard-footer button {
            padding: 10px 24px; border-radius: var(--radius-md); font-size: 14px;
            font-weight: 500; cursor: pointer; transition: all var(--transition-fast);
        }
        .wizard-footer .btn-back {
            background: var(--bg-tertiary); border: 1px solid var(--border-primary);
            color: var(--text-muted);
        }
        .wizard-footer .btn-back:hover { background: var(--bg-hover); color: var(--text-primary); }
        .wizard-footer .btn-next {
            background: var(--primary-500); border: 1px solid var(--primary-500);
            color: #fff; margin-left: auto;
        }
        .wizard-footer .btn-next:hover { background: var(--primary-600); }
        .wizard-footer .btn-next:disabled { background: var(--gray-600); border-color: var(--gray-600); cursor: not-allowed; }
        .wizard-error {
            color: #f87171; font-size: 13px; padding: 10px 12px;
            background: rgba(239, 68, 68, 0.15); border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: var(--radius-md); margin-bottom: 16px; display: none;
        }
        .wizard-success {
            color: #4ade80; font-size: 13px; padding: 10px 12px;
            background: rgba(34, 197, 94, 0.15); border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: var(--radius-md); margin-bottom: 16px;
        }
        .wizard-progress-section { margin-top: 16px; }
        .wizard-progress-bar {
            height: 6px; background: var(--bg-tertiary); border-radius: 3px;
            overflow: hidden; margin-bottom: 10px;
        }
        .wizard-progress-fill {
            height: 100%; background: linear-gradient(90deg, var(--primary-500), #7c3aed);
            transition: width 0.3s ease; border-radius: 3px;
        }
        .wizard-progress-status { font-size: 13px; color: var(--text-secondary); }
        .wizard-progress-detail { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
        .wizard-info-box {
            background: var(--bg-tertiary); border: 1px solid var(--border-primary);
            border-radius: var(--radius-md); padding: 12px 16px; font-size: 12px;
            color: var(--text-secondary); line-height: 1.5; margin-bottom: 16px;
        }
        .wizard-info-box strong { color: var(--text-primary); }
        #room-manager {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5);
            display: flex; align-items: center; justify-content: center;
            z-index: 160;
        }
        #room-manager.hidden { display: none; }
        #room-manager .rm-client-row {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 10px; border-radius: var(--radius-sm);
            cursor: pointer; font-size: 13px; color: var(--text-secondary);
        }
        #room-manager .rm-client-row:hover { background: var(--bg-hover); }
        #room-manager .rm-client-row .rm-room-info {
            font-size: 11px; color: var(--text-muted); margin-left: auto;
        }

        /* ===== Toast Notifications ===== */
        #toast-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 10000;
            display: flex;
            flex-direction: column-reverse;
            gap: 8px;
            pointer-events: none;
        }
        .toast {
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            border-radius: var(--radius-sm);
            font-size: 13px;
            font-family: var(--font-family);
            color: #fff;
            background: var(--gray-700);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transform: translateY(12px);
            animation: toast-in 0.25s ease forwards;
            max-width: 340px;
        }
        .toast.removing {
            animation: toast-out 0.2s ease forwards;
        }
        .toast.toast-saving {
            background: var(--gray-600);
        }
        .toast.toast-success {
            background: #166534;
        }
        .toast.toast-error {
            background: #991b1b;
        }
        .toast.toast-info {
            background: var(--gray-600);
        }
        .toast.toast-warning {
            background: #92400e;
        }
        .toast .toast-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: toast-spin 0.6s linear infinite;
        }
        .toast .toast-dismiss {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            padding: 0 0 0 8px;
            margin-left: auto;
        }
        .toast .toast-dismiss:hover {
            color: #fff;
        }
        .toast.toast-undo {
            background: var(--gray-700);
        }
        .toast .toast-undo-btn {
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.25);
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            font-family: inherit;
            line-height: 1;
            padding: 4px 10px;
            border-radius: 4px;
            margin-left: 4px;
            white-space: nowrap;
        }
        .toast .toast-undo-btn:hover {
            background: rgba(255,255,255,0.25);
        }
        @keyframes toast-in {
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes toast-out {
            to { opacity: 0; transform: translateY(12px); }
        }
        @keyframes toast-spin {
            to { transform: rotate(360deg); }
        }


        .app-dialog-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1200; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .app-dialog-overlay.open { opacity: 1; visibility: visible; }
        .app-dialog { background: var(--bg-secondary); color: var(--text-primary); width: min(460px, 92vw); border: 1px solid var(--border-primary); border-radius: var(--radius-xl); box-shadow: var(--shadow-xl); transform: translateY(12px); transition: transform 0.2s; }
        .app-dialog-overlay.open .app-dialog { transform: translateY(0); }
        .app-dialog-header { padding: 18px 20px 8px; }
        .app-dialog-header h2 { margin: 0; font-size: 18px; }
        .app-dialog-body { padding: 0 20px 16px; }
        .app-dialog-message { margin: 8px 0 0; font-size: 14px; color: var(--text-muted); line-height: 1.45; white-space: pre-wrap; }
        .app-dialog-select, .app-dialog-input { width: 100%; margin-top: 14px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); padding: 10px 12px; font-size: 14px; }
        .app-dialog-error { min-height: 18px; margin-top: 8px; color: #f87171; font-size: 12px; }
        .app-dialog-footer { padding: 12px 20px 18px; display: flex; justify-content: flex-end; gap: 10px; border-top: 1px solid var(--border-primary); }

        /* ===== Mobile Sidebar Toggle ===== */
        .mobile-sidebar-toggle {
            display: none;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border: none;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            cursor: pointer;
            flex-shrink: 0;
            transition: background var(--transition-fast);
        }
        .mobile-sidebar-toggle:hover { background: var(--bg-hover); color: var(--text-primary); }

        /* Sidebar Overlay Backdrop (mobile) */
        .sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 49;
            opacity: 0;
            transition: opacity 0.25s ease;
        }
        .sidebar-overlay.visible {
            display: block;
            opacity: 1;
        }

        /* ===== Responsive: Tablet (max-width: 768px) ===== */
        @media (max-width: 768px) {
            /* Show mobile sidebar toggle */
            .mobile-sidebar-toggle { display: flex; }

            /* Sidebar: slide-out drawer on mobile */
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                z-index: 50;
                transform: translateX(-100%);
                transition: transform 0.25s ease;
                width: 288px;
                max-width: 85vw;
            }
            .sidebar.mobile-open {
                transform: translateX(0);
            }

            /* Database app fills full width */
            #database-app { flex-direction: column; }

            /* Main takes full width */
            .main { width: 100%; }

            /* Tab bar: more compact */
            .browser-tab { min-width: 80px; max-width: 160px; padding: 0 8px; font-size: 12px; }
            .tab-title { font-size: 12px; }
            .tab-count { font-size: 10px; }

            /* Toolbar: wrap on mobile */
            .toolbar {
                padding: 8px 12px;
                gap: 8px;
                flex-wrap: wrap;
            }
            .toolbar h1 { font-size: 15px; flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            .toolbar-views { flex-wrap: wrap; gap: 6px; }

            /* View controls bar: scrollable */
            .view-controls-bar {
                padding: 6px 12px;
                gap: 2px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }
            .view-controls-bar::-webkit-scrollbar { display: none; }
            .view-control-btn { font-size: 12px; padding: 6px 8px; white-space: nowrap; }
            .view-search-input { width: 140px; }
            .view-search-input:focus { width: 160px; }

            /* View control dropdowns: full-width on mobile */
            .view-control-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                margin-top: 0;
                border-radius: var(--radius-xl) var(--radius-xl) 0 0;
                max-height: 70vh;
                overflow-y: auto;
                min-width: unset;
                z-index: 200;
            }

            /* Fields dropdown: full-width */
            .fields-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                border-radius: var(--radius-xl) var(--radius-xl) 0 0;
                max-height: 70vh;
                z-index: 200;
            }

            /* View selector dropdown */
            .view-selector-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                min-width: unset;
                border-radius: var(--radius-xl) var(--radius-xl) 0 0;
                max-height: 60vh;
                z-index: 200;
            }

            /* Status bar: compact */
            .status-bar { padding: 6px 12px; font-size: 11px; gap: 8px; flex-wrap: wrap; }

            /* Pagination: compact */
            .pagination { padding: 8px 12px; gap: 8px; font-size: 12px; flex-wrap: wrap; }

            /* Sync feed panel: full width at bottom */
            .sync-feed-panel {
                width: calc(100% - 16px);
                left: 8px;
                right: 8px;
                bottom: 8px;
                max-height: 60vh;
            }

            /* Record profile panel: full screen */
            .record-profile-panel {
                width: 100vw;
                max-width: 100vw;
            }
            .profile-header { padding: 12px 16px; }
            .profile-body { padding: 12px 16px; }
            .profile-field-grid.cols-2,
            .profile-field-grid.cols-3 { grid-template-columns: 1fr; }
            .profile-nav { padding: 10px 16px; }

            /* Home page */
            .home-topbar { padding: 0 16px; height: 48px; }
            .home-content { padding: 32px 16px 60px; }
            .home-greeting h1 { font-size: 24px; }
            .home-greeting { margin-bottom: 28px; }
            .home-cards { grid-template-columns: 1fr; gap: 12px; }
            .home-card { min-height: auto; padding: 20px 18px; }
            .home-stats { flex-direction: column; }
            .home-stat { text-align: left; padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; }
            .home-stat-value { font-size: 22px; }
            .home-stat-label { font-size: 10px; }

            /* Settings page */
            #settings-app { padding: 20px 16px; }
            .settings-header h1 { font-size: 20px; }
            .settings-tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
            .settings-tabs::-webkit-scrollbar { display: none; }
            .settings-tab { white-space: nowrap; padding: 10px 14px; }
            .settings-section { padding: 16px; }
            .settings-table { font-size: 12px; }
            .settings-table th, .settings-table td { padding: 8px; }

            /* Auth/Login screens */
            .auth-box, .synapse-login-box, .offline-unlock-box { width: 90vw; max-width: 360px; padding: 24px 20px; }
            #unlock-screen .unlock-box { width: 90vw; max-width: 400px; padding: 24px 20px; }

            /* Wizard container */
            .wizard-container { width: 95vw; max-width: 95vw; padding: 0; }
            .wizard-header { padding: 20px 20px 0; }
            .wizard-header h2 { font-size: 18px; }
            .wizard-body { padding: 16px 20px; }
            .wizard-footer { padding: 16px 20px; flex-wrap: wrap; }

            /* Room manager wizard override */
            #room-manager .wizard-container { width: 95vw; max-width: 95vw; }

            /* Modals */
            .modal { width: 95vw; max-width: 95vw; }
            .pit-modal { width: 98vw; }
            .modal-header { padding: 16px; }
            .modal-toolbar { padding: 10px 16px; flex-wrap: wrap; }
            .history-values { flex-direction: column; }
            .history-value-box { min-width: unset; }

            /* Create view modal */
            .create-view-modal-content { width: 95vw; }

            /* Room publish modal */
            .room-publish-box { width: 95vw; max-width: 480px; padding: 20px; }

            /* Schema view */
            .schema-view-container { padding: 12px; gap: 12px; }
            .schema-card { width: 100%; }

            /* Events controls */
            .events-controls { padding: 8px 12px; gap: 8px; }
            .events-filter-group { flex-wrap: wrap; }
            .events-stats { margin-left: 0; }
            .events-actions { margin-left: 0; }

            /* Matrix rooms */
            .matrix-rooms-view { padding: 16px; }
            .matrix-rooms-grid { grid-template-columns: 1fr; }
            .matrix-rooms-filter { flex-direction: column; gap: 8px; }
            .matrix-rooms-filter input { max-width: 100%; }

            /* Sync status */
            .sync-status-view { padding: 16px; }
            .sync-status-cards { grid-template-columns: 1fr 1fr; }
            .sync-poll-controls { flex-wrap: wrap; }
            .snapshot-export-controls { flex-direction: column; }

            /* Room access */
            .room-access-grid { grid-template-columns: 1fr; }

            /* Context menus */
            .view-context-menu { min-width: 140px; }

            /* Connect API modal (has inline styles, need override) */
            #connect-api-modal > div { width: 90vw !important; max-width: 360px; }

            /* View selection screen (has inline styles) */
            #view-selection-screen > div { width: 90vw !important; max-width: 400px; padding: 24px 20px !important; }

            /* Loading overlay */
            .loading-content { padding: 24px 16px; }
            .loading-title { font-size: 20px; }
            .loading-facts { gap: 16px; }
            .loading-fact-value { font-size: 22px; }

            /* Table container: smooth horizontal scroll on mobile */
            .table-container {
                -webkit-overflow-scrolling: touch;
            }

            /* Table cells: increase touch targets */
            td { padding: 10px 12px; }
            th { padding: 10px 12px; }

            /* App nav bar: always show on mobile as bottom navigation */
            .app-nav {
                display: flex !important;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 40;
                height: 56px;
                padding: 0 8px;
                border-bottom: none;
                border-top: 1px solid var(--border-primary);
                justify-content: center;
                background: var(--bg-secondary);
            }
            .app-nav-btn {
                padding: 8px 12px;
                font-size: 11px;
                flex-direction: column;
                gap: 2px;
                flex: 1;
                justify-content: center;
            }
            .app-nav-btn svg { width: 20px; height: 20px; }
            .app-nav-spacer { display: none; }
            .app-nav-user { display: none; }

            /* Body padding for bottom nav */
            .app-content-wrapper { padding-bottom: 56px; }
            #home-app { padding-bottom: 56px; }
        }

        /* ===== Responsive: Small Mobile (max-width: 480px) ===== */
        @media (max-width: 480px) {
            /* Even more compact toolbar */
            .toolbar {
                padding: 6px 10px;
                gap: 6px;
            }
            .toolbar h1 { font-size: 14px; }
            .btn { padding: 5px 8px; font-size: 11px; }

            /* Hide non-essential toolbar items */
            .view-save-indicator { display: none !important; }
            #manual-save-btn { display: none !important; }

            /* View selector: compact */
            .view-selector-btn { min-width: 100px; padding: 5px 8px; font-size: 12px; }
            .fields-btn { padding: 5px 8px; font-size: 12px; }

            /* Tab bar: ultra-compact */
            .browser-tab { min-width: 60px; max-width: 120px; gap: 4px; font-size: 11px; }
            .tab-bar-new-tab { width: 24px; height: 24px; font-size: 16px; }

            /* Home page */
            .home-greeting h1 { font-size: 20px; }
            .home-card-title { font-size: 16px; }
            .home-card-desc { font-size: 12px; }
            .home-activity-item { padding: 10px 14px; font-size: 12px; }

            /* Settings */
            #settings-app { padding: 16px 12px; }
            .settings-header h1 { font-size: 18px; }

            /* Sync status cards: single column */
            .sync-status-cards { grid-template-columns: 1fr; }

            /* Profile panel adjustments */
            .profile-tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; }
            .profile-tab { white-space: nowrap; padding: 10px 12px; font-size: 12px; }
            .profile-header h2 { font-size: 14px; }

            /* Changelog */
            .changelog-entry { padding: 10px 14px; gap: 10px; }
            .changelog-header { gap: 4px; }
            .changelog-field-value { max-width: 200px; }

            /* Events table */
            .events-table { font-size: 11px; }
            .events-table th, .events-table td { padding: 6px 8px; }

            /* Filter rows */
            .filter-row { flex-wrap: wrap; }
            .sort-row { flex-wrap: wrap; }

            /* Loading overlay */
            .loading-title { font-size: 18px; }
            .loading-subtitle { font-size: 13px; }
            .loading-fact-value { font-size: 20px; }
            .loading-note { font-size: 11px; padding: 10px 12px; }
        }

        /* ===== Touch-friendly Enhancements ===== */
        @media (hover: none) and (pointer: coarse) {
            /* Increase tap targets for touch devices */
            .view-control-btn { min-height: 40px; padding: 8px 12px; }
            .btn { min-height: 36px; }
            .sidebar div.table-item { padding: 12px; min-height: 44px; }
            .table-view-item { padding: 10px 12px 10px 40px; min-height: 40px; }
            .settings-tab { min-height: 44px; }
            .app-nav-btn { min-height: 40px; }
            .browser-tab { min-height: 36px; }
            .profile-tab { min-height: 44px; }
            .events-tab { min-height: 44px; }

            /* Always show close button on tabs (no hover on touch) */
            .tab-close { opacity: 0.5; }
            .browser-tab.active .tab-close { opacity: 0.8; }

            /* Always show pin button on touch */
            .pin-btn { opacity: 0.5; }
            .pin-btn.pinned { opacity: 1; }

            /* Disable hover card transform on touch */
            .home-card:hover { transform: none; }
        }
    </style>
</head>
<body>
    <!-- Toast Notification Container -->
    <div id="toast-container"></div>


    <div id="app-dialog-overlay" class="app-dialog-overlay" aria-hidden="true" inert>
        <div class="app-dialog" role="dialog" aria-modal="true" aria-labelledby="app-dialog-title" aria-describedby="app-dialog-message">
            <div class="app-dialog-header">
                <h2 id="app-dialog-title"></h2>
            </div>
            <div class="app-dialog-body">
                <p id="app-dialog-message" class="app-dialog-message"></p>
                <select id="app-dialog-select" class="app-dialog-select" style="display:none"></select>
                <input id="app-dialog-input" class="app-dialog-input" type="text" style="display:none" />
                <div id="app-dialog-error" class="app-dialog-error"></div>
            </div>
            <div class="app-dialog-footer">
                <button id="app-dialog-cancel" class="btn">Cancel</button>
                <button id="app-dialog-confirm" class="btn">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Encryption Unlock Screen -->
    <div id="unlock-screen" class="hidden">
        <!-- Setup Mode (first time) -->
        <div id="unlock-setup" class="unlock-box">
            <h2><span class="lock-icon">&#128274;</span> Secure Your Data</h2>
            <p class="subtitle">Set up encryption to protect your locally cached data</p>
            <div id="unlock-setup-error" class="unlock-error"></div>

            <div class="security-note">
                <strong>Why encrypt?</strong> Your API key and cached data will be encrypted before being stored in your browser. If someone gains access to your browser's storage, they won't be able to read your data without your password or passkey.
            </div>

            <form onsubmit="return false;">
            <input type="text" name="username" autocomplete="username" style="display:none" aria-hidden="true" tabindex="-1">
            <div class="setup-section">
                <label for="setup-password">Create a password</label>
                <input type="password" id="setup-password" placeholder="Enter a strong password" autocomplete="new-password" oninput="updatePasswordStrength()">
                <div class="password-strength"><div class="password-strength-fill" id="password-strength-fill"></div></div>
            </div>

            <div class="setup-section">
                <label for="setup-password-confirm">Confirm password</label>
                <input type="password" id="setup-password-confirm" placeholder="Confirm your password" autocomplete="new-password">
            </div>

            <button id="setup-password-btn" onclick="setupEncryptionWithPassword()">Set Up with Password</button>
            </form>

            <div class="unlock-divider">or</div>

            <button id="setup-passkey-btn" class="passkey-btn" onclick="setupEncryptionWithPasskey()">
                <span class="passkey-icon">&#128273;</span> Set Up with Passkey
            </button>

            <button id="skip-encryption-btn" class="secondary" onclick="skipEncryption()">Skip (Not Recommended)</button>

            <div class="unlock-info">
                Passkeys use your device's biometrics (Face ID, Touch ID, Windows Hello) for secure, passwordless authentication.
            </div>
        </div>

        <!-- Unlock Mode (returning user) -->
        <div id="unlock-prompt" class="unlock-box hidden">
            <h2><span class="lock-icon">&#128274;</span> Unlock Your Data</h2>
            <p class="subtitle">Enter your password or use your passkey to access your encrypted data</p>
            <div id="unlock-prompt-error" class="unlock-error"></div>

            <div id="passkey-unlock-section">
                <button id="passkey-unlock-btn" class="passkey-btn" onclick="unlockWithPasskey()">
                    <span class="passkey-icon">&#128273;</span> Unlock with Passkey
                </button>
                <div class="unlock-divider">or enter your password</div>
            </div>

            <form onsubmit="return false;">
            <input type="text" name="username" autocomplete="username" style="display:none" aria-hidden="true" tabindex="-1">
            <input type="password" id="unlock-password" placeholder="Enter your password" autocomplete="current-password">
            <button id="unlock-password-btn" onclick="unlockWithPassword()">Unlock</button>
            </form>

            <button id="clear-encrypted-data-btn" class="secondary" onclick="clearEncryptedData()">Clear All Data & Start Fresh</button>

            <div class="unlock-info">
                Forgot your password? You'll need to clear all local data and start fresh. Your data on the server is not affected.
            </div>
        </div>
    </div>

    <div id="synapse-login-screen">
        <div class="synapse-login-box">
            <!-- Login Form -->
            <form id="synapse-login-form" onsubmit="return false;">
                <h2>Amino Viewer</h2>
                <p>Sign in to your account at app.aminoimmigration.com</p>
                <div id="synapse-login-error" class="synapse-error"></div>
                <label for="synapse-username">Username</label>
                <input type="text" id="synapse-username" placeholder="Username" autocomplete="username">
                <label for="synapse-password">Password</label>
                <input type="password" id="synapse-password" placeholder="Password" autocomplete="current-password">
                <button id="synapse-login-btn">Sign In</button>
                <a class="synapse-forgot-link" onclick="showPasswordReset()">Forgot Password?</a>
            </form>
            <!-- Password Reset Form -->
            <form id="synapse-reset-form" onsubmit="return false;">
                <input type="text" name="username" autocomplete="username" style="display:none" aria-hidden="true" tabindex="-1">
                <h2>Reset Password</h2>
                <div id="synapse-reset-error" class="synapse-error"></div>
                <div id="synapse-reset-success" class="synapse-success"></div>
                <!-- Step 1: Enter email -->
                <div id="synapse-reset-step1" class="synapse-reset-step active">
                    <p class="synapse-info">Enter the email address associated with your account. We'll send a verification link to confirm your identity.</p>
                    <label for="synapse-reset-email">Email Address</label>
                    <input type="email" id="synapse-reset-email" placeholder="you@example.com" autocomplete="email">
                    <button id="synapse-reset-send-btn" onclick="requestPasswordReset()">Send Reset Email</button>
                </div>
                <!-- Step 2: Enter new password after email verification -->
                <div id="synapse-reset-step2" class="synapse-reset-step">
                    <p class="synapse-info">A verification email has been sent. Click the link in the email, then enter your new password below and click "Reset Password".</p>
                    <label for="synapse-reset-new-password">New Password</label>
                    <input type="password" id="synapse-reset-new-password" placeholder="New password" autocomplete="new-password">
                    <label for="synapse-reset-confirm-password">Confirm Password</label>
                    <input type="password" id="synapse-reset-confirm-password" placeholder="Confirm new password" autocomplete="new-password">
                    <button id="synapse-reset-confirm-btn" onclick="confirmPasswordReset()">Reset Password</button>
                </div>
                <!-- Step 3: Success -->
                <div id="synapse-reset-step3" class="synapse-reset-step">
                    <div class="synapse-success" style="display: block;">Your password has been reset successfully. You can now sign in with your new password.</div>
                </div>
                <a class="synapse-back-link" onclick="hidePasswordReset()">Back to Sign In</a>
            </form>
        </div>
    </div>

    <!-- Offline Unlock Screen -->
    <div id="offline-unlock-screen">
        <div class="offline-unlock-box">
            <div class="offline-badge">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.56 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line></svg>
                Offline Mode
            </div>
            <h2>Welcome Back</h2>
            <p>You're offline. Enter your password to access your cached data.</p>
            <div id="offline-unlock-user" class="offline-user-badge" style="display: none;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                <span id="offline-unlock-username"></span>
            </div>
            <div id="offline-unlock-error" class="unlock-error"></div>
            <form id="offline-unlock-form" onsubmit="return false;">
                <label for="offline-unlock-password">Password</label>
                <input type="password" id="offline-unlock-password" placeholder="Enter your password" autocomplete="current-password">
                <button id="offline-unlock-btn" class="primary" type="button">Unlock</button>
                <button id="offline-unlock-online-btn" class="secondary" type="button">Sign in online instead</button>
            </form>
            <div id="offline-unlock-last-synced" class="offline-last-synced"></div>
        </div>
    </div>

    <div id="view-selection-screen" class="hidden" style="position: fixed; inset: 0; background: var(--bg-primary); display: flex; align-items: center; justify-content: center; z-index: 104;">
        <div style="background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: var(--radius-lg); padding: 32px; width: 400px; box-shadow: var(--shadow-xl);">
            <h2 style="font-size: 20px; margin-bottom: 8px; color: var(--text-primary);">Amino Viewer</h2>
            <p style="font-size: 13px; color: var(--text-muted); margin-bottom: 24px;">Choose how to view your data</p>
            <button id="view-as-database-btn" style="width: 100%; padding: 14px; background: var(--primary-500); border: none; border-radius: var(--radius-md); color: #fff; font-size: 14px; cursor: pointer; font-weight: 500; margin-bottom: 10px; transition: background var(--transition-fast);">View as Database</button>
            <button id="view-as-interface-btn" style="width: 100%; padding: 14px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-secondary); font-size: 14px; cursor: pointer; font-weight: 500; transition: background var(--transition-fast);">View as Interface</button>
        </div>
    </div>
        </div>
    </div>

    <div id="auth-screen" class="hidden">
        <div class="auth-box">
            <h2>Amino Viewer</h2>
            <p>Connect to your Amino event stream</p>
            <div id="auth-error" class="auth-error"></div>
            <form onsubmit="return false;">
            <input type="text" name="username" autocomplete="username" style="display:none" aria-hidden="true" tabindex="-1">
            <input type="password" id="api-key-input" placeholder="API Key" autocomplete="off">
            <input type="text" id="set-filter-input" placeholder="Filter by set (optional)" autocomplete="off">
            <button id="auth-submit">Connect</button>
            <button id="auth-clear" class="secondary hidden">Clear Local Data</button>
            </form>
            <div class="auth-divider" style="display: flex; align-items: center; gap: 12px; margin: 16px 0 12px;">
                <div style="flex: 1; height: 1px; background: var(--border-primary);"></div>
                <span style="font-size: 12px; color: var(--text-muted);">or</span>
                <div style="flex: 1; height: 1px; background: var(--border-primary);"></div>
            </div>
            <button id="auth-skip-upload" class="secondary" onclick="skipAuthAndUploadCSV()">Skip - Upload CSV Only</button>
            <button id="auth-skip-upload-amo" class="secondary" onclick="skipAuthAndUploadAmo()" style="margin-top: 8px;">Skip - Upload .amo Snapshot</button>
            <div id="auth-info" class="auth-info"></div>
        </div>
    </div>

    <!-- Initial Data Loading Overlay -->
    <div id="loading-overlay" class="hidden">
        <div class="loading-particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
        </div>
        <div class="loading-content">
            <div class="loading-logo">
                <div class="loading-logo-inner">A</div>
            </div>
            <h1 class="loading-title" id="loading-title">Setting Up Your Workspace</h1>
            <p class="loading-subtitle" id="loading-subtitle">We're downloading your data to this device for lightning-fast access.</p>

            <div class="loading-facts" id="loading-facts">
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-tables">0</div>
                    <div class="loading-fact-label">Tables</div>
                </div>
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-fields">0</div>
                    <div class="loading-fact-label">Fields</div>
                </div>
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-records">0</div>
                    <div class="loading-fact-label">Records</div>
                </div>
            </div>

            <div class="loading-progress-container">
                <div class="loading-progress-bar">
                    <div class="loading-progress-fill" id="loading-progress-fill" style="width: 0%"></div>
                    <div class="loading-progress-activity"></div>
                </div>
                <div class="loading-status" id="loading-status">Connecting to server...</div>
                <div class="loading-detail" id="loading-detail">Page 1</div>
                <div class="loading-table-progress" id="loading-table-progress"></div>
                <div class="loading-speed" id="loading-speed"></div>
            </div>

            <div class="loading-note" id="loading-note">
                <strong>One-time setup:</strong> This only happens once per device. After this, your data loads instantly from local storage.
            </div>

            <!-- CSV/AMO manual import removed - hydration is automatic from cloud snapshot -->
        </div>
    </div>

    <!-- Connect API Key Modal -->
    <div id="connect-api-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; align-items: center; justify-content: center;">
        <div style="background: #fff; border-radius: 8px; padding: 24px; width: 360px; box-shadow: 0 4px 24px rgba(0,0,0,0.3);">
            <h3 style="font-size: 16px; margin-bottom: 6px; color: #333;">Connect API Key</h3>
            <p style="font-size: 13px; color: #666; margin-bottom: 16px;">Add your API key to enable syncing with the server.</p>
            <div id="connect-api-error" style="color: #dc3545; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: #f8d7da; border-radius: 4px; display: none;"></div>
            <form onsubmit="return false;">
            <input type="text" name="username" autocomplete="username" style="display:none" aria-hidden="true" tabindex="-1">
            <input type="password" id="connect-api-key-input" placeholder="API Key" autocomplete="off" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <input type="text" id="connect-api-set-filter" placeholder="Filter by set (optional)" autocomplete="off" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <button id="connect-api-submit" onclick="submitConnectApi()" style="width: 100%; padding: 10px; background: #2d6cdf; border: none; border-radius: 6px; color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500;">Connect</button>
            <button onclick="hideConnectApiModal()" style="width: 100%; padding: 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 6px; color: #333; font-size: 14px; cursor: pointer; font-weight: 500;">Cancel</button>
            </form>
        </div>
    </div>

    <!-- Matrix Setup Wizard -->
    <div id="matrix-wizard" class="hidden">
        <div class="wizard-container">
            <div class="wizard-header">
                <h2 id="wizard-title">Connect to Matrix</h2>
                <p id="wizard-subtitle">Set up your organization's secure data infrastructure</p>
            </div>
            <div class="wizard-steps" id="wizard-steps">
                <div class="wizard-step-dot active"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
                <div class="wizard-step-dot"></div>
            </div>
            <div class="wizard-body" id="wizard-body">
                <!-- Wizard content rendered dynamically per step -->
            </div>
            <div class="wizard-footer" id="wizard-footer">
                <button class="btn-back" id="wizard-back" onclick="wizardBack()">Back</button>
                <button class="btn-next" id="wizard-next" onclick="wizardNext()">Next</button>
            </div>
        </div>
    </div>

    <!-- Room Manager Panel (Admin) -->
    <div id="room-manager" class="hidden">
        <div class="wizard-container" style="width: 620px;">
            <div class="wizard-header">
                <h2 id="rm-title">Manage Rooms</h2>
                <p id="rm-subtitle">Select client rooms to delete</p>
            </div>
            <div class="wizard-body" id="rm-body">
                <div class="wizard-error" id="rm-error"></div>
                <div id="rm-list-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <label class="checkbox-item" style="padding: 0; margin: 0;">
                            <input type="checkbox" id="rm-select-all" onchange="rmToggleSelectAll(this.checked)">
                            <span style="font-weight: 500;">Select all</span>
                        </label>
                        <span id="rm-selected-count" style="font-size: 12px; color: var(--text-muted);">0 selected</span>
                    </div>
                    <div class="checkbox-group" id="rm-client-list" style="max-height: 320px;"></div>
                </div>
                <div id="rm-progress-section" style="display: none;">
                    <div class="wizard-progress-section">
                        <div class="wizard-progress-bar">
                            <div class="wizard-progress-fill" id="rm-progress" style="width: 0%"></div>
                        </div>
                        <div class="wizard-progress-status" id="rm-status">Preparing...</div>
                        <div class="wizard-progress-detail" id="rm-detail"></div>
                    </div>
                </div>
                <div id="rm-result-section" style="display: none;"></div>
            </div>
            <div class="wizard-footer" id="rm-footer">
                <button class="btn-back" onclick="hideRoomManager()">Cancel</button>
                <button class="btn-next" id="rm-delete-btn" onclick="rmConfirmDelete()" style="background: var(--error-500, #ef4444); border-color: var(--error-500, #ef4444);" disabled>Delete Selected</button>
            </div>
        </div>
    </div>

    <!-- File Header Bar (shown after login) -->
    <div class="file-header" id="file-header">
        <div class="file-header-left">
            <span class="file-header-role" id="file-header-role">admin</span>
        </div>
        <div class="file-header-right">
            <button class="file-header-theme-btn" onclick="toggleTheme()" title="Toggle light/dark theme">
                <span id="file-header-theme-icon">&#9788;</span>
                <span id="file-header-theme-label">Light Mode</span>
            </button>
        </div>
    </div>

    <!-- App Navigation Bar (shown after login) -->
    <nav class="app-nav" id="app-nav">
        <button class="app-nav-btn active" id="app-nav-home" onclick="switchApp('home')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/>
            </svg>
            Home
        </button>
        <button class="app-nav-btn" id="app-nav-database" onclick="switchApp('database')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/><path d="M3 12c0 1.66 4 3 9 3s9-1.34 9-3"/>
            </svg>
            Database
        </button>
        <button class="app-nav-btn" id="app-nav-interface" onclick="switchApp('interface')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/>
            </svg>
            Interface
        </button>
        <button class="app-nav-btn" id="app-nav-forms" onclick="switchApp('forms')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/>
            </svg>
            Forms
        </button>
        <button class="app-nav-btn" id="app-nav-settings" onclick="switchApp('settings')">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
            </svg>
            Settings
        </button>
        <div class="app-nav-spacer"></div>
        <div class="app-nav-user">
            <span id="app-nav-username"></span>
            <span class="app-nav-user-role" id="app-nav-role"></span>
            <button class="app-nav-logout" onclick="appNavLogout()">Sign Out</button>
        </div>
    </nav>

    <!-- Offline Mode Banner -->
    <div id="offline-mode-banner">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.56 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line></svg>
        <span>Offline Mode  Read Only (cached data)</span>
        <button class="offline-reconnect-btn" onclick="tryReconnect()">Reconnect</button>
    </div>

    <!-- App Content Wrapper -->
    <div class="app-content-wrapper" id="app-content-wrapper">

    <!-- Home Sub-App -->
    <div id="home-app">
        <div class="routes-home">
            <div class="routes-home-header">
                <div>
                    <h1>Choose a route</h1>
                    <p>Start in Database, Interface, or Settings. Interface opens on its first page using live synced data.</p>
                </div>
                <div class="routes-home-avatar" id="home-avatar">RL</div>
            </div>

            <div class="routes-home-cards">
                <button class="routes-card" onclick="switchApp('database')">
                    <div class="routes-card-icon"></div>
                    <h3>Database</h3>
                    <p>Browse synced tables and records directly from local + Matrix cache.</p>
                    <span>Open Database </span>
                </button>
                <button class="routes-card" onclick="switchApp('interface')">
                    <div class="routes-card-icon"></div>
                    <h3>Interface</h3>
                    <p>Open the first Interface page with live records, including case notes from PostgreSQL.</p>
                    <span>Open Interface </span>
                </button>
                <button class="routes-card" onclick="switchApp('forms')">
                    <div class="routes-card-icon"></div>
                    <h3>Forms</h3>
                    <p>Create and manage data entry forms. View forms shared with you across all tables.</p>
                    <span>Open Forms </span>
                </button>
                <button class="routes-card" onclick="switchApp('settings')">
                    <div class="routes-card-icon"></div>
                    <h3>Settings</h3>
                    <p>Manage users, room access, and workspace preferences.</p>
                    <span>Open Settings </span>
                </button>
            </div>

            <div class="routes-home-stats">
                <button class="routes-stat" onclick="openHomeStat('tables')" title="Open Database tables">
                    <div class="routes-stat-value" id="home-table-count">0</div>
                    <div class="routes-stat-label">Tables</div>
                </button>
                <button class="routes-stat" onclick="openHomeStat('records')" title="Open Database records">
                    <div class="routes-stat-value" id="home-record-count">0</div>
                    <div class="routes-stat-label">Records</div>
                </button>
                <button class="routes-stat" onclick="openHomeStat('case-notes')" title="Open Case Notes table">
                    <div class="routes-stat-value" id="home-casenotes-count">0</div>
                    <div class="routes-stat-label">Case Notes</div>
                </button>
                <button class="routes-stat" onclick="switchApp('forms')" title="Open Forms">
                    <div class="routes-stat-value" id="home-forms-count">0</div>
                    <div class="routes-stat-label">Forms</div>
                </button>
                <button class="routes-stat" onclick="openHomeStat('data-source')" title="Matrix connection status">
                    <div class="routes-stat-value" id="home-sync-status">Local</div>
                    <div class="routes-stat-label">Data Source</div>
                </button>
            </div>
        </div>
    </div>

    <!-- Database Sub-App (existing sidebar + main) -->
    <div id="database-app" style="display: none; flex: 1; overflow: hidden;">
    <div class="sidebar-overlay" id="sidebar-overlay" onclick="closeMobileSidebar()"></div>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-header-top">
                <div class="sidebar-logo">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <ellipse cx="12" cy="5" rx="9" ry="3"/>
                        <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/>
                        <path d="M3 12c0 1.66 4 3 9 3s9-1.34 9-3"/>
                    </svg>
                </div>
                <h2>Amino Viewer</h2>
            </div>
            <div class="sidebar-search">
                <span class="sidebar-search-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.3-4.3"/>
                    </svg>
                </span>
                <input type="text" id="sidebar-search-input" placeholder="Search tables..." />
                <span class="sidebar-search-shortcut">&#8984;K</span>
            </div>
        </div>
        <div id="table-list"></div>
        <div class="sidebar-footer">
            <button class="theme-toggle-btn" id="matrix-connect-btn" onclick="showSynapseLoginScreen()" title="Connect to Matrix for room sync">
                <span id="matrix-status-icon">&#9675;</span>
                <span id="matrix-status-label">Connect Matrix</span>
            </button>
            <button class="theme-toggle-btn" id="manage-rooms-btn" onclick="showRoomManager()" title="Manage Matrix rooms" style="display: none;">
                <span>&#9881;</span>
                <span>Manage Rooms</span>
            </button>
            <button class="theme-toggle-btn" onclick="toggleTheme()" title="Toggle light/dark theme">
                <span id="theme-icon">&#9788;</span>
                <span id="theme-label">Light Mode</span>
            </button>
        </div>
    </div>

    <div class="main">
        <!-- Browser Tab Bar -->
        <div class="tab-bar" id="tab-bar">
            <div class="tab-bar-tabs" id="tab-bar-tabs">
                <!-- Tabs rendered dynamically -->
            </div>
            <button class="tab-bar-new-tab" id="tab-bar-new-tab" onclick="openNewTab()" title="Open in new tab">+</button>
        </div>
        <!-- Data Viewer View -->
        <div id="data-view" style="display: flex; flex-direction: column; height: 100%;">
            <div class="toolbar">
                <button class="mobile-sidebar-toggle" id="mobile-sidebar-toggle" onclick="toggleMobileSidebar()" title="Toggle sidebar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                </button>
                <h1 id="title">Select a table</h1>

                <!-- View Selector -->
                <div class="toolbar-views">
                    <div class="view-selector" id="view-selector-container">
                        <button class="view-selector-btn" id="view-selector-btn" onclick="toggleViewSelector()">
                            <span class="view-icon" id="current-view-icon">&#9638;</span>
                            <span class="view-name" id="current-view-name">All Fields</span>
                            <span class="dropdown-arrow">&#9662;</span>
                        </button>
                        <div class="view-selector-dropdown" id="view-selector-dropdown">
                            <!-- View options will be rendered here -->
                        </div>
                    </div>

                    <!-- Fields Button -->
                    <button class="fields-btn" id="fields-btn" onclick="toggleFieldsDropdown()">
                        <span class="fields-icon">&#9776;</span>
                        <span>Fields</span>
                        <span class="fields-count" id="fields-visible-count">0</span>
                    </button>
                    <div class="fields-dropdown" id="fields-dropdown">
                        <div class="fields-dropdown-header">
                            <h3>Toggle Fields</h3>
                            <div class="fields-dropdown-actions">
                                <button onclick="showAllFields()">Show All</button>
                                <button onclick="hideAllFields()">Hide All</button>
                            </div>
                        </div>
                        <div class="fields-search-container">
                            <input type="text" class="fields-search-input" id="fields-search-input" placeholder="Search fields..." oninput="filterFieldsDropdown(this.value)">
                        </div>
                        <div class="fields-dropdown-list" id="fields-dropdown-list">
                            <!-- Field items will be rendered here -->
                        </div>
                        <div class="fields-dropdown-footer">
                            Drag to reorder  Click checkbox to toggle
                        </div>
                    </div>
                </div>

                <!-- View Save Indicator -->
                <div class="view-save-indicator" id="view-save-indicator" style="display: none;">
                    <span class="save-dot"></span>
                    <span id="save-indicator-text">Saved</span>
                </div>
                <button class="view-save-btn" id="manual-save-btn" onclick="saveViewToBackendNow()" style="display: none;">Save Now</button>

                <button class="btn" id="airtable-sync-btn" onclick="manualAirtableSync()" title="Pull latest changes from Airtable">
                    <svg id="sync-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6"/><path d="M2.5 11.5a10 10 0 0118.8-4.3L21.5 8M21.5 12.5a10 10 0 01-18.8 4.3L2.5 16"/></svg>
                    <span id="sync-btn-text">Sync</span>
                </button>
                <button class="btn" id="connect-api-btn" onclick="showConnectApiModal()" style="display: none; background: #2d6cdf; color: #fff;">Connect API</button>
                <button class="btn" onclick="logout()">Logout</button>
            </div>

            <!-- Airtable-style View Controls Bar -->
            <div class="view-controls-bar" id="view-controls-bar">
                <!-- Filter Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="filter-btn" onclick="toggleFilterDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M4 8h8M6 12h4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                        <span>Filter</span>
                        <span class="control-count" id="filter-count" style="display: none;">0</span>
                        <span class="record-count-badge" id="record-count-badge"></span>
                    </button>
                    <div class="view-control-dropdown filter-dropdown" id="filter-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Filter records</span>
                                <button class="dropdown-action-btn" onclick="addFilter()">+ Add rule</button>
                                <button class="dropdown-action-btn" onclick="addSubGroup([])">+ Add group</button>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="filter-search-input" placeholder="Find a field" oninput="filterFilterDropdown(this.value)">
                            </div>
                            <div class="filter-list" id="filter-list">
                                <div class="empty-filters">No filters applied</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sort Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="sort-btn" onclick="toggleSortDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 5l2-2 2 2M6 3v10M12 11l-2 2-2-2M10 13V3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
                        <span>Sort</span>
                        <span class="control-count" id="sort-count" style="display: none;">0</span>
                    </button>
                    <div class="view-control-dropdown sort-dropdown" id="sort-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Sort records</span>
                                <button class="dropdown-action-btn" onclick="addSort()">+ Add sort</button>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="sort-search-input" placeholder="Find a field" oninput="filterSortDropdown(this.value)">
                            </div>
                            <div class="sort-list" id="sort-list">
                                <div class="empty-sorts">No sorts applied</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Group Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="group-btn" onclick="toggleGroupDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="2" y="3" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="3" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="2" y="9" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="9" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/></svg>
                        <span>Group</span>
                    </button>
                    <div class="view-control-dropdown group-dropdown" id="group-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Group records by</span>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="group-search-input" placeholder="Find a field" oninput="filterGroupDropdown(this.value)">
                            </div>
                            <div class="group-options" id="group-options">
                                <div class="group-option none-selected" onclick="setGroupBy(null)">
                                    <span class="check-mark">&#10003;</span>
                                    <span>None</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Color Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="color-btn" onclick="toggleColorDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="5" stroke="currentColor" stroke-width="1.5"/><path d="M8 3v10M3 8h10" stroke="currentColor" stroke-width="1.5"/></svg>
                        <span>Color</span>
                    </button>
                    <div class="view-control-dropdown color-dropdown" id="color-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Color records by</span>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="color-search-input" placeholder="Find a field" oninput="filterColorDropdown(this.value)">
                            </div>
                            <div class="color-options" id="color-options">
                                <div class="color-option none-selected" onclick="setColorBy(null)">
                                    <span class="check-mark">&#10003;</span>
                                    <span>None</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Row Height Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="row-height-btn" onclick="toggleRowHeightDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                        <span>Row height</span>
                    </button>
                    <div class="view-control-dropdown row-height-dropdown" id="row-height-dropdown">
                        <div class="dropdown-section">
                            <div class="row-height-option" onclick="setRowHeight('short')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 6h12M2 10h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Short</span>
                            </div>
                            <div class="row-height-option selected" onclick="setRowHeight('medium')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Medium</span>
                            </div>
                            <div class="row-height-option" onclick="setRowHeight('tall')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 3h12M2 7h12M2 11h12M2 15h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Tall</span>
                            </div>
                            <div class="row-height-option" onclick="setRowHeight('extra-tall')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 2h12M2 5h12M2 8h12M2 11h12M2 14h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Extra tall</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="view-controls-spacer"></div>

                <!-- Search -->
                <div class="view-search-wrapper">
                    <svg class="search-icon" width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="7" cy="7" r="4.5" stroke="currentColor" stroke-width="1.5"/><path d="M10.5 10.5L14 14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                    <input type="text" class="view-search-input" id="view-search-input" placeholder="Find in view" oninput="handleViewSearch(this.value)">
                </div>
            </div>
            <div class="status-bar">
                <span class="status-dot" id="status-dot"></span>
                <span id="status-text">Ready</span>
                <div class="progress-bar" id="progress-bar" style="display: none; flex: 1; max-width: 200px;">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <span id="status-detail" style="color: #999; font-size: 11px;"></span>
                <span class="offline-badge" id="offline-badge" onclick="SyncStatusFeed.show()" title="Pending offline edits">
                    <span class="offline-badge-dot"></span>
                    <span id="offline-badge-text">0 pending</span>
                </span>
                <div class="sync-toggle-wrapper">
                    <span class="sync-status-indicator" id="sync-status-indicator" onclick="SyncStatusFeed.toggle()" title="View sync activity">
                        <span class="sync-status-dot" id="sync-indicator-dot"></span>
                        <span class="sync-status-label" id="sync-indicator-label">Synced</span>
                    </span>
                </div>
                <span style="flex: 1;"></span>
                <span class="refresh-indicator" id="refresh-indicator">
                    <span class="refresh-dot"></span>
                    <span id="last-refresh-text">Auto-refresh in 60s</span>
                </span>
            </div>
            <!-- Sync Banner: shown during background hydration/sync -->
            <div class="sync-banner" id="sync-banner">
                <div class="sync-banner-spinner"></div>
                <span class="sync-banner-icon" id="sync-banner-icon" style="display:none;"></span>
                <span class="sync-banner-text" id="sync-banner-text">Syncing data in the background...</span>
                <div class="sync-banner-progress" id="sync-banner-progress" style="display:none;">
                    <div class="sync-banner-progress-fill" id="sync-banner-progress-fill"></div>
                </div>
                <button class="sync-banner-dismiss" id="sync-banner-dismiss" onclick="SyncBanner.dismiss()" title="Dismiss">&times;</button>
            </div>
            <div class="table-container" id="table-container" style="position: relative;">
                <!-- Table loading overlay for filter/sort operations -->
                <div class="table-loading-overlay" id="table-loading-overlay">
                    <div class="table-loading-overlay-content">
                        <div class="loading-spinner"></div>
                        <p id="table-loading-overlay-text">Applying filters...</p>
                    </div>
                </div>
                <table id="table"></table>
            </div>
            <div class="pagination" id="pagination">
                <span class="record-total" id="record-total"></span>
                <button id="prev-btn" onclick="prevPage()" title="Previous page"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15,18 9,12 15,6"/></svg></button>
                <span class="page-info" id="page-info">Page 1</span>
                <button id="next-btn" onclick="nextPage()" title="Next page"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9,6 15,12 9,18"/></svg></button>
            </div>
        </div>
    </div>

    <!-- View Context Menu -->
    <div class="view-context-menu" id="view-context-menu">
        <div class="view-context-menu-item" onclick="moveViewToFolder()">
            <span>&#128193;</span> Move to folder...
        </div>
        <div class="view-context-menu-item" onclick="renameView()">
            <span>&#9998;</span> Rename
        </div>
        <div class="view-context-menu-item" onclick="manageViewTags()">
            <span>&#127991;</span> Manage tags...
        </div>
        <div class="view-context-menu-item" onclick="addViewToWorkspaceMenu()">
            <span>&#11088;</span> Add to workspace...
        </div>
        <div class="view-context-menu-item" onclick="setViewParent()">
            <span>&#128279;</span> Set parent view...
        </div>
        <div class="view-context-menu-separator"></div>
        <div class="view-context-menu-item" onclick="openShareViewMenu()">
            <span id="ctx-share-icon">&#128274;</span> <span id="ctx-share-label">Share view...</span>
        </div>
        <div class="view-context-menu-separator"></div>
        <div class="view-context-menu-item danger" onclick="deleteView()">
            <span>&#128465;</span> Delete
        </div>
    </div>

    <!-- Table Context Menu -->
    <div class="view-context-menu" id="table-context-menu">
        <div class="view-context-menu-item" onclick="createViewFolderFromContextMenu()">
            <span>&#128193;</span> New folder
        </div>
    </div>

    <!-- Column Context Menu -->
    <div class="view-context-menu" id="column-context-menu">
        <div class="view-context-menu-item" id="ctx-set-display-name" onclick="setDisplayNameFromContextMenu()">
            <span>&#127991;</span> Set as display name
        </div>
        <div class="view-context-menu-separator"></div>
        <div class="view-context-menu-item" onclick="hideColumnFromContextMenu()">
            <span>&#128065;</span> Hide column
        </div>
    </div>

    <!-- Field History Modal -->
    <div class="modal-overlay" id="history-modal-overlay" onclick="closeHistoryModal(event)">
        <div class="modal history-modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 id="history-modal-title">Field History</h2>
                <button class="history-view-record-btn" id="history-view-record-btn" onclick="if(currentHistoryTableId&&currentHistoryRecordId){closeHistoryModal();goToRecordInTable(currentHistoryTableId,currentHistoryRecordId)}" title="View this record">
                    <svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                    View Record
                </button>
                <button class="modal-close" onclick="closeHistoryModal()">&times;</button>
            </div>
            <div class="modal-toolbar">
                <label>Filter by field:</label>
                <select id="history-field-filter" onchange="filterHistoryByField()">
                    <option value="">All Fields</option>
                </select>
                <span class="history-count" id="history-count"></span>
            </div>
            <div class="historical-notice">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M8 4.5V8L10.5 9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="historical-notice-text"><strong>Historical data:</strong> Values shown are what was recorded at the time of each change, not the current state of the record.</span>
            </div>
            <div class="modal-body" id="history-modal-body">
                <!-- History items will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Create View Modal -->
    <div class="create-view-modal" id="create-view-modal" onclick="closeCreateViewModal(event)">
        <div class="create-view-modal-content" onclick="event.stopPropagation()">
            <div class="create-view-modal-header">
                <h2>Create New View</h2>
                <p id="create-view-reason">Customize this view with your own filters and field settings.</p>
            </div>
            <div class="create-view-modal-body">
                <div class="create-view-field">
                    <label for="create-view-name">View Name</label>
                    <input type="text" id="create-view-name" placeholder="Enter view name...">
                </div>
                <div class="create-view-field">
                    <label for="create-view-type">View Type</label>
                    <select id="create-view-type">
                        <option value="grid">Grid View</option>
                        <option value="schema">Schema View (Cards)</option>
                        <option value="form">Form View</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-parent">Parent View (for nesting)</label>
                    <select id="create-view-parent">
                        <option value="">(No parent - root level)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-tags">Tags (comma-separated)</label>
                    <input type="text" id="create-view-tags" placeholder="e.g., reports, daily, team-a">
                </div>
                <div class="create-view-field">
                    <label for="create-view-workspace">Add to Workspace</label>
                    <select id="create-view-workspace">
                        <option value="">(None)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-sharing">Visibility</label>
                    <select id="create-view-sharing" onchange="onCreateViewSharingChange()">
                        <option value="everyone">Shared with everyone</option>
                        <option value="specific">Shared with specific people</option>
                        <option value="private">Private (only you)</option>
                    </select>
                </div>
                <div class="create-view-field" id="create-view-users-section" style="display: none;">
                    <label>Share with</label>
                    <div class="share-users-list" id="create-view-users-list">
                        <div class="share-users-loading">Loading org members...</div>
                    </div>
                </div>
            </div>
            <div class="create-view-modal-footer">
                <button class="btn-cancel" onclick="closeCreateViewModal()">Cancel</button>
                <button class="btn-create" id="create-view-submit" onclick="submitCreateView()">Create View</button>
            </div>
        </div>
    </div>

    <!-- Share View Modal -->
    <div class="create-view-modal" id="share-view-modal" onclick="closeShareViewModal(event)">
        <div class="create-view-modal-content" onclick="event.stopPropagation()">
            <div class="create-view-modal-header">
                <h2>Share View</h2>
                <p id="share-view-name">Configure who can see this view</p>
            </div>
            <div class="create-view-modal-body">
                <div class="share-view-owner" id="share-view-owner"></div>
                <div class="create-view-field">
                    <label>Sharing</label>
                    <div class="share-options">
                        <label class="share-option">
                            <input type="radio" name="share-level" value="private" checked onchange="onShareLevelChange()">
                            <span class="share-option-icon">&#128274;</span>
                            <div class="share-option-text">
                                <strong>Private</strong>
                                <span>Only you can see this view</span>
                            </div>
                        </label>
                        <label class="share-option">
                            <input type="radio" name="share-level" value="specific" onchange="onShareLevelChange()">
                            <span class="share-option-icon">&#128101;</span>
                            <div class="share-option-text">
                                <strong>Specific people</strong>
                                <span>Share with selected team members</span>
                            </div>
                        </label>
                        <label class="share-option">
                            <input type="radio" name="share-level" value="everyone" onchange="onShareLevelChange()">
                            <span class="share-option-icon">&#127760;</span>
                            <div class="share-option-text">
                                <strong>Everyone</strong>
                                <span>All org members can see this view</span>
                            </div>
                        </label>
                    </div>
                </div>
                <div class="create-view-field" id="share-users-section" style="display: none;">
                    <label>Share with</label>
                    <div class="share-users-list" id="share-users-list">
                        <div class="share-users-loading">Loading org members...</div>
                    </div>
                </div>
            </div>
            <div class="create-view-modal-footer">
                <button class="btn-cancel" onclick="closeShareViewModal()">Cancel</button>
                <button class="btn-create" id="share-view-submit" onclick="submitShareView()">Save Sharing</button>
            </div>
        </div>
    </div>

    <!-- Case Note Creation Modal -->
    <div class="case-note-modal" id="case-note-modal" onclick="CaseNotesAPI.closeModal(event)">
        <div class="case-note-modal-content" onclick="event.stopPropagation()">
            <div class="case-note-modal-header">
                <h2>New Case Note</h2>
                <button class="modal-close" onclick="CaseNotesAPI.closeModal()">&times;</button>
            </div>
            <div class="case-note-modal-body">
                <div class="case-note-field">
                    <label for="cn-client">Client</label>
                    <select id="cn-client">
                        <option value="">Select a client...</option>
                    </select>
                    <div class="field-hint">Links this note to the client via their Airtable record ID</div>
                </div>
                <div class="case-note-field">
                    <label for="cn-activity">Activity</label>
                    <input type="text" id="cn-activity" placeholder="e.g., Phone Call, Meeting, Filing...">
                </div>
                <div class="case-note-row">
                    <div class="case-note-field">
                        <label for="cn-type">Type</label>
                        <select id="cn-type">
                            <option value="">Select type...</option>
                            <option value="Note">Note</option>
                            <option value="Phone Call">Phone Call</option>
                            <option value="Email">Email</option>
                            <option value="Meeting">Meeting</option>
                            <option value="Filing">Filing</option>
                            <option value="Court Appearance">Court Appearance</option>
                            <option value="Document Review">Document Review</option>
                            <option value="Research">Research</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="case-note-field">
                        <label for="cn-date">Date</label>
                        <input type="datetime-local" id="cn-date">
                    </div>
                </div>
                <div class="case-note-field">
                    <label for="cn-matter">Matter</label>
                    <input type="text" id="cn-matter" placeholder="Matter ID or reference...">
                </div>
                <div class="case-note-field">
                    <label for="cn-contact">Contact</label>
                    <input type="text" id="cn-contact" placeholder="Contact person...">
                </div>
                <div class="case-note-field">
                    <label for="cn-description">Description</label>
                    <textarea id="cn-description" placeholder="Describe the case note details..."></textarea>
                </div>
                <div class="case-note-row">
                    <div class="case-note-field">
                        <label for="cn-due-date">Due Date</label>
                        <input type="datetime-local" id="cn-due-date">
                    </div>
                    <div class="case-note-field">
                        <label for="cn-source">Source</label>
                        <input type="text" id="cn-source" placeholder="e.g., Portal, Phone, Email">
                    </div>
                </div>
                <div class="case-note-field">
                    <label for="cn-tags">Tags (comma-separated)</label>
                    <input type="text" id="cn-tags" placeholder="e.g., urgent, follow-up, immigration">
                </div>
            </div>
            <div class="case-note-modal-footer">
                <span class="case-note-status" id="cn-status"></span>
                <div class="case-note-actions">
                    <button class="btn-cancel" onclick="CaseNotesAPI.closeModal()">Cancel</button>
                    <button class="btn-save" id="cn-submit" onclick="CaseNotesAPI.submitNote()">Create Note</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Point in Time Modal -->
    <div class="modal-overlay" id="pit-modal-overlay" onclick="closePitModal(event)">
        <div class="modal pit-modal" onclick="event.stopPropagation()">
            <div class="modal-header pit-modal-header">
                <div class="pit-info">
                    <h2 id="pit-modal-title">Record at Point in Time</h2>
                    <span class="pit-timestamp" id="pit-modal-timestamp"></span>
                </div>
                <span class="pit-event-badge" id="pit-modal-event-badge"></span>
                <button class="modal-close" onclick="closePitModal()">&times;</button>
            </div>
            <div class="historical-notice">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M8 4.5V8L10.5 9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="historical-notice-text"><strong>Snapshot:</strong> This shows the record as it existed at this point in time, not its current state. Click "View Current Record" to see the latest data.</span>
            </div>
            <div class="modal-body" id="pit-modal-body">
                <!-- Record state will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Record Profile Slide-out Panel -->
    <div class="record-profile-overlay" id="record-profile-overlay" onclick="closeRecordProfile(event)">
        <div class="record-profile-panel" onclick="event.stopPropagation()">
            <div class="profile-header">
                <h2 id="profile-title">Record</h2>
                <span class="profile-view-name" id="profile-view-name"></span>
                <span class="profile-record-id" id="profile-record-id"></span>
                <button class="profile-close" onclick="closeRecordProfile()">&times;</button>
            </div>
            <div class="profile-tabs">
                <div class="profile-tab active" data-tab="details" onclick="switchProfileTab('details')">Case Details</div>
                <div class="profile-tab" data-tab="sync-history" onclick="switchProfileTab('sync-history')">Sync History</div>
                <div class="profile-tab" data-tab="record-history" onclick="switchProfileTab('record-history')">Record History</div>
            </div>
            <div class="profile-tab-content active" id="profile-tab-details">
                <div class="profile-toolbar" id="profile-toolbar">
                    <button class="profile-configure-btn" id="profile-configure-btn" onclick="toggleProfileConfigureMode()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                        Configure
                    </button>
                    <div class="profile-toolbar-spacer"></div>
                    <button class="profile-add-block-btn" id="profile-add-block-btn" onclick="addProfileBlock()" style="display: none;">+ Add Block</button>
                </div>
                <div class="profile-body" id="profile-body">
                    <!-- Profile content will be rendered here -->
                </div>
            </div>
            <div class="profile-tab-content" id="profile-tab-sync-history">
                <!-- Sync history content will be rendered here -->
            </div>
            <div class="profile-tab-content" id="profile-tab-record-history">
                <!-- Record history (raw event stream) content will be rendered here -->
            </div>
            <div class="profile-nav">
                <button class="profile-nav-btn" id="profile-prev-btn" onclick="navigateProfile(-1)">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15,18 9,12 15,6"/></svg>
                    Prev
                </button>
                <span class="profile-nav-info" id="profile-nav-info">1 of 100</span>
                <button class="profile-nav-btn" id="profile-next-btn" onclick="navigateProfile(1)">
                    Next
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9,18 15,12 9,6"/></svg>
                </button>
            </div>
        </div>
    </div>

    </div><!-- /database-app -->

    <!-- Interface Sub-App -->
    <div id="interface-app">
        <!-- Branded main navigation (matches Softr sample) -->
        <div class="iface-mainnav">
            <div class="iface-mainnav-left">
                <a class="iface-nav-logo" onclick="switchApp('home')">
                    <div class="iface-logo-mark">A</div>
                    <div class="iface-logo-text">
                        <span class="iface-logo-firm">Amino</span>
                        <span class="iface-logo-sub">Case Management</span>
                    </div>
                </a>
                <div class="iface-nav-divider"></div>
                <div class="iface-page-tabs" id="iface-page-tabs">
                    <!-- Rendered dynamically from schema -->
                </div>
            </div>
            <div class="iface-mainnav-right">
                <input type="text" class="iface-global-search" id="iface-global-search" placeholder="Search clients, events..." oninput="InterfaceApp.onGlobalSearch(this.value)">
                <button class="iface-quick-action secondary" onclick="InterfaceApp.navigatePage('events')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                    New Event
                </button>
                <button class="iface-quick-action primary" onclick="InterfaceApp.navigatePage('case-notes')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
                    New Note
                </button>
                <span class="iface-synced-badge" id="iface-sync-badge">Synced</span>
                <div class="iface-topbar-avatar" id="iface-avatar" onclick="switchApp('settings')">RL</div>
                <button class="iface-edit-toggle" id="iface-edit-toggle" onclick="InterfaceApp.toggleEditMode()">Edit Layout</button>
            </div>
        </div>
        <!-- Page content -->
        <div class="iface-page-container" id="iface-page-container">
            <!-- Rendered dynamically from schema + data -->
        </div>
    </div>

    <div class="command-palette-overlay hidden" id="command-palette-overlay" onclick="closeCommandPalette(event)">
        <div class="command-palette-panel" onclick="event.stopPropagation()">
            <input type="text" class="command-palette-input" id="command-palette-input" placeholder="Search clients, matters, tasks..." oninput="renderCommandPaletteResults(this.value)">
            <div class="command-palette-results" id="command-palette-results"></div>
        </div>
    </div>

    <!-- Forms Sub-App -->
    <div id="forms-app">
        <!-- Form List View (default) -->
        <div id="forms-list-view">
            <div class="forms-topbar">
                <div class="forms-topbar-left">
                    <h1>Forms</h1>
                    <p>Create and manage data entry forms across your tables.</p>
                </div>
                <button class="forms-new-btn" onclick="FormsApp.openCreateModal()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                    New Form
                </button>
            </div>
            <div class="forms-toolbar">
                <div class="forms-search-wrap">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                    <input type="text" class="forms-search" id="forms-search-input" placeholder="Search forms..." oninput="FormsApp.onSearch(this.value)">
                </div>
                <select class="forms-filter-select" id="forms-table-filter" onchange="FormsApp.onFilterChange()">
                    <option value="">All Tables</option>
                </select>
                <select class="forms-filter-select" id="forms-status-filter" onchange="FormsApp.onFilterChange()">
                    <option value="">All Status</option>
                    <option value="draft">Draft</option>
                    <option value="published">Published</option>
                </select>
                <select class="forms-filter-select" id="forms-owner-filter" onchange="FormsApp.onFilterChange()">
                    <option value="">All Owners</option>
                    <option value="mine">My Forms</option>
                    <option value="shared">Shared with Me</option>
                </select>
            </div>
            <div class="forms-grid" id="forms-grid">
                <!-- Form cards rendered dynamically -->
            </div>
        </div>

        <!-- Form Builder View (shown when editing a form) -->
        <div class="forms-builder" id="forms-builder-view">
            <div class="forms-builder-topbar">
                <div class="forms-builder-topbar-left">
                    <button class="forms-builder-back" onclick="FormsApp.closeBuilder()" title="Back to forms list">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="15 18 9 12 15 6"/></svg>
                    </button>
                    <span class="forms-builder-title" id="forms-builder-title">Untitled Form</span>
                    <span class="forms-builder-subtitle" id="forms-builder-subtitle"></span>
                </div>
                <div class="forms-builder-topbar-right">
                    <button class="forms-builder-btn" onclick="FormsApp.togglePreview()">Preview</button>
                    <button class="forms-builder-btn" onclick="FormsApp.shareForm()">Share</button>
                    <button class="forms-builder-btn primary" onclick="FormsApp.publishForm()" id="forms-publish-btn">Publish</button>
                </div>
            </div>
            <div class="forms-builder-layout">
                <div class="forms-builder-sidebar" id="forms-builder-sidebar">
                    <div class="forms-builder-sidebar-title">Available Fields</div>
                    <div id="forms-builder-field-list">
                        <!-- Field items rendered dynamically -->
                    </div>
                </div>
                <div class="forms-builder-canvas" id="forms-builder-canvas">
                    <div class="forms-builder-preview" id="forms-builder-preview">
                        <!-- Live form preview rendered dynamically -->
                    </div>
                </div>
                <div class="forms-builder-config" id="forms-builder-config">
                    <div class="forms-builder-config-title">Field Settings</div>
                    <div id="forms-builder-config-body">
                        <p style="font-size:13px;color:var(--text-muted);">Select a field to configure it.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Form Modal -->
    <div class="forms-create-modal" id="forms-create-modal" onclick="FormsApp.closeCreateModal(event)">
        <div class="forms-create-modal-content" onclick="event.stopPropagation()">
            <div class="forms-create-modal-header">
                <h2>Create New Form</h2>
                <p>Choose a table and configure your new form.</p>
            </div>
            <div class="forms-create-modal-body">
                <div class="forms-create-field">
                    <label for="forms-create-name">Form Name</label>
                    <input type="text" id="forms-create-name" placeholder="e.g., Client Intake Form">
                </div>
                <div class="forms-create-field">
                    <label for="forms-create-table">Source Table</label>
                    <select id="forms-create-table" onchange="FormsApp.onCreateTableChange()">
                        <option value="">Select a table...</option>
                    </select>
                </div>
                <div class="forms-create-field">
                    <label for="forms-create-desc">Description (optional)</label>
                    <textarea id="forms-create-desc" placeholder="Describe what this form is for..."></textarea>
                </div>
                <div class="forms-create-field">
                    <label for="forms-create-sharing">Visibility</label>
                    <select id="forms-create-sharing">
                        <option value="everyone">Shared with everyone</option>
                        <option value="private">Private (only you)</option>
                    </select>
                </div>
            </div>
            <div class="forms-create-modal-footer">
                <button class="btn-cancel" onclick="FormsApp.closeCreateModal()">Cancel</button>
                <button class="btn-create" id="forms-create-submit" onclick="FormsApp.submitCreate()">Create Form</button>
            </div>
        </div>
    </div>

    <!-- Settings Sub-App -->
    <div id="settings-app">
        <div class="settings-header">
            <h1>Settings</h1>
            <p>Manage users, roles, room access, and your personal preferences.</p>
        </div>

        <div id="settings-toast" class="settings-toast"></div>

        <div class="settings-tabs">
            <button class="settings-tab active" id="settings-tab-roles" onclick="switchSettingsTab('roles')">Users &amp; Roles</button>
            <button class="settings-tab" id="settings-tab-rooms" onclick="switchSettingsTab('rooms')">Room Access</button>
            <button class="settings-tab" id="settings-tab-relationships" onclick="switchSettingsTab('relationships')">Table Relationships</button>
            <button class="settings-tab" id="settings-tab-preferences" onclick="switchSettingsTab('preferences')">Preferences</button>
        </div>

        <!-- Users & Roles Tab -->
        <div id="settings-panel-roles">
            <div class="settings-section">
                <h2>Organization Members</h2>
                <p class="settings-section-desc">Assign roles to control what each user can do. Admins can manage schema and members. Staff can create and edit records. Clients have read-only access.</p>
                <div id="settings-users-loading" class="settings-loading">
                    <div class="settings-spinner"></div>
                    Loading members...
                </div>
                <div id="settings-users-content" style="display: none;">
                    <table class="settings-table">
                        <thead>
                            <tr>
                                <th>User</th>
                                <th>Display Name</th>
                                <th>Current Role</th>
                                <th>Change Role</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="settings-users-tbody">
                        </tbody>
                    </table>
                </div>
                <div id="settings-users-empty" style="display: none; padding: 16px 0; color: var(--text-muted); font-size: 13px;">
                    No members found. Ensure you are connected to an organization space.
                </div>

                <h2 style="margin-top: 22px;">Permissions Matrix</h2>
                <p class="settings-section-desc">Toggle checkboxes to grant or revoke room access for each user. Use the buttons to bulk-remove access.</p>
                <div id="settings-permissions-matrix-loading" class="settings-loading" style="display: none;">
                    <div class="settings-spinner"></div>
                    Loading permissions matrix...
                </div>
                <div id="settings-permissions-matrix-content" style="display: none; overflow-x: auto;">
                    <table class="settings-room-access">
                        <thead id="settings-permissions-matrix-head"></thead>
                        <tbody id="settings-permissions-matrix-body"></tbody>
                    </table>
                </div>

                <div id="settings-invite-section" class="settings-invite-form" style="display: none;">
                    <h3>Invite New User</h3>
                    <p>Create a new account and add them to the organization. They will receive access to the org space.</p>
                    <div class="settings-invite-row">
                        <div class="settings-invite-field">
                            <label for="invite-username">Username</label>
                            <input type="text" id="invite-username" placeholder="e.g. jsmith" autocomplete="off">
                        </div>
                        <div class="settings-invite-field">
                            <label for="invite-display-name">Display Name</label>
                            <input type="text" id="invite-display-name" placeholder="e.g. John Smith" autocomplete="off">
                        </div>
                        <div class="settings-invite-field">
                            <label for="invite-email">Email</label>
                            <input type="email" id="invite-email" placeholder="e.g. jsmith@example.com" autocomplete="off">
                        </div>
                    </div>
                    <div class="settings-invite-row">
                        <div class="settings-invite-field" style="max-width: 180px;">
                            <label for="invite-role">Role</label>
                            <select id="invite-role">
                                <option value="staff">Staff (50)</option>
                                <option value="client">Client (10)</option>
                                <option value="admin">Admin (100)</option>
                            </select>
                        </div>
                        <button class="settings-invite-btn" id="invite-submit-btn" onclick="inviteNewUser()">Invite User</button>
                    </div>
                    <div id="invite-status" style="font-size: 13px; margin-top: 8px;"></div>
                </div>
            </div>
        </div>

        <!-- Room Access Tab -->
        <div id="settings-panel-rooms" style="display: none;">
            <div class="settings-section">
                <h2>Room Access Management</h2>
                <p class="settings-section-desc">Control which users have access to which data rooms. Check a box to grant a user access (join them to the room), uncheck to revoke (kick from room).</p>

                <div style="display: flex; gap: 16px; align-items: end; flex-wrap: wrap; margin-bottom: 16px;">
                    <div>
                        <label style="font-size: 13px; color: var(--text-secondary); display: block; margin-bottom: 6px;">Select user:</label>
                        <select id="settings-room-user-select" class="settings-role-select" style="min-width: 260px;" onchange="loadRoomAccessForUser()">
                            <option value="">-- Choose a user --</option>
                        </select>
                    </div>
                    <div>
                        <label style="font-size: 13px; color: var(--text-secondary); display: block; margin-bottom: 6px;">Permission group:</label>
                        <select id="settings-room-group-select" class="settings-role-select" style="min-width: 220px;">
                            <option value="">-- No group --</option>
                        </select>
                    </div>
                    <button class="settings-action-btn" onclick="assignSelectedUserToPermissionGroup()">Assign Group</button>
                    <button class="settings-action-btn primary" onclick="applySelectedGroupPermissions()">Apply Group Rooms</button>
                    <button class="settings-action-btn" onclick="createPermissionGroupFromSelectedUser()">Create Group From User</button>
                    <button class="settings-action-btn danger" onclick="revokeAllRoomsForSelectedUser()">Revoke All Rooms</button>
                </div>

                <div id="settings-rooms-loading" class="settings-loading" style="display: none;">
                    <div class="settings-spinner"></div>
                    Loading room access...
                </div>
                <div id="settings-rooms-content" style="display: none;">
                    <table class="settings-room-access">
                        <thead>
                            <tr>
                                <th>Room</th>
                                <th style="text-align: center; width: 80px;">Access</th>
                                <th style="width: 100px;">Status</th>
                            </tr>
                        </thead>
                        <tbody id="settings-rooms-tbody">
                        </tbody>
                    </table>
                </div>
                <div id="settings-rooms-empty" style="display: none; padding: 16px 0; color: var(--text-muted); font-size: 13px;">
                    Select a user to manage their room access.
                </div>
            </div>
        </div>

        <!-- Table Relationships Tab -->
        <div id="settings-panel-relationships" style="display: none;">
            <div class="settings-section">
                <h2>Table Relationship Graph</h2>
                <p class="settings-section-desc">Visual map of how your tables are connected through linked record fields. Relationships are auto-detected from Airtable field metadata.</p>
                <div id="rel-graph-stats" class="settings-rel-stats"></div>
                <div class="settings-rel-graph-container">
                    <canvas id="rel-graph-canvas"></canvas>
                    <div id="rel-graph-empty" class="settings-rel-graph-empty" style="display: none;">No table relationships detected. Link tables using linked record fields in Airtable.</div>
                </div>
                <div id="rel-graph-legend" class="settings-rel-legend"></div>
            </div>

            <div class="settings-section">
                <h2>Relationship Configuration</h2>
                <p class="settings-section-desc">Configure how each relationship behaves in the interface. Mark primary relationships to control default navigation paths. Labels and cardinality settings are used by interface blocks for display and filtering.</p>
                <div id="rel-table-loading" class="settings-loading" style="display: none;">
                    <div class="settings-spinner"></div>
                    Loading relationships...
                </div>
                <div id="rel-table-content" style="display: none;">
                    <table class="settings-rel-table">
                        <thead>
                            <tr>
                                <th style="width: 36px;" title="Primary relationship for navigation">Nav</th>
                                <th>From Table</th>
                                <th></th>
                                <th>To Table</th>
                                <th>Link Field</th>
                                <th>Cardinality</th>
                                <th>Label</th>
                                <th style="width: 56px;"></th>
                            </tr>
                        </thead>
                        <tbody id="rel-table-tbody">
                        </tbody>
                    </table>
                </div>
                <div id="rel-table-empty" style="display: none; padding: 16px 0; color: var(--text-muted); font-size: 13px;">
                    No relationships found. Create linked record fields in Airtable to define table relationships.
                </div>
            </div>
        </div>

        <!-- Preferences Tab -->
        <div id="settings-panel-preferences" style="display: none;">
            <div class="settings-section">
                <h2>Profile</h2>
                <p class="settings-section-desc">Update your display name and email. These are synced to your Matrix account.</p>
                <div id="profile-loading" style="color: var(--text-muted); font-size: 13px; padding: 8px 0;">Loading profile...</div>
                <div id="profile-form" style="display: none;">
                    <div class="settings-profile-row">
                        <div class="settings-profile-field">
                            <label for="profile-display-name">Display Name</label>
                            <input type="text" id="profile-display-name" placeholder="e.g. John Smith" autocomplete="off">
                        </div>
                        <div class="settings-profile-field">
                            <label for="profile-email">Email</label>
                            <input type="email" id="profile-email" placeholder="e.g. john@example.com" autocomplete="off">
                        </div>
                    </div>
                    <div class="settings-profile-row" style="margin-top: 4px;">
                        <div class="settings-profile-field" style="flex: none;">
                            <label style="visibility: hidden;">.</label>
                            <button class="settings-profile-save-btn" id="profile-save-btn" onclick="saveUserProfile()">Save Profile</button>
                        </div>
                        <div id="profile-status" style="font-size: 13px; align-self: flex-end; padding-bottom: 8px;"></div>
                    </div>
                    <div style="margin-top: 12px; font-size: 12px; color: var(--text-muted);">
                        <span style="font-family: var(--font-mono); font-size: 11px;" id="profile-user-id"></span>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h2>Notifications</h2>
                <p class="settings-section-desc">Control which notifications you receive. These preferences are synced to your account.</p>
                <div class="settings-pref-row">
                    <label class="settings-toggle-label" for="pref-offline-sync-toasts">
                        <span class="settings-toggle-text">
                            <strong>Offline sync toasts</strong>
                            <span class="settings-toggle-desc">Show a toast notification when queued offline edits finish syncing</span>
                        </span>
                        <input type="checkbox" id="pref-offline-sync-toasts" class="settings-toggle-checkbox" onchange="toggleOfflineSyncToasts(this.checked)">
                        <span class="settings-toggle-switch"></span>
                    </label>
                </div>
                <div class="settings-pref-row">
                    <label class="settings-toggle-label" for="pref-confirm-inline-cell-edit">
                        <span class="settings-toggle-text">
                            <strong>Confirm inline cell edit</strong>
                            <span class="settings-toggle-desc">Ask for confirmation before opening inline editing so values are not accidentally cleared</span>
                        </span>
                        <input type="checkbox" id="pref-confirm-inline-cell-edit" class="settings-toggle-checkbox" onchange="toggleConfirmInlineCellEdit(this.checked)">
                        <span class="settings-toggle-switch"></span>
                    </label>
                </div>
            </div>

            <div class="settings-section">
                <h2>Local Data</h2>
                <p class="settings-section-desc">Manage the local database stored on this device. Your data is encrypted at rest and synced from the server.</p>
                <div class="settings-pref-row">
                    <label class="settings-toggle-label" for="pref-online-only-mode">
                        <span class="settings-toggle-text">
                            <strong>Online-only mode</strong>
                            <span class="settings-toggle-desc">Fetch all data from the server each session. No records are stored locally in IndexedDB. Useful on shared or public devices.</span>
                        </span>
                        <input type="checkbox" id="pref-online-only-mode" class="settings-toggle-checkbox" onchange="toggleOnlineOnlyMode(this.checked)">
                        <span class="settings-toggle-switch"></span>
                    </label>
                </div>
                <div id="online-only-active-banner" style="display: none; margin-bottom: 12px; padding: 8px 12px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 6px; font-size: 12px; color: var(--text-secondary);">
                    Online-only mode is active. Records are held in memory only and will not persist after this session ends.
                </div>
                <div style="margin-bottom: 12px;">
                    <label style="font-size: 12px; font-weight: 600; color: var(--text-secondary); display: block; margin-bottom: 6px;">Hydration Source</label>
                    <select id="settings-hydration-source" style="font-size: 13px; padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border-color, #d1d5db); background: var(--surface-color, #fff); color: var(--text-primary); min-width: 200px;" onchange="onHydrationSourceChanged(this.value)">
                        <option value="postgres">Postgres API (default)</option>
                        <option value="csv">CSV File</option>
                        <option value="box">Box Download</option>
                        <option value="url">URL</option>
                        <option value="none">No Local Data</option>
                    </select>
                    <p style="font-size: 11px; color: var(--text-muted); margin-top: 4px;" id="settings-hydration-source-desc">
                        Fetch current state table-by-table from the Postgres-backed webhook API.
                    </p>
                </div>
                <div id="settings-hydration-url-row" style="display: none; margin-bottom: 12px;">
                    <label style="font-size: 12px; font-weight: 600; color: var(--text-secondary); display: block; margin-bottom: 4px;">Data URL</label>
                    <input type="url" id="settings-hydration-url" placeholder="https://example.com/data.json" style="font-size: 13px; padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border-color, #d1d5db); background: var(--surface-color, #fff); color: var(--text-primary); width: 100%; box-sizing: border-box;" onchange="AminoHydration.setHydrationURL(this.value)">
                </div>
                <div id="settings-hydration-csv-row" style="display: none; margin-bottom: 12px;">
                    <label style="font-size: 12px; font-weight: 600; color: var(--text-secondary); display: block; margin-bottom: 4px;">CSV File</label>
                    <input type="file" id="settings-hydration-csv" accept=".csv,text/csv" style="font-size: 12px;" onchange="AminoHydration.setPendingCSVFile(this.files[0] || null)">
                    <p style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                        Schema: id, created_at, recordId, operator, payload (JSON), uuid, set
                    </p>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                    <button class="settings-action-btn" id="refresh-db-btn" onclick="refreshLocalDB()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: -2px; margin-right: 4px;">
                            <polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                        </svg>
                        Refresh Database
                    </button>
                    <span id="refresh-db-status" style="font-size: 12px; color: var(--text-muted);"></span>
                </div>
                <details style="margin-top: 8px;">
                    <summary style="font-size: 12px; color: var(--text-muted); cursor: pointer;">Alternative data sources (manual)</summary>
                    <div style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
                        <button class="settings-action-btn" style="font-size: 12px; padding: 4px 10px;" onclick="refreshLocalDB('postgres')">Postgres API</button>
                        <button class="settings-action-btn" style="font-size: 12px; padding: 4px 10px;" onclick="refreshLocalDB('box')">Box Download</button>
                        <button class="settings-action-btn" style="font-size: 12px; padding: 4px 10px;" onclick="refreshLocalDB('synapse')">Synapse Replay</button>
                    </div>
                </details>
            </div>
        </div>
    </div>

    </div><!-- /app-content-wrapper -->

    <!-- Hydration Source Picker Modal (shown on startup when no hydration has completed) -->
    <div id="hydration-picker-modal" style="display:none; position:fixed; inset:0; z-index:10000; background:rgba(0,0,0,0.5); backdrop-filter:blur(4px); align-items:center; justify-content:center;">
        <div style="background:var(--surface-color, #fff); border-radius:12px; padding:28px 32px; max-width:480px; width:90%; box-shadow:0 20px 60px rgba(0,0,0,0.3); color:var(--text-primary);">
            <h2 style="margin:0 0 4px 0; font-size:18px; font-weight:700;">Data Source</h2>
            <p style="margin:0 0 20px 0; font-size:13px; color:var(--text-muted);">Choose how to load your data. This can be changed later in Settings.</p>

            <div id="hydration-picker-options" style="display:flex; flex-direction:column; gap:8px;">
                <label style="display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid var(--border-color, #d1d5db); border-radius:8px; cursor:pointer; transition:border-color 0.15s;" onmouseover="this.style.borderColor='var(--primary-500, #3b82f6)'" onmouseout="this.style.borderColor='var(--border-color, #d1d5db)'">
                    <input type="radio" name="hydration-source-pick" value="postgres" checked style="margin-top:3px;">
                    <div>
                        <strong style="font-size:13px;">Postgres API</strong>
                        <span style="display:block; font-size:11px; color:var(--text-muted); margin-top:2px;">Fetch current state from the Postgres database via webhook API. Default and recommended.</span>
                    </div>
                </label>
                <label style="display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid var(--border-color, #d1d5db); border-radius:8px; cursor:pointer; transition:border-color 0.15s;" onmouseover="this.style.borderColor='var(--primary-500, #3b82f6)'" onmouseout="this.style.borderColor='var(--border-color, #d1d5db)'">
                    <input type="radio" name="hydration-source-pick" value="csv" style="margin-top:3px;">
                    <div>
                        <strong style="font-size:13px;">CSV File</strong>
                        <span style="display:block; font-size:11px; color:var(--text-muted); margin-top:2px;">Load data from a local .csv file. Schema: id, created_at, recordId, operator, payload, uuid, set</span>
                    </div>
                </label>
                <label style="display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid var(--border-color, #d1d5db); border-radius:8px; cursor:pointer; transition:border-color 0.15s;" onmouseover="this.style.borderColor='var(--primary-500, #3b82f6)'" onmouseout="this.style.borderColor='var(--border-color, #d1d5db)'">
                    <input type="radio" name="hydration-source-pick" value="box" style="margin-top:3px;">
                    <div>
                        <strong style="font-size:13px;">Box Download</strong>
                        <span style="display:block; font-size:11px; color:var(--text-muted); margin-top:2px;">Download a bulk snapshot from the Box webhook. Fast for initial load.</span>
                    </div>
                </label>
                <label style="display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid var(--border-color, #d1d5db); border-radius:8px; cursor:pointer; transition:border-color 0.15s;" onmouseover="this.style.borderColor='var(--primary-500, #3b82f6)'" onmouseout="this.style.borderColor='var(--border-color, #d1d5db)'">
                    <input type="radio" name="hydration-source-pick" value="url" style="margin-top:3px;">
                    <div>
                        <strong style="font-size:13px;">URL</strong>
                        <span style="display:block; font-size:11px; color:var(--text-muted); margin-top:2px;">Fetch data from a URL (JSON or CSV). Enter the URL below after selecting.</span>
                    </div>
                </label>
                <label style="display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border:1px solid var(--border-color, #d1d5db); border-radius:8px; cursor:pointer; transition:border-color 0.15s;" onmouseover="this.style.borderColor='var(--primary-500, #3b82f6)'" onmouseout="this.style.borderColor='var(--border-color, #d1d5db)'">
                    <input type="radio" name="hydration-source-pick" value="none" style="margin-top:3px;">
                    <div>
                        <strong style="font-size:13px;">No Local Data</strong>
                        <span style="display:block; font-size:11px; color:var(--text-muted); margin-top:2px;">Postgres for current state, room data for historical. Nothing persisted locally.</span>
                    </div>
                </label>
            </div>

            <div id="hydration-picker-csv-row" style="display:none; margin-top:12px;">
                <label style="font-size:12px; font-weight:600; color:var(--text-secondary); display:block; margin-bottom:4px;">Select CSV File</label>
                <input type="file" id="hydration-picker-csv" accept=".csv,text/csv" style="font-size:12px;">
            </div>
            <div id="hydration-picker-url-row" style="display:none; margin-top:12px;">
                <label style="font-size:12px; font-weight:600; color:var(--text-secondary); display:block; margin-bottom:4px;">Data URL</label>
                <input type="url" id="hydration-picker-url" placeholder="https://example.com/data.json" style="font-size:13px; padding:6px 10px; border-radius:6px; border:1px solid var(--border-color, #d1d5db); background:var(--surface-color, #fff); color:var(--text-primary); width:100%; box-sizing:border-box;">
            </div>

            <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
                <button onclick="confirmHydrationPicker()" style="padding:8px 20px; border-radius:8px; border:none; background:var(--primary-500, #3b82f6); color:#fff; font-size:13px; font-weight:600; cursor:pointer;">Continue</button>
            </div>
        </div>
    </div>

    <!-- Room Assignment Modal (shown after inviting a user) -->
    <div class="room-assign-modal" id="room-assign-modal" onclick="closeRoomAssignModal(event)">
        <div class="room-assign-content" onclick="event.stopPropagation()">
            <div class="room-assign-header">
                <h2>Assign Room Access</h2>
                <p>Select which data rooms this new user should have access to.</p>
                <span class="room-assign-user-badge" id="room-assign-user-badge"></span>
            </div>
            <div class="room-assign-internal-note" id="room-assign-internal-note">
                Internal email detected -- all rooms pre-selected.
            </div>
            <div class="room-assign-toolbar">
                <button onclick="roomAssignSelectAll()">Select All</button>
                <button onclick="roomAssignDeselectAll()">Deselect All</button>
                <span class="room-assign-count" id="room-assign-count"></span>
            </div>
            <div class="room-assign-list" id="room-assign-list">
                <!-- Room checkboxes rendered dynamically -->
            </div>
            <div class="room-assign-status" id="room-assign-status"></div>
            <div class="room-assign-footer">
                <button class="room-assign-skip" onclick="closeRoomAssignModal()">Skip</button>
                <button class="room-assign-confirm" id="room-assign-confirm-btn" onclick="confirmRoomAssignment()">Grant Access</button>
            </div>
        </div>
    </div>

    <!-- Room Publishing Modal -->
    <div class="room-publish-modal hidden" id="room-publish-modal" onclick="closeRoomPublishModal(event)">
        <div class="room-publish-box" onclick="event.stopPropagation()">
            <h2>Publish to Matrix Rooms</h2>
            <p class="pub-subtitle">Select tables to publish as Matrix rooms. Each table becomes a room with its schema and records stored as state events.</p>
            <div id="room-publish-not-connected" style="display: none;">
                <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                    <p style="margin-bottom: 12px;">Not connected to Matrix. Sign in first to publish rooms.</p>
                    <button class="pub-btn-publish" onclick="closeRoomPublishModal(); showSynapseLoginScreen();">Sign in to Matrix</button>
                </div>
            </div>
            <div id="room-publish-content">
                <div class="room-publish-section">
                    <h3>Organization</h3>
                    <div id="pub-org-section">
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="pub-org-name" placeholder="Organization name" style="flex:1; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;">
                            <span id="pub-org-status" style="font-size: 12px; color: var(--text-muted);"></span>
                        </div>
                    </div>
                </div>
                <div class="room-publish-section">
                    <h3>Tables to Publish</h3>
                    <div id="pub-table-list">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                <div class="room-publish-section">
                    <h3>Client Grouping (Optional)</h3>
                    <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">If you want per-client rooms, select the table and field that identifies clients.</p>
                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        <select id="pub-client-table" style="flex:1; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;" onchange="pubClientTableChanged()">
                            <option value="">No client grouping</option>
                        </select>
                        <select id="pub-client-field" style="flex:1; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-primary); border-radius: var(--radius-md); color: var(--text-primary); font-size: 13px;" disabled>
                            <option value="">Select identifier field</option>
                        </select>
                    </div>
                </div>
                <div id="pub-progress-section" style="display: none;">
                    <div class="pub-progress">
                        <div class="pub-progress-bar"><div class="pub-progress-fill" id="pub-progress-fill" style="width: 0%"></div></div>
                        <div class="pub-progress-text" id="pub-progress-text">Preparing...</div>
                    </div>
                </div>
            </div>
            <div class="pub-actions">
                <button class="pub-btn-cancel" onclick="closeRoomPublishModal()">Cancel</button>
                <button class="pub-btn-publish" id="pub-publish-btn" onclick="executeRoomPublish()">Publish Selected</button>
            </div>
        </div>
    </div>

    <!-- Sync Status Feed Panel -->
    <div class="sync-feed-panel" id="sync-feed-panel">
        <div class="sync-feed-header">
            <div class="sync-feed-header-left">
                <span class="sync-feed-status-dot" id="sync-feed-status-dot"></span>
                <span>Sync Activity</span>
            </div>
            <button class="sync-feed-close" onclick="SyncStatusFeed.hide()">&times;</button>
        </div>
        <div class="sync-feed-body" id="sync-feed-body">
            <div class="sync-feed-empty">No sync activity yet</div>
        </div>
        <div class="sync-feed-footer">
            <span id="sync-feed-stats">Idle</span>
            <button onclick="SyncStatusFeed.clear()">Clear</button>
        </div>
    </div>

    <script defer src="https://cdn.jsdelivr.net/npm/@msgpack/msgpack@3.1.2/dist.umd/msgpack.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script defer src="matrix.js"></script>
    <script defer src="hydration.js"></script>
    <script defer src="data-layer.js"></script>

    <script>
// ============ Theme Management ============
(function() {
    var saved = localStorage.getItem('amino_theme');
    // Default to light theme unless user explicitly chose dark
    if (saved !== 'dark') document.documentElement.classList.add('light-theme');
})();

// ============ Mobile Sidebar Toggle ============
function toggleMobileSidebar() {
    var sidebar = document.getElementById('sidebar');
    var overlay = document.getElementById('sidebar-overlay');
    if (sidebar && overlay) {
        var isOpen = sidebar.classList.toggle('mobile-open');
        if (isOpen) {
            overlay.classList.add('visible');
            document.body.style.overflow = 'hidden';
        } else {
            overlay.classList.remove('visible');
            document.body.style.overflow = '';
        }
    }
}
function closeMobileSidebar() {
    var sidebar = document.getElementById('sidebar');
    var overlay = document.getElementById('sidebar-overlay');
    if (sidebar) sidebar.classList.remove('mobile-open');
    if (overlay) overlay.classList.remove('visible');
    document.body.style.overflow = '';
}
// Close sidebar when a table is selected on mobile
(function() {
    var origOpen = window.openTableInTab;
    if (origOpen) return; // Will be patched after openTableInTab is defined
    // Defer the patching to after page load
    window.addEventListener('DOMContentLoaded', function() {
        // Patch sidebar item clicks to auto-close on mobile
        document.addEventListener('click', function(e) {
            if (window.innerWidth > 768) return;
            var item = e.target.closest('.table-item, .table-view-item');
            if (item && document.getElementById('sidebar').contains(item)) {
                setTimeout(closeMobileSidebar, 150);
            }
        });
    });
})();

function toggleTheme() {
    var html = document.documentElement;
    var isLight = html.classList.toggle('light-theme');
    localStorage.setItem('amino_theme', isLight ? 'light' : 'dark');
    // Sync theme to user preferences (Synapse account data)
    UserPreferences.set('theme', isLight ? 'light' : 'dark');
    var icon = document.getElementById('theme-icon');
    var label = document.getElementById('theme-label');
    if (icon) icon.textContent = isLight ? '\u263E' : '\u2606';
    if (label) label.textContent = isLight ? 'Dark Mode' : 'Light Mode';
    var fhIcon = document.getElementById('file-header-theme-icon');
    var fhLabel = document.getElementById('file-header-theme-label');
    if (fhIcon) fhIcon.textContent = isLight ? '\u263E' : '\u2606';
    if (fhLabel) fhLabel.textContent = isLight ? 'Dark Mode' : 'Light Mode';
}

// ============ Tab Bar Management ============
var openTabs = []; // { id, tableId, tableName, viewId, viewName, icon }
var activeTabId = null;

function generateTabId() {
    return 'tab_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
}

function openTableInTab(tableId, tableName, icon) {
    // Check if already open
    var existing = openTabs.find(function(t) { return t.tableId === tableId; });
    if (existing) {
        activeTabId = existing.id;
        // Update name if changed
        if (tableName) existing.tableName = tableName;
        renderTabBar();
        if (_urlStateBootstrapped) persistUrlState();
        return;
    }
    var tab = { id: generateTabId(), tableId: tableId, tableName: tableName || resolveTableName(tableId), icon: icon || '' };
    openTabs.push(tab);
    activeTabId = tab.id;
    renderTabBar();
    if (_urlStateBootstrapped) persistUrlState();
}

var _tabNavInProgress = false;
function activateTab(tabId) {
    var tab = openTabs.find(function(t) { return t.id === tabId; });
    if (!tab) return;
    if (activeTabId === tabId && !_tabNavInProgress) { renderTabBar(); return; }
    activeTabId = tabId;
    renderTabBar();
    if (_urlStateBootstrapped) persistUrlState();
    // Prevent re-entrant calls from showTable -> openTableInTab -> activateTab
    if (_tabNavInProgress) return;
    _tabNavInProgress = true;
    // Navigate to the appropriate view
    if (tab.tableId === '_events' && typeof showEventsView === 'function') {
        showEventsView().finally(function() { _tabNavInProgress = false; });
    } else if (tab.tableId === '_sync_status' && typeof showSyncStatusView === 'function') {
        showSyncStatusView().finally(function() { _tabNavInProgress = false; });
    } else if (typeof showTable === 'function') {
        showTable(tab.tableId).finally(function() { _tabNavInProgress = false; });
    } else {
        _tabNavInProgress = false;
    }
}

function closeTab(tabId, evt) {
    if (evt) { evt.stopPropagation(); evt.preventDefault(); }
    var idx = openTabs.findIndex(function(t) { return t.id === tabId; });
    if (idx === -1) return;
    openTabs.splice(idx, 1);
    if (activeTabId === tabId) {
        if (openTabs.length > 0) {
            var newIdx = Math.min(idx, openTabs.length - 1);
            activateTab(openTabs[newIdx].id);
        } else {
            activeTabId = null;
        }
    }
    renderTabBar();
    if (_urlStateBootstrapped) persistUrlState();
}

function openNewTab() {
    // Focus the sidebar search to let user pick a table
    var searchInput = document.getElementById('sidebar-search-input');
    if (searchInput) { searchInput.focus(); searchInput.select(); }
}

function renderTabBar() {
    var container = document.getElementById('tab-bar-tabs');
    if (!container) return;

    // Build all tab elements into a DocumentFragment (single DOM write, no per-tab reflows)
    var frag = document.createDocumentFragment();
    openTabs.forEach(function(tab) {
        var el = document.createElement('div');
        el.className = 'browser-tab' + (tab.id === activeTabId ? ' active' : '');
        el.onclick = function() { activateTab(tab.id); };

        var iconEl = document.createElement('span');
        iconEl.className = 'tab-icon';
        iconEl.textContent = tab.icon || '\u25A6';
        el.appendChild(iconEl);

        var titleEl = document.createElement('span');
        titleEl.className = 'tab-title';
        titleEl.textContent = resolveTableName(tab.tableId);
        el.appendChild(titleEl);

        if (openTabs.length > 1) {
            var closeEl = document.createElement('button');
            closeEl.className = 'tab-close';
            closeEl.textContent = '\u00D7';
            closeEl.onclick = function(e) { closeTab(tab.id, e); };
            el.appendChild(closeEl);
        }

        frag.appendChild(el);
    });
    container.innerHTML = '';
    container.appendChild(frag);

    // Update theme icon state on render
    var isLight = document.documentElement.classList.contains('light-theme');
    var icon = document.getElementById('theme-icon');
    var label = document.getElementById('theme-label');
    if (icon) icon.textContent = isLight ? '\u263E' : '\u2606';
    if (label) label.textContent = isLight ? 'Dark Mode' : 'Light Mode';
    var fhIcon = document.getElementById('file-header-theme-icon');
    var fhLabel = document.getElementById('file-header-theme-label');
    if (fhIcon) fhIcon.textContent = isLight ? '\u263E' : '\u2606';
    if (fhLabel) fhLabel.textContent = isLight ? 'Dark Mode' : 'Light Mode';
}

var DB_NAME = 'amino';
var DB_VERSION = 10;
var PAGE_SIZE = 100;
var N8N_WEBHOOK_BASE = 'https://n8n.intelechia.com/webhook';

var db = null;

// ============ Online-Only Mode ============
// When enabled, data is kept in memory only  IndexedDB writes are skipped.
function _isOnlineOnlyMode() {
    return localStorage.getItem('amino_online_only_mode') === 'true';
}

// ============ Encryption Configuration ============
var ENCRYPTION_CONFIG_KEY = 'amino_encryption_config';
var ENCRYPTED_CREDENTIALS_KEY = 'amino_encrypted_credentials';
var encryptionKey = null; // CryptoKey object, only kept in memory
var encryptionEnabled = false;
var _deferEncryptionUI = false; // when true, skip per-record encryption; bulk-encrypt on logout
var passkeyCredentialId = null; // For WebAuthn

// ============ Web Crypto API Utilities ============

// Generate a random salt for key derivation
function generateSalt() {
    return crypto.getRandomValues(new Uint8Array(16));
}

// Generate a random IV for AES-GCM encryption
function generateIV() {
    return crypto.getRandomValues(new Uint8Array(12));
}

// Derive an encryption key from a password using PBKDF2
async function deriveKeyFromPassword(password, salt) {
    var encoder = new TextEncoder();
    var passwordKey = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        'PBKDF2',
        false,
        ['deriveBits', 'deriveKey']
    );

    return crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        },
        passwordKey,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
}

// Encrypt data using AES-GCM
async function encryptData(data, key) {
    var encoder = new TextEncoder();
    var iv = generateIV();
    var encodedData = encoder.encode(JSON.stringify(data));

    var encryptedBuffer = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encodedData
    );

    // Combine IV and encrypted data
    var combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encryptedBuffer), iv.length);

    return arrayBufferToBase64(combined);
}

// Decrypt data using AES-GCM
async function decryptData(encryptedBase64, key) {
    var combined = base64ToArrayBuffer(encryptedBase64);
    var iv = combined.slice(0, 12);
    var encryptedData = combined.slice(12);

    var decryptedBuffer = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encryptedData
    );

    var decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decryptedBuffer));
}

// Helper: Convert ArrayBuffer to Base64
function arrayBufferToBase64(buffer) {
    var bytes = new Uint8Array(buffer);
    var binary = '';
    for (var i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

// Helper: Convert Base64 to ArrayBuffer
function base64ToArrayBuffer(base64) {
    var binary = atob(base64);
    var bytes = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

// ============ WebAuthn Passkey Utilities ============

// Check if WebAuthn is supported
function isPasskeySupported() {
    return !!(window.PublicKeyCredential && navigator.credentials);
}

// Create a new passkey for encryption
async function createPasskey() {
    if (!isPasskeySupported()) {
        throw new Error('Passkeys are not supported in this browser');
    }

    // Generate a random challenge
    var challenge = crypto.getRandomValues(new Uint8Array(32));
    var userId = crypto.getRandomValues(new Uint8Array(16));

    var publicKeyOptions = {
        challenge: challenge,
        rp: {
            name: 'Amino Viewer',
            id: window.location.hostname
        },
        user: {
            id: userId,
            name: 'amino-user',
            displayName: 'Amino Viewer User'
        },
        pubKeyCredParams: [
            { alg: -7, type: 'public-key' },   // ES256
            { alg: -257, type: 'public-key' }  // RS256
        ],
        authenticatorSelection: {
            authenticatorAttachment: 'platform',
            userVerification: 'required',
            residentKey: 'required'
        },
        timeout: 60000,
        attestation: 'none',
        extensions: {
            prf: {
                eval: {
                    first: new TextEncoder().encode('amino-encryption-key')
                }
            }
        }
    };

    var credential = await navigator.credentials.create({ publicKey: publicKeyOptions });

    // Check if PRF extension is supported
    var prfSupported = credential.getClientExtensionResults().prf !== undefined;

    return {
        credentialId: arrayBufferToBase64(credential.rawId),
        userId: arrayBufferToBase64(userId),
        prfSupported: prfSupported
    };
}

// Authenticate with an existing passkey
async function authenticateWithPasskey(credentialId) {
    if (!isPasskeySupported()) {
        throw new Error('Passkeys are not supported in this browser');
    }

    var challenge = crypto.getRandomValues(new Uint8Array(32));

    var publicKeyOptions = {
        challenge: challenge,
        allowCredentials: [{
            id: base64ToArrayBuffer(credentialId),
            type: 'public-key'
        }],
        userVerification: 'required',
        timeout: 60000,
        extensions: {
            prf: {
                eval: {
                    first: new TextEncoder().encode('amino-encryption-key')
                }
            }
        }
    };

    var assertion = await navigator.credentials.get({ publicKey: publicKeyOptions });

    // Check if PRF was used
    var prfResult = assertion.getClientExtensionResults().prf;

    return {
        credentialId: arrayBufferToBase64(assertion.rawId),
        prfOutput: prfResult ? arrayBufferToBase64(prfResult.results.first) : null,
        authenticatorData: arrayBufferToBase64(assertion.response.authenticatorData)
    };
}

// Derive encryption key from passkey authentication
async function deriveKeyFromPasskey(prfOutput, salt) {
    if (prfOutput) {
        // PRF is supported - use PRF output directly
        var prfBytes = base64ToArrayBuffer(prfOutput);
        var keyMaterial = await crypto.subtle.importKey(
            'raw',
            prfBytes,
            'HKDF',
            false,
            ['deriveBits', 'deriveKey']
        );

        return crypto.subtle.deriveKey(
            {
                name: 'HKDF',
                salt: salt,
                info: new TextEncoder().encode('amino-aes-key'),
                hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    } else {
        // PRF not supported - fall back to using authenticator data hash
        throw new Error('Your authenticator does not support the PRF extension needed for encryption. Please use a password instead.');
    }
}

// ============ Password Strength Checker ============

function checkPasswordStrength(password) {
    var strength = 0;
    if (password.length >= 8) strength++;
    if (password.length >= 12) strength++;
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
    if (/[0-9]/.test(password)) strength++;
    if (/[^a-zA-Z0-9]/.test(password)) strength++;

    if (strength <= 2) return 'weak';
    if (strength <= 3) return 'medium';
    return 'strong';
}

function updatePasswordStrength() {
    var password = document.getElementById('setup-password').value;
    var strengthFill = document.getElementById('password-strength-fill');
    strengthFill.className = 'password-strength-fill';

    if (password.length > 0) {
        var strength = checkPasswordStrength(password);
        strengthFill.classList.add(strength);
    }
}

// ============ Encryption Setup & Unlock Functions ============

// Check if encryption is already set up
function getEncryptionConfig() {
    var configStr = localStorage.getItem(ENCRYPTION_CONFIG_KEY);
    if (!configStr) return null;
    try {
        return JSON.parse(configStr);
    } catch (e) {
        return null;
    }
}

// Save encryption configuration
function saveEncryptionConfig(config) {
    localStorage.setItem(ENCRYPTION_CONFIG_KEY, JSON.stringify(config));
}

// Session key persistence: store encryption key in sessionStorage to survive refresh
var SESSION_KEY_STORAGE = 'amino_session_key';

async function saveSessionKey(key) {
    try {
        var raw = await crypto.subtle.exportKey('raw', key);
        sessionStorage.setItem(SESSION_KEY_STORAGE, arrayBufferToBase64(raw));
    } catch (e) {
        console.warn('Could not save session key:', e);
    }
}

async function loadSessionKey() {
    var stored = sessionStorage.getItem(SESSION_KEY_STORAGE);
    if (!stored) return null;
    try {
        var raw = base64ToArrayBuffer(stored);
        return await crypto.subtle.importKey(
            'raw',
            raw,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    } catch (e) {
        console.warn('Could not restore session key:', e);
        sessionStorage.removeItem(SESSION_KEY_STORAGE);
        return null;
    }
}

function clearSessionKey() {
    sessionStorage.removeItem(SESSION_KEY_STORAGE);
}

// Show the unlock screen (setup or prompt mode)
function showUnlockScreen(mode) {
    // Cancel any pending hide timeout to prevent race condition
    if (_hideUnlockTimeout) { clearTimeout(_hideUnlockTimeout); _hideUnlockTimeout = null; }

    var unlockScreen = document.getElementById('unlock-screen');
    var setupBox = document.getElementById('unlock-setup');
    var promptBox = document.getElementById('unlock-prompt');

    unlockScreen.classList.remove('hidden', 'fading-out');

    if (mode === 'setup') {
        setupBox.classList.remove('hidden');
        promptBox.classList.add('hidden');

        // Hide passkey button if not supported
        if (!isPasskeySupported()) {
            document.getElementById('setup-passkey-btn').style.display = 'none';
        }
    } else {
        setupBox.classList.add('hidden');
        promptBox.classList.remove('hidden');

        // Check encryption config for passkey vs password
        var config = getEncryptionConfig();
        var passkeySection = document.getElementById('passkey-unlock-section');
        var passwordInput = document.getElementById('unlock-password');
        var passwordBtn = document.getElementById('unlock-password-btn');
        if (config && config.type === 'passkey' && isPasskeySupported()) {
            passkeySection.style.display = 'block';
            passkeyCredentialId = config.credentialId;
            // Hide password fields for passkey-only users
            passwordInput.style.display = 'none';
            passwordBtn.style.display = 'none';
        } else {
            passkeySection.style.display = 'none';
            passwordInput.style.display = '';
            passwordBtn.style.display = '';
        }
    }
}

// Hide the unlock screen
var _hideUnlockTimeout = null;
function hideUnlockScreen() {
    var el = document.getElementById('unlock-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        if (_hideUnlockTimeout) { clearTimeout(_hideUnlockTimeout); _hideUnlockTimeout = null; }
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    _hideUnlockTimeout = setTimeout(function() { _hideUnlockTimeout = null; el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

// Show error on unlock screen
function showUnlockError(mode, message) {
    var errorId = mode === 'setup' ? 'unlock-setup-error' : 'unlock-prompt-error';
    var errorEl = document.getElementById(errorId);
    errorEl.textContent = message;
    errorEl.style.display = 'block';
}

// Hide error on unlock screen
function hideUnlockError(mode) {
    var errorId = mode === 'setup' ? 'unlock-setup-error' : 'unlock-prompt-error';
    document.getElementById(errorId).style.display = 'none';
}

// Set up encryption with password
async function setupEncryptionWithPassword() {
    hideUnlockError('setup');

    var password = document.getElementById('setup-password').value;
    var confirmPassword = document.getElementById('setup-password-confirm').value;

    if (!password) {
        showUnlockError('setup', 'Please enter a password');
        return;
    }

    if (password.length < 8) {
        showUnlockError('setup', 'Password must be at least 8 characters');
        return;
    }

    if (password !== confirmPassword) {
        showUnlockError('setup', 'Passwords do not match');
        return;
    }

    var btn = document.getElementById('setup-password-btn');
    btn.disabled = true;
    btn.textContent = 'Setting up...';

    try {
        var salt = generateSalt();
        encryptionKey = await deriveKeyFromPassword(password, salt);

        // Create verification token
        var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, encryptionKey);

        // Save config
        saveEncryptionConfig({
            type: 'password',
            salt: arrayBufferToBase64(salt),
            verificationToken: verificationToken
        });

        encryptionEnabled = true;
        _deferEncryptionUI = true;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Encryption setup failed:', e);
        showUnlockError('setup', 'Failed to set up encryption: ' + e.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Set Up with Password';
    }
}

// Set up encryption with passkey
async function setupEncryptionWithPasskey() {
    hideUnlockError('setup');

    if (!isPasskeySupported()) {
        showUnlockError('setup', 'Passkeys are not supported in this browser');
        return;
    }

    var btn = document.getElementById('setup-passkey-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Setting up...';

    try {
        var passkeyResult = await createPasskey();

        if (!passkeyResult.prfSupported) {
            showUnlockError('setup', 'Your device does not support the encryption features needed for passkey-based encryption. Please use a password instead.');
            return;
        }

        // Authenticate immediately to get PRF output
        var authResult = await authenticateWithPasskey(passkeyResult.credentialId);

        if (!authResult.prfOutput) {
            showUnlockError('setup', 'Failed to get encryption key from passkey. Please use a password instead.');
            return;
        }

        var salt = generateSalt();
        encryptionKey = await deriveKeyFromPasskey(authResult.prfOutput, salt);

        // Create verification token
        var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, encryptionKey);

        // Save config
        saveEncryptionConfig({
            type: 'passkey',
            credentialId: passkeyResult.credentialId,
            salt: arrayBufferToBase64(salt),
            verificationToken: verificationToken
        });

        encryptionEnabled = true;
        _deferEncryptionUI = true;
        passkeyCredentialId = passkeyResult.credentialId;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Passkey setup failed:', e);
        if (e.name === 'NotAllowedError') {
            showUnlockError('setup', 'Passkey setup was cancelled. Please try again.');
        } else {
            showUnlockError('setup', 'Failed to set up passkey: ' + e.message);
        }
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Set Up with Passkey';
    }
}

// Skip encryption (not recommended)
function skipEncryption() {
    if (!confirm('Are you sure? Your API key and cached data will be stored unencrypted, which means anyone with access to your browser could read them.')) {
        return;
    }

    saveEncryptionConfig({ type: 'none' });
    encryptionEnabled = false;
    _deferEncryptionUI = false;
    encryptionKey = null;
    hideUnlockScreen();
    initAuthScreen();
}

// Unlock with password
async function unlockWithPassword() {
    hideUnlockError('prompt');

    var password = document.getElementById('unlock-password').value;
    if (!password) {
        showUnlockError('prompt', 'Please enter your password');
        return;
    }

    var btn = document.getElementById('unlock-password-btn');
    btn.disabled = true;
    btn.textContent = 'Unlocking...';

    try {
        var config = getEncryptionConfig();
        if (!config || !config.salt) {
            throw new Error('Invalid encryption configuration');
        }

        var salt = base64ToArrayBuffer(config.salt);
        encryptionKey = await deriveKeyFromPassword(password, salt);

        // Verify the key
        try {
            await decryptData(config.verificationToken, encryptionKey);
        } catch (e) {
            throw new Error('Incorrect password');
        }

        encryptionEnabled = true;
        _deferEncryptionUI = true;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        document.getElementById('unlock-password').value = '';
        initAuthScreen();
    } catch (e) {
        console.error('Unlock failed:', e);
        showUnlockError('prompt', e.message || 'Failed to unlock');
        encryptionKey = null;
    } finally {
        btn.disabled = false;
        btn.textContent = 'Unlock';
    }
}

// Unlock with passkey
async function unlockWithPasskey() {
    hideUnlockError('prompt');

    var btn = document.getElementById('passkey-unlock-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Unlocking...';

    try {
        var config = getEncryptionConfig();
        if (!config || config.type !== 'passkey') {
            throw new Error('Passkey not configured');
        }

        var authResult = await authenticateWithPasskey(config.credentialId);

        if (!authResult.prfOutput) {
            throw new Error('Failed to get encryption key from passkey');
        }

        var salt = base64ToArrayBuffer(config.salt);
        encryptionKey = await deriveKeyFromPasskey(authResult.prfOutput, salt);

        // Verify the key
        try {
            await decryptData(config.verificationToken, encryptionKey);
        } catch (e) {
            throw new Error('Passkey authentication failed');
        }

        encryptionEnabled = true;
        _deferEncryptionUI = true;
        passkeyCredentialId = config.credentialId;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Passkey unlock failed:', e);
        if (e.name === 'NotAllowedError') {
            showUnlockError('prompt', 'Passkey authentication was cancelled. Please try again.');
        } else {
            showUnlockError('prompt', e.message || 'Failed to unlock with passkey');
        }
        encryptionKey = null;
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Unlock with Passkey';
    }
}

// Clear all encrypted data and start fresh
async function clearEncryptedData() {
    if (!confirm('This will delete ALL local data including your cached database. Your data on the server is not affected. Continue?')) {
        return;
    }

    try {
        // Clear localStorage encryption config and credentials
        localStorage.removeItem(ENCRYPTION_CONFIG_KEY);
        localStorage.removeItem(ENCRYPTED_CREDENTIALS_KEY);
        localStorage.removeItem('amino_api_key');
        localStorage.removeItem('amino_set_filter');

        // Clear IndexedDB
        await new Promise((resolve, reject) => {
            var req = indexedDB.deleteDatabase(DB_NAME);
            req.onsuccess = resolve;
            req.onerror = () => reject(req.error);
        });

        encryptionKey = null;
        encryptionEnabled = false;
        _deferEncryptionUI = false;
        passkeyCredentialId = null;

        // Show setup screen
        showUnlockScreen('setup');
    } catch (e) {
        console.error('Failed to clear data:', e);
        alert('Failed to clear data: ' + e.message);
    }
}

// ============ Encrypted Credentials Storage ============

// Save API credentials (encrypted if encryption is enabled)
async function saveEncryptedCredentials(apiKey, setFilter) {
    var credentials = { apiKey: apiKey, setFilter: setFilter };

    if (encryptionEnabled && encryptionKey) {
        var encrypted = await encryptData(credentials, encryptionKey);
        localStorage.setItem(ENCRYPTED_CREDENTIALS_KEY, encrypted);
        // Remove plaintext credentials
        localStorage.removeItem('amino_api_key');
        localStorage.removeItem('amino_set_filter');
    } else {
        // Store as plaintext (no encryption)
        localStorage.setItem('amino_api_key', apiKey);
        if (setFilter) {
            localStorage.setItem('amino_set_filter', setFilter);
        } else {
            localStorage.removeItem('amino_set_filter');
        }
    }
}

// Load API credentials (decrypt if necessary)
async function loadEncryptedCredentials() {
    if (encryptionEnabled && encryptionKey) {
        var encrypted = localStorage.getItem(ENCRYPTED_CREDENTIALS_KEY);
        if (encrypted) {
            try {
                return await decryptData(encrypted, encryptionKey);
            } catch (e) {
                console.error('Failed to decrypt credentials:', e);
                return null;
            }
        }
    } else {
        var apiKey = localStorage.getItem('amino_api_key');
        if (apiKey) {
            return {
                apiKey: apiKey,
                setFilter: localStorage.getItem('amino_set_filter')
            };
        }
    }
    return null;
}

// Clear saved credentials
function clearEncryptedCredentials() {
    localStorage.removeItem(ENCRYPTED_CREDENTIALS_KEY);
    localStorage.removeItem('amino_api_key');
    localStorage.removeItem('amino_set_filter');
}

// ============ Encrypted IndexedDB Wrapper ============

// Encrypt data before storing in IndexedDB
async function encryptForStorage(data) {
    if (encryptionEnabled && encryptionKey) {
        return {
            _encrypted: true,
            data: await encryptData(data, encryptionKey)
        };
    }
    return data;
}

// Decrypt data after retrieving from IndexedDB
async function decryptFromStorage(data) {
    if (data && data._encrypted && encryptionEnabled && encryptionKey) {
        return await decryptData(data.data, encryptionKey);
    }
    return data;
}

// ============ Encryption Init Flow ============

// Initialize encryption system - called before anything else
async function initEncryption() {
    var config = getEncryptionConfig();

    if (!config) {
        // First time user - show setup screen
        showUnlockScreen('setup');
        return false;
    }

    if (config.type === 'none') {
        // User chose to skip encryption
        encryptionEnabled = false;
        encryptionKey = null;
        return true;
    }

    // Check for session key (survives page refresh within same tab)
    var sessionKey = await loadSessionKey();
    if (sessionKey && config.verificationToken) {
        try {
            await decryptData(config.verificationToken, sessionKey);
            // Session key is valid
            encryptionKey = sessionKey;
            encryptionEnabled = true;
            _deferEncryptionUI = true;
            return true;
        } catch (e) {
            // Session key is stale or invalid
            clearSessionKey();
        }
    }

    // User has encryption set up - show unlock screen
    showUnlockScreen('prompt');
    return false;
}

// Only keep lightweight metadata in memory
var META_TABLES = {};
var META_FIELDS = {};
var META_VIEWS = {};

// ============ Table Name Resolution ============
// Centralizes display name lookup so tables never show raw Airtable IDs
// (e.g. "tblJh06tcQ1X...") in the UI. Checks META_TABLES first, then
// falls back to SynapseSync room data (populated from the API and room
// state events), and only uses the raw ID as a last resort.

function _looksLikeTableId(name) {
    if (!name) return true;
    // Airtable table IDs: "tblXXXXXXXXXX" (optionally prefixed with "airtable:")
    return /^(airtable:)?tbl[A-Za-z0-9]{10,}/.test(name);
}

function resolveTableName(tableId) {
    // META_TABLES  authoritative in-memory metadata
    var meta = META_TABLES[tableId];
    if (meta && meta.tableName && !_looksLikeTableId(meta.tableName)) {
        return meta.tableName;
    }

    // Last resort  use whatever name we have (may be a raw ID)
    return (meta && meta.tableName) || tableId;
}

// Stub  room-based name backfill removed (table names come from Postgres API)
async function _backfillTableNamesFromRooms() { }

// Human-readable names for entity/event types
var ENTITY_TYPE_NAMES = {
    'data': 'Data',
    'INS': 'INS',
    'ALT': 'ALT',
    'NUL': 'NUL',
    'SYN': 'SYN',
    'table': 'Table',
    'field': 'Field',
    'view': 'View',
    'viewConfig': 'View Config',
    'tableSettings': 'Table Settings',
    'current': 'Current State'
};

var currentTable = null;
var currentView = null; // Current view ID or null for "All Fields" default
var currentPage = 0;
var currentRecordIds = [];
var totalRecords = 0;
var lastEventTimestamp = null; // ISO timestamp of last synced event
var pollInterval = null;
var navVersion = 0; // Navigation guard to prevent race conditions when rapidly switching views

// Targeted DOM update tracking  allows cell-level patching instead of full DOM rebuild
var _lastRenderedRecordIds = null;
var _lastRenderedTable = null;
var _lastRenderedPage = null;

// View field configuration cache (in-memory, persisted to IndexedDB)
// Structure: VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [...], fieldOrder: [...] }
// Note: Views default to showing ALL fields; hiddenFieldIds stores fields to hide
var VIEW_FIELD_CONFIG = {};

// View folders: Structure: VIEW_FOLDERS[tableId][folderId] = { folderId, folderName, parentFolderId, sortOrder, isExpanded }
var VIEW_FOLDERS = {};

// Workspaces: Structure: WORKSPACES[workspaceId] = { workspaceId, workspaceName, viewIds: [], sortOrder }
var WORKSPACES = {};
var currentWorkspace = null; // Current active workspace filter

// Table Settings: User-specific preferences for tables and views
// Structure: TABLE_SETTINGS = {
//   tables: {
//     [tableId]: {
//       visible: boolean,      // Whether table is visible in sidebar
//       sortOrder: number      // Custom sort order
//     }
//   },
//   tableOrder: string[],      // Array of tableIds in user's preferred order
//   views: {
//     [viewId]: {
//       isPublic: boolean,     // Whether view is public (shared) or private
//       sortOrder: number      // Custom sort order within table
//     }
//   }
// }
var TABLE_SETTINGS = {
    tables: {},
    tableOrder: [],
    views: {}
};

// ============ Sidebar Configuration ============
// Table type definitions with colors and icons
var TABLE_TYPE_CONFIG = {
    primary: {
        color: '#ef4444',
        label: 'Primary',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>'
    },
    events: {
        color: '#f59e0b',
        label: 'Events',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>'
    },
    syncStatus: {
        color: '#10b981',
        label: 'Sync Status',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>'
    },
    operational: {
        color: '#3b82f6',
        label: 'Operational',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="3" x2="21" y1="9" y2="9"/><line x1="3" x2="21" y1="15" y2="15"/><line x1="9" x2="9" y1="9" y2="21"/><line x1="15" x2="15" y1="9" y2="21"/></svg>'
    },
    collection: {
        color: '#8b5cf6',
        label: 'Collections',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>'
    },
    reference: {
        color: '#10b981',
        label: 'Reference',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg>'
    },
    dev: {
        color: '#6b7280',
        label: 'Dev / Testing',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>'
    },
    room: {
        color: '#6366f1',
        label: 'Rooms',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>'
    }
};

// Sidebar state (pinned tables, recent tables, expanded sections, search)
var SIDEBAR_STATE = {
    pinnedTables: [],
    recentTables: [],
    expandedSections: {
        primary: true,
        pinned: true,
        recent: true,
        operational: true,
        collections: false,
        reference: false,
        dev: false
    },
    searchQuery: '',
    maxRecentTables: 5
};

// Cache for sidebar data to avoid redundant DB queries on search/pin/section toggle
var _sidebarCache = {
    tables: null,
    tableCounts: null,
    maxCount: 0,
    eventsCount: 0,
    timestamp: 0
};
var SIDEBAR_CACHE_TTL = 30000; // 30 seconds

function invalidateSidebarCache() {
    _sidebarCache.tables = null;
    _sidebarCache.tableCounts = null;
    _sidebarCache.timestamp = 0;
}

// Determine table type based on name patterns
function getTableType(tableName) {
    var name = (tableName || '').toLowerCase();

    // Primary tables (always at top for everyone)
    if (name === 'client info') return 'primary';
    if (name === 'case master view') return 'primary';
    if (name === 'events') return 'primary';
    if (name === 'case notes' || name === 'case note') return 'primary';

    // Events
    if (name.includes('event') && name.includes('stream')) return 'events';

    // Collections (date patterns)
    if (name.includes('collection')) return 'collection';
    if (/\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/.test(name)) return 'collection';
    if (/\d{1,2}(st|nd|rd|th)?\s*-\s*\d{1,2}(st|nd|rd|th)?/.test(name)) return 'collection';

    // Reference (small lookup tables)
    if (name.includes('dictionary') || name.includes('appendix') || name.includes('info')) return 'reference';
    if (name.includes('type') && !name.includes('activity')) return 'reference';

    // Dev
    if (name.includes('test') || name.includes('dev') || name.includes('data test')) return 'dev';

    // Default to operational
    return 'operational';
}

// Format record count (e.g., 73262 -> "73.3k")
function formatRecordCount(count) {
    if (count >= 1000) return (count / 1000).toFixed(1) + 'k';
    return count.toString();
}

// Get count bar width ratio (logarithmic scale)
function getCountBarWidth(count, maxCount) {
    if (count <= 0 || maxCount <= 0) return 0;
    var ratio = Math.log(count + 1) / Math.log(maxCount + 1);
    return Math.max(0.15, ratio);
}

// Add table to recent list
function addToRecentTables(tableId) {
    if (tableId === '_events') return;
    var recent = SIDEBAR_STATE.recentTables.filter(id => id !== tableId);
    recent.unshift(tableId);
    SIDEBAR_STATE.recentTables = recent.slice(0, SIDEBAR_STATE.maxRecentTables);
    saveSidebarState();
}

// Toggle table pin
function toggleTablePin(tableId, event) {
    if (event) event.stopPropagation();
    var idx = SIDEBAR_STATE.pinnedTables.indexOf(tableId);
    if (idx >= 0) {
        SIDEBAR_STATE.pinnedTables.splice(idx, 1);
    } else {
        SIDEBAR_STATE.pinnedTables.push(tableId);
    }
    saveSidebarState();
    // Fast path: update pin button icon in-place instead of full sidebar rebuild
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var pinBtn = wrapper.querySelector('.pin-btn');
        if (pinBtn) {
            var isPinned = SIDEBAR_STATE.pinnedTables.includes(tableId);
            pinBtn.className = 'pin-btn' + (isPinned ? ' pinned' : '');
            pinBtn.title = isPinned ? 'Unpin' : 'Pin';
            pinBtn.innerHTML = isPinned ? SIDEBAR_ICONS.starFilled : SIDEBAR_ICONS.star;
        }
    }
    // Debounce the full re-render for structural changes (pinned section)
    _debouncedSidebarRender();
}

// Debounced sidebar render to coalesce rapid toggling
var _sidebarRenderTimer = null;
function _debouncedSidebarRender() {
    if (_sidebarRenderTimer) cancelAnimationFrame(_sidebarRenderTimer);
    _sidebarRenderTimer = requestAnimationFrame(function() {
        _sidebarRenderTimer = null;
        renderSidebar();
    });
}

// Toggle sidebar section
function toggleSidebarSection(sectionId) {
    var wasExpanded = SIDEBAR_STATE.expandedSections[sectionId];
    SIDEBAR_STATE.expandedSections[sectionId] = !wasExpanded;
    saveSidebarState();

    // Fast path for collapsing: just toggle CSS class on the header
    // (table items under it are already in the DOM, hidden by the collapsed state)
    // For expanding, we need a full render to populate the section's table items
    if (wasExpanded) {
        // Collapsing  fast DOM toggle
        var headers = document.querySelectorAll('.sidebar-section-header');
        for (var i = 0; i < headers.length; i++) {
            var hdr = headers[i];
            // Match by section ID stored in the onclick
            if (hdr.onclick && hdr._sectionId === sectionId) {
                hdr.classList.add('collapsed');
                // Hide the table wrappers that follow until next section header or divider
                var sibling = hdr.nextElementSibling;
                while (sibling && !sibling.classList.contains('sidebar-section-header') && !sibling.classList.contains('sidebar-divider')) {
                    sibling.style.display = 'none';
                    sibling = sibling.nextElementSibling;
                }
                return;
            }
        }
        // Fallback if we couldn't find the header
        renderSidebar();
    } else {
        // Expanding  need full render to build the section content
        renderSidebar();
    }
}

// Save sidebar state to localStorage
function saveSidebarState() {
    try {
        localStorage.setItem('aminoSidebarState', JSON.stringify(SIDEBAR_STATE));
    } catch (e) { /* ignore */ }
}

// Load sidebar state from localStorage
function loadSidebarState() {
    try {
        var saved = localStorage.getItem('aminoSidebarState');
        if (saved) {
            var parsed = JSON.parse(saved);
            SIDEBAR_STATE.pinnedTables = parsed.pinnedTables || [];
            SIDEBAR_STATE.recentTables = parsed.recentTables || [];
            SIDEBAR_STATE.expandedSections = Object.assign({}, SIDEBAR_STATE.expandedSections, parsed.expandedSections || {});
        }
    } catch (e) { /* ignore */ }
}

// Initialize sidebar search functionality
function initSidebarSearch() {
    var searchInput = document.getElementById('sidebar-search-input');
    if (!searchInput) return;

    var debounceTimer = null;

    // Search input handler with debounce - uses fast CSS-class-based filtering
    searchInput.addEventListener('input', function(e) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(function() {
            var newQuery = e.target.value;
            SIDEBAR_STATE.searchQuery = newQuery;
            // Use fast DOM filter if sidebar is already rendered (no need for full rebuild)
            if (_sidebarCache.tables) {
                filterSidebarDOM(newQuery);
            } else {
                renderSidebar();
            }
        }, 80); // Reduced from 150ms since CSS class toggling is much cheaper
    });

    // Clear search on Escape
    searchInput.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            searchInput.value = '';
            SIDEBAR_STATE.searchQuery = '';
            searchInput.blur();
            // Use fast DOM filter to restore all items
            if (_sidebarCache.tables) {
                filterSidebarDOM('');
            } else {
                renderSidebar();
            }
        }
    });

    // Keyboard shortcut: Cmd+K / Ctrl+K opens CRM command palette in Interface app
    document.addEventListener('keydown', function(e) {
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            if (_currentApp === 'interface' && typeof openCommandPalette === 'function') {
                openCommandPalette();
                return;
            }
            searchInput.focus();
            searchInput.select();
        }
    });
}

// Global CRM command palette state
var COMMAND_PALETTE_STATE = {
    open: false,
    allRecords: null,
    recentRecordIds: []
};

function _loadRecentProfileRecords() {
    try {
        var raw = localStorage.getItem('aminoRecentProfileRecords');
        var parsed = raw ? JSON.parse(raw) : [];
        return Array.isArray(parsed) ? parsed : [];
    } catch (e) {
        return [];
    }
}

function _saveRecentProfileRecord(entry) {
    if (!entry || !entry.recordId) return;
    var list = _loadRecentProfileRecords().filter(function(item) {
        return item && item.recordId !== entry.recordId;
    });
    list.unshift({
        recordId: entry.recordId,
        tableId: entry.tableId || '',
        title: entry.title || entry.recordId,
        subtitle: entry.subtitle || ''
    });
    if (list.length > 15) list = list.slice(0, 15);
    try { localStorage.setItem('aminoRecentProfileRecords', JSON.stringify(list)); } catch (e) {}
}

function _getCommandPaletteRecords() {
    if (COMMAND_PALETTE_STATE.allRecords) return COMMAND_PALETTE_STATE.allRecords;
    var records = [];
    var tableIds = Object.keys(META_TABLES || {});
    for (var i = 0; i < tableIds.length; i++) {
        var tableId = tableIds[i];
        var table = META_TABLES[tableId] || {};
        var tableName = resolveTableName(tableId);
        var lowered = tableName.toLowerCase();
        var category = '';
        if (lowered.indexOf('client') !== -1) category = 'client';
        else if (lowered.indexOf('matter') !== -1) category = 'matter';
        else if (lowered.indexOf('task') !== -1) category = 'task';
        if (!category) continue;

        var rows = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) ? Object.values(window.IN_MEMORY_DATA[tableId]) : [];
        for (var r = 0; r < rows.length; r++) {
            var row = rows[r] || {};
            var recordId = row.id || row.airtableRecordId || row.airtable_id || row.recordId;
            if (!recordId) continue;
            var title = '';
            var subtitle = '';
            for (var key in row) {
                if (!title && /(name|title)/i.test(key) && row[key]) title = String(row[key]);
                if (!subtitle && /(status|stage|owner|attny|attorney)/i.test(key) && row[key]) subtitle = String(row[key]);
                if (title && subtitle) break;
            }
            if (!title) title = tableName + ' ' + String(recordId).slice(-6);
            records.push({ recordId: recordId, tableId: tableId, title: title, subtitle: subtitle, type: category });
        }
    }
    COMMAND_PALETTE_STATE.allRecords = records;
    return records;
}

function openCommandPalette() {
    var overlay = document.getElementById('command-palette-overlay');
    var input = document.getElementById('command-palette-input');
    if (!overlay || !input) return;
    COMMAND_PALETTE_STATE.open = true;
    overlay.classList.remove('hidden');
    input.value = '';
    renderCommandPaletteResults('');
    setTimeout(function() { input.focus(); input.select(); }, 0);
}

function closeCommandPalette(event) {
    if (event && event.target && event.target.id && event.target.id !== 'command-palette-overlay') return;
    var overlay = document.getElementById('command-palette-overlay');
    if (!overlay) return;
    overlay.classList.add('hidden');
    COMMAND_PALETTE_STATE.open = false;
}

function renderCommandPaletteResults(query) {
    var container = document.getElementById('command-palette-results');
    if (!container) return;
    var q = String(query || '').trim().toLowerCase();
    var recent = _loadRecentProfileRecords();
    var recentIds = recent.map(function(r) { return r.recordId; });
    var all = _getCommandPaletteRecords();
    var filtered = q
        ? all.filter(function(r) {
            return String(r.title).toLowerCase().indexOf(q) !== -1 ||
                String(r.subtitle || '').toLowerCase().indexOf(q) !== -1 ||
                String(r.recordId).toLowerCase().indexOf(q) !== -1;
        })
        : all.filter(function(r) { return recentIds.indexOf(r.recordId) !== -1; });

    if (!filtered.length) {
        container.innerHTML = '<div class="command-palette-empty">No matching records. Try searching by name, status, or record ID.</div>';
        return;
    }

    var html = filtered.slice(0, 20).map(function(item) {
        var subtitle = item.subtitle ? _esc(item.subtitle) : 'Open ' + _esc(item.title) + ' profile';
        var safeTable = _esc(item.tableId).replace(/'/g, '&#39;');
        var safeRecord = _esc(item.recordId).replace(/'/g, '&#39;');
        return '<button class="command-palette-item" onclick="openCommandPaletteRecord(\'' + safeTable + '\',\'' + safeRecord + '\')">' +
            '<span><div class="command-palette-item-title">' + _esc(item.title) + '</div><div class="command-palette-item-meta">' + subtitle + '</div></span>' +
            '<span class="command-palette-item-type">' + _esc(item.type) + '</span>' +
            '</button>';
    }).join('');
    container.innerHTML = html;
}

function openCommandPaletteRecord(tableId, recordId) {
    closeCommandPalette();
    if (tableId && recordId && typeof openRecordProfile === 'function') {
        openRecordProfile(tableId, recordId);
        return;
    }
    if (typeof InterfaceApp !== 'undefined' && InterfaceApp.openClientProfilePage) {
        InterfaceApp.openClientProfilePage(recordId);
    }
}

// SVG icons for sidebar
var SIDEBAR_ICONS = {
    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>',
    star: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    starFilled: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    clock: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>'
};

// Pending view action (when user tries to modify default view)
var pendingViewAction = null; // { action: 'filter'|'sort'|'fields'|'group', data: any }


// ============ Events View State ============
var eventsPageSize = 50;
var eventsTypeFilter = ''; // 'INS', 'ALT', 'NUL', 'SYN', 'table', 'field', 'view', 'viewConfig', or '' for all
var eventsSetFilter = ''; // Filter by set (table id)
var eventsSearchQuery = '';
var expandedPayloads = new Set(); // Set of event IDs with expanded payloads
var cachedEventRecordLabels = {}; // tableId::recordId -> display label
var appOpenedEventId = 0; // Highest event ID when app was opened (events with higher IDs are "new")

// Infinite scroll state
var loadedEvents = []; // Currently loaded events (capped to MAX_LOADED_EVENTS)
var MAX_LOADED_EVENTS = 2000; // Cap to prevent unbounded memory growth
var eventsOffset = 0; // Current offset for loading more
var isLoadingMoreEvents = false; // Prevent multiple simultaneous loads
var hasMoreEvents = true; // Whether there are more events to load
var eventsScrollHandler = null; // Reference to scroll handler for cleanup

// Events view tab state: 'events', 'changelog', or 'room-access'
var eventsActiveTab = 'events';

// Room access tab state
var roomAccessSnapshot = [];
var roomAccessRefreshTimer = null;
var roomAccessRefreshInFlight = false;
var ROOM_ACCESS_REFRESH_MS = 5000;

// Changelog state (drawn from Matrix room data)
var changelogEntries = [];
var changelogPaginationTokens = {};
var changelogHasMore = true;
var changelogIsLoading = false;
var changelogTableFilter = '';
var changelogScrollHandler = null;

// In-memory event cache for fast startup from file import
// Events are loaded into memory first for instant UI, then saved to IndexedDB in background
var inMemoryEvents = null; // Array of events or null if not using memory cache
var inMemoryEventsByRecord = null; // Map of recordId -> array of events for fast lookup
var isBackgroundSaveInProgress = false; // Track background IndexedDB save status

// ============ View Auto-Save System ============
var AUTO_SAVE_DELAY = 5 * 60 * 1000; // 5 minutes
var autoSaveTimer = null;

var viewDirtyState = {
    isDirty: false,
    lastEditTime: null,
    pendingChanges: {
        tableId: null,
        viewId: null,
        changes: {}
    }
};

// ============ AminoSync - Event Stream Client (Deprecated - Xano removed) ============
// Data flows one way: Airtable  n8n  Matrix. The client does NOT write events.
// This stub is kept for backward compatibility with any code that references AminoSync.
var AminoSync = {
    async postEvent(event) {
        throw new Error('Direct event posting is not supported. Data flows from Airtable  n8n  Matrix.');
    }
};

// ============ AmoFormat - Binary Event Stream Format (.amo) ============
// Compact binary representation using MessagePack + gzip with columnar compression.
// Extension: .amo | MIME: application/x-amino-snapshot

var AmoFormat = {
    MAGIC: 'AMO1',
    VERSION: 1,
    HEADER_SIZE: 8,

    // Produce a .amo binary from the full event stream (current state only).
    // events: array of raw aminoStream events (id, set, recordId, operator, created_at, payload, uuid, ...)
    // meta: optional { tables: META_TABLES, fields: META_FIELDS } to preserve table/field names
    // History is NOT included  it lives only in Matrix rooms.
    // Returns: Uint8Array
    produceEvents: function(events, meta) {
        // Collect all unique keys across all events for the columnar schema
        var colSet = {};
        for (var i = 0; i < events.length; i++) {
            var keys = Object.keys(events[i]);
            for (var k = 0; k < keys.length; k++) {
                // Skip encrypted payload marker  we store the decrypted payload
                if (keys[k] !== '_encryptedPayload') {
                    colSet[keys[k]] = true;
                }
            }
        }
        // Ensure core columns come first for readability
        var coreColumns = ['id', 'set', 'recordId', 'operator', 'created_at', 'payload', 'uuid'];
        var columns = [];
        for (var c = 0; c < coreColumns.length; c++) {
            if (colSet[coreColumns[c]]) {
                columns.push(coreColumns[c]);
                delete colSet[coreColumns[c]];
            }
        }
        var extra = Object.keys(colSet);
        for (var e = 0; e < extra.length; e++) {
            columns.push(extra[e]);
        }

        // Convert events to positional arrays
        var rows = [];
        var maxId = 0;
        for (var j = 0; j < events.length; j++) {
            var ev = events[j];
            var row = [];
            for (var col = 0; col < columns.length; col++) {
                var val = ev[columns[col]];
                row.push(val !== undefined ? val : null);
            }
            rows.push(row);
            if (ev.id > maxId) maxId = ev.id;
        }

        var schema = { '_events': columns };
        var records = { '_events': rows };

        // Encode payload with MessagePack
        var payload = { v: 1, type: 'events', ts: Math.floor(Date.now() / 1000), cursor: maxId, schema: schema, records: records };
        if (meta) payload.meta = meta;
        var encoded = MessagePack.encode(payload);

        // Compress with gzip
        var compressed = pako.gzip(encoded);

        // Prepend 8-byte header: "AMO1" + version(1) + flags(0) + reserved(0,0)
        var header = new Uint8Array([0x41, 0x4D, 0x4F, 0x31, 0x01, 0x00, 0x00, 0x00]);
        var out = new Uint8Array(8 + compressed.length);
        out.set(header);
        out.set(compressed, 8);
        return out;
    },

    // Read a .amo binary file
    // arrayBuffer: ArrayBuffer or Uint8Array of the .amo file
    // Returns: { type: 'events'|'snapshot', events?: [...], history?: [...], tables?: {...}, cursor, ts, meta? }
    read: function(arrayBuffer) {
        var bytes = new Uint8Array(arrayBuffer);

        // Validate header
        if (bytes.length < this.HEADER_SIZE) {
            throw new Error('File too small to be a .amo file');
        }
        var magic = String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]);
        if (magic !== this.MAGIC) {
            throw new Error('Not a .amo file (bad magic bytes)');
        }
        if (bytes[4] !== this.VERSION) {
            throw new Error('Unknown .amo version: ' + bytes[4]);
        }
        if (bytes[5] !== 0x00) {
            throw new Error('Unsupported .amo flags: 0x' + bytes[5].toString(16));
        }

        // Decompress + decode
        var compressed = bytes.slice(this.HEADER_SIZE);
        var decompressed = pako.ungzip(compressed);
        var payload = MessagePack.decode(decompressed);

        // Check if this is the new events format
        if (payload.type === 'events') {
            var columns = payload.schema['_events'];
            var rows = payload.records['_events'] || [];
            var events = [];
            for (var j = 0; j < rows.length; j++) {
                var obj = {};
                for (var k = 0; k < columns.length; k++) {
                    obj[columns[k]] = (k < rows[j].length) ? (rows[j][k] !== undefined ? rows[j][k] : null) : null;
                }
                events.push(obj);
            }
            var result = { type: 'events', events: events, cursor: payload.cursor, ts: payload.ts };
            if (payload.meta) result.meta = payload.meta;

            // Parse mutation history section if present
            if (payload.schema['_history']) {
                var histCols = payload.schema['_history'];
                var histRows = payload.records['_history'] || [];
                var history = [];
                for (var hj = 0; hj < histRows.length; hj++) {
                    var hobj = {};
                    for (var hk = 0; hk < histCols.length; hk++) {
                        hobj[histCols[hk]] = (hk < histRows[hj].length) ? (histRows[hj][hk] !== undefined ? histRows[hj][hk] : null) : null;
                    }
                    history.push(hobj);
                }
                result.history = history;
            }

            return result;
        }

        // Legacy snapshot format: re-hydrate positional arrays back into objects
        var tables = {};
        var schemaEntries = Object.entries(payload.schema);
        for (var i = 0; i < schemaEntries.length; i++) {
            var tableName = schemaEntries[i][0];
            var cols = schemaEntries[i][1];
            var tblRows = payload.records[tableName] || [];
            tables[tableName] = [];
            for (var j2 = 0; j2 < tblRows.length; j2++) {
                var obj2 = {};
                for (var k2 = 0; k2 < cols.length; k2++) {
                    obj2[cols[k2]] = (k2 < tblRows[j2].length) ? (tblRows[j2][k2] !== undefined ? tblRows[j2][k2] : null) : null;
                }
                tables[tableName].push(obj2);
            }
        }

        var result2 = { type: 'snapshot', tables: tables, cursor: payload.cursor, ts: payload.ts };
        if (payload.meta) result2.meta = payload.meta;
        return result2;
    },

    // Detect the format of a buffer
    // Returns: 'amo' | 'json-gz' | 'json' | 'csv'
    detectFormat: function(buffer) {
        var b = new Uint8Array(buffer.slice(0, 4));
        if (b[0] === 0x41 && b[1] === 0x4D && b[2] === 0x4F && b[3] === 0x31) return 'amo';
        if (b[0] === 0x1F && b[1] === 0x8B) return 'json-gz';
        if (b[0] === 0x7B || b[0] === 0x5B) return 'json';
        // Check for CSV: first line should be printable ASCII text with commas
        try {
            var preview = new TextDecoder().decode(new Uint8Array(buffer.slice(0, 2048)));
            var firstLine = preview.split(/\r?\n/)[0];
            if (firstLine && firstLine.indexOf(',') !== -1) {
                // Look for the required 'id' column in the CSV header
                var cols = firstLine.split(',');
                for (var ci = 0; ci < cols.length; ci++) {
                    if (cols[ci].replace(/"/g, '').trim() === 'id') return 'csv';
                }
            }
        } catch (e) {}
        throw new Error('Unknown format');
    }
};

// ============ History lives in Postgres event_log ============
// History is fetched on-demand from the Postgres events API via
// fetchHistoryFromPostgresEvents(). Not downloaded at hydration.

// ============ Box .amo Hydration Snapshot Sync ============
var BOX_AMO_UPLOAD_URL = 'https://n8n.intelechia.com/webhook/box-upload';
var BOX_AMO_DOWNLOAD_URL = 'https://n8n.intelechia.com/webhook/box-download';
var BOX_AMO_DEFAULT_API_KEY = '7aea6b6c-ce2b-48ce-9909-9cae15cdb220';
var BOX_AMO_FILENAME = 'amino-hydration.amo';
var BOX_AMO_UPLOAD_INTERVAL_MS = 30 * 60 * 1000; // 30 minutes
var BOX_AMO_INITIAL_UPLOAD_DELAY_MS = 2 * 60 * 1000; // 2 minutes after app init
var _boxAmoUploadTimer = null;
var _boxAmoUploadInFlight = false;

function getBoxAmoApiKey() {
    return localStorage.getItem('amino_box_api_key') || BOX_AMO_DEFAULT_API_KEY;
}

async function hydrateFromBoxAmoFile() {
    var apiKey = getBoxAmoApiKey();
    var url = BOX_AMO_DOWNLOAD_URL + '?api_key=' + encodeURIComponent(apiKey);

    // Keep startup resilient: abort if Box is unreachable so normal hydration can continue.
    // The download proxies through n8n  Box.com which can be slow; 45s avoids
    // premature aborts on larger snapshots while still failing on network errors.
    var controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
    var timeoutId = null;
    if (controller) {
        timeoutId = setTimeout(function() {
            console.warn('[BoxAmo] Download timed out after 45 seconds, aborting');
            controller.abort();
        }, 45000);
    }

    var res;
    try {
        res = await fetch(url, {
            method: 'GET',
            signal: controller ? controller.signal : undefined
        });
    } finally {
        if (timeoutId) clearTimeout(timeoutId);
    }

    if (!res.ok) {
        throw new Error('Box snapshot download failed (' + res.status + ')');
    }

    var buffer = await res.arrayBuffer();
    var format = AmoFormat.detectFormat(buffer);
    if (format !== 'amo') {
        throw new Error('Box hydration file format was "' + format + '" (expected "amo")');
    }

    var amoData = AmoFormat.read(buffer);

    // ---- Legacy snapshot format handling ----
    // Older .amo files used type:"snapshot" with pre-materialized table data
    // instead of type:"events" with a replayable event stream. Handle both.
    if (amoData && amoData.type === 'snapshot' && amoData.tables) {
        console.log('[BoxAmo] Detected legacy snapshot format  converting to in-memory data');

        // Restore table/field metadata from the snapshot's meta property
        var snapshotMeta = amoData.meta || {};
        if (snapshotMeta.tables) {
            var smTableIds = Object.keys(snapshotMeta.tables);
            for (var sm = 0; sm < smTableIds.length; sm++) {
                var smTid = smTableIds[sm];
                META_TABLES[smTid] = snapshotMeta.tables[smTid];
            }
        }
        if (snapshotMeta.fields) {
            var smFieldTableIds = Object.keys(snapshotMeta.fields);
            for (var sm = 0; sm < smFieldTableIds.length; sm++) {
                var smTid = smFieldTableIds[sm];
                if (!META_FIELDS[smTid]) META_FIELDS[smTid] = {};
                var smFieldIds = Object.keys(snapshotMeta.fields[smTid]);
                for (var sf = 0; sf < smFieldIds.length; sf++) {
                    META_FIELDS[smTid][smFieldIds[sf]] = snapshotMeta.fields[smTid][smFieldIds[sf]];
                }
            }
        }

        // Convert snapshot tables into IN_MEMORY_DATA format.
        // Snapshot tables: { tableName/tableId: [ { col1: val1, ... }, ... ] }
        // IN_MEMORY_DATA:  { tableId: { recordId: { field1: val1, ... } } }
        var tableDataMap = {};
        var importedRecords = 0;
        var snapshotTableKeys = Object.keys(amoData.tables);
        for (var st = 0; st < snapshotTableKeys.length; st++) {
            var tableKey = snapshotTableKeys[st];
            var rows = amoData.tables[tableKey];
            if (!rows || !Array.isArray(rows) || rows.length === 0) continue;

            // Ensure table metadata exists (use key as tableId)
            if (!META_TABLES[tableKey]) {
                META_TABLES[tableKey] = { tableId: tableKey, tableName: tableKey, _placeholder: true };
            }

            var tblData = {};
            for (var sr = 0; sr < rows.length; sr++) {
                var row = rows[sr];
                if (!row || typeof row !== 'object') continue;

                // Detect record ID: check 'id', 'recordId', 'record_id'
                var recId = row.id || row.recordId || row.record_id;
                if (!recId) continue;

                // Detect fields: if the row has a 'fields' sub-object, use it;
                // otherwise treat all non-id properties as field values.
                var fields;
                if (row.fields && typeof row.fields === 'object') {
                    fields = row.fields;
                } else {
                    fields = {};
                    var rowKeys = Object.keys(row);
                    for (var rk = 0; rk < rowKeys.length; rk++) {
                        if (rowKeys[rk] !== 'id' && rowKeys[rk] !== 'recordId' &&
                            rowKeys[rk] !== 'record_id' && rowKeys[rk] !== 'createdTime') {
                            fields[rowKeys[rk]] = row[rowKeys[rk]];
                        }
                    }
                }

                // Auto-create placeholder field metadata
                if (!META_FIELDS[tableKey]) META_FIELDS[tableKey] = {};
                var fieldIds = Object.keys(fields);
                for (var fi = 0; fi < fieldIds.length; fi++) {
                    var fid = fieldIds[fi];
                    if (!META_FIELDS[tableKey][fid]) {
                        META_FIELDS[tableKey][fid] = {
                            tableId: tableKey,
                            fieldId: fid,
                            fieldName: fid,
                            fieldType: typeof inferFieldType === 'function' ? inferFieldType(fields[fid]) : 'unknown',
                            _placeholder: true
                        };
                    }
                }

                tblData[recId] = fields;
                importedRecords++;
            }

            if (Object.keys(tblData).length > 0) {
                tableDataMap[tableKey] = tblData;
            }
        }

        if (importedRecords === 0) {
            throw new Error('Box .amo snapshot contained 0 usable records');
        }

        // Populate IN_MEMORY_DATA directly (no event replay needed)
        window.IN_MEMORY_DATA = tableDataMap;
        inMemoryEvents = [];
        inMemoryEventsByRecord = new Map();

        console.log('[BoxAmo] Legacy snapshot hydrated: ' + importedRecords + ' records across ' + Object.keys(tableDataMap).length + ' tables');

        // Schedule a re-upload in the current events format so subsequent
        // downloads get the proper event-stream .amo file.
        setTimeout(function() {
            uploadAmoSnapshotToBox('format-upgrade').catch(function(err) {
                console.warn('[BoxAmo] Format upgrade re-upload failed:', err.message || err);
            });
        }, 30000); // 30s delay  let the app finish initializing first

        return { importedEvents: importedRecords, cursor: amoData.cursor || 0 };
    }

    // ---- Standard events format handling ----
    if (!amoData || !Array.isArray(amoData.events) || amoData.events.length === 0) {
        var amoType = amoData && amoData.type ? amoData.type : 'unknown';
        throw new Error('Box .amo file contained "' + amoType + '" payload; expected non-empty event stream');
    }

    amoData.events.sort(function(a, b) { return (a.id || 0) - (b.id || 0); });

    // Restore table/field metadata embedded in the AMO file so that
    // META_TABLES and META_FIELDS are populated before we replay events.
    var savedMeta = amoData.meta || {};
    if (savedMeta.tables) {
        var savedTableIds = Object.keys(savedMeta.tables);
        for (var m = 0; m < savedTableIds.length; m++) {
            var tid = savedTableIds[m];
            META_TABLES[tid] = savedMeta.tables[tid];
        }
    }
    if (savedMeta.fields) {
        var savedFieldTableIds = Object.keys(savedMeta.fields);
        for (var m = 0; m < savedFieldTableIds.length; m++) {
            var tid = savedFieldTableIds[m];
            if (!META_FIELDS[tid]) META_FIELDS[tid] = {};
            var fieldIds = Object.keys(savedMeta.fields[tid]);
            for (var f = 0; f < fieldIds.length; f++) {
                META_FIELDS[tid][fieldIds[f]] = savedMeta.fields[tid][fieldIds[f]];
            }
        }
    }

    // Replay the event stream into memory so META_TABLES, META_FIELDS,
    // META_VIEWS, and IN_MEMORY_DATA are fully populated. Without this
    // the init flow sees zero tables and falls through to webhook hydration,
    // discarding the AMO data entirely.
    inMemoryEvents = amoData.events;
    inMemoryEventsByRecord = buildInMemoryEventsByRecord(amoData.events);
    await processEventsMemoryOnly(amoData.events);

    // Persist everything (events + now-populated metadata + records) to IndexedDB
    // in the background so the next cold start has cached data.
    backgroundSaveToIndexedDB(amoData.events).catch(function(err) {
        console.warn('[BoxAmo] Background IndexedDB save failed:', err);
    });

    // History is not stored locally  it lives only in Matrix rooms.
    // Legacy AMO files may contain a _history section; we simply ignore it.

    return {
        importedEvents: amoData.events.length,
        importedHistory: 0,
        cursor: amoData.cursor || 0
    };
}


async function uploadAmoSnapshotToBox(reason) {
    if (_boxAmoUploadInFlight) return false;
    _boxAmoUploadInFlight = true;

    try {
        var allEvents = [];
        var batchSize = 1000;
        var offset = 0;

        while (true) {
            var batch = await getRawEventsPaginated(offset, batchSize);
            if (!batch || batch.length === 0) break;
            for (var i = 0; i < batch.length; i++) allEvents.push(batch[i]);
            offset += batch.length;
        }

        if (allEvents.length === 0) return false;

        if (encryptionEnabled && encryptionKey) {
            allEvents = await Promise.all(allEvents.map(function(e) { return decryptEventFromStorage(e); }));
        }

        // History lives in Matrix rooms only  AMO export contains current state only
        var binary = AmoFormat.produceEvents(allEvents, { tables: META_TABLES, fields: META_FIELDS });
        var apiKey = getBoxAmoApiKey();
        var url = BOX_AMO_UPLOAD_URL + '?api_key=' + encodeURIComponent(apiKey);
        var formData = new FormData();
        formData.append('file', new Blob([binary], { type: 'application/octet-stream' }), BOX_AMO_FILENAME);

        var uploadRes = await fetch(url, {
            method: 'POST',
            headers: { 'x-file-name': BOX_AMO_FILENAME, 'x-upload-reason': reason || 'scheduled' },
            body: formData
        });

        if (!uploadRes.ok) {
            throw new Error('Upload failed (' + uploadRes.status + ')');
        }

        localStorage.setItem('amino_box_amo_last_upload', String(Date.now()));
        return true;
    } finally {
        _boxAmoUploadInFlight = false;
    }
}

function startBoxAmoSnapshotUploads() {
    if (_boxAmoUploadTimer) return;

    var schedule = function(delay) {
        if (_boxAmoUploadTimer) clearTimeout(_boxAmoUploadTimer);
        _boxAmoUploadTimer = setTimeout(async function runUploadLoop() {
            _boxAmoUploadTimer = null;
            try {
                if (!document.hidden && navigator.onLine) {
                    await uploadAmoSnapshotToBox('scheduled');
                }
            } catch (err) {
                console.warn('[BoxAmo] Scheduled upload failed:', err.message || err);
            }
            schedule(BOX_AMO_UPLOAD_INTERVAL_MS);
        }, delay);
    };

    schedule(BOX_AMO_INITIAL_UPLOAD_DELAY_MS);

    window.addEventListener('beforeunload', function() {
        // Best-effort last save when user leaves.
        uploadAmoSnapshotToBox('beforeunload').catch(function() {});
    });
}

// ============ Sync Status Feed ============
// Terminal-style log for sync activity visibility

var SyncStatusFeed = {
    maxLines: 100,
    lines: [],
    isVisible: false,
    isActive: false,

    // Log a message to the feed
    log(message, type) {
        type = type || 'info';
        var timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        this.lines.push({ timestamp: timestamp, message: message, type: type });

        // Trim to max lines
        if (this.lines.length > this.maxLines) {
            this.lines = this.lines.slice(-this.maxLines);
        }

        this.render();
        this.updateButton();
    },

    info(message) { this.log(message, 'info'); },
    success(message) { this.log(message, 'success'); },
    error(message) { this.log(message, 'error'); },
    warn(message) { this.log(message, 'warn'); },

    // Set active state (sync in progress)
    setActive(active) {
        this.isActive = active;
        var dot = document.getElementById('sync-feed-status-dot');
        if (dot) {
            dot.className = 'sync-feed-status-dot' + (active ? ' active' : '');
        }
        this.updateStats();
        // Drive the status bar sync indicator
        if (typeof SyncIndicatorUI !== 'undefined') {
            SyncIndicatorUI.setState(active ? 'syncing' : 'synced');
        }
    },

    // Set error state
    setError() {
        var dot = document.getElementById('sync-feed-status-dot');
        if (dot) {
            dot.className = 'sync-feed-status-dot error';
        }
        if (typeof SyncIndicatorUI !== 'undefined') {
            SyncIndicatorUI.setState('error');
        }
    },

    // Update the sync indicator to show new activity
    updateButton() {
        var btn = document.getElementById('sync-feed-btn');
        if (btn && this.lines.length > 0) {
            btn.classList.add('has-activity');
        }
        // Also flash the sync indicator label briefly for new messages
        var labelEl = document.getElementById('sync-indicator-label');
        if (labelEl && this.lines.length > 0) {
            var lastLine = this.lines[this.lines.length - 1];
            if (lastLine && lastLine.type === 'error') {
                labelEl.textContent = 'Sync error';
            }
        }
    },

    // Update stats display
    updateStats() {
        var statsEl = document.getElementById('sync-feed-stats');
        if (statsEl) {
            statsEl.textContent = 'Idle';
        }
    },

    // Render the feed content
    render() {
        var body = document.getElementById('sync-feed-body');
        if (!body) return;

        if (this.lines.length === 0) {
            body.innerHTML = '<div class="sync-feed-empty">No sync activity yet</div>';
            return;
        }

        var html = '';
        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];
            html += '<div class="sync-feed-line ' + line.type + '">';
            html += '<span class="timestamp">' + line.timestamp + '</span>';
            html += '<span class="message">' + esc(line.message) + '</span>';
            html += '</div>';
        }
        body.innerHTML = html;

        // Auto-scroll to bottom
        body.scrollTop = body.scrollHeight;
    },

    // Show the panel
    show() {
        var panel = document.getElementById('sync-feed-panel');
        if (panel) {
            panel.classList.add('visible');
            this.isVisible = true;
            this.updateStats();
        }
    },

    // Hide the panel
    hide() {
        var panel = document.getElementById('sync-feed-panel');
        if (panel) {
            panel.classList.remove('visible');
            this.isVisible = false;
        }
    },

    // Toggle visibility
    toggle() {
        if (this.isVisible) {
            this.hide();
        } else {
            this.show();
        }
    },

    // Clear all lines
    clear() {
        this.lines = [];
        this.render();
        var btn = document.getElementById('sync-feed-btn');
        if (btn) btn.classList.remove('has-activity');
        // Reset sync indicator label
        if (typeof SyncIndicatorUI !== 'undefined') SyncIndicatorUI.setState('synced');
    }
};

// ============ Sync Banner ============
// Persistent banner below the status bar that shows during background sync/hydration.
// Unlike the status bar dot, this is highly visible and tells the user what's happening.

var SyncBanner = {
    _dismissed: false,
    _currentMode: null, // 'syncing' | 'error' | null

    show(message, opts) {
        opts = opts || {};
        this._dismissed = false;
        this._currentMode = opts.error ? 'error' : 'syncing';
        var banner = document.getElementById('sync-banner');
        var textEl = document.getElementById('sync-banner-text');
        var progressEl = document.getElementById('sync-banner-progress');
        var iconEl = document.getElementById('sync-banner-icon');
        if (!banner) return;

        textEl.textContent = message || 'Syncing data...';
        banner.classList.toggle('error', !!opts.error);

        if (opts.error) {
            iconEl.textContent = '\u26A0';
            iconEl.style.display = '';
        } else {
            iconEl.style.display = 'none';
        }

        if (typeof opts.progress === 'number') {
            progressEl.style.display = '';
            document.getElementById('sync-banner-progress-fill').style.width = Math.min(100, opts.progress) + '%';
        } else {
            progressEl.style.display = 'none';
        }

        banner.classList.add('visible');
    },

    updateProgress(progress, message) {
        if (this._dismissed) return;
        var progressEl = document.getElementById('sync-banner-progress');
        var fillEl = document.getElementById('sync-banner-progress-fill');
        var textEl = document.getElementById('sync-banner-text');
        if (progressEl && typeof progress === 'number') {
            progressEl.style.display = '';
            fillEl.style.width = Math.min(100, progress) + '%';
        }
        if (textEl && message) textEl.textContent = message;
    },

    hide() {
        var banner = document.getElementById('sync-banner');
        if (banner) banner.classList.remove('visible');
        this._currentMode = null;
    },

    dismiss() {
        this._dismissed = true;
        this.hide();
    }
};

// ============ Table Loading Overlay ============
// Semi-transparent overlay shown over the table grid during expensive operations
// (filter/sort on large datasets). Prevents the user from seeing a blank table.

var TableLoadingOverlay = {
    _timer: null,
    _visible: false,

    // Show overlay after a short delay (avoids flicker for fast operations)
    show(message, delay) {
        var self = this;
        delay = typeof delay === 'number' ? delay : 150;
        this.cancel();
        this._timer = setTimeout(function() {
            var overlay = document.getElementById('table-loading-overlay');
            var textEl = document.getElementById('table-loading-overlay-text');
            if (overlay) {
                if (textEl) textEl.textContent = message || 'Loading...';
                overlay.classList.add('visible');
                self._visible = true;
            }
        }, delay);
    },

    hide() {
        this.cancel();
        var overlay = document.getElementById('table-loading-overlay');
        if (overlay) overlay.classList.remove('visible');
        this._visible = false;
    },

    cancel() {
        if (this._timer) { clearTimeout(this._timer); this._timer = null; }
    }
};

// ============ Offline Queue Badge ============
// Shows a badge in the status bar when there are pending offline edits.

var OfflineBadgeUI = {
    _count: 0,

    async refresh() {
        if (typeof OfflineSyncQueue === 'undefined' || !db) return;
        try {
            var count = await OfflineSyncQueue.getCount();
            this._count = count;
            this._render();
        } catch (e) { /* ignore */ }
    },

    _render() {
        var badge = document.getElementById('offline-badge');
        var textEl = document.getElementById('offline-badge-text');
        if (!badge) return;

        if (this._count > 0) {
            badge.classList.add('visible');
            textEl.textContent = this._count + ' pending';
        } else {
            badge.classList.remove('visible');
        }
    },

    // Show syncing state while draining
    setSyncing(syncing) {
        var badge = document.getElementById('offline-badge');
        if (badge) badge.classList.toggle('syncing', syncing);
    }
};

// ============ Sync Indicator (Status Bar) ============
// Replaces the simple [log] button with a clear status indicator.

var SyncIndicatorUI = {
    _state: 'synced', // 'synced' | 'syncing' | 'error' | 'offline'

    setState(state, label) {
        this._state = state;
        var dot = document.getElementById('sync-indicator-dot');
        var labelEl = document.getElementById('sync-indicator-label');
        if (!dot) return;

        dot.className = 'sync-status-dot';
        switch (state) {
            case 'syncing':
                dot.classList.add('syncing');
                labelEl.textContent = label || 'Syncing...';
                break;
            case 'error':
                dot.classList.add('error');
                labelEl.textContent = label || 'Sync error';
                break;
            case 'offline':
                dot.classList.add('offline');
                labelEl.textContent = label || 'Offline';
                break;
            default:
                labelEl.textContent = label || 'Synced';
        }
    }
};

// ============ Sync History Tracker ============
// Tracks all sync operations for the Sync Status view

var SyncHistory = {
    maxEntries: 200,
    entries: [],
    pollInterval: null,
    POLL_INTERVAL: 15000, // 15 seconds - base poll interval
    MAX_POLL_INTERVAL: 300000, // 5 minutes - max backoff cap
    isPolling: false,
    consecutiveFailures: 0,
    currentPollInterval: 15000, // tracks the active interval (may be backed off)
    listeners: [],

    // Calculate next poll interval with exponential backoff + jitter
    getBackoffInterval() {
        if (this.consecutiveFailures === 0) return this.POLL_INTERVAL;
        // Exponential backoff: base * 2^failures, capped at MAX_POLL_INTERVAL
        var exponential = this.POLL_INTERVAL * Math.pow(2, this.consecutiveFailures);
        var capped = Math.min(exponential, this.MAX_POLL_INTERVAL);
        // Add jitter: +/- 20% to avoid thundering herd
        var jitter = capped * 0.2 * (Math.random() * 2 - 1);
        return Math.round(capped + jitter);
    },

    // Record a sync operation
    record(entry) {
        this.entries.unshift({
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 5),
            timestamp: new Date(),
            type: entry.type || 'incremental',    // 'incremental', 'full', 'snapshot', 'poll'
            result: entry.result || 'success',      // 'success', 'error', 'no-change'
            eventsFound: entry.eventsFound || 0,
            snapshotsUpdated: entry.snapshotsUpdated || 0,
            duration: entry.duration || 0,
            detail: entry.detail || '',
            error: entry.error || null
        });
        if (this.entries.length > this.maxEntries) {
            this.entries = this.entries.slice(0, this.maxEntries);
        }
        this.notify();
    },

    // Poll for new events via n8n webhook API (incremental sync)
    async pollForUpdates() {
        var startTime = Date.now();
        try {
            var updated = await webhookIncrementalSync();
            var duration = Date.now() - startTime;

            if (updated > 0) {
                this.consecutiveFailures = 0;
                this.record({
                    type: 'poll',
                    result: 'success',
                    eventsFound: updated,
                    duration: duration,
                    detail: 'Webhook poll: ' + updated + ' records updated'
                });
                // Re-render current view
                if (currentTable) {
                    await showTable(currentTable, true);
                }
                await renderSidebar(false);
            } else {
                this.record({
                    type: 'poll',
                    result: 'no-change',
                    eventsFound: 0,
                    duration: duration,
                    detail: 'Webhook poll: no changes'
                });
            }

            if (this.isPolling) this.scheduleNextPoll();
        } catch (err) {
            var duration = Date.now() - startTime;
            this.consecutiveFailures++;
            this.currentPollInterval = this.getBackoffInterval();
            this.record({
                type: 'poll',
                result: 'error',
                eventsFound: 0,
                duration: duration,
                error: err.message,
                detail: 'Webhook poll failed: ' + err.message
            });
            if (this.isPolling) this.scheduleNextPoll();
        }
    },

    // Schedule the next poll using setTimeout (allows dynamic interval changes)
    scheduleNextPoll() {
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
        }
        var interval = this.consecutiveFailures > 0 ? this.currentPollInterval : this.POLL_INTERVAL;
        this.currentPollInterval = interval;
        this.pollInterval = setTimeout(() => this.pollForUpdates(), interval);
    },

    // Start background polling
    startPolling() {
        if (this.isPolling) return;
        this.isPolling = true;
        this.consecutiveFailures = 0;
        this.currentPollInterval = this.POLL_INTERVAL;
        this.scheduleNextPoll();
        this.record({ type: 'poll', result: 'no-change', detail: 'Webhook polling started (' + (this.POLL_INTERVAL / 1000) + 's interval)' });
    },

    // Stop background polling
    stopPolling() {
        this.isPolling = false;
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
            this.pollInterval = null;
            this.consecutiveFailures = 0;
            this.currentPollInterval = this.POLL_INTERVAL;
            this.record({ type: 'poll', result: 'no-change', detail: 'Webhook polling stopped' });
        }
    },

    // Get summary stats
    getStats() {
        var now = Date.now();
        var last5min = this.entries.filter(e => (now - e.timestamp.getTime()) < 300000);
        var lastHour = this.entries.filter(e => (now - e.timestamp.getTime()) < 3600000);
        var errors = this.entries.filter(e => e.result === 'error');
        var totalEvents = this.entries.reduce((sum, e) => sum + (e.eventsFound || 0), 0);
        var totalSnapshots = this.entries.reduce((sum, e) => sum + (e.snapshotsUpdated || 0), 0);
        var lastSync = this.entries.find(e => e.type !== 'poll' && e.result === 'success');
        var lastPoll = this.entries.find(e => e.type === 'poll');

        var edits = this.entries.filter(e => e.type === 'edit');
        var successfulEdits = edits.filter(e => e.result === 'success');
        var failedEdits = edits.filter(e => e.result === 'error');
        var totalFieldsEdited = successfulEdits.reduce((sum, e) => sum + (e.eventsFound || 0), 0);

        return {
            totalSyncs: this.entries.filter(e => e.type !== 'poll' && e.type !== 'edit').length,
            totalPolls: this.entries.filter(e => e.type === 'poll').length,
            totalEdits: edits.length,
            successfulEdits: successfulEdits.length,
            failedEdits: failedEdits.length,
            totalFieldsEdited: totalFieldsEdited,
            last5minOps: last5min.length,
            lastHourOps: lastHour.length,
            totalEventsProcessed: totalEvents,
            totalSnapshotsUpdated: totalSnapshots,
            errorCount: errors.length,
            lastSyncTime: lastSync ? lastSync.timestamp : null,
            lastPollTime: lastPoll ? lastPoll.timestamp : null,
            isPolling: this.isPolling
        };
    },

    // Subscribe to changes (for live UI updates)
    onChange(fn) {
        this.listeners.push(fn);
        return () => { this.listeners = this.listeners.filter(l => l !== fn); };
    },

    notify() {
        this.listeners.forEach(fn => { try { fn(); } catch(e) {} });
    }
};

// ============ Offline Sync Queue ============
// Persists failed edits to IndexedDB so they survive page reloads and can be
// retried when the network comes back. Exposes a count for the sync status UI.

var OfflineSyncQueue = {
    _draining: false,
    _listeners: [],
    MAX_RETRIES: 5,

    // Enqueue a failed edit into the pendingEdits store
    async enqueue(tableId, recordId, fieldChanges, errorMessage) {
        var entry = {
            tableId: tableId,
            recordId: recordId,
            fieldChanges: fieldChanges,
            status: 'pending',      // pending | retrying | failed
            retries: 0,
            error: errorMessage || 'Unknown error',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        await new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readwrite');
            tx.objectStore('pendingEdits').add(entry);
            tx.oncomplete = function() { resolve(); };
            tx.onerror = function() { reject(tx.error); };
        });
        this._notify();
        if (typeof OfflineBadgeUI !== 'undefined') OfflineBadgeUI.refresh();
        SyncStatusFeed.warn('Edit queued offline: ' + recordId + '  will retry when online');
    },

    // Get all pending entries
    async getAll() {
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readonly');
            var req = tx.objectStore('pendingEdits').getAll();
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });
    },

    // Get count of pending entries
    async getCount() {
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readonly');
            var req = tx.objectStore('pendingEdits').count();
            req.onsuccess = function() { resolve(req.result || 0); };
            req.onerror = function() { reject(req.error); };
        });
    },

    // Remove a successfully synced entry by id
    async remove(id) {
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readwrite');
            tx.objectStore('pendingEdits').delete(id);
            tx.oncomplete = function() { resolve(); };
            tx.onerror = function() { reject(tx.error); };
        });
    },

    // Update an entry (e.g. bump retries, mark failed)
    async _update(entry) {
        entry.updatedAt = new Date().toISOString();
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('pendingEdits', 'readwrite');
            tx.objectStore('pendingEdits').put(entry);
            tx.oncomplete = function() { resolve(); };
            tx.onerror = function() { reject(tx.error); };
        });
    },

    // Drain the queue: attempt to replay all pending edits
    async drain() {
        if (this._draining) return;
        this._draining = true;

        try {
            var entries = await this.getAll();
            var pending = entries.filter(function(e) { return e.status === 'pending'; });
            if (pending.length === 0) { this._draining = false; return; }

            SyncStatusFeed.info('Draining offline queue: ' + pending.length + ' edit' + (pending.length !== 1 ? 's' : '') + ' to retry');
            if (typeof OfflineBadgeUI !== 'undefined') OfflineBadgeUI.setSyncing(true);

            var _syncedCount = 0;
            var _failedCount = 0;

            for (var i = 0; i < pending.length; i++) {
                var entry = pending[i];
                entry.status = 'retrying';
                entry.retries++;
                await this._update(entry);
                this._notify();

                try {
                    var session = _loadSynapseSession();
                    if (!session || !session.accessToken) throw new Error('Not authenticated');

                    var writeUrl = WRITE_API_BASE;
                    var writeBody = JSON.stringify({
                        tableId: entry.tableId,
                        recordId: entry.recordId,
                        fields: entry.fieldChanges,
                        access_token: session.accessToken
                    });

                    var response = await fetch(
                        writeUrl + '?access_token=' + encodeURIComponent(session.accessToken),
                        { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: writeBody }
                    );

                    if (!response.ok) throw new Error('Server returned ' + response.status);

                    var result = await response.json();

                    // Update local store with canonical data
                    if (result.fields) {
                        await saveDataRecord({ tableId: entry.tableId, recordId: entry.recordId, fields: result.fields });
                        if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[entry.tableId] && window.IN_MEMORY_DATA[entry.tableId][entry.recordId]) {
                            window.IN_MEMORY_DATA[entry.tableId][entry.recordId] = result.fields;
                        }
                        window.dispatchEvent(new CustomEvent('amino:record-updated', {
                            detail: { recordId: entry.recordId, tableId: entry.tableId, fields: result.fields, optimistic: false }
                        }));
                    }

                    // Success  remove from queue
                    await this.remove(entry.id);
                    SyncHistory.record({
                        type: 'edit',
                        result: 'success',
                        eventsFound: Object.keys(entry.fieldChanges).length,
                        duration: 0,
                        detail: 'Queued edit replayed: ' + entry.recordId
                    });
                    SyncStatusFeed.success('Queued edit synced: ' + entry.recordId);
                    _syncedCount++;

                } catch (retryErr) {
                    if (entry.retries >= this.MAX_RETRIES) {
                        entry.status = 'failed';
                        entry.error = retryErr.message;
                        await this._update(entry);
                        SyncStatusFeed.error('Queued edit permanently failed after ' + entry.retries + ' retries: ' + entry.recordId);
                        _failedCount++;
                    } else {
                        entry.status = 'pending';
                        entry.error = retryErr.message;
                        await this._update(entry);
                    }
                }
                this._notify();
            }

            // Show summary toast if the user has sync toasts enabled
            if (UserPreferences.get('showOfflineSyncToasts')) {
                if (_syncedCount > 0 && _failedCount === 0) {
                    showToast('success', _syncedCount + ' offline edit' + (_syncedCount !== 1 ? 's' : '') + ' synced');
                } else if (_syncedCount > 0 && _failedCount > 0) {
                    showToast('warning', _syncedCount + ' edit' + (_syncedCount !== 1 ? 's' : '') + ' synced, ' + _failedCount + ' failed');
                } else if (_failedCount > 0) {
                    showToast('error', _failedCount + ' offline edit' + (_failedCount !== 1 ? 's' : '') + ' failed to sync');
                }
            }
        } finally {
            this._draining = false;
            this._notify();
            if (typeof OfflineBadgeUI !== 'undefined') { OfflineBadgeUI.setSyncing(false); OfflineBadgeUI.refresh(); }
        }
    },

    // Discard a specific queued entry (user action)
    async discard(id) {
        await this.remove(id);
        this._notify();
        if (typeof OfflineBadgeUI !== 'undefined') OfflineBadgeUI.refresh();
        SyncStatusFeed.info('Queued edit discarded');
    },

    // Discard all queued entries
    async discardAll() {
        var entries = await this.getAll();
        for (var i = 0; i < entries.length; i++) {
            await this.remove(entries[i].id);
        }
        this._notify();
        if (typeof OfflineBadgeUI !== 'undefined') OfflineBadgeUI.refresh();
        SyncStatusFeed.info('All queued edits discarded');
    },

    // Listener management
    onChange(fn) {
        this._listeners.push(fn);
        return function() { OfflineSyncQueue._listeners = OfflineSyncQueue._listeners.filter(function(l) { return l !== fn; }); };
    },

    _notify() {
        this._listeners.forEach(function(fn) { try { fn(); } catch(e) {} });
    }
};

// ============ Online/Offline Detection for Queue Drain ============

window.addEventListener('online', function() {
    SyncStatusFeed.info('Network connection restored');
    SyncIndicatorUI.setState('synced', 'Online');
    // Auto-drain offline queue when back online
    if (db) {
        OfflineSyncQueue.drain();
    }
});

window.addEventListener('offline', function() {
    SyncStatusFeed.warn('Network connection lost  edits will be queued locally');
    SyncIndicatorUI.setState('offline');
});

// ============ Post-Hydration Auto-Poll (Deprecated) ============
// No longer needed  Matrix /sync handles incremental updates after initial hydration.
var PostHydrationSync = {
    isRunning: false,
    start() { /* no-op: Matrix /sync handles post-hydration updates */ },
    stop() { this.isRunning = false; }
};


// ============ IndexedDB ============

function openDB() {
    return new Promise((resolve, reject) => {
        var req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve(req.result);
        req.onupgradeneeded = (e) => {
            var db = e.target.result;

            // Delete old stores if they exist
            if (db.objectStoreNames.contains('records')) {
                db.deleteObjectStore('records');
            }
            if (db.objectStoreNames.contains('meta')) {
                db.deleteObjectStore('meta');
            }

            // Data records: keyed by [tableId, recordId]
            if (!db.objectStoreNames.contains('data')) {
                var dataStore = db.createObjectStore('data', { keyPath: ['tableId', 'recordId'] });
                dataStore.createIndex('by_table', 'tableId');
            }

            // Table metadata
            if (!db.objectStoreNames.contains('tables')) {
                db.createObjectStore('tables', { keyPath: 'tableId' });
            }

            // Field metadata: keyed by [tableId, fieldId]
            if (!db.objectStoreNames.contains('fields')) {
                var fieldStore = db.createObjectStore('fields', { keyPath: ['tableId', 'fieldId'] });
                fieldStore.createIndex('by_table', 'tableId');
            }

            // View metadata: keyed by [tableId, viewId]
            if (!db.objectStoreNames.contains('views')) {
                var viewStore = db.createObjectStore('views', { keyPath: ['tableId', 'viewId'] });
                viewStore.createIndex('by_table', 'tableId');
            }

            // Field history: keyed by auto-increment, indexed by record and field
            if (!db.objectStoreNames.contains('fieldHistory')) {
                var historyStore = db.createObjectStore('fieldHistory', { keyPath: 'id', autoIncrement: true });
                historyStore.createIndex('by_record', ['tableId', 'recordId']);
                historyStore.createIndex('by_field', ['tableId', 'recordId', 'fieldId']);
                historyStore.createIndex('by_event', 'eventId');
            }

            // View folders: keyed by folderId
            if (!db.objectStoreNames.contains('viewFolders')) {
                var folderStore = db.createObjectStore('viewFolders', { keyPath: 'folderId' });
                folderStore.createIndex('by_table', 'tableId');
            }

            // Workspaces: keyed by workspaceId
            if (!db.objectStoreNames.contains('workspaces')) {
                db.createObjectStore('workspaces', { keyPath: 'workspaceId' });
            }

            // Sync state
            if (!db.objectStoreNames.contains('sync')) {
                db.createObjectStore('sync', { keyPath: 'key' });
            }

            // Raw events: keyed by event id, indexed by set and recordId
            if (!db.objectStoreNames.contains('events')) {
                var eventsStore = db.createObjectStore('events', { keyPath: 'id' });
                eventsStore.createIndex('by_set', 'set');
                eventsStore.createIndex('by_record', 'recordId');
                eventsStore.createIndex('by_timestamp', 'created_at');
            }

            // Snapshot: materialized current state, keyed by record_id
            if (!db.objectStoreNames.contains('snapshot')) {
                var snapshotStore = db.createObjectStore('snapshot', { keyPath: 'record_id' });
                snapshotStore.createIndex('by_source_table', 'source_table');
                snapshotStore.createIndex('by_last_amino_event', 'last_amino_event');
            }

            // User preferences: per-user settings keyed by preference key
            if (!db.objectStoreNames.contains('userPreferences')) {
                db.createObjectStore('userPreferences', { keyPath: 'key' });
            }

            // Shared views: views shared with/by users, keyed by [tableId, viewId]
            if (!db.objectStoreNames.contains('sharedViews')) {
                var sharedViewStore = db.createObjectStore('sharedViews', { keyPath: ['tableId', 'viewId'] });
                sharedViewStore.createIndex('by_table', 'tableId');
                sharedViewStore.createIndex('by_owner', 'ownerId');
                sharedViewStore.createIndex('by_sharing', 'sharing');
            }

            // Pending edits: offline queue for edits that failed to sync to cloud
            if (!db.objectStoreNames.contains('pendingEdits')) {
                var pendingStore = db.createObjectStore('pendingEdits', { keyPath: 'id', autoIncrement: true });
                pendingStore.createIndex('by_table', 'tableId');
                pendingStore.createIndex('by_record', ['tableId', 'recordId']);
                pendingStore.createIndex('by_status', 'status');
            }

            // Edges: derived link graph between tables, built from multipleRecordLinks field metadata
            if (!db.objectStoreNames.contains('edges')) {
                var edgesStore = db.createObjectStore('edges', { keyPath: 'edgeId' });
                edgesStore.createIndex('by_from', 'fromTableId');
                edgesStore.createIndex('by_to', 'toTableId');
                edgesStore.createIndex('by_field', ['fromTableId', 'fieldId']);
            }
        };
    });
}

function getSyncMeta(key) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readonly');
        var req = tx.objectStore('sync').get(key);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
        req.onerror = () => reject(req.error);
    });
}

function setSyncMeta(key, value) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readwrite');
        tx.objectStore('sync').put({ key, value });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// ============ Events Store Functions ============

// Encrypt event payloads for storage
async function encryptEventForStorage(event) {
    if (!encryptionEnabled || !encryptionKey || !event.payload) {
        return event;
    }
    // Deferred encryption: store plaintext during active session, encrypt on logout
    if (_deferEncryptionUI) {
        return event;
    }
    var encrypted = { ...event };
    encrypted._encryptedPayload = await encryptData(event.payload, encryptionKey);
    delete encrypted.payload;
    return encrypted;
}

// Decrypt event payload after retrieval
// Handles both plaintext (deferred-encryption mode) and encrypted formats.
// Always attempt decryption if the event has _encryptedPayload and a key is available,
// regardless of the current encryptionEnabled flag.  This ensures events encrypted in
// a previous session are still readable after encryption settings change.
async function decryptEventFromStorage(event) {
    if (!event) return event;
    // Plaintext event (deferred-encryption mode or leftover from crash)  return as-is
    if (event.payload && !event._encryptedPayload) {
        return event;
    }
    if (!event._encryptedPayload || !encryptionKey) {
        return event;
    }
    try {
        var decrypted = { ...event };
        decrypted.payload = await decryptData(event._encryptedPayload, encryptionKey);
        delete decrypted._encryptedPayload;
        return decrypted;
    } catch (e) {
        console.warn('[decryptEvent] Failed to decrypt event', event.id, e);
        return event;
    }
}

// Encrypt data record fields for storage
async function encryptRecordForStorage(record) {
    if (!encryptionEnabled || !encryptionKey || !record.fields) {
        return record;
    }
    // Deferred encryption: store plaintext during active session, encrypt on logout
    if (_deferEncryptionUI) {
        return record;
    }
    var encrypted = { ...record };
    encrypted._encryptedFields = await encryptData(record.fields, encryptionKey);
    delete encrypted.fields;
    return encrypted;
}

// Decrypt data record fields after retrieval
// Handles both plaintext (deferred-encryption mode) and encrypted formats.
// Always attempt decryption if the record has _encryptedFields and a key is available,
// regardless of the current encryptionEnabled flag.
async function decryptRecordFromStorage(record) {
    if (!record) return record;
    // Plaintext record (deferred-encryption mode or leftover from crash)  return as-is
    if (record.fields && !record._encryptedFields) {
        return record;
    }
    if (!record._encryptedFields || !encryptionKey) {
        return record;
    }
    try {
        var decrypted = { ...record };
        decrypted.fields = await decryptData(record._encryptedFields, encryptionKey);
        delete decrypted._encryptedFields;
        return decrypted;
    } catch (e) {
        console.warn('[decryptRecord] Failed to decrypt record', record.recordId, e);
        return record;
    }
}

async function saveRawEvents(events) {
    if (!events || events.length === 0) return;

    // Encrypt events if encryption is enabled
    var eventsToStore = events;
    if (encryptionEnabled && encryptionKey) {
        eventsToStore = await Promise.all(events.map(e => encryptEventForStorage(e)));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readwrite');
        var store = tx.objectStore('events');
        eventsToStore.forEach(e => store.put(e));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// ============ Encrypt-on-Logout: Bulk Encryption ============

// Encrypt all plaintext data records and events in the UI IndexedDB.
// Called on logout to ensure data-at-rest is encrypted.
// Processes in batches to avoid memory pressure.
async function encryptAllUIRecords() {
    if (!db || !encryptionKey) return 0;
    var BATCH_SIZE = 200;
    var encrypted = 0;

    //  Encrypt plaintext data records 
    try {
        var allRecords = await new Promise(function(resolve, reject) {
            var tx = db.transaction('data', 'readonly');
            var req = tx.objectStore('data').getAll();
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });

        for (var b = 0; b < allRecords.length; b += BATCH_SIZE) {
            var batch = allRecords.slice(b, b + BATCH_SIZE);
            var writeTx = db.transaction('data', 'readwrite');
            var store = writeTx.objectStore('data');
            for (var i = 0; i < batch.length; i++) {
                var rec = batch[i];
                // Only encrypt records that have plaintext fields (not already encrypted)
                if (rec.fields && !rec._encryptedFields) {
                    rec._encryptedFields = await encryptData(rec.fields, encryptionKey);
                    delete rec.fields;
                    store.put(rec);
                    encrypted++;
                }
            }
            await new Promise(function(resolve, reject) {
                writeTx.oncomplete = resolve;
                writeTx.onerror = function() { reject(writeTx.error); };
            });
        }
    } catch (e) {
        console.error('[encryptAllUIRecords] Failed to encrypt data records:', e);
    }

    //  Encrypt plaintext events 
    try {
        var allEvents = await new Promise(function(resolve, reject) {
            var tx = db.transaction('events', 'readonly');
            var req = tx.objectStore('events').getAll();
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });

        for (var eb = 0; eb < allEvents.length; eb += BATCH_SIZE) {
            var evBatch = allEvents.slice(eb, eb + BATCH_SIZE);
            var evWriteTx = db.transaction('events', 'readwrite');
            var evStore = evWriteTx.objectStore('events');
            for (var ei = 0; ei < evBatch.length; ei++) {
                var evt = evBatch[ei];
                // Only encrypt events that have plaintext payload (not already encrypted)
                if (evt.payload && !evt._encryptedPayload) {
                    evt._encryptedPayload = await encryptData(evt.payload, encryptionKey);
                    delete evt.payload;
                    evStore.put(evt);
                    encrypted++;
                }
            }
            await new Promise(function(resolve, reject) {
                evWriteTx.oncomplete = resolve;
                evWriteTx.onerror = function() { reject(evWriteTx.error); };
            });
        }
    } catch (e) {
        console.error('[encryptAllUIRecords] Failed to encrypt events:', e);
    }

    console.log('[Amino] Encrypted', encrypted, 'plaintext records/events on logout');
    return encrypted;
}

async function getAllRawEvents(limit, offset) {
    var maxLimit = limit || 100;
    var startOffset = offset || 0;

    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        // Events are sorted by ID ascending, we want newest first (descending)
        // Iterate in reverse and collect only the slice we need (avoids copying entire array)
        var results = [];
        var end = inMemoryEvents.length - 1 - startOffset;
        var start = Math.max(end - maxLimit + 1, 0);
        for (var i = end; i >= start && results.length < maxLimit; i--) {
            results.push(inMemoryEvents[i]);
        }
        return results;
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;
        var collected = 0;

        // Use a cursor to iterate in reverse order (newest first)
        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor && collected < maxLimit) {
                if (skipped < startOffset) {
                    skipped++;
                    cursor.continue();
                } else {
                    results.push(cursor.value);
                    collected++;
                    cursor.continue();
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if any have encrypted payloads and a key is available
    if (encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getRawEventsCount() {
    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        return Promise.resolve(inMemoryEvents.length);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var req = tx.objectStore('events').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

async function getRawEventsByRecordId(recordId, maxEventId) {
    // Check in-memory events first (from CSV import)
    if (inMemoryEventsByRecord && inMemoryEventsByRecord.has(recordId)) {
        var results = inMemoryEventsByRecord.get(recordId).slice();
        if (maxEventId) {
            results = results.filter(e => e.id <= maxEventId);
        }
        results.sort((a, b) => (a.id || 0) - (b.id || 0));
        return results;
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var index = tx.objectStore('events').index('by_record');
        var req = index.getAll(recordId);
        req.onsuccess = () => {
            var results = req.result || [];
            // Filter to events up to maxEventId and sort by id ascending
            if (maxEventId) {
                results = results.filter(e => e.id <= maxEventId);
            }
            results.sort((a, b) => (a.id || 0) - (b.id || 0));
            resolve(results);
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if any have encrypted payloads and a key is available
    if (encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getRawEventsBySet(setFilter) {
    // DEPRECATED: Use getRawEventsBySetPaginated instead
    return getRawEventsBySetPaginated(setFilter, 0, 500);
}

// Memory-efficient paginated events by set retrieval
async function getRawEventsBySetPaginated(setFilter, offset, limit) {
    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        var filtered = [];
        for (var i = inMemoryEvents.length - 1; i >= 0; i--) {
            if (inMemoryEvents[i].set === setFilter) {
                filtered.push(inMemoryEvents[i]);
            }
        }
        return filtered.slice(offset, offset + limit);
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var index = tx.objectStore('events').index('by_set');

        // Get all matching, then sort and paginate
        // Note: IndexedDB index doesn't support ordering by different field, so we collect and sort
        var req = index.getAll(setFilter);
        req.onsuccess = () => {
            var all = req.result || [];
            all.sort((a, b) => new Date(b.created_at || 0).getTime() - new Date(a.created_at || 0).getTime()); // Newest first by timestamp
            // Apply pagination
            resolve(all.slice(offset, offset + limit));
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if any have encrypted payloads and a key is available
    if (encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

async function searchRawEvents(query, limit, offset) {
    var maxLimit = limit || 100;
    var skipCount = offset || 0;
    var lowerQuery = query.toLowerCase();

    // Shared match helper  avoids repeating logic in both code paths.
    // Combines recordId + set + payload into a single string for one indexOf call.
    function eventMatchesQuery(event) {
        var combined = (event.recordId || '') + ' ' + (event.set || '') + ' ' +
            (typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload || ''));
        return combined.toLowerCase().indexOf(lowerQuery) !== -1;
    }

    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        var results = [];
        var skipped = 0;
        for (var i = inMemoryEvents.length - 1; i >= 0 && results.length < maxLimit; i--) {
            if (eventMatchesQuery(inMemoryEvents[i])) {
                if (skipped < skipCount) {
                    skipped++;
                } else {
                    results.push(inMemoryEvents[i]);
                }
            }
        }
        return results;
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;

        var index = store.index('by_timestamp');
        var req = index.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                if (eventMatchesQuery(cursor.value)) {
                    if (skipped < skipCount) {
                        skipped++;
                        cursor.continue();
                    } else if (results.length < maxLimit) {
                        results.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                } else {
                    cursor.continue();
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if any have encrypted payloads and a key is available
    if (encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getMaxEventId() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var req = store.openCursor(null, 'prev'); // Open cursor in reverse to get highest ID first
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                resolve(cursor.value.id || 0);
            } else {
                resolve(0); // No events
            }
        };
        req.onerror = () => reject(req.error);
    });
}

function getAllRawEventsNoPagination() {
    // DEPRECATED: Use getRawEventsPaginated instead to avoid memory issues
    return getRawEventsPaginated(0, 500); // Return max 500 events
}

// Memory-efficient paginated events retrieval using IndexedDB cursor
async function getRawEventsPaginated(offset, limit) {
    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;

        // Use by_timestamp index in reverse order (newest first, most recent timestamp first)
        var index = store.index('by_timestamp');
        var req = index.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                if (skipped < offset) {
                    skipped++;
                    cursor.continue();
                } else if (results.length < limit) {
                    results.push(cursor.value);
                    cursor.continue();
                } else {
                    resolve(results);
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if any have encrypted payloads and a key is available
    if (encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

// Get total count of raw events
function getRawEventsTotalCount() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var req = tx.objectStore('events').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

// Get all current records from all tables as synthetic event-like objects
// DEPRECATED: Use getCurrentRecordsPaginated instead to avoid memory issues
function getAllCurrentRecords() {
    return getCurrentRecordsPaginated(0, 500); // Return max 500 records
}

// Memory-efficient paginated current records retrieval.
// Pre-builds search text per record to avoid repeated collectSearchableText() calls.
function getCurrentRecordsPaginated(offset, limit, tableFilter, searchQuery) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var results = [];
        var skipped = 0;
        var setFilter = tableFilter || null;
        var searchTokens = normalizeSearchTokens(searchQuery);

        var req = store.openCursor();
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                var rec = cursor.value;
                var setVal = 'airtable:' + rec.tableId;

                // Apply table filter if set
                if (setFilter && setVal !== setFilter) {
                    cursor.continue();
                    return;
                }

                // Apply search filter using pre-built search text
                if (searchTokens.length) {
                    var searchText = getLocalSearchText(
                        rec.tableId,
                        rec.recordId,
                        { recordId: rec.recordId, fields: rec.fields || {} }
                    );
                    // Also include set value in search
                    var combined = searchText + ' ' + setVal.toLowerCase();
                    var hit = true;
                    for (var ti = 0; ti < searchTokens.length; ti++) {
                        if (combined.indexOf(searchTokens[ti]) === -1) { hit = false; break; }
                    }
                    if (!hit) {
                        cursor.continue();
                        return;
                    }
                }

                if (skipped < offset) {
                    skipped++;
                    cursor.continue();
                } else if (results.length < limit) {
                    results.push({
                        id: 0,
                        recordId: rec.recordId,
                        set: setVal,
                        payload: JSON.stringify({
                            _set: 'current',
                            fields: { INS: rec.fields }
                        }),
                        created_at: null,
                        _isCurrentState: true
                    });
                    cursor.continue();
                } else {
                    resolve(results);
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

// Get count of all current records
function getCurrentRecordsCount() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var req = tx.objectStore('data').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

function getAllTables() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readonly');
        var req = tx.objectStore('tables').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getFieldsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var index = tx.objectStore('fields').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getViewsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var index = tx.objectStore('views').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllViews() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var req = tx.objectStore('views').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllFields() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var req = tx.objectStore('fields').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Query schema elements by recordId prefix
function getSchemaByPrefix(prefix) {
    // Returns tables (tbl*), fields (fld*), or views (viw*) based on prefix
    return new Promise(async (resolve) => {
        var results = [];
        if (prefix === 'tbl') {
            var tables = await getAllTables();
            results = tables.filter(t => t.tableId && t.tableId.startsWith('tbl'));
        } else if (prefix === 'fld') {
            var fields = await getAllFields();
            results = fields.filter(f => f.fieldId && f.fieldId.startsWith('fld'));
        } else if (prefix === 'viw') {
            var views = await getAllViews();
            results = views.filter(v => v.viewId && v.viewId.startsWith('viw'));
        }
        resolve(results);
    });
}

function getRecordIdsForTable(tableId) {
    // Collect record IDs from both in-memory data and IndexedDB, merging them.
    // IN_MEMORY_DATA (from Box AMO) may have fewer records than IDB
    // (from Postgres webhook hydration or previous sessions).
    var memIds = {};
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        var keys = Object.keys(window.IN_MEMORY_DATA[tableId]);
        for (var i = 0; i < keys.length; i++) memIds[keys[i]] = true;
    }

    // Online-only mode: use memory only, skip IndexedDB
    if (_isOnlineOnlyMode() || typeof db === 'undefined' || !db) {
        return Promise.resolve(Object.keys(memIds));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var index = tx.objectStore('data').index('by_table');
        var req = index.getAllKeys(tableId);
        req.onsuccess = () => {
            // Keys are [tableId, recordId], extract recordIds.
            // Filter to rec* only  IDB may contain stale fld*/viw* entries
            // from before the hydration filter was added.
            var idbIds = (req.result || []).map(k => k[1]).filter(id => id.startsWith('rec'));
            // Merge IDB record IDs with in-memory IDs
            for (var j = 0; j < idbIds.length; j++) {
                memIds[idbIds[j]] = true;
            }
            resolve(Object.keys(memIds));
        };
        req.onerror = () => reject(req.error);
    });
}

// Record count combining in-memory and IndexedDB sources
function getRecordCountForTable(tableId) {
    var memCount = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId])
        ? Object.keys(window.IN_MEMORY_DATA[tableId]).length : 0;

    // Online-only mode: use memory count only
    if (_isOnlineOnlyMode() || typeof db === 'undefined' || !db) {
        return Promise.resolve(memCount);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var index = tx.objectStore('data').index('by_table');
        var req = index.count(tableId);
        req.onsuccess = () => resolve(Math.max(req.result || 0, memCount));
        req.onerror = () => resolve(memCount); // Fall back to memory count on error
    });
}

async function getRecord(tableId, recordId) {
    // Check in-memory data first (from CSV import or online-only hydration)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
        return {
            tableId: tableId,
            recordId: recordId,
            fields: window.IN_MEMORY_DATA[tableId][recordId]
        };
    }

    // Online-only mode: fetch single record from API when not in memory
    if (_isOnlineOnlyMode()) {
        try {
            var data = await webhookFetch('/amino-records?tableId=' + encodeURIComponent(tableId));
            var records = data.records || [];
            // Populate IN_MEMORY_DATA for all fetched records from this table
            if (!window.IN_MEMORY_DATA) window.IN_MEMORY_DATA = {};
            if (!window.IN_MEMORY_DATA[tableId]) window.IN_MEMORY_DATA[tableId] = {};
            for (var ri = 0; ri < records.length; ri++) {
                var rec = records[ri];
                if (rec.id && rec.fields) {
                    window.IN_MEMORY_DATA[tableId][rec.id] = rec.fields;
                }
            }
            if (window.IN_MEMORY_DATA[tableId][recordId]) {
                return {
                    tableId: tableId,
                    recordId: recordId,
                    fields: window.IN_MEMORY_DATA[tableId][recordId]
                };
            }
        } catch (e) {
            console.warn('[getRecord] Online-only API fetch failed:', e.message || e);
        }
        return null;
    }

    var result = await new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var req = tx.objectStore('data').get([tableId, recordId]);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
    });

    // Decrypt record if needed  use encryptionKey alone (not encryptionEnabled)
    // so records encrypted during a previous session's logout are still readable.
    if (result && encryptionKey) {
        return decryptRecordFromStorage(result);
    }
    return result;
}

// Multi-table record cache  keeps recently fetched records in memory so that
// re-renders (same page, filter tweaks, view toggles, table back-nav) avoid
// hitting IndexedDB.  Keyed by "tableId|recordId" and supports records from
// multiple tables simultaneously.
// Uses a Map for LRU eviction: on access, delete+re-set moves the entry to
// the end; on eviction, the oldest entries (front of iteration order) are removed.
var _recordCache = new Map();  // key: "tableId|recordId" -> record object
var _recordCacheTable = null;
var _RECORD_CACHE_MAX = 2000; // cap to avoid unbounded growth (raised from 600 for fewer IDB reads)
function _rcKey(tid, rid) { return tid + '|' + rid; }
function clearRecordCache() { _recordCache = new Map(); _recordCacheTable = null; invalidateLocalSearchIndex(); }

async function getRecordsByIds(tableId, recordIds) {
    if (!recordIds.length) return [];

    // Track current table (no longer evicts  cache is multi-table now)
    _recordCacheTable = tableId;

    // Serve from cache where possible, only fetch missing IDs.
    // On cache hit, delete+re-set to move the entry to the end (LRU refresh).
    var cached = [];
    var missingForCache = [];
    for (var ci = 0; ci < recordIds.length; ci++) {
        var ck = _rcKey(tableId, recordIds[ci]);
        var cachedRec = _recordCache.get(ck);
        if (cachedRec) {
            // LRU refresh: move to end of Map iteration order
            _recordCache.delete(ck);
            _recordCache.set(ck, cachedRec);
            cached.push(cachedRec);
        } else {
            missingForCache.push(recordIds[ci]);
        }
    }
    if (missingForCache.length === 0) return cached;

    // Check in-memory data first (from CSV import)  only for missing IDs
    var fetched = [];
    var stillMissing = missingForCache;
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        var afterMem = [];
        for (var i = 0; i < stillMissing.length; i++) {
            var rid = stillMissing[i];
            if (window.IN_MEMORY_DATA[tableId][rid]) {
                fetched.push({
                    tableId: tableId,
                    recordId: rid,
                    fields: window.IN_MEMORY_DATA[tableId][rid]
                });
            } else {
                afterMem.push(rid);
            }
        }
        stillMissing = afterMem;
    }

    // Fetch remaining from IndexedDB
    if (stillMissing.length > 0) {
        var dbResults = await getRecordsByIdsFromDB(tableId, stillMissing);
        fetched = fetched.concat(dbResults);
    }

    // Populate cache (cap size to avoid unbounded growth).
    // LRU eviction: remove oldest entries (front of Map iteration) to make room.
    var spaceNeeded = (_recordCache.size + fetched.length) - _RECORD_CACHE_MAX;
    if (spaceNeeded > 0) {
        var iter = _recordCache.keys();
        for (var ri = 0; ri < spaceNeeded; ri++) {
            var oldKey = iter.next().value;
            _recordCache.delete(oldKey);
        }
    }
    for (var fi = 0; fi < fetched.length; fi++) {
        _recordCache.set(_rcKey(tableId, fetched[fi].recordId), fetched[fi]);
    }

    return cached.concat(fetched);
}

// Internal: Get records from IndexedDB only
async function getRecordsByIdsFromDB(tableId, recordIds) {
    if (!recordIds.length) return [];

    var results = await new Promise((resolve, reject) => {
        var store = db.transaction('data', 'readonly').objectStore('data');
        var results = [];
        var pending = recordIds.length;

        recordIds.forEach(rid => {
            var req = store.get([tableId, rid]);
            req.onsuccess = () => {
                if (req.result) results.push(req.result);
                if (--pending === 0) resolve(results);
            };
            req.onerror = () => {
                if (--pending === 0) resolve(results);
            };
        });
    });

    // Decrypt records if needed.  Always attempt decryption when a key is
    // available  records may have been encrypted during a previous session's
    // logout even if the current encryptionEnabled flag is false.
    if (encryptionKey) {
        return Promise.all(results.map(r => decryptRecordFromStorage(r)));
    }
    return results;
}

function saveTable(table) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readwrite');
        tx.objectStore('tables').put(table);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveField(field) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readwrite');
        tx.objectStore('fields').put(field);
        tx.oncomplete = () => {
            if (field.fieldType === 'multipleRecordLinks') scheduleEdgeRebuild();
            resolve();
        };
        tx.onerror = () => reject(tx.error);
    });
}

function saveView(view) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readwrite');
        tx.objectStore('views').put(view);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function saveDataRecord(record) {
    // Online-only mode: keep data in memory only, skip IndexedDB write.
    if (_isOnlineOnlyMode()) {
        if (window.IN_MEMORY_DATA) {
            if (!window.IN_MEMORY_DATA[record.tableId]) window.IN_MEMORY_DATA[record.tableId] = {};
            window.IN_MEMORY_DATA[record.tableId][record.recordId] = record.fields;
        }
        return;
    }

    // Encrypt record if needed
    var recordToStore = record;
    if (encryptionEnabled && encryptionKey) {
        recordToStore = await encryptRecordForStorage(record);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readwrite');
        tx.objectStore('data').put(recordToStore);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function saveBatch(tables, fields, views, dataRecords) {
    // Online-only mode: save metadata (tables, fields, views) to IDB
    // but skip persisting data records  keep them in memory only.
    if (_isOnlineOnlyMode()) {
        // Still populate IN_MEMORY_DATA for the current session
        for (var oi = 0; oi < dataRecords.length; oi++) {
            var dr = dataRecords[oi];
            if (window.IN_MEMORY_DATA) {
                if (!window.IN_MEMORY_DATA[dr.tableId]) window.IN_MEMORY_DATA[dr.tableId] = {};
                window.IN_MEMORY_DATA[dr.tableId][dr.recordId] = dr.fields;
            }
        }

        // Still save metadata (tables/fields/views)  these are schema, not user data
        var metaStores = [];
        if (tables.length) metaStores.push('tables');
        if (fields.length) metaStores.push('fields');
        if (views.length) metaStores.push('views');
        if (metaStores.length) {
            return new Promise((resolve, reject) => {
                var tx = db.transaction(metaStores, 'readwrite');
                tables.forEach(t => tx.objectStore('tables').put(t));
                fields.forEach(f => tx.objectStore('fields').put(f));
                views.forEach(v => tx.objectStore('views').put(v));
                tx.oncomplete = () => {
                    if (fields.length) scheduleEdgeRebuild();
                    resolve();
                };
                tx.onerror = () => reject(tx.error);
            });
        }
        if (fields.length) scheduleEdgeRebuild();
        return;
    }

    var stores = [];
    if (tables.length) stores.push('tables');
    if (fields.length) stores.push('fields');
    if (views.length) stores.push('views');
    if (dataRecords.length) stores.push('data');
    if (!stores.length) return;

    // Encrypt data records if needed
    var recordsToStore = dataRecords;
    if (encryptionEnabled && encryptionKey && dataRecords.length) {
        recordsToStore = await Promise.all(dataRecords.map(r => encryptRecordForStorage(r)));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction(stores, 'readwrite');

        tables.forEach(t => tx.objectStore('tables').put(t));
        fields.forEach(f => tx.objectStore('fields').put(f));
        views.forEach(v => tx.objectStore('views').put(v));
        recordsToStore.forEach(d => tx.objectStore('data').put(d));

        tx.oncomplete = () => {
            if (fields.length) scheduleEdgeRebuild();
            resolve();
        };
        tx.onerror = () => reject(tx.error);
    });
}

function clearAllData() {
    // Clear the localStorage hydration flag so the app knows to re-hydrate
    try { localStorage.removeItem('amino_hydration_complete'); } catch(e) {}
    return new Promise((resolve, reject) => {
        var tx = db.transaction(['data', 'tables', 'fields', 'views', 'sync', 'fieldHistory', 'events', 'edges'], 'readwrite');
        tx.objectStore('data').clear();
        tx.objectStore('tables').clear();
        tx.objectStore('fields').clear();
        tx.objectStore('views').clear();
        tx.objectStore('sync').clear();
        tx.objectStore('fieldHistory').clear();
        tx.objectStore('events').clear();
        tx.objectStore('edges').clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveFieldHistory(historyEntries) {
    return new Promise((resolve, reject) => {
        if (!historyEntries.length) return resolve();
        var tx = db.transaction('fieldHistory', 'readwrite');
        var store = tx.objectStore('fieldHistory');
        historyEntries.forEach(entry => store.add(entry));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// ============ Edges: Local Link Graph ============
// Edges are derived from multipleRecordLinks field metadata.
// Each edge represents one linked-record field connecting two tables.
// The edges store is local-only (IndexedDB) and auto-rebuilt when field metadata changes.

var _edgesCache = null; // in-memory cache, invalidated on rebuild
var _edgesRebuildPending = false;
var _edgesRebuildTimer = null;
var _edgesRebuildSuppressed = false; // suppress during bulk ops (backfill, hydration)
var _edgesRebuildNeeded = false;    // track if rebuild was requested while suppressed

// Suppress edge rebuilds during bulk operations to avoid redundant work.
// Call unsuppressEdgeRebuilds() when done  triggers one rebuild if needed.
function suppressEdgeRebuilds() {
    _edgesRebuildSuppressed = true;
    _edgesRebuildNeeded = false;
}
function unsuppressEdgeRebuilds() {
    _edgesRebuildSuppressed = false;
    if (_edgesRebuildNeeded) {
        _edgesRebuildNeeded = false;
        scheduleEdgeRebuild();
    }
}

// Schedule an edge rebuild with debounce (coalesces rapid field updates)
function scheduleEdgeRebuild() {
    _edgesCache = null; // invalidate cache immediately
    if (_edgesRebuildSuppressed) {
        _edgesRebuildNeeded = true;
        return;
    }
    if (_edgesRebuildTimer) clearTimeout(_edgesRebuildTimer);
    _edgesRebuildTimer = setTimeout(function() {
        _edgesRebuildTimer = null;
        rebuildEdges();
    }, 1500);
}

function buildEdgesFromFields(metaFields) {
    var edges = [];
    var tableIds = Object.keys(metaFields || {});
    for (var t = 0; t < tableIds.length; t++) {
        var tableId = tableIds[t];
        var fields = metaFields[tableId] || {};
        var fieldIds = Object.keys(fields);
        for (var f = 0; f < fieldIds.length; f++) {
            var field = fields[fieldIds[f]];
            if (field.fieldType !== 'multipleRecordLinks') continue;
            var opts = field.options || {};
            if (!opts.linkedTableId) continue;
            edges.push({
                edgeId: tableId + '|' + field.fieldId,
                fromTableId: tableId,
                fieldId: field.fieldId,
                fieldName: field.fieldName || field.fieldId,
                toTableId: opts.linkedTableId,
                inverseFieldId: opts.inverseLinkFieldId || null,
                prefersSingle: !!opts.prefersSingleRecordLink
            });
        }
    }
    return edges;
}

function saveEdges(edges) {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('edges', 'readwrite');
        var store = tx.objectStore('edges');
        store.clear();
        for (var i = 0; i < edges.length; i++) {
            store.put(edges[i]);
        }
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function() { reject(tx.error); };
    });
}

function getAllEdges() {
    if (_edgesCache) return Promise.resolve(_edgesCache);
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('edges', 'readonly');
        var req = tx.objectStore('edges').getAll();
        req.onsuccess = function() {
            _edgesCache = req.result || [];
            resolve(_edgesCache);
        };
        req.onerror = function() { reject(req.error); };
    });
}

function getEdgesFromTable(tableId) {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('edges', 'readonly');
        var index = tx.objectStore('edges').index('by_from');
        var req = index.getAll(tableId);
        req.onsuccess = function() { resolve(req.result || []); };
        req.onerror = function() { reject(req.error); };
    });
}

function getEdgesToTable(tableId) {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('edges', 'readonly');
        var index = tx.objectStore('edges').index('by_to');
        var req = index.getAll(tableId);
        req.onsuccess = function() { resolve(req.result || []); };
        req.onerror = function() { reject(req.error); };
    });
}

// Rebuild edges from current META_FIELDS and persist to IndexedDB.
// Called automatically when field metadata changes.
async function rebuildEdges() {
    if (_edgesRebuildPending) return;
    _edgesRebuildPending = true;
    try {
        var edges = buildEdgesFromFields(META_FIELDS);
        await saveEdges(edges);
        _edgesCache = edges;
        console.log('[Edges] Rebuilt ' + edges.length + ' edges from field metadata');
    } catch (e) {
        console.error('[Edges] Rebuild failed:', e);
    } finally {
        _edgesRebuildPending = false;
    }
}

// Compute the shortest path from a given tableId to a target tableId using BFS.
// Returns an array of edges forming the path, or null if unreachable.
function findPathBetweenTables(edges, fromTableId, toTableId, maxHops) {
    if (fromTableId === toTableId) return [];
    maxHops = maxHops || 4;

    // Build adjacency list: tableId -> [{edge, neighborTableId}]
    var adj = {};
    for (var i = 0; i < edges.length; i++) {
        var e = edges[i];
        if (!adj[e.fromTableId]) adj[e.fromTableId] = [];
        adj[e.fromTableId].push({ edge: e, neighbor: e.toTableId });
        // Also traverse inverse direction (toTable has a back-link field to fromTable)
        if (e.inverseFieldId) {
            if (!adj[e.toTableId]) adj[e.toTableId] = [];
            adj[e.toTableId].push({ edge: { edgeId: e.toTableId + '|' + e.inverseFieldId, fromTableId: e.toTableId, fieldId: e.inverseFieldId, fieldName: e.fieldName + ' (inverse)', toTableId: e.fromTableId, inverseFieldId: e.fieldId, prefersSingle: false }, neighbor: e.fromTableId });
        }
    }

    // BFS
    var queue = [{ tableId: fromTableId, path: [] }];
    var visited = {};
    visited[fromTableId] = true;

    while (queue.length > 0) {
        var current = queue.shift();
        if (current.path.length >= maxHops) continue;

        var neighbors = adj[current.tableId] || [];
        for (var n = 0; n < neighbors.length; n++) {
            var next = neighbors[n];
            if (visited[next.neighbor]) continue;

            var newPath = current.path.concat([next.edge]);
            if (next.neighbor === toTableId) return newPath;

            visited[next.neighbor] = true;
            queue.push({ tableId: next.neighbor, path: newPath });
        }
    }

    return null; // unreachable
}

// For each table, compute the best link-field path to the client table.
// Returns: { tableId -> { fieldId, hops, path[] } }
function computeLinkedRecordTableMap(edges, clientTableId) {
    var result = {};
    if (!clientTableId || !edges || !edges.length) return result;

    // Group edges by fromTableId for direct-link preference
    var directEdges = {};
    for (var i = 0; i < edges.length; i++) {
        var e = edges[i];
        if (!directEdges[e.fromTableId]) directEdges[e.fromTableId] = [];
        directEdges[e.fromTableId].push(e);
    }

    // Collect all unique table IDs
    var allTables = {};
    for (var j = 0; j < edges.length; j++) {
        allTables[edges[j].fromTableId] = true;
        allTables[edges[j].toTableId] = true;
    }

    var tableIds = Object.keys(allTables);
    for (var t = 0; t < tableIds.length; t++) {
        var tid = tableIds[t];
        if (tid === clientTableId) continue;

        // Prefer direct link to client table (1 hop)
        var directs = directEdges[tid] || [];
        var bestDirect = null;
        for (var d = 0; d < directs.length; d++) {
            if (directs[d].toTableId === clientTableId) {
                bestDirect = directs[d];
                break;
            }
        }

        if (bestDirect) {
            result[tid] = { fieldId: bestDirect.fieldId, hops: 1, path: [bestDirect] };
        } else {
            // Multi-hop: find shortest path
            var path = findPathBetweenTables(edges, tid, clientTableId, 4);
            if (path && path.length > 0) {
                result[tid] = { fieldId: path[0].fieldId, hops: path.length, path: path };
            }
        }
    }

    return result;
}

// Field history limit to prevent excessive memory usage
var FIELD_HISTORY_LIMIT = 1000;

function getFieldHistoryForRecord(tableId, recordId, limit) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fieldHistory', 'readonly');
        var index = tx.objectStore('fieldHistory').index('by_record');
        var maxLimit = limit || FIELD_HISTORY_LIMIT;

        // Use cursor for memory-efficient retrieval with limit
        var results = [];
        var req = index.openCursor(IDBKeyRange.only([tableId, recordId]));

        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor && results.length < maxLimit) {
                results.push(cursor.value);
                cursor.continue();
            } else {
                // Sort by eventId descending (most recent first)
                results.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

/**
 * Normalize a Matrix event from either format into a consistent history entry.
 * Works for both law.firm.schema.object and law.firm.record.mutate events.
 */
function normalizeHistoryEvent(matrixEvent) {
    var content = matrixEvent.content || {};
    if (!content.recordId) return null; // schema-level event, skip

    var payload = content.payload || {};
    var fields = payload.fields || {};

    // Normalize timestamp: seconds (migration) vs milliseconds (n8n/client)
    var ts = content.sourceTimestamp;
    if (ts && ts < 10000000000) ts = ts * 1000;
    var timestamp = ts || matrixEvent.origin_server_ts;

    // Extract actor and device
    var actor = payload._a || content.actor || matrixEvent.sender;
    var device = payload._d || content.device || null;

    // Normalize field changes  both formats use the same structure
    var changes = {
        inserted: fields.INS || {},
        altered: fields.ALT || {},
        nulled: fields.NUL || []
    };

    // Handle flat format (op + content.fields without payload wrapper)
    if (!fields.ALT && !fields.INS && !fields.NUL && content.op && content.fields) {
        if (content.op === 'INS') changes.inserted = content.fields;
        else if (content.op === 'ALT') changes.altered = content.fields;
        else if (content.op === 'NUL') changes.nulled = content.fields;
    }

    var op = content.op || 'ALT';

    return {
        eventId: matrixEvent.event_id,
        eventType: matrixEvent.type,
        recordId: content.recordId,
        op: op,
        changes: changes,
        actor: actor,
        device: device,
        timestamp: timestamp,
        source: content.source || 'unknown',
        set: content.set || payload._set || ''
    };
}

function getHistoryFieldName(tableId, fieldId) {
    if (fieldId === '__created_at') return 'Created At';
    return (META_FIELDS[tableId] && META_FIELDS[tableId][fieldId] && META_FIELDS[tableId][fieldId].fieldName) || fieldId;
}

function maybeAddSyntheticCreatedAtHistory(fieldHistoryEntries, baseMeta, payload, state) {
    if (!baseMeta || !payload) return;

    var fieldOps = payload.fields || {};
    var hasFieldChanges = Object.keys(fieldOps.INS || {}).length > 0 ||
        Object.keys(fieldOps.ALT || {}).length > 0 ||
        Object.keys(fieldOps.SYN || {}).length > 0 ||
        (Array.isArray(fieldOps.NUL) && fieldOps.NUL.length > 0);
    if (hasFieldChanges) return;

    var op = payload.op || null;
    if (op !== 'INS') return;

    var createdAt = payload._created_at || baseMeta.timestamp || null;
    if (!createdAt) return;

    fieldHistoryEntries.push(Object.assign({}, baseMeta, {
        fieldId: '__created_at',
        changeType: 'created',
        oldValue: null,
        newValue: createdAt
    }));

    if (state && state.__created_at === undefined) {
        state.__created_at = createdAt;
    }
}

// Fetch event history from Postgres events API (amino.event_log) and build
// field history entries. This is the primary on-demand history source 
// events are queried when needed, not downloaded at hydration.
async function fetchHistoryFromPostgresEvents(tableId, recordId) {
    try {
        var result = await AminoData.fetchEventsForRecord(recordId);
        if (!result || !result.events || result.events.length === 0) {
            return [];
        }
        return buildFieldHistoryFromRawEvents(tableId, recordId, result.events);
    } catch (err) {
        console.warn('[History] Postgres events API failed, will fall back to Matrix:', err.message);
        return [];
    }
}

// ============ View Folders ============

function getFoldersForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readonly');
        var index = tx.objectStore('viewFolders').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function saveFolder(folder) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readwrite');
        tx.objectStore('viewFolders').put(folder);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function deleteFolder(folderId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readwrite');
        tx.objectStore('viewFolders').delete(folderId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getAllFolders() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readonly');
        var req = tx.objectStore('viewFolders').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// ============ View Auto-Save System ============

// Mark view as dirty (edited)
function markViewDirty(changeType, data) {
    if (!currentTable || !currentView) return;

    viewDirtyState.isDirty = true;
    viewDirtyState.lastEditTime = Date.now();
    viewDirtyState.pendingChanges.tableId = currentTable;
    viewDirtyState.pendingChanges.viewId = currentView;
    viewDirtyState.pendingChanges.changes[changeType] = data;

    // Reset auto-save timer (debounce)
    clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(saveViewToBackend, AUTO_SAVE_DELAY);

    // Update UI indicator
    updateSaveIndicator('dirty');
}

// Update save indicator UI
function updateSaveIndicator(state) {
    var indicator = document.getElementById('view-save-indicator');
    var text = document.getElementById('save-indicator-text');
    var saveBtn = document.getElementById('manual-save-btn');

    if (!indicator || !text || !saveBtn) return;

    indicator.style.display = 'flex';
    indicator.className = 'view-save-indicator ' + state;

    switch(state) {
        case 'dirty':
            var remaining = Math.ceil((AUTO_SAVE_DELAY - (Date.now() - viewDirtyState.lastEditTime)) / 60000);
            text.textContent = 'Auto-save in ~' + Math.max(1, remaining) + 'm';
            saveBtn.style.display = 'inline-block';
            saveBtn.disabled = false;
            break;
        case 'saving':
            text.textContent = 'Saving...';
            saveBtn.style.display = 'inline-block';
            saveBtn.disabled = true;
            break;
        case 'saved':
            text.textContent = 'Saved';
            saveBtn.style.display = 'none';
            // Hide after 3 seconds
            setTimeout(() => {
                if (!viewDirtyState.isDirty) {
                    indicator.style.display = 'none';
                }
            }, 3000);
            break;
        default:
            indicator.style.display = 'none';
    }
}

// Save view changes to backend
// View config is now stored via Matrix state events (user preferences)
async function saveViewToBackend() {
    if (!viewDirtyState.isDirty) return;

    var { tableId, viewId, changes } = viewDirtyState.pendingChanges;
    if (!tableId || !viewId) return;

    updateSaveIndicator('saving');

    try {
        // Save view config via user preferences (Matrix account data)
        var view = META_VIEWS[tableId]?.[viewId] || {};
        var config = VIEW_FIELD_CONFIG[tableId]?.[viewId] || {};
        var viewConfigData = {
            viewId: viewId,
            viewName: view.viewName || viewId,
            hiddenFieldIds: config.hiddenFieldIds || [],
            fieldOrder: config.fieldOrder || [],
            filters: view.filters || [],
            sorts: view.sorts || [],
            folderId: view.folderId || null,
            ...changes
        };

        // Store via user preferences system (Matrix account data)
        await UserPreferences.set('viewConfig:' + tableId + ':' + viewId, viewConfigData);

        // Clear dirty state
        viewDirtyState.isDirty = false;
        viewDirtyState.pendingChanges = { tableId: null, viewId: null, changes: {} };
        clearTimeout(autoSaveTimer);

        updateSaveIndicator('saved');
        console.log('View saved via Matrix user preferences:', viewId);
    } catch (error) {
        console.error('Failed to save view:', error);
        updateSaveIndicator('dirty');
    }
}

// Manual save button handler
async function saveViewToBackendNow() {
    clearTimeout(autoSaveTimer);
    await saveViewToBackend();
}

// Auto-save before navigation (sync fast-path when nothing is dirty)
function autoSaveBeforeNavigation() {
    if (!viewDirtyState.isDirty) return; // sync return  no await overhead
    clearTimeout(autoSaveTimer);
    return saveViewToBackend();
}

// Browser beforeunload - auto-save
window.addEventListener('beforeunload', function(e) {
    if (viewDirtyState.isDirty) {
        // Attempt to save (may not complete if user leaves too quickly)
        saveViewToBackend();
    }
    if (tableSettingsDirty) {
        // Attempt to save table settings
        saveTableSettings();
    }
});

// ============ Table Settings (User-Specific Table/View Preferences) ============

// Table settings dirty state tracking
var tableSettingsDirty = false;
var tableSettingsAutoSaveTimer = null;

// Get current table settings
function getTableSettings() {
    return TABLE_SETTINGS;
}

// Update table visibility
function setTableVisible(tableId, visible) {
    if (!TABLE_SETTINGS.tables[tableId]) {
        TABLE_SETTINGS.tables[tableId] = {};
    }
    TABLE_SETTINGS.tables[tableId].visible = visible;
    markTableSettingsDirty();
}

// Update table sort order
function setTableSortOrder(tableId, sortOrder) {
    if (!TABLE_SETTINGS.tables[tableId]) {
        TABLE_SETTINGS.tables[tableId] = {};
    }
    TABLE_SETTINGS.tables[tableId].sortOrder = sortOrder;
    markTableSettingsDirty();
}

// Update the table order array (reorder tables)
function setTableOrder(tableOrder) {
    TABLE_SETTINGS.tableOrder = tableOrder;
    markTableSettingsDirty();
}

// Update view public/private setting
function setViewPublic(viewId, isPublic) {
    if (!TABLE_SETTINGS.views[viewId]) {
        TABLE_SETTINGS.views[viewId] = {};
    }
    TABLE_SETTINGS.views[viewId].isPublic = isPublic;
    markTableSettingsDirty();
}

// Update view sort order
function setViewSortOrder(viewId, sortOrder) {
    if (!TABLE_SETTINGS.views[viewId]) {
        TABLE_SETTINGS.views[viewId] = {};
    }
    TABLE_SETTINGS.views[viewId].sortOrder = sortOrder;
    markTableSettingsDirty();
}

// Check if a table is visible (defaults to true if not set)
function isTableVisible(tableId) {
    var settings = TABLE_SETTINGS.tables[tableId];
    return settings ? settings.visible !== false : true;
}

// Check if a view is public (defaults to false - private by default)
function isViewPublic(viewId) {
    var settings = TABLE_SETTINGS.views[viewId];
    return settings ? settings.isPublic === true : false;
}

// Get table sort order (returns null if not set)
function getTableSortOrder(tableId) {
    var settings = TABLE_SETTINGS.tables[tableId];
    return settings ? settings.sortOrder : null;
}

// Get view sort order (returns null if not set)
function getViewSortOrder(viewId) {
    var settings = TABLE_SETTINGS.views[viewId];
    return settings ? settings.sortOrder : null;
}

// Mark table settings as dirty and schedule auto-save
function markTableSettingsDirty() {
    tableSettingsDirty = true;

    // Clear existing timer
    if (tableSettingsAutoSaveTimer) {
        clearTimeout(tableSettingsAutoSaveTimer);
    }

    // Schedule auto-save after 2 seconds of inactivity
    tableSettingsAutoSaveTimer = setTimeout(function() {
        saveTableSettings();
    }, 2000);
}

// Save table settings to backend (via Matrix user preferences)
async function saveTableSettings() {
    if (!tableSettingsDirty) return;

    try {
        // Save via user preferences (Matrix account data)
        await UserPreferences.set('tableSettings', {
            tables: TABLE_SETTINGS.tables,
            tableOrder: TABLE_SETTINGS.tableOrder,
            views: TABLE_SETTINGS.views
        });

        tableSettingsDirty = false;
        clearTimeout(tableSettingsAutoSaveTimer);
        console.log('Table settings saved via Matrix user preferences');
    } catch (error) {
        console.error('Failed to save table settings:', error);
    }
}

// Load table settings from sync metadata
// Table settings are now persisted via events and restored during event replay
async function loadTableSettings() {
    try {
        var stored = await getSyncMeta('tableSettings');
        if (stored) {
            if (stored.tables) TABLE_SETTINGS.tables = stored.tables;
            if (stored.tableOrder) TABLE_SETTINGS.tableOrder = stored.tableOrder;
            if (stored.views) TABLE_SETTINGS.views = stored.views;
            console.log('Table settings loaded from sync metadata');
        }
    } catch (error) {
        console.error('Failed to load table settings:', error);
    }
}

// ============ User Preferences (Per-User Synapse Account Storage) ============
//
// User preferences are stored in two layers:
// 1. Local: IndexedDB 'userPreferences' store (for fast access, offline support)
// 2. Remote: Matrix account data (synced across devices, private to user)
//
// Preferences include: theme, sidebar collapsed state, default table/view,
// table visibility/order, and any other user-specific settings.
//
// When the user is logged into Synapse, preferences sync bidirectionally.
// Local storage acts as cache; Matrix account data is the source of truth.

var UserPreferences = (function() {
    'use strict';

    var ACCOUNT_DATA_TYPE = 'law.firm.user.preferences';

    // Default preferences
    var _defaults = {
        theme: 'dark',
        sidebarCollapsed: false,
        defaultTableId: null,
        defaultViewId: null,
        tableSettings: { tables: {}, tableOrder: [], views: {} },
        recentTables: [],
        pinnedViews: [],
        gridDensity: 'comfortable',  // 'compact', 'comfortable', 'spacious'
        pageSize: 100,
        dateFormat: 'relative',      // 'relative', 'absolute', 'iso'
        timezone: null,              // null = browser default
        showOfflineSyncToasts: true, // show toast when offline-queued edits sync
        confirmInlineCellEdit: true  // require confirmation before opening inline edit
    };

    var _prefs = Object.assign({}, _defaults);
    var _dirty = false;
    var _saveTimer = null;
    var _userId = null;

    // ---- Local Storage (IndexedDB) ----

    async function _loadLocal() {
        try {
            if (!db) return;
            var tx = db.transaction('userPreferences', 'readonly');
            var req = tx.objectStore('userPreferences').get('prefs');
            var result = await new Promise(function(resolve, reject) {
                req.onsuccess = function() { resolve(req.result); };
                req.onerror = function() { reject(req.error); };
            });
            if (result && result.value) {
                _prefs = Object.assign({}, _defaults, result.value);
            }
        } catch (e) {
            console.warn('[UserPreferences] Failed to load local prefs:', e);
        }
    }

    async function _saveLocal() {
        try {
            if (!db) return;
            var tx = db.transaction('userPreferences', 'readwrite');
            tx.objectStore('userPreferences').put({ key: 'prefs', value: _prefs });
            await new Promise(function(resolve, reject) {
                tx.oncomplete = resolve;
                tx.onerror = function() { reject(tx.error); };
            });
        } catch (e) {
            console.warn('[UserPreferences] Failed to save local prefs:', e);
        }
    }

    // ---- Remote Storage (Matrix Account Data) ----

    async function _loadRemote() {
        if (!MatrixClient.isLoggedIn()) return false;
        try {
            var data = await MatrixClient.getAccountData(ACCOUNT_DATA_TYPE);
            if (data) {
                // Merge remote into local, remote wins for conflicts
                _prefs = Object.assign({}, _defaults, _prefs, data);
                await _saveLocal();
                return true;
            }
            // Account data doesn't exist yet on server (first login);
            // initialize with current prefs so future loads don't 404
            await _saveRemote();
        } catch (e) {
            console.warn('[UserPreferences] Failed to load remote prefs:', e);
        }
        return false;
    }

    async function _saveRemote() {
        if (!MatrixClient.isLoggedIn()) return;
        try {
            await MatrixClient.setAccountData(ACCOUNT_DATA_TYPE, _prefs);
        } catch (e) {
            console.warn('[UserPreferences] Failed to save remote prefs:', e);
        }
    }

    // ---- Public API ----

    async function load() {
        _userId = MatrixClient.getUserId();
        await _loadLocal();
        if (MatrixClient.isLoggedIn()) {
            await _loadRemote();
        }
        console.log('[UserPreferences] Loaded for', _userId || 'anonymous');
    }

    async function save() {
        await _saveLocal();
        await _saveRemote();
        _dirty = false;
    }

    function get(key) {
        return _prefs[key] !== undefined ? _prefs[key] : _defaults[key];
    }

    function set(key, value) {
        _prefs[key] = value;
        _dirty = true;
        _scheduleSave();
    }

    function getAll() {
        return Object.assign({}, _prefs);
    }

    function setMultiple(obj) {
        Object.keys(obj).forEach(function(k) {
            _prefs[k] = obj[k];
        });
        _dirty = true;
        _scheduleSave();
    }

    function _scheduleSave() {
        if (_saveTimer) clearTimeout(_saveTimer);
        _saveTimer = setTimeout(function() {
            save();
        }, 2000);
    }

    function reset() {
        _prefs = Object.assign({}, _defaults);
        _dirty = true;
        _scheduleSave();
    }

    return {
        load: load,
        save: save,
        get: get,
        set: set,
        getAll: getAll,
        setMultiple: setMultiple,
        reset: reset
    };
})();

// ============ Shared Views (Views with Ownership & Sharing) ============
//
// Views start as personal (private to the creator). They can then be shared:
//   - 'private': Only the creator can see/use this view (default)
//   - 'specific': Shared with specific users (by Matrix userId)
//   - 'everyone': Shared with everyone in the org
//
// Storage architecture:
//   - Private views: stored in IndexedDB + Matrix account data (law.firm.user.views)
//   - Shared views: stored in IndexedDB + Matrix room state events (law.firm.view.share)
//     in the org space, with the view config as the content and sharing metadata
//
// Each view has ownership metadata:
//   ownerId:     Matrix userId of the creator
//   sharing:     'private' | 'specific' | 'everyone'
//   sharedWith:  string[]  (Matrix userIds, only used when sharing === 'specific')
//   createdAt:   timestamp
//   updatedAt:   timestamp

var SharedViews = (function() {
    'use strict';

    var ACCOUNT_DATA_TYPE = 'law.firm.user.views';
    var _orgSpaceId = null;

    // ---- Local Storage ----

    async function _getLocalSharedView(tableId, viewId) {
        if (!db) return null;
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readonly');
            var req = tx.objectStore('sharedViews').get([tableId, viewId]);
            req.onsuccess = function() { resolve(req.result || null); };
            req.onerror = function() { reject(req.error); };
        });
    }

    async function _saveLocalSharedView(viewData) {
        if (!db) return;
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readwrite');
            tx.objectStore('sharedViews').put(viewData);
            tx.oncomplete = resolve;
            tx.onerror = function() { reject(tx.error); };
        });
    }

    async function _deleteLocalSharedView(tableId, viewId) {
        if (!db) return;
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readwrite');
            tx.objectStore('sharedViews').delete([tableId, viewId]);
            tx.oncomplete = resolve;
            tx.onerror = function() { reject(tx.error); };
        });
    }

    async function _getAllLocalSharedViews() {
        if (!db) return [];
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readonly');
            var req = tx.objectStore('sharedViews').getAll();
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });
    }

    async function _getLocalSharedViewsForTable(tableId) {
        if (!db) return [];
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('sharedViews', 'readonly');
            var index = tx.objectStore('sharedViews').index('by_table');
            var req = index.getAll(tableId);
            req.onsuccess = function() { resolve(req.result || []); };
            req.onerror = function() { reject(req.error); };
        });
    }

    // ---- Remote Storage ----

    // Save private view list to Matrix account data
    async function _syncPrivateViewsToRemote(privateViews) {
        if (!MatrixClient.isLoggedIn()) return;
        try {
            await MatrixClient.setAccountData(ACCOUNT_DATA_TYPE, {
                views: privateViews,
                updatedAt: Date.now()
            });
        } catch (e) {
            console.warn('[SharedViews] Failed to sync private views to remote:', e);
        }
    }

    // Load private views from Matrix account data
    async function _loadPrivateViewsFromRemote() {
        if (!MatrixClient.isLoggedIn()) return null;
        try {
            var data = await MatrixClient.getAccountData(ACCOUNT_DATA_TYPE);
            if (data) {
                return data.views ? data.views : null;
            }
            // Account data doesn't exist yet on server (first login);
            // initialize with empty views so future loads don't 404
            await _syncPrivateViewsToRemote([]);
            return null;
        } catch (e) {
            console.warn('[SharedViews] Failed to load private views from remote:', e);
            return null;
        }
    }

    // Share a view to the org space as a room state event
    async function _publishSharedView(viewData) {
        if (!MatrixClient.isLoggedIn() || !_orgSpaceId) return;
        var stateKey = viewData.tableId + '|' + viewData.viewId;
        try {
            await MatrixClient.sendStateEvent(
                _orgSpaceId,
                MatrixClient.EVENT_TYPES.VIEW_SHARE,
                stateKey,
                viewData
            );
        } catch (e) {
            console.warn('[SharedViews] Failed to publish shared view:', e);
            throw e;
        }
    }

    // Remove a shared view from the org space
    async function _unpublishSharedView(tableId, viewId) {
        if (!MatrixClient.isLoggedIn() || !_orgSpaceId) return;
        var stateKey = tableId + '|' + viewId;
        try {
            // Set empty content to effectively remove the state event
            await MatrixClient.sendStateEvent(
                _orgSpaceId,
                MatrixClient.EVENT_TYPES.VIEW_SHARE,
                stateKey,
                { deleted: true, deletedAt: Date.now() }
            );
        } catch (e) {
            console.warn('[SharedViews] Failed to unpublish shared view:', e);
        }
    }

    // Load all shared views from the org space
    async function _loadSharedViewsFromOrgSpace() {
        if (!MatrixClient.isLoggedIn() || !_orgSpaceId) return [];
        try {
            var events = MatrixClient.getStateEventsOfType(_orgSpaceId, MatrixClient.EVENT_TYPES.VIEW_SHARE);
            var views = [];
            for (var i = 0; i < events.length; i++) {
                var content = events[i].content;
                if (content && !content.deleted && content.viewId) {
                    views.push(content);
                }
            }
            return views;
        } catch (e) {
            console.warn('[SharedViews] Failed to load shared views from org space:', e);
            return [];
        }
    }

    // ---- Public API ----

    function setOrgSpaceId(orgSpaceId) {
        _orgSpaceId = orgSpaceId;
    }

    // Initialize: load from local + merge with remote
    async function load() {
        // Load all local shared view metadata
        var localViews = await _getAllLocalSharedViews();

        // Load from remote sources
        if (MatrixClient.isLoggedIn()) {
            // Load private views from account data
            var remotePrivate = await _loadPrivateViewsFromRemote();
            if (remotePrivate) {
                for (var i = 0; i < remotePrivate.length; i++) {
                    var rv = remotePrivate[i];
                    if (rv.tableId && rv.viewId) {
                        await _saveLocalSharedView(rv);
                    }
                }
            }

            // Load shared views from org space state events
            if (_orgSpaceId) {
                var remoteShared = await _loadSharedViewsFromOrgSpace();
                for (var j = 0; j < remoteShared.length; j++) {
                    var sv = remoteShared[j];
                    if (sv.tableId && sv.viewId) {
                        await _saveLocalSharedView(sv);
                    }
                }
            }
        }

        console.log('[SharedViews] Loaded views');
    }

    // Get sharing metadata for a view
    async function getViewSharing(tableId, viewId) {
        var viewData = await _getLocalSharedView(tableId, viewId);
        if (!viewData) {
            return {
                ownerId: null,
                sharing: 'private',
                sharedWith: [],
                createdAt: null,
                updatedAt: null
            };
        }
        return {
            ownerId: viewData.ownerId || null,
            sharing: viewData.sharing || 'private',
            sharedWith: viewData.sharedWith || [],
            createdAt: viewData.createdAt || null,
            updatedAt: viewData.updatedAt || null
        };
    }

    // Set ownership on a new view
    async function setViewOwnership(tableId, viewId, ownerId) {
        var existing = await _getLocalSharedView(tableId, viewId);
        var viewData = existing || {
            tableId: tableId,
            viewId: viewId,
            sharing: 'everyone',
            sharedWith: [],
            createdAt: Date.now()
        };
        viewData.ownerId = ownerId;
        viewData.updatedAt = Date.now();
        await _saveLocalSharedView(viewData);
    }

    // Share a view: update sharing level and persist to appropriate storage
    async function shareView(tableId, viewId, sharing, sharedWith) {
        var existing = await _getLocalSharedView(tableId, viewId);
        if (!existing) {
            console.warn('[SharedViews] Cannot share non-existent view:', viewId);
            return;
        }

        var oldSharing = existing.sharing;
        existing.sharing = sharing;
        existing.sharedWith = sharedWith || [];
        existing.updatedAt = Date.now();

        // Include the full view config from META_VIEWS for the shared copy
        var viewMeta = META_VIEWS[tableId] && META_VIEWS[tableId][viewId];
        if (viewMeta) {
            existing.viewName = viewMeta.viewName;
            existing.viewType = viewMeta.viewType;
            existing.filters = viewMeta.filters || [];
            existing.sorts = viewMeta.sorts || [];
            existing.groupBy = viewMeta.groupBy || null;
            existing.hiddenFieldIds = viewMeta.hiddenFieldIds || [];
            existing.fieldOrder = viewMeta.fieldOrder || [];
            existing.tags = viewMeta.tags || [];
            existing.folderId = viewMeta.folderId || null;
        }

        // Save locally
        await _saveLocalSharedView(existing);

        // Handle remote persistence based on sharing level
        if (sharing === 'private') {
            // Remove from org space if it was previously shared
            if (oldSharing !== 'private') {
                await _unpublishSharedView(tableId, viewId);
            }
            // Sync to private account data
            await _syncAllPrivateViews();
        } else {
            // Publish to org space (for 'specific' and 'everyone')
            await _publishSharedView(existing);
            // Also sync private view list (remove from it if needed)
            await _syncAllPrivateViews();
        }

        console.log('[SharedViews] View', viewId, 'sharing set to:', sharing);
    }

    // Unshare a view: revert to private
    async function unshareView(tableId, viewId) {
        await shareView(tableId, viewId, 'private', []);
    }

    // Delete a shared view's metadata
    async function deleteViewSharing(tableId, viewId) {
        var existing = await _getLocalSharedView(tableId, viewId);
        if (existing && existing.sharing !== 'private') {
            await _unpublishSharedView(tableId, viewId);
        }
        await _deleteLocalSharedView(tableId, viewId);
        await _syncAllPrivateViews();
    }

    // Get all shared views visible to the current user for a given table
    async function getVisibleViewsForTable(tableId) {
        var allViews = await _getLocalSharedViewsForTable(tableId);
        var currentUserId = MatrixClient.getUserId();
        var visible = [];

        for (var i = 0; i < allViews.length; i++) {
            var v = allViews[i];
            if (_isViewVisibleToUser(v, currentUserId)) {
                visible.push(v);
            }
        }

        return visible;
    }

    // Check if a view is visible to a specific user
    function _isViewVisibleToUser(viewData, userId) {
        if (!viewData) return false;
        // Owner always sees their own views
        if (viewData.ownerId === userId) return true;
        // Everyone can see 'everyone' views
        if (viewData.sharing === 'everyone') return true;
        // Check specific sharing list
        if (viewData.sharing === 'specific' && viewData.sharedWith) {
            return viewData.sharedWith.indexOf(userId) >= 0;
        }
        return false;
    }

    // Check if the current user owns a view
    function isOwnedByCurrentUser(viewData) {
        var currentUserId = MatrixClient.getUserId();
        return viewData && viewData.ownerId === currentUserId;
    }

    // Sync all private views to account data
    async function _syncAllPrivateViews() {
        var allViews = await _getAllLocalSharedViews();
        var currentUserId = MatrixClient.getUserId();
        var privateViews = allViews.filter(function(v) {
            return v.ownerId === currentUserId && v.sharing === 'private';
        });
        await _syncPrivateViewsToRemote(privateViews);
    }

    // Get org members for the sharing picker
    async function getOrgMembers() {
        if (!_orgSpaceId || !MatrixClient.isLoggedIn()) return [];
        try {
            return await MatrixClient.getRoomMembers(_orgSpaceId);
        } catch (e) {
            console.warn('[SharedViews] Failed to get org members:', e);
            return [];
        }
    }

    // Get a human-readable sharing label for display
    function getSharingLabel(viewData) {
        if (!viewData || !viewData.sharing) return 'Private';
        switch (viewData.sharing) {
            case 'private': return 'Private';
            case 'specific':
                var count = (viewData.sharedWith || []).length;
                return 'Shared with ' + count + ' user' + (count !== 1 ? 's' : '');
            case 'everyone': return 'Shared with everyone';
            default: return 'Private';
        }
    }

    // Get sharing icon for display
    function getSharingIcon(viewData) {
        if (!viewData || !viewData.sharing || viewData.sharing === 'private') {
            return '&#128274;'; // lock icon
        }
        if (viewData.sharing === 'everyone') {
            return '&#127760;'; // globe icon
        }
        return '&#128101;'; // people icon (specific sharing)
    }

    return {
        setOrgSpaceId: setOrgSpaceId,
        load: load,
        getViewSharing: getViewSharing,
        setViewOwnership: setViewOwnership,
        shareView: shareView,
        unshareView: unshareView,
        deleteViewSharing: deleteViewSharing,
        getVisibleViewsForTable: getVisibleViewsForTable,
        isOwnedByCurrentUser: isOwnedByCurrentUser,
        getOrgMembers: getOrgMembers,
        getSharingLabel: getSharingLabel,
        getSharingIcon: getSharingIcon
    };
})();

// ============ Column Definition Registry & Smart Ordering ============
//
// Inspired by the EO/Noema definition concept: every column has semantic meaning
// beyond its label. A field named "name" is an identity field that belongs leftmost.
// A field named "created_at" is temporal metadata that belongs further right.
//
// This system:
// 1. Recognizes common field names via fuzzy matching (CommonDefinitionsRegistry)
// 2. Assigns semantic roles (identifier, property, temporal, quantity, etc.)
// 3. Scores each field's "relevance" for left-to-right column priority
// 4. Produces an intelligent default column order when a view is first created

// Definition roles - the semantic purpose of a field
var FieldRole = Object.freeze({
    PRIMARY_IDENTITY: 'primary_identity',   // Name, title - the "what is this?" column
    IDENTIFIER: 'identifier',               // IDs, codes, keys, references
    DESCRIPTIVE: 'descriptive',             // Description, notes, summary
    CONTACT: 'contact',                     // Email, phone, address
    STATUS: 'status',                       // Status, state, type, category
    QUANTITY: 'quantity',                    // Amounts, prices, counts
    TEMPORAL: 'temporal',                   // Dates, timestamps
    RELATIONAL: 'relational',              // Foreign keys, linked records
    ORGANIZATIONAL: 'organizational',       // Department, role, company
    SPATIAL: 'spatial',                     // Address, coordinates
    TECHNICAL: 'technical',                 // UUIDs, hashes, internal IDs
    UNKNOWN: 'unknown'
});

// Role display priority - lower number = further left (more relevant)
var ROLE_PRIORITY = {
    primary_identity: 0,    // "Name" column is almost always the most important
    identifier: 1,          // IDs that help identify the record
    descriptive: 2,         // Descriptions give context
    status: 3,              // Status/type helps at a glance
    contact: 4,             // Contact info is often actionable
    organizational: 5,      // Org context
    quantity: 6,            // Numeric values
    spatial: 7,             // Location data
    relational: 8,          // Links to other records
    temporal: 9,            // Dates tend to be reference, not primary
    technical: 10,          // Internal IDs, hashes - least human-relevant
    unknown: 11
};

/**
 * CommonDefinitionsRegistry - Recognizes common field names and assigns semantic meaning
 *
 * Borrowed from the Noema epistemic data workbench concept: definitions are not just
 * labels but carry meaning, authority, and role. Here we use a lightweight version
 * focused on field name recognition and semantic role assignment for column ordering.
 */
var COMMON_DEFINITIONS = [
    //  Primary Identity (the "what is this record?" fields) 
    { keys: ['name', 'full name', 'fullname', 'display name', 'displayname', 'record name', 'title', 'subject', 'headline', 'label'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Primary display name', sensitivity: 'low', stability: 'stable' },
    { keys: ['first name', 'firstname', 'fname', 'given name', 'givenname', 'first'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'First/given name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['last name', 'lastname', 'lname', 'surname', 'family name', 'familyname', 'last'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Last/family name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['middle name', 'middlename', 'mname', 'middle'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Middle name', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['prefix', 'salutation', 'honorific'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Name prefix', sensitivity: 'low', stability: 'stable' },
    { keys: ['suffix', 'name suffix', 'generational'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Name suffix', sensitivity: 'low', stability: 'stable' },
    { keys: ['company name', 'companyname', 'company', 'org name', 'orgname', 'organization name', 'organization', 'org', 'business name', 'firm'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Organization name', sensitivity: 'low', stability: 'stable' },
    { keys: ['product name', 'productname', 'product', 'item name', 'itemname', 'item'], role: FieldRole.PRIMARY_IDENTITY, meaning: 'Product/item name', sensitivity: 'low', stability: 'stable' },

    //  Identifiers (unique keys and codes) 
    { keys: ['id', 'identifier', 'uid', 'guid', 'key', 'pk', 'primary key', 'unique identifier', 'record id', 'recordid'], role: FieldRole.IDENTIFIER, meaning: 'Unique identifier', sensitivity: 'low', stability: 'stable' },
    { keys: ['code', 'sku', 'barcode', 'upc', 'ean', 'gtin', 'item number', 'itemnumber', 'stock keeping unit', 'part number', 'partnumber'], role: FieldRole.IDENTIFIER, meaning: 'Item code', sensitivity: 'low', stability: 'stable' },
    { keys: ['account number', 'accountnumber', 'acct', 'account no'], role: FieldRole.IDENTIFIER, meaning: 'Account number', sensitivity: 'high', stability: 'stable' },
    { keys: ['invoice number', 'invoicenumber', 'invoice', 'inv number', 'invnumber', 'invoice no'], role: FieldRole.IDENTIFIER, meaning: 'Invoice number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['order number', 'ordernumber', 'order no', 'order'], role: FieldRole.IDENTIFIER, meaning: 'Order number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['transaction id', 'transactionid', 'trans id', 'transid', 'txn id', 'txnid', 'transaction'], role: FieldRole.IDENTIFIER, meaning: 'Transaction ID', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['employee number', 'employeenumber', 'employee no', 'emp number', 'empnumber', 'emp no', 'badge', 'badge number'], role: FieldRole.IDENTIFIER, meaning: 'Employee number', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['social security number', 'ssn', 'social security', 'ss number', 'sin', 'national id'], role: FieldRole.IDENTIFIER, meaning: 'Social Security Number', sensitivity: 'high', stability: 'stable' },
    { keys: ['drivers license number', 'dl', 'drivers license', 'license number', 'dl number'], role: FieldRole.IDENTIFIER, meaning: 'Drivers license', sensitivity: 'high', stability: 'stable' },
    { keys: ['passport number', 'passport', 'passport no'], role: FieldRole.IDENTIFIER, meaning: 'Passport number', sensitivity: 'high', stability: 'stable' },

    //  Descriptive (text that describes/explains) 
    { keys: ['description', 'desc', 'details', 'summary', 'about', 'overview', 'bio', 'biography'], role: FieldRole.DESCRIPTIVE, meaning: 'Description text', sensitivity: 'low', stability: 'contextual' },
    { keys: ['notes', 'note', 'comments', 'comment', 'remarks', 'remark', 'memo', 'observation', 'observations'], role: FieldRole.DESCRIPTIVE, meaning: 'Notes/comments', sensitivity: 'low', stability: 'contextual' },
    { keys: ['body', 'content', 'text', 'message', 'body text'], role: FieldRole.DESCRIPTIVE, meaning: 'Body content', sensitivity: 'low', stability: 'contextual' },

    //  Status/Categorical (classification and state) 
    { keys: ['status', 'state', 'condition', 'stage', 'phase', 'workflow status'], role: FieldRole.STATUS, meaning: 'Current status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['type', 'kind', 'classification', 'record type', 'recordtype', 'entity type'], role: FieldRole.STATUS, meaning: 'Type classification', sensitivity: 'low', stability: 'stable' },
    { keys: ['category', 'cat', 'group', 'class', 'segment', 'division'], role: FieldRole.STATUS, meaning: 'Category', sensitivity: 'low', stability: 'stable' },
    { keys: ['subcategory', 'sub category', 'subcat', 'subgroup', 'sub group'], role: FieldRole.STATUS, meaning: 'Subcategory', sensitivity: 'low', stability: 'stable' },
    { keys: ['priority', 'pri', 'importance', 'urgency', 'severity', 'level'], role: FieldRole.STATUS, meaning: 'Priority level', sensitivity: 'low', stability: 'contextual' },
    { keys: ['tags', 'tag', 'labels', 'keywords'], role: FieldRole.STATUS, meaning: 'Tags/labels', sensitivity: 'low', stability: 'contextual' },
    { keys: ['active', 'isactive', 'is active', 'enabled', 'isenabled', 'is enabled', 'live'], role: FieldRole.STATUS, meaning: 'Active flag', sensitivity: 'low', stability: 'contextual' },
    { keys: ['approved', 'isapproved', 'is approved', 'approval', 'approval status'], role: FieldRole.STATUS, meaning: 'Approval status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['verified', 'isverified', 'is verified', 'confirmed', 'isconfirmed', 'is confirmed', 'validation'], role: FieldRole.STATUS, meaning: 'Verification status', sensitivity: 'low', stability: 'contextual' },
    { keys: ['source', 'origin', 'referral source', 'lead source', 'channel'], role: FieldRole.STATUS, meaning: 'Source/origin', sensitivity: 'low', stability: 'stable' },
    { keys: ['gender', 'sex'], role: FieldRole.STATUS, meaning: 'Gender', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['race', 'ethnicity', 'race ethnicity', 'raceethnicity', 'race/ethnicity'], role: FieldRole.STATUS, meaning: 'Race/Ethnicity', sensitivity: 'high', stability: 'stable' },

    //  Contact (communication channels) 
    { keys: ['email', 'email address', 'emailaddress', 'e-mail', 'e mail', 'mail', 'primary email'], role: FieldRole.CONTACT, meaning: 'Email address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['phone', 'telephone', 'phone number', 'phonenumber', 'tel', 'primary phone', 'contact number'], role: FieldRole.CONTACT, meaning: 'Phone number', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['mobile phone', 'mobile', 'cell', 'cellphone', 'cell phone', 'mobilephone', 'mobile number'], role: FieldRole.CONTACT, meaning: 'Mobile phone', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['work phone', 'workphone', 'office phone', 'officephone', 'business phone'], role: FieldRole.CONTACT, meaning: 'Work phone', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['fax', 'fax number', 'faxnumber'], role: FieldRole.CONTACT, meaning: 'Fax number', sensitivity: 'low', stability: 'stable' },
    { keys: ['url', 'link', 'href', 'web address', 'webaddress', 'uri', 'website', 'web', 'homepage', 'webpage'], role: FieldRole.CONTACT, meaning: 'URL/website', sensitivity: 'low', stability: 'contextual' },
    { keys: ['image url', 'imageurl', 'image', 'img', 'photo', 'picture', 'pic', 'avatar', 'thumbnail', 'icon'], role: FieldRole.CONTACT, meaning: 'Image', sensitivity: 'low', stability: 'contextual' },

    //  Organizational (workplace structure) 
    { keys: ['department', 'dept', 'division', 'team', 'unit', 'group'], role: FieldRole.ORGANIZATIONAL, meaning: 'Department', sensitivity: 'low', stability: 'contextual' },
    { keys: ['job title', 'jobtitle', 'title', 'position', 'role', 'designation'], role: FieldRole.ORGANIZATIONAL, meaning: 'Job title', sensitivity: 'low', stability: 'contextual' },
    { keys: ['manager', 'supervisor', 'reports to', 'reportsto', 'boss', 'lead'], role: FieldRole.ORGANIZATIONAL, meaning: 'Manager', sensitivity: 'low', stability: 'contextual' },

    //  Quantity (numeric/measurable values) 
    { keys: ['amount', 'amt', 'value', 'total', 'sum', 'grand total'], role: FieldRole.QUANTITY, meaning: 'Amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['price', 'cost', 'unit price', 'unitprice', 'rate', 'charge', 'fee'], role: FieldRole.QUANTITY, meaning: 'Price/cost', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['revenue', 'income', 'earnings', 'sales', 'proceeds', 'gross'], role: FieldRole.QUANTITY, meaning: 'Revenue', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['balance', 'outstanding', 'remaining', 'due', 'owed'], role: FieldRole.QUANTITY, meaning: 'Balance', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['payment amount', 'paymentamount', 'payment', 'pay', 'payout'], role: FieldRole.QUANTITY, meaning: 'Payment amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['currency', 'curr', 'currency code', 'currencycode'], role: FieldRole.QUANTITY, meaning: 'Currency', sensitivity: 'low', stability: 'stable' },
    { keys: ['tax amount', 'taxamount', 'tax', 'taxes', 'vat', 'gst'], role: FieldRole.QUANTITY, meaning: 'Tax amount', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['discount', 'disc', 'discount amount', 'discountamount', 'rebate'], role: FieldRole.QUANTITY, meaning: 'Discount', sensitivity: 'low', stability: 'contextual' },
    { keys: ['quantity', 'qty', 'count', 'number', 'num', 'units', 'pieces', 'lot size'], role: FieldRole.QUANTITY, meaning: 'Quantity/count', sensitivity: 'low', stability: 'contextual' },
    { keys: ['age', 'years old', 'yearsold'], role: FieldRole.QUANTITY, meaning: 'Age', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['weight', 'mass', 'wt'], role: FieldRole.QUANTITY, meaning: 'Weight', sensitivity: 'low', stability: 'contextual' },
    { keys: ['height', 'length', 'width', 'depth', 'size', 'dimension'], role: FieldRole.QUANTITY, meaning: 'Dimension', sensitivity: 'low', stability: 'contextual' },
    { keys: ['percentage', 'percent', 'pct', 'ratio', 'rate'], role: FieldRole.QUANTITY, meaning: 'Percentage/ratio', sensitivity: 'low', stability: 'contextual' },
    { keys: ['score', 'rating', 'rank', 'grade', 'points'], role: FieldRole.QUANTITY, meaning: 'Score/rating', sensitivity: 'low', stability: 'contextual' },

    //  Spatial (location and geography) 
    { keys: ['street address', 'address', 'address1', 'address line 1', 'street', 'street1', 'mailing address', 'physical address'], role: FieldRole.SPATIAL, meaning: 'Street address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['address line 2', 'address2', 'address line2', 'apt', 'suite', 'unit', 'street2'], role: FieldRole.SPATIAL, meaning: 'Address line 2', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['city', 'town', 'municipality', 'locality'], role: FieldRole.SPATIAL, meaning: 'City', sensitivity: 'low', stability: 'contextual' },
    { keys: ['state', 'province', 'region', 'state province', 'stateprovince'], role: FieldRole.SPATIAL, meaning: 'State/province', sensitivity: 'low', stability: 'contextual' },
    { keys: ['postal code', 'zip', 'zipcode', 'zip code', 'postcode', 'post code'], role: FieldRole.SPATIAL, meaning: 'Postal code', sensitivity: 'low', stability: 'stable' },
    { keys: ['county', 'parish', 'district', 'borough'], role: FieldRole.SPATIAL, meaning: 'County/district', sensitivity: 'low', stability: 'stable' },
    { keys: ['country', 'nation', 'country code', 'countrycode'], role: FieldRole.SPATIAL, meaning: 'Country', sensitivity: 'low', stability: 'stable' },
    { keys: ['latitude', 'lat'], role: FieldRole.SPATIAL, meaning: 'Latitude', sensitivity: 'low', stability: 'stable' },
    { keys: ['longitude', 'lng', 'lon', 'long'], role: FieldRole.SPATIAL, meaning: 'Longitude', sensitivity: 'low', stability: 'stable' },
    { keys: ['full address', 'fulladdress', 'complete address', 'location', 'site'], role: FieldRole.SPATIAL, meaning: 'Full address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['po box', 'pobox', 'p.o. box'], role: FieldRole.SPATIAL, meaning: 'PO Box', sensitivity: 'low', stability: 'stable' },

    //  Relational (foreign keys, linked records) 
    { keys: ['parent id', 'parentid', 'parent'], role: FieldRole.RELATIONAL, meaning: 'Parent record', sensitivity: 'low', stability: 'stable' },
    { keys: ['customer id', 'customerid', 'customer', 'cust id', 'custid', 'client id', 'clientid', 'client'], role: FieldRole.RELATIONAL, meaning: 'Customer reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['user id', 'userid', 'user', 'member id', 'memberid'], role: FieldRole.RELATIONAL, meaning: 'User reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['account id', 'accountid', 'account', 'acct id', 'acctid'], role: FieldRole.RELATIONAL, meaning: 'Account reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['organization id', 'organizationid', 'orgid', 'org id', 'company id', 'companyid'], role: FieldRole.RELATIONAL, meaning: 'Organization reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['case id', 'caseid', 'case', 'case number', 'casenumber', 'ticket', 'ticket id', 'ticketid'], role: FieldRole.RELATIONAL, meaning: 'Case/ticket reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['order id', 'orderid'], role: FieldRole.RELATIONAL, meaning: 'Order reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['product id', 'productid', 'prod id', 'prodid', 'item id', 'itemid'], role: FieldRole.RELATIONAL, meaning: 'Product reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['vendor id', 'vendorid', 'supplier id', 'supplierid', 'vendor', 'supplier'], role: FieldRole.RELATIONAL, meaning: 'Vendor reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['employee id', 'employeeid', 'employee', 'emp id', 'empid', 'worker id'], role: FieldRole.RELATIONAL, meaning: 'Employee reference', sensitivity: 'low', stability: 'stable' },
    { keys: ['owner', 'assigned to', 'assignedto', 'assignee', 'responsible', 'created by', 'createdby', 'modified by', 'modifiedby', 'author'], role: FieldRole.RELATIONAL, meaning: 'Person reference', sensitivity: 'low', stability: 'contextual' },

    //  Temporal (dates and times) 
    { keys: ['date', 'dt'], role: FieldRole.TEMPORAL, meaning: 'Date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['created date', 'createdat', 'created at', 'created', 'creation date', 'datecreated', 'date created', 'created on', 'createdon'], role: FieldRole.TEMPORAL, meaning: 'Creation date', sensitivity: 'low', stability: 'stable' },
    { keys: ['modified date', 'updatedat', 'updated at', 'updated', 'modifiedat', 'modified at', 'last modified', 'datemodified', 'date modified', 'modified on', 'modifiedon', 'last updated', 'lastupdated'], role: FieldRole.TEMPORAL, meaning: 'Last modified date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['deleted date', 'deletedat', 'deleted at', 'deleted', 'deletion date', 'removed date'], role: FieldRole.TEMPORAL, meaning: 'Deletion date', sensitivity: 'low', stability: 'stable' },
    { keys: ['start date', 'startdate', 'begin date', 'begindate', 'from date', 'fromdate', 'effective date', 'effectivedate', 'start'], role: FieldRole.TEMPORAL, meaning: 'Start date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['end date', 'enddate', 'finish date', 'finishdate', 'to date', 'todate', 'expiry date', 'expirydate', 'expiration date', 'expires', 'due date', 'duedate', 'deadline', 'end'], role: FieldRole.TEMPORAL, meaning: 'End date', sensitivity: 'low', stability: 'contextual' },
    { keys: ['timestamp', 'ts', 'datetime', 'date time'], role: FieldRole.TEMPORAL, meaning: 'Timestamp', sensitivity: 'low', stability: 'stable' },
    { keys: ['year', 'yr', 'fiscal year', 'fiscalyear', 'fy'], role: FieldRole.TEMPORAL, meaning: 'Year', sensitivity: 'low', stability: 'stable' },
    { keys: ['month', 'mo', 'period'], role: FieldRole.TEMPORAL, meaning: 'Month', sensitivity: 'low', stability: 'stable' },
    { keys: ['quarter', 'qtr', 'q'], role: FieldRole.TEMPORAL, meaning: 'Quarter', sensitivity: 'low', stability: 'stable' },
    { keys: ['date of birth', 'dob', 'birthdate', 'birth date', 'birthday'], role: FieldRole.TEMPORAL, meaning: 'Date of birth', sensitivity: 'high', stability: 'stable' },
    { keys: ['hire date', 'hiredate', 'hired date', 'date hired', 'employment date', 'start date'], role: FieldRole.TEMPORAL, meaning: 'Hire date', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['termination date', 'terminationdate', 'term date', 'termdate', 'separation date', 'end of employment'], role: FieldRole.TEMPORAL, meaning: 'Termination date', sensitivity: 'moderate', stability: 'stable' },
    { keys: ['duration', 'elapsed', 'time spent', 'timespent', 'hours', 'minutes'], role: FieldRole.TEMPORAL, meaning: 'Duration', sensitivity: 'low', stability: 'contextual' },
    { keys: ['time', 'clock time'], role: FieldRole.TEMPORAL, meaning: 'Time', sensitivity: 'low', stability: 'contextual' },
    { keys: ['day', 'day of week', 'weekday'], role: FieldRole.TEMPORAL, meaning: 'Day', sensitivity: 'low', stability: 'stable' },

    //  Technical (system/internal fields) 
    { keys: ['uuid', 'guid', 'unique id', 'uniqueid'], role: FieldRole.TECHNICAL, meaning: 'UUID', sensitivity: 'low', stability: 'stable' },
    { keys: ['hash', 'checksum', 'md5', 'sha256', 'sha1', 'digest'], role: FieldRole.TECHNICAL, meaning: 'Hash/checksum', sensitivity: 'low', stability: 'stable' },
    { keys: ['version', 'ver', 'revision', 'rev'], role: FieldRole.TECHNICAL, meaning: 'Version', sensitivity: 'low', stability: 'contextual' },
    { keys: ['sequence number', 'sequencenumber', 'seq', 'sequence', 'sort order', 'sortorder', 'display order', 'ordinal'], role: FieldRole.TECHNICAL, meaning: 'Sequence number', sensitivity: 'low', stability: 'contextual' },
    { keys: ['batch id', 'batchid', 'batch', 'run id', 'runid'], role: FieldRole.TECHNICAL, meaning: 'Batch ID', sensitivity: 'low', stability: 'stable' },
    { keys: ['api key', 'apikey', 'token', 'access token', 'secret', 'secret key'], role: FieldRole.TECHNICAL, meaning: 'API key', sensitivity: 'high', stability: 'stable' },
    { keys: ['ip address', 'ipaddress', 'ip', 'ipv4', 'ipv6'], role: FieldRole.TECHNICAL, meaning: 'IP address', sensitivity: 'moderate', stability: 'contextual' },
    { keys: ['external identifier', 'externalidentifier', 'external id', 'externalid', 'ext id', 'extid', 'ref', 'reference', 'reference number'], role: FieldRole.TECHNICAL, meaning: 'External identifier', sensitivity: 'low', stability: 'stable' },
    { keys: ['file path', 'filepath', 'path', 'filename', 'file name'], role: FieldRole.TECHNICAL, meaning: 'File path', sensitivity: 'low', stability: 'contextual' },
    { keys: ['created by', 'createdby', 'author', 'creator'], role: FieldRole.TECHNICAL, meaning: 'Creator', sensitivity: 'low', stability: 'stable' },
    { keys: ['modified by', 'modifiedby', 'updated by', 'updatedby', 'last modified by', 'editor'], role: FieldRole.TECHNICAL, meaning: 'Last modifier', sensitivity: 'low', stability: 'stable' }
];

/**
 * Normalize a field name for comparison against definition keys.
 * Handles camelCase, snake_case, kebab-case, prefixes, suffixes.
 */
function normalizeFieldKey(fieldName) {
    return (fieldName || '')
        .toLowerCase()
        .replace(/([a-z])([A-Z])/g, '$1 $2')   // camelCase -> spaces
        .replace(/[-_]+/g, ' ')                  // separators -> spaces
        .replace(/\s+/g, ' ')                    // collapse whitespace
        .trim();
}

/**
 * Find the best matching definition for a field name.
 * Returns { definition, score, matchType } or null.
 */
function matchFieldToDefinition(fieldName) {
    if (!fieldName) return null;

    var normalized = normalizeFieldKey(fieldName);
    if (!normalized) return null;

    // Strip common prefixes (fld_, col_, field_, column_) and suffixes (_id, _key, _code, _num)
    var stripped = normalized
        .replace(/^(fld |col |field |column )/, '')
        .replace(/( id| key| code| num| no| number)$/, '');

    var bestMatch = null;
    var bestScore = 0;

    for (var i = 0; i < COMMON_DEFINITIONS.length; i++) {
        var def = COMMON_DEFINITIONS[i];
        var score = 0;
        var matchType = null;

        for (var k = 0; k < def.keys.length; k++) {
            var key = def.keys[k];

            // Exact match on normalized name
            if (normalized === key) {
                score = 1.0;
                matchType = 'exact';
                break;
            }

            // Exact match on stripped name
            if (stripped && stripped !== normalized && stripped === key) {
                score = 0.9;
                matchType = 'stripped';
                // Don't break, might find exact
            }

            // Contains match (field name contains the key or vice versa)
            if (score < 0.7) {
                if (normalized.includes(key) || key.includes(normalized)) {
                    var longer = normalized.length > key.length ? normalized : key;
                    var shorter = normalized.length > key.length ? key : normalized;
                    var containsScore = (shorter.length / longer.length) * 0.75;
                    if (containsScore > score) {
                        score = containsScore;
                        matchType = 'contains';
                    }
                }
            }
        }

        if (score > bestScore) {
            bestScore = score;
            bestMatch = { definition: def, score: score, matchType: matchType };
            if (score === 1.0) break; // Can't do better than exact
        }
    }

    // Minimum threshold
    return bestScore >= 0.4 ? bestMatch : null;
}

/**
 * Infer a field's semantic role from its name AND its data type.
 * Falls back to heuristics when no definition match is found.
 */
function inferFieldRole(fieldId, fieldMeta) {
    var fieldName = (fieldMeta && fieldMeta.fieldName) || fieldId;
    var fieldType = fieldMeta && fieldMeta.fieldType;

    // Try matching against known definitions first
    var match = matchFieldToDefinition(fieldName);
    if (match && match.score >= 0.4) {
        return {
            role: match.definition.role,
            confidence: match.score,
            meaning: match.definition.meaning,
            source: 'definition_match',
            matchType: match.matchType
        };
    }

    // Fallback: infer from field type
    if (fieldType === 'date' || fieldType === 'dateTime') {
        return { role: FieldRole.TEMPORAL, confidence: 0.6, meaning: 'Date field', source: 'type_inference' };
    }
    if (fieldType === 'number' || fieldType === 'currency' || fieldType === 'percent') {
        return { role: FieldRole.QUANTITY, confidence: 0.5, meaning: 'Numeric field', source: 'type_inference' };
    }
    if (fieldType === 'email') {
        return { role: FieldRole.CONTACT, confidence: 0.8, meaning: 'Email field', source: 'type_inference' };
    }
    if (fieldType === 'url') {
        return { role: FieldRole.CONTACT, confidence: 0.5, meaning: 'URL field', source: 'type_inference' };
    }
    if (fieldType === 'checkbox') {
        return { role: FieldRole.STATUS, confidence: 0.4, meaning: 'Boolean field', source: 'type_inference' };
    }
    if (fieldType === 'multipleRecordLinks') {
        return { role: FieldRole.RELATIONAL, confidence: 0.7, meaning: 'Linked records', source: 'type_inference' };
    }
    if (fieldType === 'multipleAttachments') {
        return { role: FieldRole.TECHNICAL, confidence: 0.5, meaning: 'Attachments', source: 'type_inference' };
    }

    // Fallback: heuristic patterns on the field name
    var norm = normalizeFieldKey(fieldName);
    if (/\b(id|key|pk|guid|uuid)\b/.test(norm)) {
        return { role: FieldRole.IDENTIFIER, confidence: 0.5, meaning: 'ID-like field', source: 'name_heuristic' };
    }
    if (/\b(date|time|created|updated|modified|timestamp)\b/.test(norm)) {
        return { role: FieldRole.TEMPORAL, confidence: 0.5, meaning: 'Time-like field', source: 'name_heuristic' };
    }
    if (/\b(name|title|label|subject|headline)\b/.test(norm)) {
        return { role: FieldRole.PRIMARY_IDENTITY, confidence: 0.5, meaning: 'Name-like field', source: 'name_heuristic' };
    }
    if (/\b(status|state|type|kind|category|active|enabled|flag)\b/.test(norm)) {
        return { role: FieldRole.STATUS, confidence: 0.4, meaning: 'Status-like field', source: 'name_heuristic' };
    }
    if (/\b(amount|price|cost|total|sum|count|qty|quantity|rate|fee|balance|revenue|payment|tax|discount|score|rating|percent|ratio)\b/.test(norm)) {
        return { role: FieldRole.QUANTITY, confidence: 0.4, meaning: 'Quantity-like field', source: 'name_heuristic' };
    }
    if (/\b(email|phone|mobile|cell|tel|fax|url|website|link)\b/.test(norm)) {
        return { role: FieldRole.CONTACT, confidence: 0.4, meaning: 'Contact-like field', source: 'name_heuristic' };
    }
    if (/\b(address|city|state|zip|postal|country|county|lat|lon|location)\b/.test(norm)) {
        return { role: FieldRole.SPATIAL, confidence: 0.4, meaning: 'Location-like field', source: 'name_heuristic' };
    }
    if (/\b(description|desc|notes|note|comment|remarks|memo|body|content|text|summary)\b/.test(norm)) {
        return { role: FieldRole.DESCRIPTIVE, confidence: 0.4, meaning: 'Descriptive field', source: 'name_heuristic' };
    }
    if (/\b(department|dept|team|role|position|manager|supervisor|job)\b/.test(norm)) {
        return { role: FieldRole.ORGANIZATIONAL, confidence: 0.4, meaning: 'Org field', source: 'name_heuristic' };
    }

    return { role: FieldRole.UNKNOWN, confidence: 0, meaning: 'Unknown', source: 'none' };
}

/**
 * Score a single field for left-to-right relevance.
 * Lower score = more relevant = further left.
 *
 * Scoring formula:
 *   base = ROLE_PRIORITY[role] * 100     (role is the primary sort factor)
 *   penalty adjustments:
 *     - High confidence match gets a bonus (moved left within role group)
 *     - Fields with "name" in them get extra left-push
 *     - Fields with only-ID suffixes get pushed right within their role group
 *     - Alphabetical tiebreaker within same score
 */
function scoreFieldRelevance(fieldId, fieldMeta) {
    var inference = inferFieldRole(fieldId, fieldMeta);
    var rolePriority = ROLE_PRIORITY[inference.role] !== undefined ? ROLE_PRIORITY[inference.role] : 11;

    // Base score from role (0-1100 range, in steps of 100)
    var score = rolePriority * 100;

    // Confidence adjustment: higher confidence = slightly more left (-0 to -40)
    score -= Math.round(inference.confidence * 40);

    // Name-like fields within identity get extra boost
    var norm = normalizeFieldKey((fieldMeta && fieldMeta.fieldName) || fieldId);
    if (inference.role === FieldRole.PRIMARY_IDENTITY) {
        // "name" or "full name" is the king column
        if (norm === 'name' || norm === 'full name' || norm === 'fullname' || norm === 'display name') {
            score -= 50;
        }
        // first name before last name
        if (norm.includes('first')) score -= 20;
        if (norm.includes('last')) score -= 10;
    }

    // Penalize pure ID fields (they look like "fldXyz123")
    if (/^fld[a-z0-9]+$/i.test(fieldId) && (!fieldMeta || !fieldMeta.fieldName || fieldMeta.fieldName === fieldId)) {
        score += 50; // Push raw field IDs to the right
    }

    return {
        fieldId: fieldId,
        score: score,
        role: inference.role,
        confidence: inference.confidence,
        meaning: inference.meaning,
        source: inference.source
    };
}

/**
 * Compute the intelligent default field order for a table.
 * This replaces the old alphabetical sort with semantic ordering.
 *
 * Returns an array of field IDs sorted by relevance (most relevant leftmost).
 */
function computeSmartFieldOrder(tableId) {
    var fields = META_FIELDS[tableId] || {};
    var fieldIds = Object.keys(fields);

    if (fieldIds.length === 0) return [];

    // Score every field
    var scored = fieldIds.map(function(fid) {
        return scoreFieldRelevance(fid, fields[fid]);
    });

    // Sort by score ascending (lower = more relevant = further left)
    // Tiebreaker: alphabetical by field name
    scored.sort(function(a, b) {
        if (a.score !== b.score) return a.score - b.score;
        var nameA = (fields[a.fieldId] && fields[a.fieldId].fieldName || a.fieldId).toLowerCase();
        var nameB = (fields[b.fieldId] && fields[b.fieldId].fieldName || b.fieldId).toLowerCase();
        return nameA.localeCompare(nameB);
    });

    // Log the smart ordering decision for debugging (only once per table)
    if (scored.length > 0 && !computeSmartFieldOrder._logged) computeSmartFieldOrder._logged = {};
    if (scored.length > 0 && !computeSmartFieldOrder._logged[tableId]) {
        computeSmartFieldOrder._logged[tableId] = true;
        // Track seen names to append field ID for disambiguation
        var _seenNames = {};
        var _top8 = scored.slice(0, 8);
        for (var _si = 0; _si < _top8.length; _si++) {
            var _n = fields[_top8[_si].fieldId] && fields[_top8[_si].fieldId].fieldName || _top8[_si].fieldId;
            _seenNames[_n] = (_seenNames[_n] || 0) + 1;
        }
        console.log('Smart column order for table ' + tableId + ':',
            _top8.map(function(s) {
                var name = fields[s.fieldId] && fields[s.fieldId].fieldName || s.fieldId;
                var suffix = _seenNames[name] > 1 ? ' (' + s.fieldId + ')' : '';
                return name + suffix + ' [' + s.role + ', score=' + s.score + ']';
            }).join(' | ')
        );
    }

    return scored.map(function(s) { return s.fieldId; });
}

// ============ View Field Configuration ============

// Get the field configuration for a view (from cache or initialize default)
function getViewFieldConfig(tableId, viewId) {
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};

    // Return cached config if exists
    if (VIEW_FIELD_CONFIG[tableId][viewId]) {
        return VIEW_FIELD_CONFIG[tableId][viewId];
    }

    // Check if view has stored config in META_VIEWS
    var view = META_VIEWS[tableId]?.[viewId];
    if (view && (view.hiddenFieldIds || view.fieldOrder)) {
        VIEW_FIELD_CONFIG[tableId][viewId] = {
            hiddenFieldIds: view.hiddenFieldIds || [],
            fieldOrder: view.fieldOrder || []
        };
        return VIEW_FIELD_CONFIG[tableId][viewId];
    }

    // Initialize default config - show all fields in their natural order
    return initViewFieldConfig(tableId, viewId);
}

// Initialize default view field config (all fields visible)
function initViewFieldConfig(tableId, viewId) {
    // Use intelligent column ordering instead of alphabetical sort.
    // This puts the most relevant fields (names, identifiers) leftmost
    // and pushes metadata/technical fields to the right.
    var smartOrder = computeSmartFieldOrder(tableId);

    var config = {
        hiddenFieldIds: [],            // No fields hidden initially (all visible)
        fieldOrder: smartOrder.slice()  // Intelligent semantic order
    };

    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    VIEW_FIELD_CONFIG[tableId][viewId] = config;

    return config;
}

// Save view field configuration to memory and IndexedDB
async function saveViewFieldConfig(tableId, viewId, config) {
    // Update cache
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    VIEW_FIELD_CONFIG[tableId][viewId] = config;

    // Update META_VIEWS and persist to IndexedDB
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        // Create a synthetic view if it doesn't exist
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId,
            viewType: 'grid'
        };
    }

    // Merge config into view
    META_VIEWS[tableId][viewId].hiddenFieldIds = config.hiddenFieldIds;
    META_VIEWS[tableId][viewId].fieldOrder = config.fieldOrder;

    // Persist to IndexedDB
    await saveView(META_VIEWS[tableId][viewId]);
}

// Save view filters, sorts, and groupBy to IndexedDB
async function saveViewFiltersAndSorts(tableId, viewId, filters, sorts, groupBy) {
    if (!tableId || !viewId) return;

    // Update META_VIEWS
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        // Create a synthetic view if it doesn't exist
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId,
            viewType: 'grid'
        };
    }

    // Store filters, sorts, groupBy, and colorBy
    META_VIEWS[tableId][viewId].filters = filters || { logic: 'AND', conditions: [] };
    META_VIEWS[tableId][viewId].sorts = sorts || [];
    META_VIEWS[tableId][viewId].groupBy = groupBy || null;
    META_VIEWS[tableId][viewId].colorBy = currentColorBy || null;

    // Persist to IndexedDB
    await saveView(META_VIEWS[tableId][viewId]);
}

// Get view filters, sorts, groupBy, and colorBy
function getViewFiltersAndSorts(tableId, viewId) {
    if (!tableId || !viewId) return { filters: normalizeFilterGroup([]), sorts: [], groupBy: null, colorBy: null };

    var view = META_VIEWS[tableId]?.[viewId];
    return {
        filters: normalizeFilterGroup((view && view.filters) ? view.filters : []),
        sorts: (view && view.sorts) ? view.sorts.slice() : [],
        groupBy: (view && view.groupBy) ? view.groupBy : null,
        colorBy: (view && view.colorBy) ? view.colorBy : null
    };
}

// Memoize visible fields per render cycle (same table+view = same result)
var _visibleFieldsCache = { key: null, result: null };
function invalidateVisibleFieldsCache() { _visibleFieldsCache.key = null; _visibleFieldsCache.result = null; }

// Get visible fields for current view in correct order
function getVisibleFieldsForView(tableId, viewId) {
    var ckey = tableId + '|' + (viewId || '_default');
    if (_visibleFieldsCache.key === ckey && _visibleFieldsCache.result) return _visibleFieldsCache.result;
    var config = getViewFieldConfig(tableId, viewId || '_default');
    var fields = META_FIELDS[tableId] || {};
    var allFieldIds = Object.keys(fields);

    // Hidden fields are in hiddenFieldIds; all others are visible
    var hiddenSet = new Set(config.hiddenFieldIds || []);
    var result = [];
    var addedSet = new Set();

    // First add fields from fieldOrder that are not hidden
    for (var fid of (config.fieldOrder || [])) {
        if (fields[fid] && !hiddenSet.has(fid) && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    // Add any remaining visible fields not in fieldOrder (newly added fields)
    for (var fid of allFieldIds) {
        if (!hiddenSet.has(fid) && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    _visibleFieldsCache.key = ckey;
    _visibleFieldsCache.result = result;
    return result;
}

// Get all fields in order (both visible and hidden) for the fields dropdown
function getAllFieldsInOrder(tableId, viewId) {
    var config = getViewFieldConfig(tableId, viewId || '_default');
    var fields = META_FIELDS[tableId] || {};
    var allFieldIds = Object.keys(fields);
    var result = [];
    var addedSet = new Set();

    // First add fields in fieldOrder
    for (var fid of (config.fieldOrder || [])) {
        if (fields[fid] && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    // Then add any remaining fields (newly added ones)
    for (var fid of allFieldIds) {
        if (!addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    return result;
}

// Toggle field visibility for current view
function toggleFieldVisibility(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    if (!config.hiddenFieldIds) config.hiddenFieldIds = [];

    var idx = config.hiddenFieldIds.indexOf(fieldId);
    if (idx >= 0) {
        // Field is hidden, make it visible
        config.hiddenFieldIds.splice(idx, 1);
    } else {
        // Field is visible, hide it
        config.hiddenFieldIds.push(fieldId);
    }

    // Ensure field is in fieldOrder
    if (!config.fieldOrder.includes(fieldId)) {
        config.fieldOrder.push(fieldId);
    }

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

// Move field up in order (optimized with DOM manipulation)
function moveFieldUp(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var idx = config.fieldOrder.indexOf(fieldId);
    if (idx > 0) {
        // Move column in DOM immediately (no full re-render)
        moveColumnInDOM(idx, idx - 1);

        // Swap with previous in array
        var temp = config.fieldOrder[idx - 1];
        config.fieldOrder[idx - 1] = config.fieldOrder[idx];
        config.fieldOrder[idx] = temp;

        // Fast update: in-memory + debounced save
        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();
    }
}

// Move field down in order (optimized with DOM manipulation)
function moveFieldDown(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var idx = config.fieldOrder.indexOf(fieldId);
    if (idx >= 0 && idx < config.fieldOrder.length - 1) {
        // Move column in DOM immediately (no full re-render)
        moveColumnInDOM(idx, idx + 1);

        // Swap with next in array
        var temp = config.fieldOrder[idx + 1];
        config.fieldOrder[idx + 1] = config.fieldOrder[idx];
        config.fieldOrder[idx] = temp;

        // Fast update: in-memory + debounced save
        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();
    }
}

// Show all fields
function showAllFields() {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var fields = META_FIELDS[currentTable] || {};
    var allFieldIds = Object.keys(fields);

    var config = getViewFieldConfig(currentTable, viewId);
    config.hiddenFieldIds = []; // Clear all hidden fields

    // Ensure all fields are in fieldOrder
    for (var fid of allFieldIds) {
        if (!config.fieldOrder.includes(fid)) {
            config.fieldOrder.push(fid);
        }
    }

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

// Hide all fields (except keep at least one visible)
function hideAllFields() {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var fields = META_FIELDS[currentTable] || {};
    var allFieldIds = Object.keys(fields);

    var config = getViewFieldConfig(currentTable, viewId);

    // Get all fields in order, keep the first one visible
    var orderedFields = getAllFieldsInOrder(currentTable, viewId);
    var firstField = orderedFields[0] || allFieldIds[0];

    // Hide all fields except the first one
    config.hiddenFieldIds = allFieldIds.filter(fid => fid !== firstField);

    // Fast path: update in-memory immediately, defer IndexedDB save
    updateFieldVisibilityFast(currentTable, viewId, config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    renderTable();
}

function getLocalStats() {
    return new Promise(async (resolve) => {
        try {
            var tempDb = await openDB();
            var count = await new Promise((res, rej) => {
                var tx = tempDb.transaction('data', 'readonly');
                var req = tx.objectStore('data').count();
                req.onsuccess = () => res(req.result);
                req.onerror = () => res(0);
            });
            var lastTimestamp = await new Promise((res, rej) => {
                var tx = tempDb.transaction('sync', 'readonly');
                var req = tx.objectStore('sync').get('lastEventTimestamp');
                req.onsuccess = () => res(req.result ? req.result.value : null);
                req.onerror = () => res(null);
            });
            tempDb.close();
            resolve({ count, lastTimestamp });
        } catch (e) {
            resolve({ count: 0, lastTimestamp: null });
        }
    });
}

// ============ Safe JSON Parsing ============

// Safely parse a fetch Response as JSON. If the server returns non-JSON
// (e.g. an HTML error page from a reverse proxy), this throws a clear
// error instead of the cryptic "Unexpected token '<'" message.
async function safeResponseJson(response, context) {
    var contentType = (response.headers.get('content-type') || '').toLowerCase();
    var body = '';

    try {
        body = await response.text();
    } catch (e) {
        throw new Error(
            (context ? context + ': ' : '') +
            'Could not read response body (HTTP ' + response.status + ').'
        );
    }

    var preview = body.substring(0, 120).trim();
    if (!preview) {
        throw new Error(
            (context ? context + ': ' : '') +
            'Empty response body (HTTP ' + response.status + ').'
        );
    }

    // Accept JSON payloads even when a proxy/webhook mislabels content-type.
    // We still keep content-type in error messages for easier diagnostics.
    try {
        return JSON.parse(body);
    } catch (e) {
        var maybeHtml = preview.indexOf('<html') !== -1 || preview.indexOf('<!DOCTYPE') !== -1;
        throw new Error(
            (context ? context + ': ' : '') +
            'Invalid JSON response from server (HTTP ' + response.status + '). ' +
            'content-type=' + (contentType || 'unknown') +
            ', body="' + preview.replace(/\s+/g, ' ') + '".' +
            (maybeHtml ? ' The server may be down or the URL may be incorrect.' : '')
        );
    }
}

// ============ Synapse Login ============

var SYNAPSE_HOMESERVER_URL = 'https://app.aminoimmigration.com';
var SYNAPSE_SESSION_KEY = 'amino_synapse_session';

function _saveSynapseSession(session) {
    try {
        localStorage.setItem(SYNAPSE_SESSION_KEY, JSON.stringify(session));
    } catch (e) {
        console.warn('[Synapse] Could not save session:', e);
    }
}

function _loadSynapseSession() {
    try {
        var stored = localStorage.getItem(SYNAPSE_SESSION_KEY);
        return stored ? JSON.parse(stored) : null;
    } catch (e) {
        return null;
    }
}

function _clearSynapseSession() {
    localStorage.removeItem(SYNAPSE_SESSION_KEY);
}

async function verifySynapseSession() {
    var session = _loadSynapseSession();
    if (!session || !session.accessToken) return false;

    try {
        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/account/whoami', {
            headers: { 'Authorization': 'Bearer ' + session.accessToken }
        });
        if (!response.ok) {
            // Token expired or invalid
            _clearSynapseSession();
            return false;
        }
        // Verify the response is actually JSON from a Matrix server,
        // not an HTML page from a reverse proxy or misconfigured server
        var contentType = response.headers.get('content-type') || '';
        if (!contentType.includes('application/json')) {
            console.warn('[Synapse] Session verification returned non-JSON response (content-type: ' + contentType + '). Server may be misconfigured.');
            _clearSynapseSession();
            return false;
        }
        return true;
    } catch (e) {
        // Network error  allow offline access if session exists
        console.warn('[Synapse] Could not verify session, allowing cached session:', e);
        return true;
    }
}

async function trySynapseLogin() {
    var username = document.getElementById('synapse-username').value.trim();
    var password = document.getElementById('synapse-password').value.trim();

    if (!username || !password) {
        showSynapseError('Please enter your username and password.');
        return;
    }

    var btn = document.getElementById('synapse-login-btn');
    btn.textContent = 'Signing in...';
    btn.disabled = true;
    hideSynapseError();

    try {
        var body = {
            type: 'm.login.password',
            identifier: { type: 'm.id.user', user: username },
            password: password,
            initial_device_display_name: 'Amino Viewer'
        };

        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });

        var data = await safeResponseJson(response, 'Login');

        if (!response.ok) {
            throw new Error(data.error || 'Login failed');
        }

        _saveSynapseSession({
            homeserverUrl: SYNAPSE_HOMESERVER_URL,
            accessToken: data.access_token,
            userId: data.user_id,
            deviceId: data.device_id
        });

        // Set up MatrixClient session for room operations
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, data.access_token, data.user_id, data.device_id);

        // Derive local encryption key from Synapse password
        var salt = new TextEncoder().encode('amino-local-encrypt:' + data.user_id);
        var derivedKey = await deriveKeyFromPassword(password, salt);

        // Check for existing encryption config and handle migration
        var existingConfig = getEncryptionConfig();
        if (existingConfig && existingConfig.verificationToken && existingConfig.type === 'synapse') {
            // Returning user  verify the derived key matches
            try {
                await decryptData(existingConfig.verificationToken, derivedKey);
            } catch (e) {
                // Password changed on Synapse  re-create encryption config with new key
                console.warn('[Synapse] Password changed, re-creating encryption config');
                var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, derivedKey);
                saveEncryptionConfig({
                    type: 'synapse',
                    userId: data.user_id,
                    verificationToken: verificationToken
                });
            }
        } else {
            // First time or migrating from old flow  create new encryption config
            var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, derivedKey);
            saveEncryptionConfig({
                type: 'synapse',
                userId: data.user_id,
                verificationToken: verificationToken
            });
        }

        encryptionKey = derivedKey;
        encryptionEnabled = true;
        _deferEncryptionUI = true;
        await saveSessionKey(encryptionKey);

        // NOTE: AminoData layer is not used for the main hydration flow 
        // hydrateFromWebhooks() handles fetching from n8n directly.
        // Skipping AminoData.init() here to avoid a redundant /api/tables call.
        // However, sub-pages (layout builder, client profile) need the derived
        // encryption key to initialize AminoData. Pre-store it for them.
        await AminoData.prepareKey(password, data.user_id);

        // Password no longer needed
        password = null;

        // Show loading overlay before hiding login screen to prevent blank screen gap
        showLoadingOverlay();
        updateLoadingOverlay('Signing in...', 'Setting up your workspace...', 0, 0, 0, 0, null);
        hideSynapseLoginScreen();

        // Decide whether to keep encrypted local data or clear for re-hydration.
        // If the same user logs back in with the same password, the derived key
        // will match the verification token and we can reuse cached data  it's
        // already AES-GCM-256 encrypted at rest and unreadable without the key.
        var retainLocalData = false;
        if (existingConfig && existingConfig.type === 'synapse'
            && existingConfig.userId === data.user_id
            && existingConfig.verificationToken) {
            try {
                await decryptData(existingConfig.verificationToken, derivedKey);
                retainLocalData = true;
                console.log('[Synapse] Returning user with valid key  retaining encrypted local data');
            } catch (e) {
                console.log('[Synapse] Key mismatch (password changed or different user)  clearing local data');
            }
        }

        if (!retainLocalData) {
            try {
                var freshDb = await openDB();
                db = freshDb;
                await clearAllData();
                db.close();
                db = null;
            } catch (clearErr) {
                console.warn('[Synapse] Could not clear local data for fresh sync:', clearErr);
            }
        }

        // Go directly to app initialization  will hydrate all rooms from Synapse
        try {
            await init();
        } catch (initErr) {
            console.error('[Synapse] Init failed after login:', initErr);
            hideLoadingOverlay();
            showSynapseError('Signed in but initialization failed: ' + initErr.message);
            showSynapseLoginScreen();
        }
    } catch (err) {
        console.error('[Synapse] Login failed:', err);
        showSynapseError(err.message || 'Login failed. Please check your credentials.');
    } finally {
        btn.textContent = 'Sign In';
        btn.disabled = false;
    }
}

function showSynapseError(msg) {
    var el = document.getElementById('synapse-login-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function hideSynapseError() {
    var el = document.getElementById('synapse-login-error');
    el.style.display = 'none';
}

function showSynapseLoginScreen() {
    var el = document.getElementById('synapse-login-screen');
    el.classList.remove('hidden', 'fading-out');
    // Always show the login form, not the reset form
    document.getElementById('synapse-login-form').style.display = 'block';
    document.getElementById('synapse-reset-form').style.display = 'none';
}

function hideSynapseLoginScreen() {
    var el = document.getElementById('synapse-login-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    setTimeout(function() { el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

async function initSynapseLogin() {
    var valid = await verifySynapseSession();
    if (valid) {
        // Session is valid  restore MatrixClient and proceed
        var session = _loadSynapseSession();
        if (session) {
            MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
        }
        return true;
    }
    // No valid session  show Synapse login screen
    showSynapseLoginScreen();
    return false;
}

// ============ Password Reset ============

var _resetClientSecret = null;
var _resetSid = null;

function showPasswordReset() {
    document.getElementById('synapse-login-form').style.display = 'none';
    document.getElementById('synapse-reset-form').style.display = 'block';
    _showResetStep(1);
    _resetClientSecret = null;
    _resetSid = null;
    document.getElementById('synapse-reset-error').style.display = 'none';
    document.getElementById('synapse-reset-success').style.display = 'none';
}

function hidePasswordReset() {
    document.getElementById('synapse-reset-form').style.display = 'none';
    document.getElementById('synapse-login-form').style.display = 'block';
    document.getElementById('synapse-reset-email').value = '';
    document.getElementById('synapse-reset-error').style.display = 'none';
    document.getElementById('synapse-reset-success').style.display = 'none';
}

function _showResetStep(step) {
    document.querySelectorAll('.synapse-reset-step').forEach(function(el) { el.classList.remove('active'); });
    var stepEl = document.getElementById('synapse-reset-step' + step);
    if (stepEl) stepEl.classList.add('active');
}

function _showResetError(msg) {
    var el = document.getElementById('synapse-reset-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function _hideResetError() {
    document.getElementById('synapse-reset-error').style.display = 'none';
}

async function requestPasswordReset() {
    var email = document.getElementById('synapse-reset-email').value.trim();
    if (!email) {
        _showResetError('Please enter your email address.');
        return;
    }

    var btn = document.getElementById('synapse-reset-send-btn');
    btn.disabled = true;
    btn.textContent = 'Sending...';
    _hideResetError();

    try {
        // Generate a unique client_secret for this reset flow
        _resetClientSecret = 'amino_reset_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/account/password/email/requestToken', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                email: email,
                client_secret: _resetClientSecret,
                send_attempt: 1
            })
        });

        var data = await response.json().catch(function() { return {}; });

        if (!response.ok) {
            if (data.errcode === 'M_THREEPID_NOT_FOUND') {
                throw new Error('No account found with that email address.');
            }
            throw new Error(data.error || 'Failed to send reset email (HTTP ' + response.status + ')');
        }

        _resetSid = data.sid;

        // Move to step 2  user must verify email then enter new password
        _showResetStep(2);

    } catch (e) {
        console.error('[Reset] Failed to request password reset:', e);
        _showResetError(e.message || 'Failed to send reset email.');
    } finally {
        btn.disabled = false;
        btn.textContent = 'Send Reset Email';
    }
}

async function confirmPasswordReset() {
    var newPassword = document.getElementById('synapse-reset-new-password').value;
    var confirmPassword = document.getElementById('synapse-reset-confirm-password').value;

    if (!newPassword) {
        _showResetError('Please enter a new password.');
        return;
    }
    if (newPassword.length < 8) {
        _showResetError('Password must be at least 8 characters.');
        return;
    }
    if (newPassword !== confirmPassword) {
        _showResetError('Passwords do not match.');
        return;
    }

    if (!_resetSid || !_resetClientSecret) {
        _showResetError('Reset session expired. Please start over.');
        return;
    }

    var btn = document.getElementById('synapse-reset-confirm-btn');
    btn.disabled = true;
    btn.textContent = 'Resetting...';
    _hideResetError();

    try {
        var response = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/account/password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                new_password: newPassword,
                logout_devices: false,
                auth: {
                    type: 'm.login.email.identity',
                    threepid_creds: {
                        sid: _resetSid,
                        client_secret: _resetClientSecret
                    },
                    threepidCreds: {
                        sid: _resetSid,
                        client_secret: _resetClientSecret
                    }
                }
            })
        });

        if (!response.ok) {
            var data = await response.json().catch(function() { return {}; });
            if (data.errcode === 'M_THREEPID_AUTH_FAILED') {
                throw new Error('Email not yet verified. Please click the link in your email first, then try again.');
            }
            throw new Error(data.error || 'Failed to reset password (HTTP ' + response.status + ')');
        }

        // Success  show step 3
        _showResetStep(3);
        document.getElementById('synapse-reset-new-password').value = '';
        document.getElementById('synapse-reset-confirm-password').value = '';
        _resetClientSecret = null;
        _resetSid = null;

    } catch (e) {
        console.error('[Reset] Failed to confirm password reset:', e);
        _showResetError(e.message || 'Failed to reset password.');
    } finally {
        btn.disabled = false;
        btn.textContent = 'Reset Password';
    }
}

// ============ View Selection ============

function showViewSelection() {
    var el = document.getElementById('view-selection-screen');
    el.classList.remove('hidden');
}

function hideViewSelection() {
    var el = document.getElementById('view-selection-screen');
    el.classList.add('hidden');
}

function selectDatabaseView() {
    hideViewSelection();
    // Database view is the current default  already rendered by init()
}

function selectInterfaceView() {
    hideViewSelection();
    switchApp('interface');
}

function synapseLogout() {
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        // Fire and forget logout request
        fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/logout', {
            method: 'POST',
            headers: {
                'Authorization': 'Bearer ' + session.accessToken,
                'Content-Type': 'application/json'
            }
        }).catch(function() {});
    }
    // Keep a minimal session stub (userId + homeserverUrl) for offline re-login.
    // The access token is cleared since the server invalidated it.
    if (session && session.userId) {
        _saveSynapseSession({
            homeserverUrl: (session.homeserverUrl || SYNAPSE_HOMESERVER_URL),
            userId: session.userId,
            accessToken: null,
            deviceId: null
        });
    } else {
        _clearSynapseSession();
    }
    // Clear the stored AminoData encryption key used by sub-pages
    localStorage.removeItem('amino_data_layer_key');
}

// Wire up Synapse login UI
document.getElementById('synapse-login-btn').onclick = trySynapseLogin;
document.getElementById('synapse-username').onkeydown = function(e) { if (e.key === 'Enter') document.getElementById('synapse-password').focus(); };
document.getElementById('synapse-password').onkeydown = function(e) { if (e.key === 'Enter') trySynapseLogin(); };

// Wire up password reset UI
document.getElementById('synapse-reset-email').onkeydown = function(e) { if (e.key === 'Enter') requestPasswordReset(); };
document.getElementById('synapse-reset-new-password').onkeydown = function(e) { if (e.key === 'Enter') document.getElementById('synapse-reset-confirm-password').focus(); };
document.getElementById('synapse-reset-confirm-password').onkeydown = function(e) { if (e.key === 'Enter') confirmPasswordReset(); };

// Wire up view selection UI
document.getElementById('view-as-database-btn').onclick = selectDatabaseView;
document.getElementById('view-as-interface-btn').onclick = selectInterfaceView;

// ============ Offline Unlock ============

var _isOfflineSession = false;

function showOfflineUnlockScreen() {
    var session = _loadSynapseSession();
    var screen = document.getElementById('offline-unlock-screen');
    screen.classList.add('visible');

    // Show cached username
    if (session && session.userId) {
        var userBadge = document.getElementById('offline-unlock-user');
        var usernameSpan = document.getElementById('offline-unlock-username');
        var localpart = session.userId.split(':')[0].replace(/^@/, '');
        usernameSpan.textContent = localpart;
        userBadge.style.display = 'inline-flex';
    }

    // Hide the synapse login screen while offline unlock is visible
    document.getElementById('synapse-login-screen').classList.add('hidden');

    // Focus the password input
    setTimeout(function() {
        document.getElementById('offline-unlock-password').focus();
    }, 100);
}

function hideOfflineUnlockScreen() {
    var screen = document.getElementById('offline-unlock-screen');
    screen.classList.add('fading-out');
    screen.addEventListener('transitionend', function handler() {
        screen.removeEventListener('transitionend', handler);
        screen.classList.remove('visible', 'fading-out');
    }, { once: true });
    setTimeout(function() { screen.classList.remove('visible', 'fading-out'); }, 400);
}

function showOfflineUnlockError(msg) {
    var el = document.getElementById('offline-unlock-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function hideOfflineUnlockError() {
    document.getElementById('offline-unlock-error').style.display = 'none';
}

function showOfflineModeBanner() {
    document.getElementById('offline-mode-banner').classList.add('visible');
}

function hideOfflineModeBanner() {
    document.getElementById('offline-mode-banner').classList.remove('visible');
}

async function tryOfflineUnlock() {
    var password = document.getElementById('offline-unlock-password').value;
    if (!password) {
        showOfflineUnlockError('Please enter your password.');
        return;
    }

    var btn = document.getElementById('offline-unlock-btn');
    btn.textContent = 'Unlocking...';
    btn.disabled = true;
    hideOfflineUnlockError();

    try {
        var session = _loadSynapseSession();
        if (!session || !session.userId) {
            throw new Error('No cached session found.');
        }

        // 1. Derive the UI-level encryption key (same as trySynapseLogin)
        var salt = new TextEncoder().encode('amino-local-encrypt:' + session.userId);
        var derivedKey = await deriveKeyFromPassword(password, salt);

        // 2. Verify against stored encryption config
        var config = getEncryptionConfig();
        if (config && config.verificationToken && config.type === 'synapse') {
            try {
                await decryptData(config.verificationToken, derivedKey);
            } catch (e) {
                throw new Error('Incorrect password.');
            }
        } else {
            throw new Error('No encryption data found. Please sign in online first.');
        }

        // 3. Set UI encryption state
        encryptionKey = derivedKey;
        encryptionEnabled = true;
        _deferEncryptionUI = true;
        await saveSessionKey(encryptionKey);

        // 4. Prepare AminoData key for sub-pages
        await AminoData.prepareKey(password, session.userId);

        // 5. Use AminoData.offlineUnlock for the data layer
        var unlockResult = await AminoData.offlineUnlock(password);

        // 6. Show last synced time
        if (unlockResult.lastSynced) {
            var lastSyncedEl = document.getElementById('offline-unlock-last-synced');
            var syncDate = new Date(unlockResult.lastSynced);
            lastSyncedEl.textContent = 'Last synced: ' + syncDate.toLocaleString();
        }

        // 7. Mark offline session state
        _isOfflineSession = true;

        // 8. Clear password from memory
        password = null;
        document.getElementById('offline-unlock-password').value = '';

        // 9. Show loading overlay, then hide offline unlock and show app with offline banner
        showLoadingOverlay();
        setLoadingOverlayMode('local-memory');
        hideOfflineUnlockScreen();
        showOfflineModeBanner();

        // 10. Initialize the app UI with cached data
        try {
            await init();
        } catch (initErr) {
            console.error('[OfflineUnlock] Init failed:', initErr);
            hideLoadingOverlay();
            showOfflineUnlockScreen();
            showOfflineUnlockError('Failed to load cached data: ' + initErr.message);
            return;
        }

        console.log('[OfflineUnlock] Offline session started for', session.userId,
            '(' + (unlockResult.tables ? unlockResult.tables.length : 0) + ' tables)');

    } catch (err) {
        console.error('[OfflineUnlock] Failed:', err);
        showOfflineUnlockError(err.message || 'Unlock failed.');
    } finally {
        btn.textContent = 'Unlock';
        btn.disabled = false;
    }
}

function offlineUnlockGoOnline() {
    // User wants to try online login instead
    hideOfflineUnlockScreen();
    showSynapseLoginScreen();
}

async function tryReconnect() {
    var btn = document.querySelector('#offline-mode-banner .offline-reconnect-btn');
    if (btn) {
        btn.textContent = 'Checking...';
        btn.disabled = true;
    }

    try {
        var online = await AminoData.checkConnectivity();
        if (online) {
            // Attempt transition to online mode
            var password = null; // password not available  will re-auth if token expired
            var result = await AminoData.transitionToOnline(password);

            _isOfflineSession = false;
            hideOfflineModeBanner();

            // Resume normal polling
            console.log('[Reconnect] Back online. Synced:', result.syncedRecords, 'records.',
                'Flushed:', result.flushed, 'mutations.');

            // Restore Matrix session
            var session = _loadSynapseSession();
            if (session && session.accessToken) {
                MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
            }
        } else {
            if (btn) btn.textContent = 'Still offline';
            setTimeout(function() { if (btn) btn.textContent = 'Reconnect'; }, 2000);
        }
    } catch (err) {
        console.warn('[Reconnect] Failed:', err.message);
        if (err.message && err.message.indexOf('Session expired') !== -1) {
            // Need full re-login
            if (btn) btn.textContent = 'Session expired';
            setTimeout(function() {
                if (confirm('Your session has expired. Sign in again?')) {
                    logout();
                }
            }, 500);
        } else {
            if (btn) btn.textContent = 'Failed';
            setTimeout(function() { if (btn) btn.textContent = 'Reconnect'; }, 2000);
        }
    } finally {
        if (btn) btn.disabled = false;
    }
}

// Listen for connectivity restored events from AminoData
window.addEventListener('amino:connectivity-restored', function() {
    if (_isOfflineSession) {
        tryReconnect();
    }
});

// Wire up offline unlock UI
document.getElementById('offline-unlock-btn').onclick = tryOfflineUnlock;
document.getElementById('offline-unlock-online-btn').onclick = offlineUnlockGoOnline;
document.getElementById('offline-unlock-password').onkeydown = function(e) { if (e.key === 'Enter') tryOfflineUnlock(); };

// ============ Auth ============

document.getElementById('auth-submit').onclick = tryAuth;
document.getElementById('api-key-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('set-filter-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('auth-clear').onclick = clearLocalAndReset;
document.getElementById('connect-api-key-input').onkeydown = (e) => { if (e.key === 'Enter') submitConnectApi(); };
document.getElementById('connect-api-set-filter').onkeydown = (e) => { if (e.key === 'Enter') submitConnectApi(); };

async function initAuthScreen() {
    // No-op: auth is handled exclusively via Synapse login (trySynapseLogin).
}

// Silently restore Matrix session without blocking app startup
function restoreMatrixSessionQuietly() {
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
        updateMatrixStatus();
    }
}

async function clearLocalAndReset() {
    if (!confirm('Clear all local data?')) return;
    try {
        db = await openDB();
        await clearAllData();
        db.close();
        db = null;
    } catch (e) {
        console.error('Clear error:', e);
    }
    // Clear stale form state and errors
    document.getElementById('api-key-input').value = '';
    document.getElementById('set-filter-input').value = '';
    document.getElementById('auth-error').style.display = 'none';
    initAuthScreen();
}

// Refresh the entire local database by clearing all cached data and
// re-downloading from the selected source. Box webhook is default;
// Postgres webhook API and Synapse room replay are manual options.
async function refreshLocalDB(sourceOverride) {
    // sourceOverride: 'postgres' (default), 'box', 'synapse', 'csv', 'url', or 'none'
    // When called without override, uses the persisted hydration source preference (default: postgres).
    var source = sourceOverride || AminoHydration.getHydrationSource();

    var confirmMessages = {
        'box': 'Refresh local database from Box snapshot?\n\nThis will clear all locally cached data and re-download from the Box webhook.',
        'postgres': 'Refresh from Postgres webhook API?\n\nThis will clear all locally cached data and re-download table-by-table from the Postgres-backed API.',
        'synapse': 'Refresh from Synapse room replay?\n\nThis will clear all locally cached data and rebuild state by replaying Matrix room events.',
        'csv': 'Refresh from CSV file?\n\nThis will clear all locally cached data and re-import from the selected CSV file.',
        'url': 'Refresh from URL?\n\nThis will clear all locally cached data and re-download from the configured URL.',
        'none': 'Switch to no-local-data mode?\n\nThis will clear all locally cached data. Postgres will be used for current state and room data for historical.'
    };
    if (!confirm(confirmMessages[source] || ('Refresh from ' + source + '?'))) return;

    var btn = document.getElementById('refresh-db-btn');
    var statusEl = document.getElementById('refresh-db-status');
    if (btn) btn.disabled = true;
    if (statusEl) statusEl.textContent = 'Refreshing (' + source + ')...';

    // Switch to the home/database view so the loading overlay is visible
    switchApp('home');

    try {
        // Pause real-time sync while we rebuild
        SynapseSync.stop();

        // Show loading overlay
        showLoadingOverlay();
        updateLoadingOverlay('Refreshing database...', 'Clearing local data...', 0, 0, 0, 0, null);

        // Clear all local data stores
        await clearAllData();
        console.log('[RefreshDB] Local data cleared');

        // Reset in-memory metadata
        META_TABLES = {};
        META_FIELDS = {};
        META_VIEWS = {};
        currentTable = null;
        currentPage = 0;
        currentRecordIds = [];
        originalRecordIds = [];
        totalRecords = 0;
        lastEventTimestamp = null;

        var hydrated = false;

        if (source === 'csv') {
            // CSV file import
            updateLoadingOverlay('Refreshing database...', 'Parsing CSV file...', 0, 0, 0, 0, null);
            var csvFile = AminoHydration.getPendingCSVFile();
            if (!csvFile) {
                // Prompt user to select a file
                var csvInput = document.getElementById('settings-hydration-csv');
                if (csvInput && csvInput.files && csvInput.files[0]) {
                    csvFile = csvInput.files[0];
                }
            }
            if (csvFile) {
                try {
                    var csvText = await new Promise(function(resolve, reject) {
                        var reader = new FileReader();
                        reader.onload = function() { resolve(reader.result); };
                        reader.onerror = function() { reject(reader.error); };
                        reader.readAsText(csvFile);
                    });
                    var parsed = AminoHydration.parseCSVEvents(csvText);
                    if (parsed.events.length > 0) {
                        var state = AminoHydration.buildStateFromCSVEvents(parsed.events);
                        var csvTableIds = Object.keys(state.byTable);
                        var csvTotalRecords = 0;
                        for (var cti = 0; cti < csvTableIds.length; cti++) {
                            var ctId = csvTableIds[cti];
                            var cRecordMap = state.byTable[ctId];
                            var cRecordIds = Object.keys(cRecordMap);
                            for (var cri = 0; cri < cRecordIds.length; cri++) {
                                await saveRecord(ctId, cRecordIds[cri], cRecordMap[cRecordIds[cri]]);
                                csvTotalRecords++;
                            }
                        }
                        hydrated = true;
                        await setSyncMeta('lastWebhookSync', new Date().toISOString());
                        SyncStatusFeed.success('Refreshed from CSV: ' + csvTotalRecords + ' records');
                        console.log('[RefreshDB] CSV hydration:', csvTotalRecords, 'records from', csvTableIds.length, 'tables');
                        if (statusEl) {
                            statusEl.style.color = 'var(--success-500, #22c55e)';
                            statusEl.textContent = 'Refreshed from CSV  ' + csvTotalRecords + ' records';
                        }
                    }
                } catch (csvErr) {
                    console.error('[RefreshDB] CSV hydration failed:', csvErr);
                    SyncStatusFeed.error('CSV refresh failed: ' + csvErr.message);
                    if (statusEl) {
                        statusEl.style.color = 'var(--danger-500, #ef4444)';
                        statusEl.textContent = 'CSV refresh failed: ' + csvErr.message;
                    }
                }
            } else {
                SyncStatusFeed.warn('No CSV file selected. Use Settings to select a file.');
                if (statusEl) {
                    statusEl.style.color = 'var(--danger-500, #ef4444)';
                    statusEl.textContent = 'No CSV file selected';
                }
            }
        } else if (source === 'url') {
            // URL import
            var refreshUrl = AminoHydration.getHydrationURL();
            if (!refreshUrl) {
                var urlInput = document.getElementById('settings-hydration-url');
                if (urlInput) refreshUrl = urlInput.value;
            }
            if (refreshUrl) {
                updateLoadingOverlay('Refreshing database...', 'Fetching from URL...', 0, 0, 0, 0, null);
                try {
                    var urlResp = await fetch(refreshUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json, text/csv, text/plain' }
                    });
                    if (!urlResp.ok) throw new Error('HTTP ' + urlResp.status);
                    var urlCt = (urlResp.headers.get('content-type') || '').toLowerCase();
                    var urlBody = await urlResp.text();
                    var urlIsCSV = urlCt.indexOf('csv') !== -1 || urlCt.indexOf('text/plain') !== -1;
                    if (!urlIsCSV) {
                        var fc = urlBody.trim().charAt(0);
                        if (fc !== '[' && fc !== '{') urlIsCSV = true;
                    }
                    if (urlIsCSV) {
                        var urlParsed = AminoHydration.parseCSVEvents(urlBody);
                        if (urlParsed.events.length > 0) {
                            var urlState = AminoHydration.buildStateFromCSVEvents(urlParsed.events);
                            var urlTblIds = Object.keys(urlState.byTable);
                            var urlTotal = 0;
                            for (var uti2 = 0; uti2 < urlTblIds.length; uti2++) {
                                var utId2 = urlTblIds[uti2];
                                var uMap = urlState.byTable[utId2];
                                var uIds = Object.keys(uMap);
                                for (var ui = 0; ui < uIds.length; ui++) {
                                    await saveRecord(utId2, uIds[ui], uMap[uIds[ui]]);
                                    urlTotal++;
                                }
                            }
                            hydrated = true;
                        }
                    } else {
                        var urlJson = JSON.parse(urlBody);
                        var urlRecs = [];
                        if (Array.isArray(urlJson)) urlRecs = urlJson;
                        else if (urlJson && Array.isArray(urlJson.records)) urlRecs = urlJson.records;
                        else if (urlJson && typeof urlJson.tables === 'object') {
                            var tk = Object.keys(urlJson.tables);
                            for (var tki = 0; tki < tk.length; tki++) {
                                var tRecs = urlJson.tables[tk[tki]];
                                if (Array.isArray(tRecs)) {
                                    for (var tri = 0; tri < tRecs.length; tri++) {
                                        tRecs[tri].tableId = tRecs[tri].tableId || tRecs[tri].table_id || tk[tki];
                                        urlRecs.push(tRecs[tri]);
                                    }
                                }
                            }
                        }
                        for (var uRi = 0; uRi < urlRecs.length; uRi++) {
                            var uR = urlRecs[uRi];
                            var uTid = uR.tableId || uR.table_id || 'unknown';
                            var uRid = uR.id || uR.record_id || uR.recordId;
                            if (uRid) await saveRecord(uTid, uRid, uR.fields || uR);
                        }
                        if (urlRecs.length > 0) hydrated = true;
                    }
                    if (hydrated) {
                        await setSyncMeta('lastWebhookSync', new Date().toISOString());
                        SyncStatusFeed.success('Refreshed from URL');
                        if (statusEl) {
                            statusEl.style.color = 'var(--success-500, #22c55e)';
                            statusEl.textContent = 'Refreshed from URL';
                        }
                    }
                } catch (urlErr) {
                    console.error('[RefreshDB] URL hydration failed:', urlErr);
                    SyncStatusFeed.error('URL refresh failed: ' + urlErr.message);
                    if (statusEl) {
                        statusEl.style.color = 'var(--danger-500, #ef4444)';
                        statusEl.textContent = 'URL refresh failed: ' + urlErr.message;
                    }
                }
            } else {
                SyncStatusFeed.warn('No URL configured. Use Settings to enter a URL.');
                if (statusEl) {
                    statusEl.style.color = 'var(--danger-500, #ef4444)';
                    statusEl.textContent = 'No URL configured';
                }
            }
        } else if (source === 'none') {
            // No local data  enable online-only mode
            if (typeof AminoData !== 'undefined' && AminoData.setOnlineOnlyMode) {
                AminoData.setOnlineOnlyMode(true);
            }
            updateLoadingOverlay('Refreshing database...', 'Fetching current state from Postgres (online-only)...', 0, 0, 0, 0, null);
            var onlineWebhook = await hydrateFromWebhooks();
            hydrated = !!(onlineWebhook && onlineWebhook.success);
            if (hydrated) {
                await setSyncMeta('lastWebhookSync', new Date().toISOString());
                if (statusEl) {
                    statusEl.style.color = 'var(--success-500, #22c55e)';
                    statusEl.textContent = 'Online-only mode  ' + (onlineWebhook.totalRecords || 0).toLocaleString() + ' records in memory';
                }
                SyncStatusFeed.success('No-local-data mode active');
            }
        } else if (source === 'box') {
            // Box AMO snapshot
            updateLoadingOverlay('Refreshing database...', 'Downloading Box snapshot...', 0, 0, 0, 0, null);
            try {
                var boxResult = await hydrateFromBoxAmoFile();
                if (boxResult && boxResult.importedEvents > 0 && Object.keys(META_TABLES).length > 0) {
                    hydrated = true;
                    await setSyncMeta('lastWebhookSync', new Date().toISOString());
                    SyncStatusFeed.success('Refreshed from Box snapshot (' + boxResult.importedEvents.toLocaleString() + ' events)');
                    console.log('[RefreshDB] Box hydration succeeded:', boxResult.importedEvents, 'events');
                    if (statusEl) {
                        statusEl.style.color = 'var(--success-500, #22c55e)';
                        statusEl.textContent = 'Refreshed from Box  ' + boxResult.importedEvents.toLocaleString() + ' events';
                    }
                }
            } catch (boxErr) {
                console.error('[RefreshDB] Box hydration failed:', boxErr);
                SyncStatusFeed.error('Box refresh failed: ' + boxErr.message);
                if (statusEl) {
                    statusEl.style.color = 'var(--danger-500, #ef4444)';
                    statusEl.textContent = 'Box refresh failed  try another source';
                }
            }
        } else if (source === 'postgres') {
            // Postgres webhook API
            updateLoadingOverlay('Refreshing database...', 'Downloading from Postgres API...', 0, 0, 0, 0, null);
            var webhookHydration = await hydrateFromWebhooks();
            hydrated = !!(webhookHydration && webhookHydration.success);
            if (hydrated) {
                var hydrationCursor = webhookHydration.nextCursor || new Date().toISOString();
                await setSyncMeta('lastWebhookSync', hydrationCursor);
                if (statusEl) {
                    statusEl.style.color = 'var(--success-500, #22c55e)';
                    statusEl.textContent = 'Refreshed  ' + (webhookHydration.totalRecords || 0).toLocaleString() + ' records downloaded';
                }
                console.log('[RefreshDB] Postgres: ' + (webhookHydration.totalRecords || 0) + ' records across ' + (webhookHydration.totalTables || 0) + ' tables');
                SyncStatusFeed.success('Database refresh complete: ' + (webhookHydration.totalRecords || 0) + ' records');
            }
        } else if (source === 'synapse') {
            // Synapse room replay
            updateLoadingOverlay('Refreshing database...', 'Replaying Synapse rooms...', 0, 0, 0, 0, null);
            hydrated = await hydrateFromSynapse();
            if (hydrated) {
                await setSyncMeta('lastWebhookSync', new Date().toISOString());
                if (statusEl) {
                    statusEl.style.color = 'var(--success-500, #22c55e)';
                    statusEl.textContent = 'Refreshed from Synapse room replay';
                }
                SyncStatusFeed.success('Database refresh complete via Synapse replay');
            }
        }

        if (hydrated) {
            // Mark hydration complete in localStorage (survives IDB transaction races)
            try { localStorage.setItem('amino_hydration_complete', new Date().toISOString()); } catch(e) {}

            // Reload metadata into memory
            var reloadResults = await Promise.all([getAllTables(), getAllFields(), getAllViews()]);
            var tables = reloadResults[0];
            var fields = reloadResults[1];
            var views = reloadResults[2];

            // For Box hydration, merge additively (Box populates META_* in memory)
            if (source === 'box') {
                tables.forEach(function(t) { META_TABLES[t.tableId] = META_TABLES[t.tableId] || t; });
                fields.forEach(function(f) {
                    if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
                    META_FIELDS[f.tableId][f.fieldId] = META_FIELDS[f.tableId][f.fieldId] || f;
                });
                views.forEach(function(v) {
                    if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
                    META_VIEWS[v.tableId][v.viewId] = META_VIEWS[v.tableId][v.viewId] || v;
                });
            } else {
                tables.forEach(function(t) { META_TABLES[t.tableId] = t; });
                fields.forEach(function(f) {
                    if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
                    META_FIELDS[f.tableId][f.fieldId] = f;
                });
                views.forEach(function(v) {
                    if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
                    META_VIEWS[v.tableId][v.viewId] = v;
                });
            }

            // Schedule edge rebuild after refresh (debounced to coalesce with other updates)
            scheduleEdgeRebuild();

            // Re-render UI
            await renderSidebar(true);
            var firstTable = Object.keys(META_TABLES)[0];
            if (firstTable) {
                await showTable(firstTable);
            }

            // Notify listeners
            window.dispatchEvent(new CustomEvent('amino:sync', {
                detail: { source: 'refresh-' + source, tables: Object.keys(META_TABLES).length }
            }));
        } else {
            // Hydration failed  try rendering whatever we have
            await renderSidebar(true);
            if (statusEl && !statusEl.textContent.includes('failed')) {
                statusEl.style.color = 'var(--danger-500, #ef4444)';
                statusEl.textContent = 'Refresh failed  could not download data from server';
            }
            SyncStatusFeed.error('Database refresh failed  no data returned from ' + source);
        }

        hideLoadingOverlay();

        // Restart real-time sync
        lastSyncTime = Date.now();
        SynapseSync.start();

    } catch (err) {
        console.error('[RefreshDB] Failed:', err);
        hideLoadingOverlay();
        if (statusEl) {
            statusEl.style.color = 'var(--danger-500, #ef4444)';
            statusEl.textContent = 'Refresh failed: ' + err.message;
        }
        SyncStatusFeed.error('Database refresh failed: ' + err.message);
        // Restart sync even on error
        SynapseSync.start();
    } finally {
        if (btn) btn.disabled = false;
    }
}

async function tryAuth() {
    // No-op: auth is via Synapse login.
    showAuthError('API key authentication has been replaced. Please use the Synapse login.');
}

function showAuthError(msg) {
    var el = document.getElementById('auth-error');
    el.textContent = msg;
    el.style.display = 'block';
}

var _hideAuthTimeout = null;
function hideAuthScreen() {
    var el = document.getElementById('auth-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        if (_hideAuthTimeout) { clearTimeout(_hideAuthTimeout); _hideAuthTimeout = null; }
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    _hideAuthTimeout = setTimeout(function() { _hideAuthTimeout = null; el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

function showAuthScreen() {
    // Cancel any pending hide timeout to prevent race condition
    if (_hideAuthTimeout) { clearTimeout(_hideAuthTimeout); _hideAuthTimeout = null; }

    var el = document.getElementById('auth-screen');
    el.classList.remove('hidden', 'fading-out');
    if (pollInterval) clearInterval(pollInterval);
    SyncHistory.stopPolling();
    initAuthScreen();
}

async function logout() {
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = null;
    SynapseSync.stop();
    // Stop n8n webhook data layer polling, encrypt records, and clear its encryption key
    await AminoData.logout(false); // Encrypts plaintext records, keeps data in IndexedDB for next session
    // Encrypt all plaintext records/events in the UI database before closing.
    // Must happen while encryptionKey and db are still available.
    if (_deferEncryptionUI && encryptionKey && db) {
        try {
            await encryptAllUIRecords();
        } catch (encErr) {
            console.error('[logout] Failed to encrypt UI records on logout:', encErr);
        }
    }
    _deferEncryptionUI = false;
    // Close stale IndexedDB connection
    if (db) {
        try { db.close(); } catch (e) { /* ignore */ }
        db = null;
    }
    clearSessionKey();
    // Clear encryption state
    encryptionKey = null;
    encryptionEnabled = false;
    _isOfflineSession = false;
    hideOfflineModeBanner();
    // Log out of Synapse and show login screen
    synapseLogout();
    showSynapseLoginScreen();
}

async function manualSync() {
    // Manual sync: restart the Synapse sync loop
    if (!SynapseSync.running) {
        SynapseSync.start();
    }
}

// ============ Airtable Manual Sync ============

var _syncBtnCooldownTimer = null;

async function manualAirtableSync() {
    var btn = document.getElementById('airtable-sync-btn');
    var textEl = document.getElementById('sync-btn-text');

    // Check if still in cooldown
    if (btn && btn.classList.contains('cooldown')) return;

    // Visual: show syncing state
    if (btn) btn.classList.add('syncing');
    if (textEl) textEl.textContent = 'Syncing...';

    try {
        // 1. Trigger n8n to pull from Airtable
        var result = await AminoData.triggerAirtableSync();

        if (!result.triggered && result.cooldownRemaining > 0) {
            // Was rate-limited  start cooldown UI
            _startSyncCooldownUI(result.cooldownRemaining);
            return;
        }

        if (result.error) {
            console.warn('[ManualSync] Airtable trigger had error:', result.error);
        }

        // 2. Also ensure Synapse sync is running to pick up the changes
        if (!SynapseSync.running) {
            SynapseSync.start();
        }

        // 3. Brief delay for n8n to process, then show cooldown
        if (btn) btn.classList.remove('syncing');
        if (textEl) textEl.textContent = 'Triggered';

        // Start cooldown countdown after a short feedback delay
        setTimeout(function() {
            _startSyncCooldownUI(result.cooldownRemaining || 180000);
        }, 1500);

    } catch (err) {
        console.error('[ManualSync] Error:', err);
        if (btn) btn.classList.remove('syncing');
        if (textEl) textEl.textContent = 'Sync';
    }
}

function _startSyncCooldownUI(remainingMs) {
    var btn = document.getElementById('airtable-sync-btn');
    var textEl = document.getElementById('sync-btn-text');

    if (btn) {
        btn.classList.remove('syncing');
        btn.classList.add('cooldown');
    }

    if (_syncBtnCooldownTimer) clearInterval(_syncBtnCooldownTimer);

    var endTime = Date.now() + remainingMs;

    function tick() {
        var left = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
        if (left <= 0) {
            clearInterval(_syncBtnCooldownTimer);
            _syncBtnCooldownTimer = null;
            if (btn) btn.classList.remove('cooldown');
            if (textEl) textEl.textContent = 'Sync';
            return;
        }
        if (textEl) textEl.textContent = left + 's';
    }

    tick();
    _syncBtnCooldownTimer = setInterval(tick, 1000);
}

// ============ Intelligent Auto-Sync on Tab Focus ============
// When the user returns to the tab after being away, trigger an Airtable
// sync if enough time has passed (respects the data-layer cooldown).

(function() {
    var IDLE_THRESHOLD = 60000; // 60s away before auto-triggering on return
    var _lastHidden = 0;

    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            _lastHidden = Date.now();
            return;
        }

        // Tab became visible  check if we've been away long enough
        var away = Date.now() - _lastHidden;
        if (_lastHidden > 0 && away >= IDLE_THRESHOLD) {
            // Check cooldown before triggering
            var status = AminoData.getAirtableSyncStatus();
            if (status.cooldownRemaining <= 0 && !status.inFlight) {
                console.log('[AutoSync] Tab refocused after ' + Math.round(away / 1000) + 's  triggering Airtable sync');
                manualAirtableSync();
            }
        }
    });
})();

// Skip auth and go directly to CSV upload
async function skipAuthAndUploadCSV() {
    // Prompt for file FIRST - if user cancels, stay on auth screen
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return; // User cancelled - stay on auth screen

        // Now hide auth screen and initialize the app
        hideAuthScreen();

        META_TABLES = {};
        META_FIELDS = {};
        META_VIEWS = {};
        TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
        currentTable = null;
        currentPage = 0;
        currentRecordIds = [];
        originalRecordIds = [];
        totalRecords = 0;
        lastEventTimestamp = null;

        loadSidebarState();
        initSidebarSearch();

        db = await openDB();
        appOpenedEventId = await getMaxEventId();

        var tables = await getAllTables();
        var fields = await getAllFields();
        var views = await getAllViews();

        tables.forEach(t => META_TABLES[t.tableId] = t);
        fields.forEach(f => {
            if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
            META_FIELDS[f.tableId][f.fieldId] = f;
        });
        views.forEach(v => {
            if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
            META_VIEWS[v.tableId][v.viewId] = v;
        });

        await loadTableSettings();
        updateConnectApiButton();

        // Process the selected file directly instead of opening another picker
        await processCSVFile(file);
    };

    input.click();
}

// Skip auth and go directly to .amo snapshot upload
async function skipAuthAndUploadAmo() {
    // Prompt for file FIRST - if user cancels, stay on auth screen
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.amo';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return; // User cancelled - stay on auth screen

        // Now hide auth screen and initialize the app
        hideAuthScreen();

        META_TABLES = {};
        META_FIELDS = {};
        META_VIEWS = {};
        TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
        currentTable = null;
        currentPage = 0;
        currentRecordIds = [];
        originalRecordIds = [];
        totalRecords = 0;
        lastEventTimestamp = null;

        loadSidebarState();
        initSidebarSearch();

        db = await openDB();
        appOpenedEventId = await getMaxEventId();

        var tables = await getAllTables();
        var fields = await getAllFields();
        var views = await getAllViews();

        tables.forEach(t => META_TABLES[t.tableId] = t);
        fields.forEach(f => {
            if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
            META_FIELDS[f.tableId][f.fieldId] = f;
        });
        views.forEach(v => {
            if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
            META_VIEWS[v.tableId][v.viewId] = v;
        });

        await loadTableSettings();
        updateConnectApiButton();

        // Process the selected file directly instead of opening another picker
        await processAmoFile(file);
    };

    input.click();
}

function updateConnectApiButton() {
    // No-op: Synapse auth replaces API key
    var btn = document.getElementById('connect-api-btn');
    if (btn) {
        btn.style.display = 'none';
    }
}

// Connect API modal functions
function showConnectApiModal() {
    var modal = document.getElementById('connect-api-modal');
    modal.style.display = 'flex';
    document.getElementById('connect-api-key-input').value = '';
    document.getElementById('connect-api-set-filter').value = '';
    document.getElementById('connect-api-error').style.display = 'none';
    document.getElementById('connect-api-key-input').focus();
}

function hideConnectApiModal() {
    document.getElementById('connect-api-modal').style.display = 'none';
}

async function submitConnectApi() {
    // No-op: auth is via Synapse login.
    var errEl = document.getElementById('connect-api-error');
    if (errEl) {
        errEl.textContent = 'API key authentication has been replaced by Synapse login.';
        errEl.style.display = 'block';
    }
}

// ============ Data Processing ============

function parsePayload(payload) {
    if (typeof payload === 'string') {
        try { return JSON.parse(payload); } catch { return null; }
    }
    return payload;
}

// Infer field type from a sample value (used for auto-discovered fields)
function inferFieldType(value) {
    if (value === null || value === undefined) return 'unknown';
    if (Array.isArray(value)) {
        // Check if it's an attachment array (objects with url property)
        if (value.length > 0 && typeof value[0] === 'object' && value[0].url) {
            return 'multipleAttachments';
        }
        // Check if it's a linked record array (strings starting with 'rec')
        if (value.length > 0 && typeof value[0] === 'string' && value[0].startsWith('rec')) {
            return 'multipleRecordLinks';
        }
        return 'multipleSelects';
    }
    if (typeof value === 'object') {
        // Could be a single attachment or other complex type
        if (value.url) return 'multipleAttachments';
        return 'object';
    }
    if (typeof value === 'number') {
        return Number.isInteger(value) ? 'number' : 'number';
    }
    if (typeof value === 'boolean') return 'checkbox';
    if (typeof value === 'string') {
        // Try to detect dates
        if (/^\d{4}-\d{2}-\d{2}/.test(value)) return 'date';
        // Try to detect emails
        if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) return 'email';
        // Try to detect URLs
        if (/^https?:\/\//.test(value)) return 'url';
        return 'singleLineText';
    }
    return 'unknown';
}

// Fast in-memory event processing for CSV import - skips IndexedDB entirely
// Calls onProgress periodically for UI updates
async function processEventsMemoryOnly(events, onProgress) {
    if (!events || !Array.isArray(events)) return;

    var tableDataMap = {}; // tableId -> { recordId -> fields }
    var total = events.length;

    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;

        if (recordType === 'table') {
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.displayNameFieldId) tableData.displayNameFieldId = payload.displayNameFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            if (payload.readOnly != null) fieldData.readOnly = payload.readOnly;
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else if (recordType === 'viewConfig') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) {
                META_VIEWS[tableId][viewId] = { tableId, viewId };
            }
            var viewData = META_VIEWS[tableId][viewId];
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.hiddenFieldIds) viewData.hiddenFieldIds = payload.hiddenFieldIds;
            if (payload.fieldOrder) viewData.fieldOrder = payload.fieldOrder;
            if (payload.filters) viewData.filters = payload.filters;
            if (payload.sorts) viewData.sorts = payload.sorts;
            if (payload.folderId !== undefined) viewData.folderId = payload.folderId;

        } else if (recordType === 'tableSettings') {
            // User-specific table and view settings
            if (payload.tables) TABLE_SETTINGS.tables = payload.tables;
            if (payload.tableOrder) TABLE_SETTINGS.tableOrder = payload.tableOrder;
            if (payload.views) TABLE_SETTINGS.views = payload.views;

        } else {
            // Data record
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            // Auto-create placeholder table
            if (!META_TABLES[tableId]) {
                META_TABLES[tableId] = {
                    tableId: tableId,
                    tableName: tableId,
                    _placeholder: true
                };
            }

            // Auto-create placeholder fields
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            var allFieldIds = [
                ...Object.keys(pfields.INS || {}),
                ...Object.keys(pfields.ALT || {}),
                ...Object.keys(pfields.SYN || {}),
                ...(Array.isArray(pfields.NUL) ? pfields.NUL : [])
            ];
            for (var fid of allFieldIds) {
                if (!META_FIELDS[tableId][fid]) {
                    var sampleValue = (pfields.INS && pfields.INS[fid]) || (pfields.ALT && pfields.ALT[fid]) || (pfields.SYN && pfields.SYN[fid]);
                    META_FIELDS[tableId][fid] = {
                        tableId: tableId,
                        fieldId: fid,
                        fieldName: fid,
                        fieldType: inferFieldType(sampleValue),
                        _placeholder: true
                    };
                }
            }

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) tableDataMap[tableId][recordId] = {};

            var state = tableDataMap[tableId][recordId];
            if (pfields.INS) Object.assign(state, pfields.INS);
            if (pfields.ALT) Object.assign(state, pfields.ALT);
            if (pfields.SYN) Object.assign(state, pfields.SYN);
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => delete state[fieldId]);
            }
        }

        // Report progress and yield to UI every 5000 events
        if (i > 0 && i % 5000 === 0) {
            if (onProgress) onProgress(i, total, Object.keys(META_TABLES).length);
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Store data records in a memory-only snapshot (for showing table data)
    // Structure: IN_MEMORY_DATA[tableId][recordId] = { fields }
    window.IN_MEMORY_DATA = tableDataMap;

    if (onProgress) onProgress(total, total, Object.keys(META_TABLES).length);
}

// Process events into IndexedDB records, field history, and schema metadata.
//
// Options:
//   historyOnly (boolean, default false)  when true, only builds field
//       history entries and saves schema metadata (tables/fields/views).
//       Data records are NOT written to IndexedDB, preserving the
//       webhook-hydrated current state.  Record state is still tracked
//       in memory (starting from {}) so that oldValue / newValue in
//       history entries are accurate relative to the event sequence.
async function processEvents(events, options) {
    if (!events || !Array.isArray(events)) return;

    options = options || {};
    var historyOnly = !!options.historyOnly;

    var tables = [];
    var fields = [];
    var views = [];
    var dataRecords = [];
    var tableDataMap = {}; // tableId -> { recordId -> fields }

    // Pre-load existing record states from IndexedDB for accurate history
    // oldValue tracking.  In historyOnly mode we skip pre-loading so that
    // the in-memory state starts from {} and history old/new values reflect
    // the chronological event sequence rather than the current DB snapshot.
    if (!historyOnly) {
        // First pass: collect all unique [tableId, recordId] pairs for data records
        var recordsToLoad = {}; // tableId -> Set of recordIds
        for (var e of events) {
            if (!e || !e.set || !e.recordId) continue;
            var payload = parsePayload(e.payload);
            if (!payload || typeof payload !== 'object') continue;
            var recordType = payload._set;
            // Only load state for data records (not table/field/view metadata)
            if (recordType !== 'table' && recordType !== 'field' && recordType !== 'view') {
                var tableId = e.set.replace('airtable:', '');
                if (!recordsToLoad[tableId]) recordsToLoad[tableId] = new Set();
                recordsToLoad[tableId].add(e.recordId);
            }
        }

        // Load existing records from IndexedDB
        for (var tableId in recordsToLoad) {
            var recordIds = Array.from(recordsToLoad[tableId]);
            if (recordIds.length > 0) {
                var existingRecords = await getRecordsByIds(tableId, recordIds);
                if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
                for (var rec of existingRecords) {
                    // Pre-populate with existing field values
                    tableDataMap[tableId][rec.recordId] = { ...rec.fields };
                }
            }
        }
    }

    for (var e of events) {
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;
        var eventId = e.id;
        var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

        if (recordType === 'table') {
            // Tables: recordId starts with "tbl", set points to base
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.displayNameFieldId) tableData.displayNameFieldId = payload.displayNameFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            tables.push(tableData);
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            // Fields: recordId starts with "fld", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            if (payload.readOnly != null) fieldData.readOnly = payload.readOnly;
            fields.push(fieldData);
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            // Views: recordId starts with "viw", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            views.push(viewData);
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else if (recordType === 'viewConfig') {
            // View configuration updates: hiddenFieldIds, fieldOrder, filters, sorts
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;

            // Initialize META_VIEWS if needed
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) {
                META_VIEWS[tableId][viewId] = { tableId, viewId };
            }

            // Update the view with config data
            var viewData = META_VIEWS[tableId][viewId];
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.hiddenFieldIds) viewData.hiddenFieldIds = payload.hiddenFieldIds;
            if (payload.fieldOrder) viewData.fieldOrder = payload.fieldOrder;
            if (payload.filters) viewData.filters = payload.filters;
            if (payload.sorts) viewData.sorts = payload.sorts;
            if (payload.folderId !== undefined) viewData.folderId = payload.folderId;

            views.push(viewData);

        } else if (recordType === 'tableSettings') {
            // User-specific table and view settings
            if (payload.tables) TABLE_SETTINGS.tables = payload.tables;
            if (payload.tableOrder) TABLE_SETTINGS.tableOrder = payload.tableOrder;
            if (payload.views) TABLE_SETTINGS.views = payload.views;

        } else {
            // Data record: recordId starts with "rec"
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            // Auto-create placeholder table if not seen yet (will be updated when real metadata arrives)
            if (!META_TABLES[tableId]) {
                var placeholderTable = {
                    tableId: tableId,
                    tableName: tableId,  // Use ID as placeholder name
                    _placeholder: true   // Mark as placeholder for later update
                };
                META_TABLES[tableId] = placeholderTable;
                tables.push(placeholderTable);
            }

            // Auto-create placeholder fields from INS/ALT/SYN/NUL keys
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            var allFieldIds = [
                ...Object.keys(pfields.INS || {}),
                ...Object.keys(pfields.ALT || {}),
                ...Object.keys(pfields.SYN || {}),
                ...(Array.isArray(pfields.NUL) ? pfields.NUL : [])
            ];
            for (var fid of allFieldIds) {
                if (!META_FIELDS[tableId][fid]) {
                    // Get a sample value to infer type
                    var sampleValue = (pfields.INS && pfields.INS[fid]) || (pfields.ALT && pfields.ALT[fid]) || (pfields.SYN && pfields.SYN[fid]);
                    var placeholderField = {
                        tableId: tableId,
                        fieldId: fid,
                        fieldName: fid,  // Use ID as placeholder name
                        fieldType: inferFieldType(sampleValue),
                        _placeholder: true  // Mark as placeholder for later update
                    };
                    META_FIELDS[tableId][fid] = placeholderField;
                    fields.push(placeholderField);
                }
            }

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) {
                // Initialize new record (existing records pre-loaded above)
                tableDataMap[tableId][recordId] = {};
            }

            var state = tableDataMap[tableId][recordId];

            // Default first ALT as INS: if record state is empty (new record) and
            // there's no INS but there IS ALT, promote ALT to INS
            if (Object.keys(state).length === 0 && !pfields.INS && pfields.ALT) {
                pfields = { INS: pfields.ALT, NUL: pfields.NUL };
            }

            // Field history is not stored locally  it lives in Matrix rooms only.
        }

        // Track the latest event timestamp for incremental sync
        if (e.created_at && (!lastEventTimestamp || e.created_at > lastEventTimestamp)) {
            lastEventTimestamp = e.created_at;
        }
    }

    // In historyOnly mode, skip saving data records to IndexedDB  the
    // webhook-hydrated current state is authoritative.  We still save
    // schema metadata (tables/fields/views) since room state events carry
    // richer schema info (field types, options, readOnly flags).
    if (!historyOnly) {
        // Convert tableDataMap to dataRecords array and save per-table to limit peak memory
        var dataRecords = [];
        for (var tableId in tableDataMap) {
            for (var recordId in tableDataMap[tableId]) {
                dataRecords.push({
                    tableId,
                    recordId,
                    fields: tableDataMap[tableId][recordId]
                });
            }
            // Free this table's data from the map after converting
            delete tableDataMap[tableId];
        }

        // Save batch (schema + data records)
        if (tables.length || fields.length || views.length || dataRecords.length) {
            await saveBatch(tables, fields, views, dataRecords);
        }
        dataRecords = null; // release
    } else {
        // historyOnly: save schema metadata only, no data records
        if (tables.length || fields.length || views.length) {
            await saveBatch(tables, fields, views, []);
        }
        tableDataMap = null; // release  not needed for storage
    }

    // Field history is not stored locally  it lives in Matrix rooms only.

    // Save raw events for Events view
    await saveRawEvents(events);
}

function applyPayloadFields(target, payload) {
    if (!payload.fields) return;
    var fields = payload.fields;
    if (fields.INS) Object.assign(target, fields.INS);
    if (fields.ALT) Object.assign(target, fields.ALT);
    if (fields.SYN) Object.assign(target, fields.SYN);
    if (fields.NUL && Array.isArray(fields.NUL)) {
        fields.NUL.forEach(k => delete target[k]);
    }
}

// ============ UI ============

// Fast DOM-only search filter  uses CSS class toggling for minimal reflow
function filterSidebarDOM(query) {
    var searchQuery = (query || '').toLowerCase().trim();
    var tableList = document.getElementById('table-list');
    if (!tableList) return;

    // Toggle a single class on the container to control search-mode styles via CSS
    // This avoids touching every element's style.display individually
    var isSearching = !!searchQuery;
    tableList.classList.toggle('sidebar-searching', isSearching);

    if (!isSearching) {
        // Clear any per-item hidden classes when search is cleared
        var hidden = tableList.querySelectorAll('.sidebar-search-hidden');
        for (var i = 0; i < hidden.length; i++) {
            hidden[i].classList.remove('sidebar-search-hidden');
        }
        return;
    }

    // Only update the per-wrapper match/hide class (batch reads then writes)
    var wrappers = tableList.querySelectorAll('.table-wrapper[data-table-id]');
    var names = new Array(wrappers.length);
    for (var i = 0; i < wrappers.length; i++) {
        var tableId = wrappers[i].getAttribute('data-table-id');
        if (tableId === '_events' || tableId === '_sync_status') {
            names[i] = null;
        } else {
            var nameEl = wrappers[i].querySelector('.table-name');
            names[i] = nameEl ? nameEl.textContent.toLowerCase() : tableId.toLowerCase();
        }
    }
    for (var i = 0; i < wrappers.length; i++) {
        var shouldHide = names[i] === null || !names[i].includes(searchQuery);
        wrappers[i].classList.toggle('sidebar-search-hidden', shouldHide);
    }
}

// Update sidebar count badges in-place without full re-render
function _updateSidebarCounts(tableCounts, maxCount, eventsCount) {
    var wrappers = document.querySelectorAll('.table-wrapper[data-table-id]');
    for (var i = 0; i < wrappers.length; i++) {
        var tid = wrappers[i].getAttribute('data-table-id');
        var count = tid === '_events' ? eventsCount : (tableCounts[tid] || 0);
        var barWidth = Math.round(getCountBarWidth(count, maxCount) * 20);
        var barEl = wrappers[i].querySelector('.count-bar');
        var valEl = wrappers[i].querySelector('.count-value');
        if (barEl) barEl.style.width = barWidth + 'px';
        if (valEl) valEl.textContent = formatRecordCount(count);
    }
}

async function renderSidebar(forceRefresh) {
    var tableList = document.getElementById('table-list');
    // Build new content into a DocumentFragment off-screen to avoid visible blink
    var fragment = document.createDocumentFragment();

    var now = Date.now();
    var cacheValid = !forceRefresh && _sidebarCache.tables && (now - _sidebarCache.timestamp < SIDEBAR_CACHE_TTL);

    var tables, tableCounts, maxCount, eventsCount;

    if (cacheValid) {
        // Use cached data for fast re-renders (search, pin toggle, section toggle)
        tables = _sidebarCache.tables;
        tableCounts = _sidebarCache.tableCounts;
        maxCount = _sidebarCache.maxCount;
        eventsCount = _sidebarCache.eventsCount;
    } else {
        // Use in-memory META_TABLES if already populated (avoids redundant IDB read)
        var metaTableIds = Object.keys(META_TABLES);
        if (metaTableIds.length > 0) {
            tables = metaTableIds.map(function(tid) { return META_TABLES[tid]; });
        } else {
            tables = await getAllTables();
            // Also merge any META_TABLES entries added after the IDB snapshot
            metaTableIds = Object.keys(META_TABLES);
            for (var i = 0; i < metaTableIds.length; i++) {
                var tid = metaTableIds[i];
                if (!tables.find(t => t.tableId === tid)) {
                    tables.push(META_TABLES[tid]);
                }
            }
        }

        // Render sidebar immediately with zero counts  then backfill counts
        // asynchronously so the sidebar paints without waiting for N IDB queries.
        tableCounts = {};
        maxCount = 0;
        eventsCount = 0;
        tables.forEach(function(t) { tableCounts[t.tableId] = 0; });

        // Update cache with zero counts for now
        _sidebarCache.tables = tables;
        _sidebarCache.tableCounts = tableCounts;
        _sidebarCache.maxCount = maxCount;
        _sidebarCache.eventsCount = eventsCount;
        _sidebarCache.timestamp = now;

        // Deferred count backfill  runs after sidebar is painted
        var _countTables = tables;
        queueMicrotask(function() {
            Promise.all([
                Promise.all(_countTables.map(function(table) {
                    return getRecordCountForTable(table.tableId).then(function(count) {
                        return { tableId: table.tableId, count: count };
                    });
                })),
                getRawEventsCount()
            ]).then(function(countAndEvents) {
                var countResults = countAndEvents[0];
                var deferredEventsCount = countAndEvents[1];
                var deferredMax = 0;
                var deferredCounts = {};
                countResults.forEach(function(r) {
                    deferredCounts[r.tableId] = r.count;
                    if (r.count > deferredMax) deferredMax = r.count;
                });
                if (deferredEventsCount > deferredMax) deferredMax = deferredEventsCount;
                // Update cache and re-render sidebar with real counts
                _sidebarCache.tableCounts = deferredCounts;
                _sidebarCache.maxCount = deferredMax;
                _sidebarCache.eventsCount = deferredEventsCount;
                _sidebarCache.timestamp = Date.now();
                // Update count badges in-place (no full re-render needed)
                _updateSidebarCounts(deferredCounts, deferredMax, deferredEventsCount);
            }).catch(function(e) {
                console.warn('[Sidebar] Deferred count backfill failed:', e);
            });
        });
    }

    // Filter tables by search query
    var searchQuery = SIDEBAR_STATE.searchQuery.toLowerCase().trim();
    var filteredTables = tables;
    if (searchQuery) {
        filteredTables = tables.filter(t => {
            var name = resolveTableName(t.tableId).toLowerCase();
            return name.includes(searchQuery);
        });
    }

    // Group tables by type
    var groupedTables = {
        primary: [],
        operational: [],
        collection: [],
        reference: [],
        dev: []
    };

    filteredTables.forEach(table => {
        var tableName = resolveTableName(table.tableId);
        var type = getTableType(tableName);
        // Map 'events' type to operational
        if (type === 'events') type = 'operational';
        if (groupedTables[type]) {
            groupedTables[type].push(table);
        } else {
            groupedTables.operational.push(table);
        }
    });

    // Sort each group alphabetically (except primary which has a fixed order)
    var primaryOrder = ['client info', 'case master view', 'events', 'case notes'];
    Object.keys(groupedTables).forEach(type => {
        if (type === 'primary') {
            groupedTables[type].sort((a, b) => {
                var aIdx = primaryOrder.indexOf(resolveTableName(a.tableId).toLowerCase());
                var bIdx = primaryOrder.indexOf(resolveTableName(b.tableId).toLowerCase());
                return aIdx - bIdx;
            });
        } else {
            groupedTables[type].sort((a, b) => resolveTableName(a.tableId).localeCompare(resolveTableName(b.tableId)));
        }
    });

    // Helper to render a table item
    function renderTableItem(table, showExpandArrow = true) {
        var tableId = table.tableId;
        var tableName = resolveTableName(tableId);
        var type = getTableType(tableName);
        var config = TABLE_TYPE_CONFIG[type] || TABLE_TYPE_CONFIG.operational;
        var count = tableCounts[tableId] || 0;
        var isPinned = SIDEBAR_STATE.pinnedTables.includes(tableId);
        var isActive = tableId === currentTable;
        var barWidth = Math.round(getCountBarWidth(count, maxCount) * 20);

        var wrapper = document.createElement('div');
        wrapper.className = 'table-wrapper';
        wrapper.setAttribute('data-table-id', tableId);

        var div = document.createElement('div');
        div.className = 'table-item' + (isActive ? ' active expanded' : '');
        div.style.cssText = isActive ? '--active-color: ' + config.color + ';' : '';

        // Set the ::before background color for active state
        if (isActive) {
            div.style.setProperty('--type-color', config.color);
        }

        div.innerHTML =
            '<span class="table-icon type-' + type + '">' + config.icon + '</span>' +
            '<span class="table-name">' + esc(tableName) + '</span>' +
            '<button class="pin-btn' + (isPinned ? ' pinned' : '') + '" onclick="toggleTablePin(\'' + esc(tableId) + '\', event)" title="' + (isPinned ? 'Unpin' : 'Pin') + '">' +
                (isPinned ? SIDEBAR_ICONS.starFilled : SIDEBAR_ICONS.star) +
            '</button>' +
            '<span class="count-bar-wrapper">' +
                '<span class="count-bar" style="width: ' + barWidth + 'px; background: ' + config.color + ';"></span>' +
                '<span class="count-value" style="color: ' + config.color + ';">' + formatRecordCount(count) + '</span>' +
            '</span>' +
            (showExpandArrow ? '<span class="expand-arrow">&#9654;</span>' : '');

        div.oncontextmenu = ((t) => (e) => {
            showTableContextMenu(e, t);
        })(tableId);

        div.onclick = ((t) => (e) => {
            // Don't toggle if clicking pin button
            if (e.target.closest('.pin-btn')) return;
            toggleTableViews(t, e);
        })(tableId);

        wrapper.appendChild(div);

        // Create views list container
        var viewsList = document.createElement('div');
        viewsList.className = 'table-views-list' + (isActive ? ' expanded' : '');
        viewsList.id = 'views-list-' + tableId;
        // Use cached views for instant rendering instead of showing "Loading views..."
        if (META_VIEWS[tableId] && Object.keys(META_VIEWS[tableId]).length > 0) {
            viewsList.innerHTML = renderViewsListHTML(tableId);
        } else {
            viewsList.innerHTML = '<div class="table-view-item loading" style="color: #6b7280; font-style: italic;">Loading views...</div>';
        }
        wrapper.appendChild(viewsList);

        return wrapper;
    }

    // Helper to render a section header
    function renderSectionHeader(sectionId, title, icon, color, count) {
        var isExpanded = SIDEBAR_STATE.expandedSections[sectionId];
        var header = document.createElement('div');
        header.className = 'sidebar-section-header' + (isExpanded ? '' : ' collapsed');
        header.innerHTML =
            SIDEBAR_ICONS.chevronDown +
            '<span class="section-icon" style="color: ' + color + ';">' + icon + '</span>' +
            '<span>' + title + '</span>' +
            '<span class="section-count">' + count + '</span>';
        header.onclick = () => toggleSidebarSection(sectionId);
        header._sectionId = sectionId;
        return header;
    }

    // Collect table IDs that need views loaded (for after DOM swap)
    var _viewLoadQueue = [];

    // If not searching, show pinned and recent sections
    if (!searchQuery) {
        // Events Stream (always at top)
        var eventsWrapper = document.createElement('div');
        eventsWrapper.className = 'table-wrapper';
        eventsWrapper.setAttribute('data-table-id', '_events');

        var eventsDiv = document.createElement('div');
        eventsDiv.className = 'table-item events-item' + (currentTable === '_events' ? ' active' : '');
        var eventsBarWidth = Math.round(getCountBarWidth(eventsCount, maxCount) * 20);
        eventsDiv.innerHTML =
            '<span class="table-icon type-events">' + TABLE_TYPE_CONFIG.events.icon + '</span>' +
            '<span class="table-name">Events Stream</span>' +
            '<span class="count-bar-wrapper">' +
                '<span class="count-bar" style="width: ' + eventsBarWidth + 'px; background: ' + TABLE_TYPE_CONFIG.events.color + ';"></span>' +
                '<span class="count-value" style="color: ' + TABLE_TYPE_CONFIG.events.color + ';">' + formatRecordCount(eventsCount) + '</span>' +
            '</span>';
        eventsDiv.onclick = () => showEventsView();
        eventsWrapper.appendChild(eventsDiv);
        fragment.appendChild(eventsWrapper);

        // Sync Status (below Events Stream)
        var syncStatusWrapper = document.createElement('div');
        syncStatusWrapper.className = 'table-wrapper';
        syncStatusWrapper.setAttribute('data-table-id', '_sync_status');

        var syncStatusDiv = document.createElement('div');
        syncStatusDiv.className = 'table-item sync-status-item' + (currentTable === '_sync_status' ? ' active' : '');
        syncStatusDiv.innerHTML =
            '<span class="table-icon type-sync-status">' + TABLE_TYPE_CONFIG.syncStatus.icon + '</span>' +
            '<span class="table-name">Sync Status</span>';
        syncStatusDiv.onclick = () => showSyncStatusView();
        syncStatusWrapper.appendChild(syncStatusDiv);
        fragment.appendChild(syncStatusWrapper);

        // Pinned Section
        var pinnedTables = tables.filter(t => SIDEBAR_STATE.pinnedTables.includes(t.tableId));
        if (pinnedTables.length > 0) {
            fragment.appendChild(renderSectionHeader('pinned', 'Pinned', SIDEBAR_ICONS.starFilled, '#fbbf24', pinnedTables.length));
            if (SIDEBAR_STATE.expandedSections.pinned) {
                pinnedTables.forEach(table => {
                    fragment.appendChild(renderTableItem(table));
                    _viewLoadQueue.push(table.tableId);
                });
            }
        }

        // Recent Section
        var recentTables = SIDEBAR_STATE.recentTables
            .filter(id => !SIDEBAR_STATE.pinnedTables.includes(id))
            .map(id => tables.find(t => t.tableId === id))
            .filter(t => t);
        if (recentTables.length > 0) {
            fragment.appendChild(renderSectionHeader('recent', 'Recent', SIDEBAR_ICONS.clock, '#9ca3af', recentTables.length));
            if (SIDEBAR_STATE.expandedSections.recent) {
                recentTables.forEach(table => {
                    fragment.appendChild(renderTableItem(table));
                    _viewLoadQueue.push(table.tableId);
                });
            }
        }

        // Divider
        if (pinnedTables.length > 0 || recentTables.length > 0) {
            var divider = document.createElement('div');
            divider.className = 'sidebar-divider';
            fragment.appendChild(divider);
        }
    }

    // Grouped Sections
    var sectionConfig = [
        { id: 'primary', key: 'primary', label: 'Primary', color: '#ef4444' },
        { id: 'operational', key: 'operational', label: 'Operational', color: '#3b82f6' },
        { id: 'collections', key: 'collection', label: 'Collections', color: '#8b5cf6' },
        { id: 'reference', key: 'reference', label: 'Reference', color: '#10b981' },
        { id: 'dev', key: 'dev', label: 'Dev / Testing', color: '#6b7280' }
    ];

    sectionConfig.forEach(section => {
        var sectionTables = groupedTables[section.key] || [];
        // When searching, show all matching tables; otherwise filter out pinned from main sections
        if (!searchQuery) {
            sectionTables = sectionTables.filter(t => !SIDEBAR_STATE.pinnedTables.includes(t.tableId));
        }
        if (sectionTables.length === 0 && searchQuery) return;
        if (sectionTables.length === 0 && !SIDEBAR_STATE.expandedSections[section.id]) return;

        var config = TABLE_TYPE_CONFIG[section.key] || TABLE_TYPE_CONFIG.operational;
        fragment.appendChild(renderSectionHeader(section.id, section.label, config.icon, section.color, sectionTables.length));

        if (SIDEBAR_STATE.expandedSections[section.id] || searchQuery) {
            sectionTables.forEach(table => {
                fragment.appendChild(renderTableItem(table));
                _viewLoadQueue.push(table.tableId);
            });
        }
    });

    // Atomic DOM swap: replace all children at once to eliminate blink
    tableList.innerHTML = '';
    tableList.appendChild(fragment);

    // Load views for visible tables (after DOM is in place)
    // Prioritize the active table, then load others with idle callbacks
    var activeTid = currentTable;
    if (activeTid && _viewLoadQueue.includes(activeTid)) {
        loadTableViewsAsync(activeTid);
    }
    // Stagger view loading with setTimeout to avoid long requestIdleCallback handlers.
    // Each table gets a small delay offset so the main thread stays responsive.
    var _staggerDelay = 0;
    for (var _qi = 0; _qi < _viewLoadQueue.length; _qi++) {
        var _tid = _viewLoadQueue[_qi];
        if (_tid === activeTid) continue;
        _staggerDelay += 50;
        setTimeout(loadTableViewsAsync.bind(null, _tid), _staggerDelay);
    }

    // Active indicator color is set via --type-color CSS variable on renderTableItem above.
}

// Render views list HTML from cached META_VIEWS (synchronous, no DB hit)
function renderViewsListHTML(tableId) {
    var html = '';

    // Add "All Fields" default option first
    var isDefaultActive = currentTable === tableId && (!currentView || currentView === '_default');
    html += '<div class="table-view-item' + (isDefaultActive ? ' active' : '') + '" onclick="selectTableView(\'' + esc(tableId) + '\', \'_default\')">' +
            '<span class="view-icon">&#9638;</span>' +
            '<span class="view-name table-view-default">All Fields</span>' +
            '</div>';

    // Group views by folder
    var viewsByFolder = { '_root': [] };
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    for (var vid of viewIds) {
        if (vid === '_default') continue;
        var view = META_VIEWS[tableId][vid];
        var folderId = view.folderId || '_root';
        if (!viewsByFolder[folderId]) viewsByFolder[folderId] = [];
        viewsByFolder[folderId].push(view);
    }

    // Render root-level views first
    for (var view of viewsByFolder['_root'] || []) {
        html += renderViewItem(tableId, view);
    }

    // Render folders and their views
    var folderIds = Object.keys(VIEW_FOLDERS[tableId] || {});
    folderIds.sort((a, b) => {
        var fa = VIEW_FOLDERS[tableId][a];
        var fb = VIEW_FOLDERS[tableId][b];
        return (fa.sortOrder || 0) - (fb.sortOrder || 0);
    });

    for (var fid of folderIds) {
        var folder = VIEW_FOLDERS[tableId][fid];
        var isExpanded = folder.isExpanded !== false;

        html += '<div class="table-view-folder' + (isExpanded ? ' expanded' : '') + '" data-folder-id="' + esc(fid) + '" onclick="toggleViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)">';
        html += '<span class="folder-icon">&#9654;</span>';
        html += '<span class="folder-name">&#128193; ' + esc(folder.folderName || 'Folder') + '</span>';
        html += '<span class="folder-actions">';
        html += '<button class="folder-action-btn" onclick="renameViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)" title="Rename">&#9998;</button>';
        html += '<button class="folder-action-btn" onclick="deleteViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)" title="Delete">&#128465;</button>';
        html += '</span>';
        html += '</div>';

        html += '<div class="folder-views-list' + (isExpanded ? ' expanded' : '') + '" id="folder-views-' + esc(fid) + '">';
        for (var view of viewsByFolder[fid] || []) {
            html += renderViewItem(tableId, view, true);
        }
        html += '</div>';
    }

    // Add "New view" button
    html += '<div class="table-view-add-btn" onclick="openCreateViewModal(\'' + esc(tableId) + '\')">';
    html += '<span class="add-icon">+</span>';
    html += '<span>New view</span>';
    html += '</div>';

    return html;
}

// Track in-flight view load requests to prevent duplicate fetches
var _viewLoadInFlight = {};

// Load views for a table and populate the views list
async function loadTableViewsAsync(tableId) {
    var viewsList = document.getElementById('views-list-' + tableId);
    if (!viewsList) return;

    // If views are already cached, render immediately from cache (no blink)
    if (META_VIEWS[tableId] && Object.keys(META_VIEWS[tableId]).length > 0) {
        viewsList.innerHTML = renderViewsListHTML(tableId);
        return;
    }

    // Deduplicate: if already loading this table's views, skip
    if (_viewLoadInFlight[tableId]) return;
    _viewLoadInFlight[tableId] = true;

    try {
        // Fetch views and folders in parallel instead of sequentially
        var results = await Promise.all([
            getViewsForTable(tableId),
            getFoldersForTable(tableId)
        ]);
        var views = results[0];
        var folders = results[1];

        // Cache views in META_VIEWS
        if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
        views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

        // Load sharing metadata for views and attach as _sharing
        try {
            var sharedViews = await SharedViews.getVisibleViewsForTable(tableId);
            var sharingMap = {};
            sharedViews.forEach(function(sv) { sharingMap[sv.viewId] = sv; });

            // Merge shared views that aren't in local DB yet (from other users)
            sharedViews.forEach(function(sv) {
                if (sv.viewId && !META_VIEWS[tableId][sv.viewId] && sv.viewName) {
                    META_VIEWS[tableId][sv.viewId] = {
                        tableId: sv.tableId,
                        viewId: sv.viewId,
                        viewName: sv.viewName,
                        viewType: sv.viewType || 'grid',
                        filters: sv.filters || [],
                        sorts: sv.sorts || [],
                        groupBy: sv.groupBy || null,
                        hiddenFieldIds: sv.hiddenFieldIds || [],
                        fieldOrder: sv.fieldOrder || [],
                        tags: sv.tags || [],
                        folderId: sv.folderId || null
                    };
                }
            });

            // Attach sharing metadata to cached views for rendering
            Object.keys(META_VIEWS[tableId]).forEach(function(vid) {
                META_VIEWS[tableId][vid]._sharing = sharingMap[vid] || null;
            });
        } catch (e) {
            console.warn('[loadTableViewsAsync] Failed to load sharing metadata:', e);
        }

        // Cache folders in VIEW_FOLDERS
        if (!VIEW_FOLDERS[tableId]) VIEW_FOLDERS[tableId] = {};
        folders.forEach(f => VIEW_FOLDERS[tableId][f.folderId] = f);

        viewsList.innerHTML = renderViewsListHTML(tableId);
    } finally {
        delete _viewLoadInFlight[tableId];
    }
}

// Render a single view item
function renderViewItem(tableId, view, inFolder) {
    var isActive = currentTable === tableId && currentView === view.viewId;
    var viewName = view.viewName || view.viewId;
    var viewIcon = getViewTypeIcon(view.viewType);
    var paddingClass = inFolder ? ' style="padding-left: 52px;"' : '';

    // Check sharing status (from in-memory cache if available)
    var sharingBadge = '';
    var viewSharing = view._sharing;
    if (viewSharing && viewSharing.sharing && viewSharing.sharing !== 'private') {
        var badgeIcon = SharedViews.getSharingIcon(viewSharing);
        var isShared = viewSharing.sharing !== 'private';
        sharingBadge = '<span class="view-sharing-badge' + (isShared ? ' shared' : '') + '" title="' +
            esc(SharedViews.getSharingLabel(viewSharing)) + '">' + badgeIcon + '</span>';
    }

    return '<div class="table-view-item' + (isActive ? ' active' : '') + '"' + paddingClass + ' ' +
           'data-table-id="' + esc(tableId) + '" data-view-id="' + esc(view.viewId) + '" ' +
           'onclick="selectTableView(\'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'ondblclick="startViewRename(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'oncontextmenu="showViewContextMenu(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')">' +
           '<span class="view-icon">' + viewIcon + '</span>' +
           '<span class="view-name">' + esc(viewName) + '</span>' +
           sharingBadge +
           '</div>';
}

// Toggle view folder expanded state
async function toggleViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var folder = VIEW_FOLDERS[tableId]?.[folderId];
    if (!folder) return;

    folder.isExpanded = !folder.isExpanded;
    await saveFolder(folder);

    // Update UI
    var folderEl = document.querySelector('.table-view-folder[data-folder-id="' + folderId + '"]');
    var viewsListEl = document.getElementById('folder-views-' + folderId);

    if (folderEl && viewsListEl) {
        if (folder.isExpanded) {
            folderEl.classList.add('expanded');
            viewsListEl.classList.add('expanded');
        } else {
            folderEl.classList.remove('expanded');
            viewsListEl.classList.remove('expanded');
        }
    }
}

// Create a new view folder
async function createViewFolder(tableId) {
    var result = await showAppDialog({
        title: 'Create folder',
        message: 'Enter a name for the new folder.',
        input: true,
        defaultValue: '',
        placeholder: 'Folder name',
        confirmText: 'Create',
        validate: function(data) {
            if (!data.value || !data.value.trim()) return 'Folder name is required.';
            return '';
        }
    });
    if (!result.confirmed) return;
    var folderName = result.value.trim();

    var folderId = 'vfld' + Date.now();
    var folder = {
        folderId: folderId,
        tableId: tableId,
        folderName: folderName,
        parentFolderId: null,
        sortOrder: Object.keys(VIEW_FOLDERS[tableId] || {}).length,
        isExpanded: true
    };

    await saveFolder(folder);
    if (!VIEW_FOLDERS[tableId]) VIEW_FOLDERS[tableId] = {};
    VIEW_FOLDERS[tableId][folderId] = folder;

    // Also sync to backend
    await saveFolderToBackend(folder, 'create');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Rename a view folder
async function renameViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var folder = VIEW_FOLDERS[tableId]?.[folderId];
    if (!folder) return;

    var renameResult = await showAppDialog({
        title: 'Rename folder',
        message: 'Update the folder name.',
        input: true,
        defaultValue: folder.folderName || '',
        placeholder: 'Folder name',
        confirmText: 'Save',
        validate: function(data) {
            if (!data.value || !data.value.trim()) return 'Folder name is required.';
            return '';
        }
    });
    if (!renameResult.confirmed) return;
    var newName = renameResult.value.trim();
    if (newName === folder.folderName) return;

    folder.folderName = newName;
    await saveFolder(folder);

    // Sync to backend
    await saveFolderToBackend(folder, 'update');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Delete a view folder
async function deleteViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var deleteResult = await showAppDialog({
        title: 'Delete folder?',
        message: 'Views in this folder will be moved to the root level.',
        confirmText: 'Delete',
        cancelText: 'Cancel'
    });
    if (!deleteResult.confirmed) return;

    // Move all views in this folder to root
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    for (var vid of viewIds) {
        var view = META_VIEWS[tableId][vid];
        if (view.folderId === folderId) {
            view.folderId = null;
            await saveView(view);
        }
    }

    // Delete the folder
    await deleteFolder(folderId);
    delete VIEW_FOLDERS[tableId][folderId];

    // Sync to backend
    await saveFolderToBackend({ folderId: folderId, tableId: tableId }, 'delete');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Save folder to backend (local only  data flows Airtable  n8n  Matrix)
async function saveFolderToBackend(folder, operator) {
    // Folder config is stored locally. The client does not write to Matrix.
    // Folders are persisted via user preferences (Matrix account data).
    try {
        await UserPreferences.set('viewFolder:' + folder.folderId, folder);
    } catch (error) {
        console.error('Failed to save folder:', error);
    }
}

// View context menu state
var contextMenuViewId = null;
var contextMenuTableId = null;

// Show view context menu
function showViewContextMenu(event, tableId, viewId) {
    event.preventDefault();
    event.stopPropagation();

    contextMenuTableId = tableId;
    contextMenuViewId = viewId;

    // Update sharing label/icon in context menu
    var view = META_VIEWS[tableId] && META_VIEWS[tableId][viewId];
    var sharing = view && view._sharing;
    var shareIcon = document.getElementById('ctx-share-icon');
    var shareLabel = document.getElementById('ctx-share-label');
    if (shareIcon && shareLabel) {
        shareIcon.innerHTML = SharedViews.getSharingIcon(sharing);
        shareLabel.textContent = sharing && sharing.sharing !== 'private'
            ? SharedViews.getSharingLabel(sharing)
            : 'Share view...';
    }

    var menu = document.getElementById('view-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close view context menu
function closeViewContextMenu() {
    var menu = document.getElementById('view-context-menu');
    menu.classList.remove('open');
    contextMenuViewId = null;
    contextMenuTableId = null;
}

// Table context menu state
var tableContextMenuTableId = null;

// Show table context menu
function showTableContextMenu(event, tableId) {
    event.preventDefault();
    event.stopPropagation();

    tableContextMenuTableId = tableId;

    var menu = document.getElementById('table-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close table context menu
function closeTableContextMenu() {
    var menu = document.getElementById('table-context-menu');
    menu.classList.remove('open');
    tableContextMenuTableId = null;
}

// Column context menu state
var contextMenuFieldId = null;

// Show column context menu
function showColumnContextMenu(event, fieldId) {
    event.preventDefault();
    event.stopPropagation();

    contextMenuFieldId = fieldId;

    // Update display name menu item label
    var displayNameItem = document.getElementById('ctx-set-display-name');
    if (displayNameItem) {
        var isCurrentDisplayName = currentTable && META_TABLES[currentTable] && META_TABLES[currentTable].displayNameFieldId === fieldId;
        displayNameItem.innerHTML = isCurrentDisplayName
            ? '<span>&#127991;</span> Remove display name'
            : '<span>&#127991;</span> Set as display name';
    }

    var menu = document.getElementById('column-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close column context menu
function closeColumnContextMenu() {
    var menu = document.getElementById('column-context-menu');
    menu.classList.remove('open');
    contextMenuFieldId = null;
}

// Hide column from context menu
function hideColumnFromContextMenu() {
    if (!contextMenuFieldId) return;
    var fieldId = contextMenuFieldId;
    closeColumnContextMenu();
    toggleFieldVisibility(fieldId);
}

// Get the display name field ID for a table (explicit setting or fallback to first visible field)
function getDisplayNameFieldId(tableId) {
    var table = META_TABLES[tableId];
    if (table && table.displayNameFieldId) {
        // Verify the field still exists
        var fields = META_FIELDS[tableId] || {};
        if (fields[table.displayNameFieldId]) {
            return table.displayNameFieldId;
        }
    }
    return null;
}

// Set a field as the display name for its table
async function setDisplayNameFromContextMenu() {
    if (!contextMenuFieldId || !currentTable) return;
    var fieldId = contextMenuFieldId;
    closeColumnContextMenu();

    var table = META_TABLES[currentTable];
    if (!table) return;

    // Toggle: if already the display name, clear it
    if (table.displayNameFieldId === fieldId) {
        delete table.displayNameFieldId;
    } else {
        table.displayNameFieldId = fieldId;

        // Move the display name field to the leftmost column in the current view
        var viewId = currentView || '_default';
        var config = getViewFieldConfig(currentTable, viewId);
        var currentOrder = (config.fieldOrder || []).slice();
        // Remove the field from its current position (if present)
        var idx = currentOrder.indexOf(fieldId);
        if (idx > 0) {
            currentOrder.splice(idx, 1);
            currentOrder.unshift(fieldId);
            updateFieldOrderFast(currentTable, viewId, currentOrder);
        } else if (idx === -1 && currentOrder.length > 0) {
            // Field not in fieldOrder yet (newly added)  prepend it
            currentOrder.unshift(fieldId);
            updateFieldOrderFast(currentTable, viewId, currentOrder);
        }
    }

    await saveTable(table);
    renderTable();
}

// Create view folder from table context menu
async function createViewFolderFromContextMenu() {
    if (!tableContextMenuTableId) return;
    var tableId = tableContextMenuTableId;
    closeTableContextMenu();
    await createViewFolder(tableId);

    // Ensure the table's views list is expanded so the user can see the new folder
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItem = wrapper.querySelector('.table-item');
        var viewsList = wrapper.querySelector('.table-views-list');
        if (tableItem && !tableItem.classList.contains('expanded')) {
            tableItem.classList.add('expanded');
        }
        if (viewsList && !viewsList.classList.contains('expanded')) {
            viewsList.classList.add('expanded');
        }
    }
}

// Move view to folder
async function moveViewToFolder() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var folders = VIEW_FOLDERS[contextMenuTableId] || {};
    var folderNames = Object.values(folders).map(f => f.folderName);

    var options = ['(Root level)', ...folderNames];
    var choice = prompt('Move to folder:\n' + options.map((n, i) => i + ': ' + n).join('\n') + '\n\nEnter number:');

    if (choice === null) {
        closeViewContextMenu();
        return;
    }

    var choiceIdx = parseInt(choice);
    if (isNaN(choiceIdx) || choiceIdx < 0 || choiceIdx >= options.length) {
        closeViewContextMenu();
        return;
    }

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    if (choiceIdx === 0) {
        view.folderId = null;
    } else {
        var folderIds = Object.keys(folders);
        view.folderId = folderIds[choiceIdx - 1];
    }

    await saveView(view);
    markViewDirty('folderId', view.folderId);

    closeViewContextMenu();
    await loadTableViewsAsync(contextMenuTableId);
}

// Start inline view rename (double-click)
function startViewRename(event, tableId, viewId) {
    event.preventDefault();
    event.stopPropagation();

    var view = META_VIEWS[tableId]?.[viewId];
    if (!view) return;

    var viewItem = event.currentTarget;
    var nameSpan = viewItem.querySelector('.view-name');
    if (!nameSpan) return;

    // Create input element
    var input = document.createElement('input');
    input.type = 'text';
    input.className = 'view-name-input';
    input.value = view.viewName || '';
    input.setAttribute('data-table-id', tableId);
    input.setAttribute('data-view-id', viewId);

    // Replace span with input
    nameSpan.style.display = 'none';
    nameSpan.parentNode.insertBefore(input, nameSpan.nextSibling);
    input.focus();
    input.select();

    // Handle blur and enter key
    input.addEventListener('blur', finishViewRename);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            input.value = view.viewName || '';
            input.blur();
        }
    });
    input.addEventListener('click', function(e) {
        e.stopPropagation();
    });
}

// Finish inline view rename
async function finishViewRename(event) {
    var input = event.target;
    var tableId = input.getAttribute('data-table-id');
    var viewId = input.getAttribute('data-view-id');
    var newName = input.value.trim();

    var view = META_VIEWS[tableId]?.[viewId];
    var nameSpan = input.previousElementSibling;

    // Restore the span
    if (nameSpan) {
        nameSpan.style.display = '';
    }
    input.remove();

    if (!view || !newName || newName === view.viewName) {
        return;
    }

    // Update the view name
    view.viewName = newName;
    await saveView(view);
    markViewDirty('viewName', newName);

    // Refresh the UI
    await loadTableViewsAsync(tableId);
    renderViewSelector();
}

// Rename view (from context menu)
async function renameView() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    closeViewContextMenu();

    // Find the view item and trigger inline rename
    var viewItem = document.querySelector('.table-view-item[data-view-id="' + contextMenuViewId + '"]');
    if (viewItem) {
        var fakeEvent = {
            preventDefault: function() {},
            stopPropagation: function() {},
            currentTarget: viewItem
        };
        startViewRename(fakeEvent, contextMenuTableId, contextMenuViewId);
    } else {
        // Fallback to prompt if element not found
        var newName = prompt('Enter new view name:', view.viewName);
        if (!newName || newName === view.viewName) {
            return;
        }
        view.viewName = newName;
        await saveView(view);
        markViewDirty('viewName', newName);
        await loadTableViewsAsync(contextMenuTableId);
        renderViewSelector();
    }
}

// Delete view
async function deleteView() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    if (!confirm('Delete this view?')) {
        closeViewContextMenu();
        return;
    }

    var tableId = contextMenuTableId;
    var viewId = contextMenuViewId;

    // Capture snapshot before deletion (for undo / propagation)
    var viewSnapshot = META_VIEWS[tableId] && META_VIEWS[tableId][viewId]
        ? Object.assign({}, META_VIEWS[tableId][viewId])
        : { tableId: tableId, viewId: viewId };
    delete viewSnapshot._sharing; // strip transient UI metadata from snapshot

    // Immediately remove from local UI (no waiting for network)
    delete META_VIEWS[tableId][viewId];

    // If current view was deleted, switch to default
    if (currentView === viewId && currentTable === tableId) {
        currentView = '_default';
        renderViewSelector();
        renderFieldsDropdown();
        updateFieldsCount();
        renderTable(); // fire-and-forget; don't block deletion flow
    }

    closeViewContextMenu();

    // Re-render sidebar immediately so the view disappears
    var viewsList = document.getElementById('views-list-' + tableId);
    if (viewsList) {
        viewsList.innerHTML = renderViewsListHTML(tableId);
    }

    // Remove from IndexedDB
    try {
        await new Promise((resolve, reject) => {
            var tx = db.transaction('views', 'readwrite');
            tx.objectStore('views').delete([tableId, viewId]);
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
        });
    } catch (e) {
        console.warn('[deleteView] Failed to remove view from IndexedDB:', e);
    }

    // Remove sharing metadata (unpublishes from org space if shared)
    try {
        await SharedViews.deleteViewSharing(tableId, viewId);
    } catch (e) {
        console.warn('[deleteView] Failed to clean up sharing metadata:', e);
    }

    // Record deletion in Matrix (NUL event) for propagation to other clients
    try {
        await AminoData.deleteView(tableId, viewId, viewSnapshot);
    } catch (e) {
        console.warn('[deleteView] Failed to record deletion in Matrix (view removed locally):', e);
    }
}

// Manage view tags from context menu
async function manageViewTags() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    var currentTags = (view.tags || []).join(', ');
    var newTags = prompt('Enter tags (comma-separated):', currentTags);

    if (newTags !== null) {
        view.tags = newTags.split(',').map(t => t.trim()).filter(t => t);
        await saveView(view);
        markViewDirty('tags', view.tags);
        await loadTableViewsAsync(contextMenuTableId);
    }

    closeViewContextMenu();
}

// Add view to workspace from context menu
async function addViewToWorkspaceMenu() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var wsIds = Object.keys(WORKSPACES);

    if (wsIds.length === 0) {
        var firstWorkspaceResult = await showAppDialog({
            title: 'Create workspace',
            message: 'No workspaces exist yet. Create one to continue.',
            input: true,
            placeholder: 'Workspace name',
            confirmText: 'Create',
            validate: function(data) {
                if (!data.value || !data.value.trim()) return 'Workspace name is required.';
                return '';
            }
        });
        if (firstWorkspaceResult.confirmed) {
            var wsId = await createWorkspace(firstWorkspaceResult.value.trim());
            await addViewToWorkspace(contextMenuViewId, wsId);
            renderWorkspaceTabs();
            await loadTableViewsAsync(contextMenuTableId);
        }
        closeViewContextMenu();
        return;
    }

    var selectionOptions = wsIds.map(function(wid) {
        var ws = WORKSPACES[wid];
        var inWs = ws.viewIds.includes(contextMenuViewId) ? ' (already added)' : '';
        return { label: ws.workspaceName + inWs, workspaceId: wid };
    });
    selectionOptions.push({ label: 'Create new workspace', workspaceId: '__new__' });

    var chooseWorkspaceResult = await showAppDialog({
        title: 'Add view to workspace',
        message: 'Choose where this view should be added.',
        selectOptions: selectionOptions,
        confirmText: 'Continue'
    });

    if (chooseWorkspaceResult.confirmed) {
        var picked = selectionOptions[chooseWorkspaceResult.selectedIndex];
        if (picked && picked.workspaceId && picked.workspaceId !== '__new__') {
            await addViewToWorkspace(contextMenuViewId, picked.workspaceId);
            renderWorkspaceTabs();
        } else if (picked && picked.workspaceId === '__new__') {
            var newWorkspaceResult = await showAppDialog({
                title: 'Create workspace',
                message: 'Enter a workspace name.',
                input: true,
                placeholder: 'Workspace name',
                confirmText: 'Create',
                validate: function(data) {
                    if (!data.value || !data.value.trim()) return 'Workspace name is required.';
                    return '';
                }
            });
            if (newWorkspaceResult.confirmed) {
                var wsId = await createWorkspace(newWorkspaceResult.value.trim());
                await addViewToWorkspace(contextMenuViewId, wsId);
                renderWorkspaceTabs();
            }
        }
    }

    closeViewContextMenu();
}

// Set parent view from context menu
async function setViewParent() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    var views = META_VIEWS[contextMenuTableId] || {};
    var options = ['0: (No parent - root level)'];
    var viewIds = [''];

    var idx = 1;
    for (var vid in views) {
        if (vid === '_default' || vid === contextMenuViewId) continue;
        var v = views[vid];
        options.push(idx + ': ' + (v.viewName || vid));
        viewIds.push(vid);
        idx++;
    }

    var parentOptions = viewIds.map(function(vid, i) {
        return { label: options[i].replace(/^\d+:\s*/, ''), viewId: vid };
    });
    var parentResult = await showAppDialog({
        title: 'Set parent view',
        message: 'Choose a parent to nest this view, or select root level.',
        selectOptions: parentOptions,
        confirmText: 'Save'
    });

    if (parentResult.confirmed) {
        var selected = parentOptions[parentResult.selectedIndex];
        if (selected) {
            view.parentViewId = selected.viewId || null;
            await saveView(view);
            markViewDirty('parentViewId', view.parentViewId);
            await loadTableViewsAsync(contextMenuTableId);
        }
    }

    closeViewContextMenu();
}

// ============ Share View Functions ============

var _shareViewTableId = null;
var _shareViewId = null;

async function openShareViewMenu() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    _shareViewTableId = contextMenuTableId;
    _shareViewId = contextMenuViewId;
    closeViewContextMenu();

    var view = META_VIEWS[_shareViewTableId] && META_VIEWS[_shareViewTableId][_shareViewId];
    var viewName = (view && view.viewName) ? view.viewName : _shareViewId;

    // Get current sharing status
    var sharing = await SharedViews.getViewSharing(_shareViewTableId, _shareViewId);

    // Update modal header
    var nameEl = document.getElementById('share-view-name');
    if (nameEl) nameEl.textContent = 'Sharing settings for "' + viewName + '"';

    // Show owner info
    var ownerEl = document.getElementById('share-view-owner');
    if (ownerEl) {
        if (sharing.ownerId) {
            ownerEl.textContent = 'Created by ' + sharing.ownerId;
            ownerEl.style.display = '';
        } else {
            ownerEl.style.display = 'none';
        }
    }

    // Set current sharing level
    var radios = document.querySelectorAll('input[name="share-level"]');
    radios.forEach(function(radio) {
        radio.checked = radio.value === (sharing.sharing || 'private');
    });

    // Show/hide users section
    onShareLevelChange();

    // If sharing is 'specific', load and check the shared users
    if (sharing.sharing === 'specific') {
        await _loadShareUsersList(sharing.sharedWith || []);
    }

    // Show modal
    document.getElementById('share-view-modal').classList.add('open');
}

function onShareLevelChange() {
    var selected = document.querySelector('input[name="share-level"]:checked');
    var usersSection = document.getElementById('share-users-section');
    if (selected && selected.value === 'specific') {
        usersSection.style.display = '';
        _loadShareUsersList([]);
    } else {
        usersSection.style.display = 'none';
    }
}

async function _loadShareUsersList(preselectedUserIds) {
    var listEl = document.getElementById('share-users-list');
    if (!listEl) return;
    listEl.innerHTML = '<div class="share-users-loading">Loading org members...</div>';

    var members = await SharedViews.getOrgMembers();
    var currentUserId = MatrixClient.getUserId();

    if (members.length === 0) {
        listEl.innerHTML = '<div class="share-users-loading">No org members found. Make sure you are logged into Synapse.</div>';
        return;
    }

    var html = '';
    for (var i = 0; i < members.length; i++) {
        var m = members[i];
        if (m.userId === currentUserId) continue; // skip self
        var isChecked = preselectedUserIds.indexOf(m.userId) >= 0;
        html += '<label class="share-user-item">' +
            '<input type="checkbox" value="' + esc(m.userId) + '"' + (isChecked ? ' checked' : '') + '>' +
            '<div>' +
            '<div class="user-name">' + esc(m.displayName) + '</div>' +
            '<div class="user-id">' + esc(m.userId) + '</div>' +
            '</div>' +
            '</label>';
    }

    listEl.innerHTML = html;
}

async function submitShareView() {
    if (!_shareViewTableId || !_shareViewId) return;

    var selected = document.querySelector('input[name="share-level"]:checked');
    if (!selected) return;

    var sharing = selected.value;
    var sharedWith = [];

    if (sharing === 'specific') {
        var checkboxes = document.querySelectorAll('#share-users-list input[type="checkbox"]:checked');
        checkboxes.forEach(function(cb) {
            sharedWith.push(cb.value);
        });
    }

    var submitBtn = document.getElementById('share-view-submit');
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Saving...';
    }

    try {
        await SharedViews.shareView(_shareViewTableId, _shareViewId, sharing, sharedWith);
        closeShareViewModal();

        // Refresh sidebar to update sharing badges
        await loadTableViewsAsync(_shareViewTableId);
    } catch (e) {
        console.error('[ShareView] Failed to share view:', e);
        alert('Failed to update sharing: ' + e.message);
    } finally {
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Save Sharing';
        }
    }
}

function closeShareViewModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('share-view-modal').classList.remove('open');
    _shareViewTableId = null;
    _shareViewId = null;
}

// Open create view modal directly (not from default view protection)
function openCreateViewModal(tableId) {
    if (tableId) {
        // Temporarily switch context to the target table
        currentTable = tableId;
    }

    pendingViewAction = null;

    // Close any open dropdowns so they don't overlap the modal
    closeAllDropdowns();

    // Set the reason text
    var reasonEl = document.getElementById('create-view-reason');
    if (reasonEl) {
        reasonEl.textContent = 'Create a custom view with your own filters, sorting, and field configuration.';
    }

    // Set default view name
    var nameInput = document.getElementById('create-view-name');
    if (nameInput) {
        nameInput.value = generateDefaultViewName();
    }

    // Reset other fields
    document.getElementById('create-view-type').value = 'grid';
    document.getElementById('create-view-tags').value = '';

    // Populate parent view options
    populateParentViewOptions();

    // Populate workspace options
    populateWorkspaceOptions();

    // Reset sharing to default (everyone) and hide users section
    var sharingSelect = document.getElementById('create-view-sharing');
    if (sharingSelect) sharingSelect.value = 'everyone';
    var usersSection = document.getElementById('create-view-users-section');
    if (usersSection) usersSection.style.display = 'none';

    // Show modal
    document.getElementById('create-view-modal').classList.add('open');

    // Focus name input
    setTimeout(() => nameInput?.focus(), 100);
}

// Handle sharing level change in create view modal
function onCreateViewSharingChange() {
    var sharingSelect = document.getElementById('create-view-sharing');
    var usersSection = document.getElementById('create-view-users-section');
    if (!sharingSelect || !usersSection) return;

    if (sharingSelect.value === 'specific') {
        usersSection.style.display = '';
        _loadCreateViewUsersList();
    } else {
        usersSection.style.display = 'none';
    }
}

// Load org members into the create view user picker
async function _loadCreateViewUsersList() {
    var listEl = document.getElementById('create-view-users-list');
    if (!listEl) return;
    listEl.innerHTML = '<div class="share-users-loading">Loading org members...</div>';

    var members = await SharedViews.getOrgMembers();
    var currentUserId = MatrixClient.getUserId();

    if (members.length === 0) {
        listEl.innerHTML = '<div class="share-users-loading">No org members found.</div>';
        return;
    }

    var html = '';
    for (var i = 0; i < members.length; i++) {
        var m = members[i];
        if (m.userId === currentUserId) continue;
        html += '<label class="share-user-item">' +
            '<input type="checkbox" value="' + esc(m.userId) + '">' +
            '<div>' +
            '<div class="user-name">' + esc(m.displayName) + '</div>' +
            '<div class="user-id">' + esc(m.userId) + '</div>' +
            '</div>' +
            '</label>';
    }

    listEl.innerHTML = html;
}

// Close context menu on click outside
document.addEventListener('click', function() {
    closeViewContextMenu();
    closeTableContextMenu();
    closeColumnContextMenu();
});

// Clean up state from special views (Events, Sync Status) before switching
function cleanupSpecialViewState() {
    // Clean up events view state
    expandedPayloads.clear();
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;
    if (eventsScrollHandler) {
        var container = document.querySelector('.table-container');
        if (container) container.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }
    if (changelogScrollHandler) {
        var container = document.querySelector('.table-container');
        if (container) container.removeEventListener('scroll', changelogScrollHandler);
        changelogScrollHandler = null;
    }

    // Clean up sync status listener
    if (syncStatusUnsubscribe) { syncStatusUnsubscribe(); syncStatusUnsubscribe = null; }

    // Restore view controls bar visibility
    var viewControlsBar = document.getElementById('view-controls-bar');
    if (viewControlsBar) viewControlsBar.style.display = '';
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = '';
}

// Toggle the expanded views list for a table
function toggleTableViews(tableId, event) {
    event.stopPropagation();

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (!wrapper) return;

    var tableItem = wrapper.querySelector('.table-item');
    var viewsList = wrapper.querySelector('.table-views-list');

    if (tableItem.classList.contains('expanded')) {
        // Collapse
        tableItem.classList.remove('expanded');
        viewsList.classList.remove('expanded');
    } else {
        // Expand
        tableItem.classList.add('expanded');
        viewsList.classList.add('expanded');

        // If clicking a different table, also load it with its default view
        if (currentTable !== tableId) {
            showTable(tableId);
        }
    }
}

// Select a view from the sidebar and show the table
async function selectTableView(tableId, viewId) {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Auto-save any pending changes before navigating
    await autoSaveBeforeNavigation();
    if (navVersion !== myNav) return; // Another navigation started, abort

    // Clean up any special view state (Events, Sync Status)
    cleanupSpecialViewState();

    // Update sidebar active states - only clear previous active, not all items
    var prevActive = document.querySelectorAll('.table-item.active, .table-view-item.active');
    for (var i = 0; i < prevActive.length; i++) prevActive[i].classList.remove('active');

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItemEl = wrapper.querySelector('.table-item');
        if (tableItemEl) tableItemEl.classList.add('active');
        // Find and mark the selected view as active using data attribute
        var viewItem = wrapper.querySelector('.table-view-item[data-view-id="' + viewId + '"]');
        if (viewItem) viewItem.classList.add('active');
    }

    // If switching to a different table, load it first
    if (currentTable !== tableId) {
        // Release previous table's field data to free memory
        // Keep META_VIEWS cached since it's small and used by sidebar for instant rendering
        if (currentTable) {
            delete META_FIELDS[currentTable];
        }
        originalRecordIds = [];
        currentRecordIds = [];

        currentTable = tableId;
        currentPage = 0;

        var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
        if (navVersion !== myNav) return;
        var tableName = resolveTableName(tableId);
        document.getElementById('title').textContent = tableName;

        // Show loading state immediately
        showTableLoading('Loading table structure...');

        // Load fields, views, and record IDs in parallel
        var parallelResults = await Promise.all([
            getFieldsForTable(tableId),
            getViewsForTable(tableId),
            getRecordIdsForTable(tableId)
        ]);
        if (navVersion !== myNav) return;

        var fields = parallelResults[0];
        var views = parallelResults[1];
        var recordIds = parallelResults[2];

        META_FIELDS[tableId] = {};
        fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

        META_VIEWS[tableId] = {};
        views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

        originalRecordIds = recordIds;
        currentRecordIds = originalRecordIds;
        totalRecords = currentRecordIds.length;
    }

    // Set the current view
    currentView = viewId;

    // Load and apply view filters, sorts, groupBy, and colorBy
    var viewConfig = getViewFiltersAndSorts(tableId, viewId);
    currentFilters = viewConfig.filters;
    currentSorts = viewConfig.sorts;
    currentGroupBy = viewConfig.groupBy;
    currentColorBy = viewConfig.colorBy;
    currentSearchQuery = ''; // Reset search when switching views

    // Update filter/sort/group/color button states
    updateFilterCount();
    updateSortCount();
    updateGroupButtonState();
    updateColorButtonState();
    var searchInput = document.getElementById('view-search-input');
    if (searchInput) searchInput.value = '';

    // Render view selector and fields dropdown
    renderViewSelector();
    renderFieldsDropdown();
    updateFieldsCount();

    // Render the table
    await renderTable();
}

function updateStatus(msg, isSynced, progress, detail) {
    var dot = document.getElementById('status-dot');
    var text = document.getElementById('status-text');
    var progressBar = document.getElementById('progress-bar');
    var progressFill = document.getElementById('progress-fill');
    var statusDetail = document.getElementById('status-detail');

    dot.className = 'status-dot ' + (isSynced ? 'synced' : 'loading');
    text.textContent = msg;

    if (typeof progress === 'number' && progress >= 0) {
        progressBar.style.display = 'block';
        progressFill.style.width = Math.min(100, progress) + '%';
    } else {
        progressBar.style.display = 'none';
    }

    statusDetail.textContent = detail || '';
}

// ============ Loading Overlay ============

var refreshCountdownInterval = null;
var lastSyncTime = null;

function showLoadingOverlay() {
    var overlay = document.getElementById('loading-overlay');
    overlay.classList.remove('hidden', 'fading-out');
    setLoadingOverlayMode('default');
}

function hideLoadingOverlay() {
    var overlay = document.getElementById('loading-overlay');
    overlay.classList.add('fading-out');
    overlay.addEventListener('transitionend', function handler() {
        overlay.removeEventListener('transitionend', handler);
        overlay.classList.add('hidden');
        overlay.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    setTimeout(function() { overlay.classList.add('hidden'); overlay.classList.remove('fading-out'); }, 500);
}

var _loadingStartTime = null;
var _loadingPrevRecords = 0;
var _loadingPrevTime = null;
var _loadingSmoothedSpeed = 0;

var _defaultLoadingOverlayContent = null;

function _ensureDefaultLoadingOverlayContent() {
    if (_defaultLoadingOverlayContent) return _defaultLoadingOverlayContent;
    var titleEl = document.getElementById('loading-title');
    var subtitleEl = document.getElementById('loading-subtitle');
    var noteEl = document.getElementById('loading-note');
    _defaultLoadingOverlayContent = {
        title: titleEl ? titleEl.textContent : '',
        subtitle: subtitleEl ? subtitleEl.textContent : '',
        note: noteEl ? noteEl.innerHTML : ''
    };
    return _defaultLoadingOverlayContent;
}

function setLoadingOverlayMode(mode) {
    var titleEl = document.getElementById('loading-title');
    var subtitleEl = document.getElementById('loading-subtitle');
    var noteEl = document.getElementById('loading-note');
    var factsEl = document.getElementById('loading-facts');
    var defaults = _ensureDefaultLoadingOverlayContent();
    if (!titleEl || !subtitleEl || !noteEl) return;

    if (mode === 'local-memory') {
        titleEl.textContent = 'Loading from Local Memory';
        subtitleEl.textContent = "We found local cached data, so your workspace is starting instantly.";
        noteEl.innerHTML = '<strong>Fast startup:</strong> Using local memory avoids a full download and gets you to work faster.';
        if (factsEl) factsEl.style.display = 'none';
    } else {
        titleEl.textContent = defaults.title;
        subtitleEl.textContent = defaults.subtitle;
        noteEl.innerHTML = defaults.note;
        if (factsEl) factsEl.style.display = '';
    }
}

function _formatElapsed(ms) {
    var secs = Math.floor(ms / 1000);
    if (secs < 60) return secs + 's';
    var mins = Math.floor(secs / 60);
    secs = secs % 60;
    return mins + 'm ' + (secs < 10 ? '0' : '') + secs + 's';
}

function updateLoadingOverlay(status, detail, progress, tables, fields, records, tableProgress) {
    var statusEl = document.getElementById('loading-status');
    var detailEl = document.getElementById('loading-detail');
    var progressEl = document.getElementById('loading-progress-fill');
    var tablesEl = document.getElementById('loading-tables');
    var fieldsEl = document.getElementById('loading-fields');
    var recordsEl = document.getElementById('loading-records');
    var tableProgressEl = document.getElementById('loading-table-progress');
    var speedEl = document.getElementById('loading-speed');

    if (statusEl) statusEl.textContent = status || 'Loading...';
    if (detailEl) detailEl.textContent = detail || '';
    if (progressEl) progressEl.style.width = Math.min(100, progress || 0) + '%';
    if (tablesEl) tablesEl.textContent = (tables || 0).toLocaleString();
    if (fieldsEl) fieldsEl.textContent = (fields || 0).toLocaleString();
    if (recordsEl) recordsEl.textContent = (records || 0).toLocaleString();
    if (tableProgressEl) tableProgressEl.textContent = tableProgress || '';

    // Speed and elapsed time calculation
    var now = Date.now();
    var totalRecords = records || 0;
    if (!_loadingStartTime && totalRecords > 0) {
        _loadingStartTime = now;
        _loadingPrevTime = now;
        _loadingPrevRecords = 0;
    }

    if (speedEl && _loadingStartTime && totalRecords > 0) {
        var elapsedMs = now - _loadingStartTime;
        var elapsed = _formatElapsed(elapsedMs);

        // Calculate instantaneous speed over recent interval
        var intervalMs = now - (_loadingPrevTime || now);
        if (intervalMs > 200) {
            var intervalRecords = totalRecords - _loadingPrevRecords;
            var instantSpeed = intervalRecords / (intervalMs / 1000);
            // Smooth with exponential moving average
            _loadingSmoothedSpeed = _loadingSmoothedSpeed > 0
                ? _loadingSmoothedSpeed * 0.7 + instantSpeed * 0.3
                : instantSpeed;
            _loadingPrevTime = now;
            _loadingPrevRecords = totalRecords;
        }

        var speedStr = _loadingSmoothedSpeed > 0
            ? Math.round(_loadingSmoothedSpeed).toLocaleString() + ' records/sec'
            : '';
        speedEl.textContent = elapsed + (speedStr ? '  \u00B7  ' + speedStr : '');
    } else if (speedEl) {
        speedEl.textContent = '';
    }
}

function setRefreshIndicatorSyncing(isSyncing) {
    var indicator = document.getElementById('refresh-indicator');
    var textEl = document.getElementById('last-refresh-text');
    if (!indicator) return;

    if (isSyncing) {
        indicator.classList.add('syncing');
        textEl.textContent = 'Checking for updates...';
    } else {
        indicator.classList.remove('syncing');
        lastSyncTime = Date.now();
        startRefreshCountdown();
    }
}

function startRefreshCountdown() {
    if (refreshCountdownInterval) clearInterval(refreshCountdownInterval);

    var textEl = document.getElementById('last-refresh-text');
    if (!textEl) return;

    function updateCountdown() {
        var elapsed = Math.floor((Date.now() - lastSyncTime) / 1000);
        var remaining = Math.max(0, 180 - elapsed);

        if (remaining > 0) {
            textEl.textContent = 'Auto-refresh in ' + remaining + 's';
        } else {
            textEl.textContent = 'Refreshing soon...';
        }
    }

    updateCountdown();
    refreshCountdownInterval = setInterval(updateCountdown, 1000);
}

async function showTable(tableId) {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Auto-save any pending changes before switching tables
    await autoSaveBeforeNavigation();
    if (navVersion !== myNav) return;

    // Clean up special view state (Events, Sync Status)
    cleanupSpecialViewState();

    // Release previous table's field data to free memory (re-loaded on demand)
    // Keep META_VIEWS cached since it's small and used by sidebar for instant rendering
    if (currentTable && currentTable !== tableId) {
        delete META_FIELDS[currentTable];
        // Clear field registry fetch flag so it's re-fetched when table is visited again
        if (typeof _fieldRegistryFetched !== 'undefined') {
            delete _fieldRegistryFetched[currentTable];
        }
    }
    // Release previous record IDs
    originalRecordIds = [];
    currentRecordIds = [];

    currentTable = tableId;
    currentView = null; // Reset view when switching tables
    currentPage = 0;
    invalidateFilterCache(); // New table  stale cache
    // Don't clear the record cache here  getRecordsByIds() already handles
    // table-change eviction internally, and clearing proactively destroys
    // cached records that are reusable when navigating back to the same table.

    if (_urlStateBootstrapped) persistUrlState();

    // Track as recently accessed table
    addToRecentTables(tableId);

    // Reset search and other controls (filters/sorts will be loaded from view)
    if (typeof currentGroupBy !== 'undefined') currentGroupBy = null;
    if (typeof currentColorBy !== 'undefined') currentColorBy = null;
    if (typeof currentSearchQuery !== 'undefined') currentSearchQuery = '';

    // Reset non-filter/sort button states and search input
    var groupBtn = document.getElementById('group-btn');
    var colorBtn = document.getElementById('color-btn');
    var searchInput = document.getElementById('view-search-input');
    if (groupBtn) groupBtn.classList.remove('active');
    if (colorBtn) colorBtn.classList.remove('active');
    if (searchInput) searchInput.value = '';

    var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
    if (navVersion !== myNav) return;
    var tableName = resolveTableName(tableId);

    document.getElementById('title').textContent = tableName;

    // Update tab bar - open or activate tab for this table
    var tableType = table.tableType || 'operational';
    var tabIcons = { events: '\u26A1', operational: '\u25A6', collection: '\uD83D\uDCC5', reference: '\uD83D\uDCD6', dev: '\u2699' };
    openTableInTab(tableId, tableName, tabIcons[tableType] || '\u25A6');

    // Update sidebar - only clear previous active elements, then expand new one
    var prevActive = document.querySelectorAll('.table-item.active, .table-view-item.active');
    for (var i = 0; i < prevActive.length; i++) prevActive[i].classList.remove('active');

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItem = wrapper.querySelector('.table-item');
        var viewsList = wrapper.querySelector('.table-views-list');
        if (tableItem) {
            tableItem.classList.add('active', 'expanded');
            // Set the type color for the active indicator
            var tableName_temp = resolveTableName(tableId);
            var type_temp = getTableType(tableName_temp);
            var config_temp = TABLE_TYPE_CONFIG[type_temp] || TABLE_TYPE_CONFIG.operational;
            tableItem.style.setProperty('--type-color', config_temp.color);
        }
        if (viewsList) {
            viewsList.classList.add('expanded');
        }
    }

    // Show loading state immediately
    showTableLoading('Loading table structure...');

    // Use cached metadata when available (populated during init) to skip IDB reads.
    // Only fall back to IDB for fields/views that aren't in memory yet.
    var cachedFields = META_FIELDS[tableId] && Object.keys(META_FIELDS[tableId]).length > 0;
    var cachedViews = META_VIEWS[tableId] && Object.keys(META_VIEWS[tableId]).length > 0;

    // Load only what's missing, always need record IDs from IDB
    var parallelPromises = [
        cachedFields ? Promise.resolve(null) : getFieldsForTable(tableId),
        cachedViews ? Promise.resolve(null) : getViewsForTable(tableId),
        getRecordIdsForTable(tableId)
    ];
    var parallelResults = await Promise.all(parallelPromises);
    if (navVersion !== myNav) return;

    var fields = parallelResults[0];
    var views = parallelResults[1];
    var recordIds = parallelResults[2];

    if (fields) {
        META_FIELDS[tableId] = {};
        fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);
    }
    if (views) {
        META_VIEWS[tableId] = {};
        views.forEach(v => META_VIEWS[tableId][v.viewId] = v);
    }

    // Fetch field registry metadata (formula/lookup/rollup definitions) from
    // Postgres. This is non-blocking: we fire it early and await before render
    // so formula definitions are available when _applyFormulaColumns runs.
    var fieldRegistryPromise = fetchFieldRegistry(tableId);

    originalRecordIds = recordIds;
    currentRecordIds = originalRecordIds;
    totalRecords = currentRecordIds.length;

    // Set current view to the first available view or default
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    if (viewIds.length > 0 && !currentView) {
        // Check if there's a saved preference or use first view
        currentView = viewIds[0];
    } else if (!currentView) {
        currentView = '_default';
    }

    // Load and apply view filters, sorts, groupBy, and colorBy
    var viewConfig = getViewFiltersAndSorts(tableId, currentView);
    currentFilters = viewConfig.filters;
    currentSorts = viewConfig.sorts;
    currentGroupBy = viewConfig.groupBy;
    currentColorBy = viewConfig.colorBy;

    // Update critical button states synchronously (cheap DOM writes)
    updateFilterCount();
    updateSortCount();

    // Show table headers immediately with skeleton rows (even before data loads)
    renderTableHeaders();

    // Defer non-critical UI updates so the table skeleton paints first
    var _deferredViewId = currentView;
    var _deferredTableId = tableId;
    queueMicrotask(function() {
        updateGroupButtonState();
        updateColorButtonState();
        updateSidebarViewActive(_deferredTableId, _deferredViewId);
        renderViewSelector();
        renderFieldsDropdown();
        updateFieldsCount();
    });

    // Wait for field registry to complete before rendering so formula
    // definitions are available for _applyFormulaColumns.
    await fieldRegistryPromise;
    if (navVersion !== myNav) return;

    // Now render full table with data
    await renderTable();
}

// Update the sidebar to highlight the active view
function updateSidebarViewActive(tableId, viewId) {
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (!wrapper) return;

    // Clear only currently active items (cheaper than iterating all)
    var prevActive = wrapper.querySelectorAll('.table-view-item.active');
    for (var i = 0; i < prevActive.length; i++) prevActive[i].classList.remove('active');

    // Use data-view-id attribute for O(1) lookup
    var target = wrapper.querySelector('.table-view-item[data-view-id="' + viewId + '"]');
    if (target) target.classList.add('active');
}

function showTableLoading(message) {
    var container = document.getElementById('table-container');
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>' + esc(message) + '</h3></div>';
    document.getElementById('pagination').style.display = 'none';
}

function renderTableHeaders() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');
    var fields = META_FIELDS[currentTable] || {};

    // Use view field configuration for visible fields
    var viewId = currentView || '_default';
    var colList = getVisibleFieldsForView(currentTable, viewId);

    if (colList.length === 0) {
        // No visible fields, show empty state
        container.innerHTML = '<div class="empty-state"><h3>No visible fields</h3><p>Click the Fields button to show columns</p></div>';
        return;
    }

    var colNames = {};
    colList.forEach(fid => {
        colNames[fid] = fields[fid]?.fieldName || fid;
    });

    // Build table with headers and skeleton rows
    var html = '<table id="table"><thead><tr><th style="width: 66px; min-width: 66px; text-align: center; padding: 8px 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></svg></th><th>ID</th>';
    colList.forEach(col => {
        html += '<th title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    // Add skeleton loading rows
    for (var i = 0; i < 5; i++) {
        html += '<tr class="skeleton-row"><td><div class="skeleton-cell" style="width: 50px;"></div></td><td><div class="skeleton-cell" style="width: 60px;"></div></td>';
        colList.forEach(() => {
            html += '<td><div class="skeleton-cell" style="width: ' + (60 + Math.random() * 80) + 'px;"></div></td>';
        });
        html += '</tr>';
    }

    html += '</tbody></table>';
    container.innerHTML = html;
}

async function renderTable(paginationOnly) {
    if (!currentTable) return;
    // Skip rendering if we're in a special view (Events or Sync Status)
    if (currentTable === '_events' || currentTable === '_sync_status') return;

    var renderNav = navVersion; // Capture current nav version for stale check

    // Check if table container exists - may not exist during early loading
    var tableContainer = document.getElementById('table-container');
    if (!tableContainer) {
        console.log('renderTable: table-container not ready yet');
        return;
    }

    // When paginationOnly is true (e.g. prev/next page), skip the expensive
    // filter+sort pipeline and reuse the already-computed currentRecordIds.
    if (!paginationOnly) {
        var needsFiltering = hasFilterConditions(currentFilters) || currentSearchQuery || currentSorts.length > 0;
        if (needsFiltering) {
            // Show a loading overlay if the dataset is large enough that filtering may be noticeable
            var _showFilterOverlay = originalRecordIds.length > 500;
            if (_showFilterOverlay) {
                var _overlayMsg = currentSearchQuery ? 'Searching...' : 'Applying filters...';
                TableLoadingOverlay.show(_overlayMsg, 100);
            }
            currentRecordIds = await getFilteredSortedRecords();
            if (_showFilterOverlay) TableLoadingOverlay.hide();
            if (navVersion !== renderNav) return; // Navigation changed, abort stale render
        } else {
            // Reuse original array directly when no filters are active (avoid copying large arrays)
            currentRecordIds = originalRecordIds;
        }
    }
    totalRecords = currentRecordIds.length;

    var tableEl = document.getElementById('table');

    // Determine which records to display
    var displayRecordIds;
    var isGrouped = !!currentGroupBy;

    if (isGrouped) {
        // When grouping, show all records (no pagination) - capped to limit memory
        var maxGroupedRecords = 500;
        displayRecordIds = currentRecordIds.slice(0, maxGroupedRecords);
    } else {
        // Standard pagination
        displayRecordIds = currentRecordIds.slice(currentPage * PAGE_SIZE, (currentPage + 1) * PAGE_SIZE);

        // Check if we're on a page beyond available data (can happen after filtering)
        if (displayRecordIds.length === 0 && currentPage > 0) {
            currentPage = 0;
            displayRecordIds = currentRecordIds.slice(0, PAGE_SIZE);
        }
    }

    if (displayRecordIds.length === 0) {
        if (tableEl) tableEl.innerHTML = '';
        var emptyMsg = (hasFilterConditions(currentFilters) || currentSearchQuery)
            ? '<div class="empty-state"><h3>No matching records</h3><p>Try adjusting your filters or search</p></div>'
            : '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        tableContainer.innerHTML = emptyMsg;
        document.getElementById('pagination').style.display = 'none';
        updateRecordCountBadge();
        return;
    }

    // Fetch records before clearing the container to avoid a white flash
    var records = await getRecordsByIds(currentTable, displayRecordIds);
    if (navVersion !== renderNav) return; // Navigation changed, abort stale render
    var recordMap = {};
    records.forEach(r => recordMap[r.recordId] = r.fields || {});

    // Get columns from view configuration
    var fields = META_FIELDS[currentTable] || {};

    // OPTIMIZATION 5: Defer formula computation until after first paint.
    // Instead of blocking the HTML build with _applyFormulaColumns(), render
    // the table with raw data first (formula cells show as empty/loading),
    // then compute formulas in a requestAnimationFrame callback and surgically
    // update only the formula cells in the DOM. This lets the browser paint
    // the table grid ~100-500ms sooner on tables with complex formulas.
    var _deferFormulas = !paginationOnly && displayRecordIds.length > 0;
    if (!_deferFormulas) {
        // Pagination or empty  compute inline (fast, no visible difference)
        _applyFormulaColumns(currentTable, fields, recordMap);
    }
    var viewId = currentView || '_default';
    var colList = getVisibleFieldsForView(currentTable, viewId);

    // If no visible fields but we have data, initialize with all fields
    if (colList.length === 0 && Object.keys(fields).length === 0) {
        // Discover from data
        var colSet = {};
        records.forEach(r => {
            if (r.fields) Object.keys(r.fields).forEach(k => colSet[k] = true);
        });
        colList = Object.keys(colSet).sort();
    }

    var colNames = {};
    colList.forEach(fid => {
        colNames[fid] = fields[fid]?.fieldName || fid;
    });

    // Build color map if color-by is active
    var colorMap = null;
    if (currentColorBy) {
        colorMap = buildColorMap(displayRecordIds, recordMap, currentColorBy, colNames);
    }

    // Get group field name for header display
    var groupFieldName = currentGroupBy ? (fields[currentGroupBy]?.fieldName || currentGroupBy) : null;

    // Pre-compute per-column metadata once (avoids per-cell function calls)
    var displayNameFid = getDisplayNameFieldId(currentTable);
    var _colMeta = colList.map(function(col) {
        var f = fields[col];
        var isComp = f && isComputedFieldType(f.fieldType);
        var isRO = !isComp && f && isReadOnlyField(f);
        var visual = isComp ? computedFieldVisual(f.fieldType) : null;
        return {
            id: col,
            escapedId: esc(col),
            name: colNames[col],
            field: f,
            fieldType: f ? f.fieldType : null,
            isComputed: isComp,
            isReadOnly: isRO,
            isDisplayName: col === displayNameFid,
            computedLabel: isComp ? esc(computedFieldLabel(f.fieldType)) : '',
            readOnlyLabel: isRO ? esc(readOnlyFieldLabel(f)) : '',
            computedCellClass: visual ? visual.cellClass : '',
            computedHeaderIconClass: visual ? visual.headerIconClass : '',
            computedHeaderSvg: visual ? visual.headerSvg : '',
            computedBadgeClass: visual ? visual.badgeClass : ''
        };
    });

    // Build table with draggable headers
    var html = '<thead><tr><th style="width: 66px; min-width: 66px; cursor: default; text-align: center; padding: 8px 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></svg></th>';
    colList.forEach((col, idx) => {
        var colField = fields[col];
        var colIsComputed = colField && isComputedFieldType(colField.fieldType);
        var colIsReadOnly = colField && isReadOnlyField(colField);
        var colIsDisplayName = col === displayNameFid;
        var colTitle = esc(col) + (colIsDisplayName ? ' (Display name)' : '') + (colIsComputed ? ' (' + computedFieldLabel(colField.fieldType) + ')' : (colIsReadOnly ? ' (Read-only)' : ''));
        html += '<th draggable="true"' + (colIsDisplayName ? ' class="primary-field-col"' : '') + ' data-field-id="' + esc(col) + '" data-field-index="' + idx + '" ' +
                'ondragstart="handleColumnDragStart(event)" ondragover="handleColumnDragOver(event)" ' +
                'ondrop="handleColumnDrop(event)" ondragend="handleColumnDragEnd(event)" ' +
                'oncontextmenu="showColumnContextMenu(event, \'' + esc(col) + '\')" ' +
                'title="' + colTitle + '">' + esc(colNames[col]);
        if (colIsDisplayName) {
            html += '<span class="display-name-icon" title="Display name field"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg></span>';
        }
        if (colIsComputed) {
            var _hdrVisual = computedFieldVisual(colField.fieldType);
            html += '<span class="' + _hdrVisual.headerIconClass + '" title="' + esc(computedFieldLabel(colField.fieldType)) + '">' + _hdrVisual.headerSvg + '</span>';
        } else if (colIsReadOnly) {
            html += '<span class="readonly-icon" title="' + esc(readOnlyFieldLabel(colField)) + '">' +
                    '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg></span>';
        }
        html += '</th>';
    });
    html += '</tr></thead><tbody>';

    if (isGrouped) {
        // Group records by field value
        var groups = groupRecordsByField(displayRecordIds, recordMap, currentGroupBy, colNames);

        // Render grouped rows
        var groupIndex = 0;
        for (var groupKey in groups) {
            var groupRecords = groups[groupKey];
            var groupId = 'group-' + groupIndex;

            // Group header row
            html += '<tr class="group-header-row" data-group-id="' + groupId + '" onclick="toggleGroup(\'' + groupId + '\', event)">';
            html += '<td colspan="' + (colList.length + 1) + '">';
            html += '<span class="group-toggle">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg>';
            html += '<span class="group-name">' + esc(groupFieldName) + ': ' + esc(groupKey) + '</span>';
            html += '<span class="group-count">(' + groupRecords.length + ')</span>';
            html += '</span>';
            html += '</td></tr>';

            // Group data rows
            var _grpRowNum = 0;
            groupRecords.forEach(rid => {
                _grpRowNum++;
                var row = recordMap[rid] || {};
                var colorAttr = '';
                if (colorMap) {
                    var cv = row[currentColorBy];
                    if (cv === undefined && colNames) cv = row[colNames[currentColorBy]];
                    var ck = getGroupKeyFromValue(cv);
                    if (ck in colorMap) colorAttr = ' data-color-idx="' + colorMap[ck] + '"';
                }
                html += '<tr class="group-row" data-group-id="' + groupId + '" data-record-id="' + esc(rid) + '" data-table-id="' + esc(currentTable) + '"' + colorAttr + ' ondblclick="handleRowDblClick(event, \'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" style="cursor: default;">';
                html += '<td class="row-number-cell"><span class="row-num">' + _grpRowNum + '</span>';
                html += '<button class="row-expand-btn" onclick="event.stopPropagation(); openRecordProfile(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="Expand record">';
                html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>';
                html += '</button></td>';
                for (var _ci = 0; _ci < _colMeta.length; _ci++) {
                    var cm = _colMeta[_ci];
                    var _pfc = cm.isDisplayName ? ' primary-field-cell' : '';
                    var value = row[cm.id];
                    if (value === undefined) value = row[cm.name];
                    if (cm.isComputed) {
                        html += '<td class="cell-computed ' + cm.computedCellClass + _pfc + '" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" onclick="handleFormulaCellClick(event, this)" title="' + cm.computedLabel + '  click for info">' + formatCell(value, cm.fieldType) + '</td>';
                    } else if (cm.isReadOnly) {
                        html += '<td class="cell-readonly' + _pfc + '" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" title="' + cm.readOnlyLabel + '  read-only">' + formatCell(value, cm.fieldType) + '</td>';
                    } else {
                        html += '<td class="inline-editable' + _pfc + '" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" onclick="startInlineCellEdit(event, this)">' + formatCell(value, cm.fieldType) + '</td>';
                    }
                }
                html += '</tr>';
            });

            groupIndex++;
        }
    } else {
        // Standard flat rendering
        var _rowNumOffset = currentPage * PAGE_SIZE;
        displayRecordIds.forEach((rid, _rowIdx) => {
            var row = recordMap[rid] || {};
            var colorAttr = '';
            if (colorMap) {
                var cv = row[currentColorBy];
                if (cv === undefined && colNames) cv = row[colNames[currentColorBy]];
                var ck = getGroupKeyFromValue(cv);
                if (ck in colorMap) colorAttr = ' data-color-idx="' + colorMap[ck] + '"';
            }
            html += '<tr data-record-id="' + esc(rid) + '" data-table-id="' + esc(currentTable) + '"' + colorAttr + ' ondblclick="handleRowDblClick(event, \'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" style="cursor: default;">';
            html += '<td class="row-number-cell"><span class="row-num">' + (_rowNumOffset + _rowIdx + 1) + '</span>';
            html += '<button class="row-expand-btn" onclick="event.stopPropagation(); openRecordProfile(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="Expand record">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>';
            html += '</button></td>';
            for (var _ci = 0; _ci < _colMeta.length; _ci++) {
                var cm = _colMeta[_ci];
                var _pfc = cm.isDisplayName ? ' primary-field-cell' : '';
                var value = row[cm.id];
                if (value === undefined) value = row[cm.name];
                if (cm.isComputed) {
                    html += '<td class="cell-computed ' + cm.computedCellClass + _pfc + '" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" onclick="handleFormulaCellClick(event, this)" title="' + cm.computedLabel + '  click for info">' + formatCell(value, cm.fieldType) + '</td>';
                } else if (cm.isReadOnly) {
                    html += '<td class="cell-readonly' + _pfc + '" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" title="' + cm.readOnlyLabel + '  read-only">' + formatCell(value, cm.fieldType) + '</td>';
                } else {
                    html += '<td class="inline-editable' + _pfc + '" data-field-id="' + cm.escapedId + '" data-record-id="' + esc(rid) + '" onclick="startInlineCellEdit(event, this)">' + formatCell(value, cm.fieldType) + '</td>';
                }
            }
            html += '</tr>';
        });
    }

    html += '</tbody>';

    // Targeted DOM update: if the same set of record IDs is already rendered
    // (e.g. a sync-triggered re-render on the same page), diff and update only
    // cells whose content changed instead of destroying and rebuilding 2000+ nodes.
    var _canPatch = !isGrouped && tableEl && tableEl.querySelector('tbody') &&
        _lastRenderedRecordIds && _lastRenderedTable === currentTable &&
        _lastRenderedPage === currentPage &&
        displayRecordIds.length === _lastRenderedRecordIds.length &&
        displayRecordIds.every(function(id, i) { return id === _lastRenderedRecordIds[i]; });

    if (_canPatch) {
        // Patch existing DOM cells with new values
        for (var pi = 0; pi < displayRecordIds.length; pi++) {
            var prid = displayRecordIds[pi];
            var prow = recordMap[prid] || {};
            var domRow = tableEl.querySelector('tr[data-record-id="' + CSS.escape(prid) + '"]');
            if (!domRow) { _canPatch = false; break; }
            for (var pci = 0; pci < _colMeta.length; pci++) {
                var pcm = _colMeta[pci];
                var pval = prow[pcm.id];
                if (pval === undefined) pval = prow[pcm.name];
                var newHtml = formatCell(pval, pcm.fieldType);
                var cell = domRow.querySelector('td[data-field-id="' + CSS.escape(pcm.id) + '"]');
                if (cell && cell === _inlineEditingCell) continue; // don't clobber active edit
                if (cell && cell.innerHTML !== newHtml) {
                    cell.innerHTML = newHtml;
                }
            }
        }
    }

    if (!_canPatch) {
        // Full DOM replacement (table/page/columns changed)
        tableContainer.innerHTML = '<table id="table"></table>';
        tableEl = document.getElementById('table');
        tableEl.innerHTML = html;
    }

    // Track what we just rendered for future diff checks
    _lastRenderedRecordIds = displayRecordIds.slice();
    _lastRenderedTable = currentTable;
    _lastRenderedPage = currentPage;

    // Update pagination (show record count always, hide page nav when grouped)
    if (isGrouped) {
        var _gPag = document.getElementById('pagination');
        _gPag.style.display = 'flex';
        var _gTotalEl = document.getElementById('record-total');
        if (_gTotalEl) _gTotalEl.innerHTML = '<strong>' + totalRecords.toLocaleString() + '</strong> record' + (totalRecords !== 1 ? 's' : '');
        document.getElementById('prev-btn').style.display = 'none';
        document.getElementById('next-btn').style.display = 'none';
        document.getElementById('page-info').style.display = 'none';
    } else {
        document.getElementById('pagination').style.display = '';
        updatePagination();
    }

    // Update record count badge
    updateRecordCountBadge();

    // OPTIMIZATION 5 (cont.): After the table DOM is painted, compute formula
    // columns in a rAF callback and surgically update only the formula cells.
    // This lets the browser paint the full grid (with non-formula data) first.
    if (_deferFormulas) {
        var _dfTable = currentTable;
        var _dfNav = renderNav;
        var _dfRecordMap = recordMap;
        var _dfFields = fields;
        var _dfColMeta = _colMeta;
        var _dfDisplayIds = displayRecordIds;
        requestAnimationFrame(function() {
            if (navVersion !== _dfNav) return; // Navigation changed, skip stale update
            _applyFormulaColumns(_dfTable, _dfFields, _dfRecordMap);
            // Surgically update only formula cells in the DOM
            var _tbl = document.getElementById('table');
            if (!_tbl) return;
            for (var _dfi = 0; _dfi < _dfDisplayIds.length; _dfi++) {
                var _dfRid = _dfDisplayIds[_dfi];
                var _dfRow = _dfRecordMap[_dfRid] || {};
                for (var _dfci = 0; _dfci < _dfColMeta.length; _dfci++) {
                    var _dfCm = _dfColMeta[_dfci];
                    if (!_dfCm.isComputed) continue; // Only update formula cells
                    var _dfVal = _dfRow[_dfCm.id];
                    if (_dfVal === undefined) _dfVal = _dfRow[_dfCm.name];
                    var _dfNewHtml = formatCell(_dfVal, _dfCm.fieldType);
                    var _dfCell = _tbl.querySelector('tr[data-record-id="' + CSS.escape(_dfRid) + '"] td[data-field-id="' + CSS.escape(_dfCm.id) + '"]');
                    if (_dfCell && _dfCell.innerHTML !== _dfNewHtml) {
                        _dfCell.innerHTML = _dfNewHtml;
                    }
                }
            }
        });
    }
}

// Group records by a field value
function groupRecordsByField(recordIds, recordMap, fieldId, colNames) {
    var groups = {};
    var emptyGroupKey = '(Empty)';

    recordIds.forEach(rid => {
        var row = recordMap[rid] || {};
        var value = row[fieldId];
        if (value === undefined) value = row[colNames[fieldId]];

        // Convert value to display string for grouping
        var groupKey = getGroupKeyFromValue(value);

        if (!groups[groupKey]) {
            groups[groupKey] = [];
        }
        groups[groupKey].push(rid);
    });

    // Sort groups: put (Empty) last, then sort alphabetically
    var sortedGroups = {};
    var keys = Object.keys(groups).sort((a, b) => {
        if (a === emptyGroupKey) return 1;
        if (b === emptyGroupKey) return -1;
        return a.localeCompare(b);
    });
    keys.forEach(k => sortedGroups[k] = groups[k]);

    return sortedGroups;
}

// Get a display string for grouping from a cell value
function getGroupKeyFromValue(value) {
    if (value == null || value === '') return '(Empty)';

    if (Array.isArray(value)) {
        if (value.length === 0) return '(Empty)';
        // For arrays, join values for display
        return value.map(v => {
            if (typeof v === 'object' && v !== null) {
                return v.name || v.filename || v.email || v.id || JSON.stringify(v);
            }
            return String(v);
        }).join(', ');
    }

    if (typeof value === 'object') {
        return value.name || value.filename || value.email || value.url || JSON.stringify(value);
    }

    return String(value);
}

// Toggle group visibility (Ctrl+click or Cmd+click collapses/expands ALL groups)
function toggleGroup(groupId, event) {
    var headerRow = document.querySelector('.group-header-row[data-group-id="' + groupId + '"]');
    var isCollapsed = headerRow.classList.contains('collapsed');

    if (event && (event.ctrlKey || event.metaKey)) {
        // Ctrl+click: toggle ALL groups to match the opposite of clicked group's state
        var allHeaders = document.querySelectorAll('.group-header-row');
        allHeaders.forEach(function(h) {
            var gid = h.getAttribute('data-group-id');
            var rows = document.querySelectorAll('.group-row[data-group-id="' + gid + '"]');
            if (isCollapsed) {
                h.classList.remove('collapsed');
                rows.forEach(function(r) { r.classList.remove('hidden'); });
            } else {
                h.classList.add('collapsed');
                rows.forEach(function(r) { r.classList.add('hidden'); });
            }
        });
    } else {
        // Normal click: toggle just this group
        var dataRows = document.querySelectorAll('.group-row[data-group-id="' + groupId + '"]');
        if (isCollapsed) {
            headerRow.classList.remove('collapsed');
            dataRows.forEach(function(row) { row.classList.remove('hidden'); });
        } else {
            headerRow.classList.add('collapsed');
            dataRows.forEach(function(row) { row.classList.add('hidden'); });
        }
    }
}

function _tagColorClass(str) {
    var h = 0;
    for (var i = 0; i < str.length; i++) { h = ((h << 5) - h + str.charCodeAt(i)) | 0; }
    return 'tag-c' + (((h % 10) + 10) % 10);
}

function formatCell(v, fieldType) {
    if (v == null || v === '') {
        return '<span class="cell-empty"></span>';
    }

    // Date / dateTime / createdTime / lastModifiedTime  format nicely
    if (fieldType === 'date' || fieldType === 'dateTime' || fieldType === 'createdTime' || fieldType === 'lastModifiedTime') {
        var d = new Date(v);
        if (!isNaN(d.getTime())) {
            if (fieldType === 'date') {
                return '<span class="cell-date">' + d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) + '</span>';
            }
            return '<span class="cell-date">' + d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) + ' ' + d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) + '</span>';
        }
        // Fall through if not a valid date
    }

    // Airtable-style: single select renders as a colored pill
    if (fieldType === 'singleSelect' && typeof v === 'string') {
        return '<span class="cell-array"><span class="tag ' + _tagColorClass(v) + '">' + esc(v) + '</span></span>';
    }

    // For plain text field types, render arrays as comma-separated text, not tags
    var isTextField = fieldType === 'singleLineText' || fieldType === 'multilineText' || fieldType === 'richText'
        || fieldType === 'email' || fieldType === 'phoneNumber';
    var isSelectField = fieldType === 'multipleSelects' || fieldType === 'multipleSelect';

    if (Array.isArray(v)) {
        if (v.length === 0) return '<span class="cell-empty"></span>';

        if (isTextField) {
            // Text fields: render as plain comma-separated text
            var textItems = v.map(item => {
                if (typeof item === 'object' && item !== null) {
                    return item.name || item.filename || item.email || item.id || JSON.stringify(item).slice(0, 30);
                }
                return String(item);
            });
            return esc(textItems.join(', '));
        }

        // Check if it's an array of objects (linked records, attachments, etc.)
        if (typeof v[0] === 'object' && v[0] !== null) {
            var items = v.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return '<span class="cell-array">' + items.map(i => '<span class="tag ' + _tagColorClass(i) + '">' + esc(i) + '</span>').join('') + '</span>';
        }

        // Simple array - colored tags for select fields, standard for others
        return '<span class="cell-array">' + v.map(i => { var s = String(i); return '<span class="tag ' + _tagColorClass(s) + '">' + esc(s) + '</span>'; }).join('') + '</span>';
    }

    if (typeof v === 'object') {
        // Single object
        if (v.name) return esc(v.name);
        if (v.filename) return esc(v.filename);
        if (v.email) return esc(v.email);
        if (v.url) return '<a class="cell-link" href="' + esc(v.url) + '" target="_blank">' + esc(v.url.slice(0, 40)) + '</a>';
        return esc(JSON.stringify(v).slice(0, 50));
    }

    if (typeof v === 'boolean') {
        return '<span class="cell-bool ' + v + '">' + (v ? 'Yes' : 'No') + '</span>';
    }

    if (typeof v === 'number') {
        return '<span class="cell-number">' + v.toLocaleString() + '</span>';
    }

    // String - check for URLs
    var str = String(v);
    if (str.startsWith('http://') || str.startsWith('https://')) {
        return '<a class="cell-link" href="' + esc(str) + '" target="_blank">' + esc(str.slice(0, 50)) + '</a>';
    }

    // Auto-detect ISO date strings (e.g. "2024-01-15" or "2024-01-15T10:30:00.000Z")
    if (/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2})?/.test(str) && str.length <= 30) {
        var _ad = new Date(str);
        if (!isNaN(_ad.getTime())) {
            var hasTime = str.indexOf('T') !== -1;
            if (hasTime) {
                return '<span class="cell-date">' + _ad.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) + ' ' + _ad.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) + '</span>';
            }
            return '<span class="cell-date">' + _ad.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) + '</span>';
        }
    }

    return esc(str);
}

function updatePagination() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    var start = currentPage * PAGE_SIZE + 1;
    var end = Math.min((currentPage + 1) * PAGE_SIZE, totalRecords);

    var recordTotalEl = document.getElementById('record-total');
    if (recordTotalEl) {
        recordTotalEl.innerHTML = '<strong>' + totalRecords.toLocaleString() + '</strong> record' + (totalRecords !== 1 ? 's' : '');
    }
    document.getElementById('page-info').textContent = start + '' + end + ' of ' + totalRecords.toLocaleString();
    document.getElementById('prev-btn').disabled = currentPage === 0;
    document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
    // Always show pagination footer so total count is visible; hide nav controls when not needed
    var paginationEl = document.getElementById('pagination');
    paginationEl.style.display = 'flex';
    document.getElementById('prev-btn').style.display = totalRecords > PAGE_SIZE ? '' : 'none';
    document.getElementById('next-btn').style.display = totalRecords > PAGE_SIZE ? '' : 'none';
    document.getElementById('page-info').style.display = totalRecords > PAGE_SIZE ? '' : 'none';
}

function prevPage() {
    if (currentPage > 0) {
        currentPage--;
        if (_urlStateBootstrapped) persistUrlState();
        renderTable(true);
    }
}

function nextPage() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    if (currentPage < totalPages - 1) {
        currentPage++;
        if (_urlStateBootstrapped) persistUrlState();
        renderTable(true);
    }
}

// ============ API ============

// Fetch all records of a specific set type (table, field, view)
// Fetch all pages and filter events client-side by set type
async function fetchAllBySet(setType, onProgress) {
    var allEvents = [];
    var page = 1;
    var iterations = 0;
    while (true) {
        // Fetch using page-based pagination
        var result = await fetchPage(page);
        if (!result.events || result.events.length === 0) break;

        // Filter events client-side by payload._set
        var matchingEvents = result.events.filter(function(e) {
            if (!e || !e.payload) return false;
            var payload = parsePayload(e.payload);
            return payload && payload._set === setType;
        });

        for (var m = 0; m < matchingEvents.length; m++) allEvents.push(matchingEvents[m]);
        if (onProgress) onProgress(allEvents.length);
        if (!result.hasMore) break;
        page = result.nextPage;
        iterations++;
        if (iterations > 100) break; // Safety limit for schema
    }
    return allEvents;
}

// Fetch events (Deprecated - Xano API removed)
// The client now reads from Matrix Synapse. This stub is kept for backward compatibility.
var FETCH_PAGE_TIMEOUT = 30000;
var FETCH_PAGE_RETRIES = 3;

async function fetchPage(page, createdAfter, options) {
    // Xano API has been removed. All data flows through Matrix Synapse.
    console.warn('[fetchPage] Xano API removed  data now served via Matrix /sync');
    return { events: [], hasMore: false, nextPage: null };
}

// fullSync (Deprecated - Xano API removed)
// Initial data loading is now handled by hydrateFromSynapse() which replays
// all law.firm.schema.object events from Matrix rooms.
async function fullSync() {
    console.warn('[fullSync] Xano API removed  use hydrateFromSynapse() instead');
    await hydrateFromSynapse();
}

// incrementalSync (Deprecated - Xano API removed)
// Incremental updates are now handled by SynapseSync which long-polls Matrix /sync.
var _incrementalSyncRunning = false;
async function incrementalSync() {
    console.warn('[incrementalSync] Xano API removed  updates delivered via Matrix /sync');
    // Ensure SynapseSync is running for incremental updates
    if (!SynapseSync.running) {
        SynapseSync.start();
    }
}

// ============ Sync Status View ============

var syncStatusUnsubscribe = null;
var queueStatusUnsubscribe = null;

async function showSyncStatusView() {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Open tab for sync status
    openTableInTab('_sync_status', 'Sync Status', '\uD83D\uDD04');

    // Clean up events view state
    expandedPayloads.clear();
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;
    if (eventsScrollHandler) {
        var evContainer = document.querySelector('.table-container');
        if (evContainer) evContainer.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }
    if (changelogScrollHandler) {
        var evContainer = document.querySelector('.table-container');
        if (evContainer) evContainer.removeEventListener('scroll', changelogScrollHandler);
        changelogScrollHandler = null;
    }

    currentTable = '_sync_status';
    currentView = null;

    // Update sidebar selection
    document.querySelectorAll('.sidebar .table-item').forEach(el => el.classList.remove('active', 'expanded'));
    document.querySelectorAll('.sidebar .table-view-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.sidebar .table-item.sync-status-item')?.classList.add('active');

    // Hide view controls and show sync status view
    document.getElementById('view-controls-bar').style.display = 'none';
    document.getElementById('title').textContent = 'Sync Status';
    document.getElementById('pagination').style.display = 'none';

    // Hide toolbar views section
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = 'none';

    // Show loading state immediately
    var container = document.querySelector('.table-container');
    if (container) container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading sync status...</h3></div>';

    await renderSyncStatusView();
    if (navVersion !== myNav) return;

    // Subscribe to live updates
    if (syncStatusUnsubscribe) syncStatusUnsubscribe();
    syncStatusUnsubscribe = SyncHistory.onChange(() => {
        if (currentTable === '_sync_status') renderSyncStatusView();
    });
    if (queueStatusUnsubscribe) queueStatusUnsubscribe();
    queueStatusUnsubscribe = OfflineSyncQueue.onChange(() => {
        if (currentTable === '_sync_status') renderSyncStatusView();
    });
}

async function renderSyncStatusView() {
    var container = document.querySelector('.table-container');
    var stats = SyncHistory.getStats();
    var passiveStats = { isRunning: false, pulled: 0, verified: 0 };
    var totalEventsCount = await getRawEventsCount();

    // Fetch offline queue state
    var queueEntries = [];
    var queueCount = 0;
    try {
        queueEntries = await OfflineSyncQueue.getAll();
        queueCount = queueEntries.length;
    } catch (e) { /* db may not be ready */ }

    // Determine overall sync state
    var syncState = 'synced';
    var syncLabel = 'Up to Date';
    if (queueCount > 0) {
        syncState = 'queued';
        syncLabel = queueCount + ' Edit' + (queueCount !== 1 ? 's' : '') + ' Queued';
    } else if (SyncHistory.isPolling) {
        syncState = 'syncing';
        syncLabel = 'Checking...';
    } else if (stats.errorCount > 0 && stats.errorCount === stats.totalSyncs + stats.totalPolls) {
        syncState = 'error';
        syncLabel = 'Errors Detected';
    }

    var html = '<div class="sync-status-view">';

    // Header
    html += '<div class="sync-status-header">';
    html += '<h2>Sync Status</h2>';
    html += '<span class="sync-status-badge ' + syncState + '">' + syncLabel + '</span>';
    html += '</div>';

    // Summary cards
    html += '<div class="sync-status-cards">';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Total Events in DB</div>';
    html += '<div class="card-value">' + totalEventsCount.toLocaleString() + '</div>';
    html += '<div class="card-sub">Last event timestamp: ' + (lastEventTimestamp ? formatTimestamp(lastEventTimestamp) : 'N/A') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Events Synced (Session)</div>';
    html += '<div class="card-value">' + stats.totalEventsProcessed.toLocaleString() + '</div>';
    html += '<div class="card-sub">' + stats.totalSyncs + ' sync operation' + (stats.totalSyncs !== 1 ? 's' : '') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Snapshots Updated</div>';
    html += '<div class="card-value">' + stats.totalSnapshotsUpdated.toLocaleString() + '</div>';
    html += '<div class="card-sub">Passive: ' + passiveStats.pulled + ' pulled, ' + passiveStats.verified + ' verified</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Local Edits Propagated</div>';
    html += '<div class="card-value">' + stats.successfulEdits.toLocaleString() + '</div>';
    html += '<div class="card-sub">' + stats.totalFieldsEdited + ' field' + (stats.totalFieldsEdited !== 1 ? 's' : '') + ' changed' + (stats.failedEdits > 0 ? ', ' + stats.failedEdits + ' failed' : '') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card' + (queueCount > 0 ? ' queue-highlight' : '') + '">';
    html += '<div class="card-label">Offline Queue</div>';
    html += '<div class="card-value">' + queueCount + '</div>';
    var pendingCount = queueEntries.filter(function(e) { return e.status === 'pending'; }).length;
    var failedCount = queueEntries.filter(function(e) { return e.status === 'failed'; }).length;
    html += '<div class="card-sub">' + (queueCount === 0 ? 'All synced' : pendingCount + ' pending' + (failedCount > 0 ? ', ' + failedCount + ' failed' : '')) + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Last Sync</div>';
    html += '<div class="card-value" style="font-size: 16px;">' + (stats.lastSyncTime ? formatSyncTimestamp(stats.lastSyncTime) : 'Never') + '</div>';
    html += '<div class="card-sub">Last poll: ' + (stats.lastPollTime ? formatSyncTimestamp(stats.lastPollTime) : 'Never') + '</div>';
    html += '</div>';

    html += '</div>';

    // Polling controls
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (SyncHistory.isPolling ? (SyncHistory.consecutiveFailures > 0 ? 'red' : 'green') : 'amber') + '"></span>Database Polling</h3>';
    html += '<div class="sync-poll-controls">';
    html += '<button class="btn-poll primary" onclick="SyncHistory.pollForUpdates(); renderSyncStatusView();">';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>';
    html += 'Poll Now</button>';
    if (SyncHistory.isPolling) {
        html += '<button class="btn-poll" onclick="SyncHistory.stopPolling(); renderSyncStatusView();">Stop Auto-Poll</button>';
        if (SyncHistory.consecutiveFailures > 0) {
            html += '<span style="font-size: 12px; color: #ef4444;">Backing off: ' + Math.round(SyncHistory.currentPollInterval / 1000) + 's interval (' + SyncHistory.consecutiveFailures + ' consecutive failure' + (SyncHistory.consecutiveFailures > 1 ? 's' : '') + ')</span>';
        } else {
            html += '<span style="font-size: 12px; color: #6b7280;">Polling every ' + (SyncHistory.POLL_INTERVAL / 1000) + 's</span>';
        }
    } else {
        html += '<button class="btn-poll" onclick="SyncHistory.startPolling(); renderSyncStatusView();">Start Auto-Poll</button>';
        html += '<span style="font-size: 12px; color: #6b7280;">Auto-poll is off</span>';
    }
    html += '</div>';
    html += '</div>';

    // Offline sync queue section
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (queueCount > 0 ? 'amber' : 'green') + '"></span>Offline Queue';
    if (queueCount > 0) {
        html += ' <span class="queue-count-badge">' + queueCount + '</span>';
    }
    html += '</h3>';

    if (queueCount === 0) {
        html += '<div style="text-align: center; padding: 20px; color: #9ca3af; font-size: 13px;">No pending edits. All changes are synced to the cloud.</div>';
    } else {
        html += '<div class="sync-poll-controls" style="margin-bottom: 12px;">';
        html += '<button class="btn-poll primary" onclick="OfflineSyncQueue.drain().then(function() { renderSyncStatusView(); });">';
        html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5M5 12l7-7 7 7"/></svg>';
        html += ' Retry All Now</button>';
        html += '<button class="btn-poll" onclick="if(confirm(\'Discard all queued edits? This cannot be undone.\')) { OfflineSyncQueue.discardAll().then(function() { renderSyncStatusView(); }); }">';
        html += 'Discard All</button>';
        if (OfflineSyncQueue._draining) {
            html += '<span style="font-size: 12px; color: #fbbf24;">Syncing queued edits...</span>';
        } else if (!navigator.onLine) {
            html += '<span style="font-size: 12px; color: #f87171;">Offline  edits will sync when connection returns</span>';
        } else {
            html += '<span style="font-size: 12px; color: #6b7280;">' + queueCount + ' edit' + (queueCount !== 1 ? 's' : '') + ' waiting to sync</span>';
        }
        html += '</div>';

        html += '<table class="sync-history-table">';
        html += '<thead><tr>';
        html += '<th>Record</th>';
        html += '<th>Table</th>';
        html += '<th>Fields</th>';
        html += '<th>Status</th>';
        html += '<th>Retries</th>';
        html += '<th>Queued At</th>';
        html += '<th>Error</th>';
        html += '<th>Actions</th>';
        html += '</tr></thead>';
        html += '<tbody>';

        for (var qi = 0; qi < queueEntries.length; qi++) {
            var qe = queueEntries[qi];
            var fieldCount = qe.fieldChanges ? Object.keys(qe.fieldChanges).length : 0;
            var statusClass = qe.status === 'failed' ? 'error' : (qe.status === 'retrying' ? 'syncing' : 'queued');
            html += '<tr>';
            html += '<td style="font-size: 12px; font-family: monospace; color: #9ca3af;">' + esc(qe.recordId || '') + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280;">' + esc(qe.tableId || '') + '</td>';
            html += '<td>' + fieldCount + ' field' + (fieldCount !== 1 ? 's' : '') + '</td>';
            html += '<td><span class="sync-result-badge ' + statusClass + '">' + esc(qe.status || 'pending') + '</span></td>';
            html += '<td style="text-align: center;">' + (qe.retries || 0) + '</td>';
            html += '<td style="white-space: nowrap; font-size: 12px; color: #6b7280;">' + formatSyncTimestamp(qe.createdAt) + '</td>';
            html += '<td style="font-size: 12px; color: #f87171; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + esc(qe.error || '') + '</td>';
            html += '<td><button class="btn-poll" style="font-size: 11px; padding: 2px 8px;" onclick="OfflineSyncQueue.discard(' + qe.id + ').then(function() { renderSyncStatusView(); });">Discard</button></td>';
            html += '</tr>';
        }

        html += '</tbody></table>';
    }
    html += '</div>';

    // Sync history table
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (stats.errorCount > 0 ? 'red' : 'green') + '"></span>Sync History</h3>';

    if (SyncHistory.entries.length === 0) {
        html += '<div style="text-align: center; padding: 32px; color: #9ca3af; font-size: 13px;">No sync operations recorded yet. Syncs will appear here as they occur.</div>';
    } else {
        html += '<table class="sync-history-table">';
        html += '<thead><tr>';
        html += '<th>Time</th>';
        html += '<th>Type</th>';
        html += '<th>Result</th>';
        html += '<th>Events</th>';
        html += '<th>Snapshots</th>';
        html += '<th>Duration</th>';
        html += '<th>Detail</th>';
        html += '</tr></thead>';
        html += '<tbody>';

        var displayEntries = SyncHistory.entries.slice(0, 50);
        for (var i = 0; i < displayEntries.length; i++) {
            var entry = displayEntries[i];
            html += '<tr>';
            html += '<td style="white-space: nowrap; font-size: 12px; color: #6b7280;">' + formatSyncTimestamp(entry.timestamp) + '</td>';
            html += '<td><span class="sync-type-badge ' + entry.type + '">' + entry.type + '</span></td>';
            html += '<td><span class="sync-result-badge ' + entry.result + '">' + entry.result.replace('-', ' ') + '</span></td>';
            html += '<td>' + (entry.eventsFound || 0) + '</td>';
            html += '<td>' + (entry.snapshotsUpdated || 0) + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280;">' + (entry.duration > 0 ? entry.duration + 'ms' : '-') + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + esc(entry.detail || '') + '</td>';
            html += '</tr>';
        }

        html += '</tbody></table>';
        if (SyncHistory.entries.length > 50) {
            html += '<div style="text-align: center; padding: 8px; color: #9ca3af; font-size: 12px;">Showing 50 of ' + SyncHistory.entries.length + ' entries</div>';
        }
    }
    html += '</div>';

    // Activity log (mirrors SyncStatusFeed)
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (SyncStatusFeed.isActive ? 'green' : 'amber') + '"></span>Activity Log</h3>';
    html += '<div class="sync-activity-log">';
    if (SyncStatusFeed.lines.length === 0) {
        html += '<div class="log-empty">No sync activity logged yet</div>';
    } else {
        var logLines = SyncStatusFeed.lines.slice(-50);
        for (var j = 0; j < logLines.length; j++) {
            var line = logLines[j];
            html += '<div class="log-line ' + line.type + '">';
            html += '<span class="timestamp">' + line.timestamp + '</span>';
            html += '<span class="message">' + esc(line.message) + '</span>';
            html += '</div>';
        }
    }
    html += '</div>';
    html += '</div>';

    html += '</div>';
    container.innerHTML = html;

    // Scroll activity log to bottom
    var logEl = container.querySelector('.sync-activity-log');
    if (logEl) logEl.scrollTop = logEl.scrollHeight;
}

function formatSyncTimestamp(ts) {
    var d;
    if (ts instanceof Date) {
        d = ts;
    } else if (typeof ts === 'number') {
        d = new Date(ts);
    } else {
        d = new Date(ts);
    }
    if (isNaN(d.getTime())) return String(ts);
    var now = new Date();
    var isToday = d.toDateString() === now.toDateString();
    var time = d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });
    if (isToday) return time;
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' + time;
}

// ============ Synapse Sync (removed) ============
// Room-as-table sync has been removed. Record data is now hydrated
// exclusively from the Postgres server via /amino-records and /amino-records-since.
// Matrix is still used for auth, views, messaging, and org config.

// Stub SynapseSync for any remaining references
var SynapseSync = {
    running: false,
    since: null,
    tableRooms: [],
    roomToTable: {},
    _backoffMs: 1000,
    _lastEventTime: 0,
    async discoverTableRooms() { return []; },
    async start() { console.log('[SynapseSync] Room-as-table sync removed  using Postgres hydration'); },
    stop() { this.running = false; }
};

// Stubs for removed room-table lookup functions
function _getRoomForTable(tableId) { return null; }
function _getRoomTableMap() { return {}; }

// hydrateFromSynapse: removed  hydration now uses Postgres via /amino-records
async function hydrateFromSynapse() {
    console.log('[Hydration] Room-based hydration removed  use Postgres hydration instead');
    return false;
}

// backfillHistoryFromMatrix: removed  history now comes from Postgres
async function backfillHistoryFromMatrix() {
    console.log('[HistoryBackfill] Room-based history backfill removed');
    return false;
}

// (Original hydrateFromSynapse and backfillHistoryFromMatrix implementations removed)
// Records are now hydrated from Postgres via webhook API.
async function _hydrateFromSynapse_removed() { return false; }
async function _backfillHistoryFromMatrix_removed() { return false; }

/* --- START REMOVED ROOM SYNC CODE ---
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) {
            console.warn('[Hydration] No Synapse session  cannot hydrate');
            return false;
        }

        // Discover table rooms (vault rooms)
        var tableRooms = await SynapseSync.discoverTableRooms();
        if (tableRooms.length === 0) {
            console.log('[Hydration] No table rooms found');
            return false;
        }

        updateStatus('Hydrating from Synapse...', false, 0, 'Found ' + tableRooms.length + ' tables');
        var totalProcessed = 0;
        var totalFieldsFound = 0;
        var totalRecordsFound = 0;

        // Reset speed tracking for this hydration run
        _loadingStartTime = null;
        _loadingPrevRecords = 0;
        _loadingPrevTime = null;
        _loadingSmoothedSpeed = 0;

        updateLoadingOverlay('Downloading data...', 'Found ' + tableRooms.length + ' tables', 0, tableRooms.length, 0, 0, null);

        // Suppress edge rebuilds during bulk hydration  one rebuild at the end
        suppressEdgeRebuilds();

        for (var idx = 0; idx < tableRooms.length; idx++) {
            var tr = tableRooms[idx];
            var progressPct = Math.round((idx / tableRooms.length) * 100);
            updateStatus('Hydrating ' + tr.name + '...', false, progressPct, 'Table ' + (idx + 1) + ' of ' + tableRooms.length);
            updateLoadingOverlay('Downloading ' + tr.name + '...', 'Table ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, totalFieldsFound, totalRecordsFound, 'Reading schema...');

            // 1. Read schema state events for this room
            try {
                var stateRes = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/rooms/' + encodeURIComponent(tr.roomId) + '/state', {
                    headers: { 'Authorization': 'Bearer ' + session.accessToken }
                });
                if (stateRes.ok) {
                    var stateEvents = await safeResponseJson(stateRes, 'Room state');
                    for (var i = 0; i < stateEvents.length; i++) {
                        var evt = stateEvents[i];
                        if (evt.type === 'law.firm.vault.metadata' && evt.content) {
                            var vaultTableId = evt.content.tableId || evt.content.table_id || tr.tableId;
                            var vaultTableName = evt.content.tableName || evt.content.table_name || evt.content.name || tr.name;
                            await saveTable({ tableId: vaultTableId, tableName: vaultTableName });
                        } else if (evt.type === 'law.firm.schema.table' && evt.content) {
                            await saveTable({ tableId: evt.content.tableId || evt.content.table_id || tr.tableId, tableName: evt.content.name || evt.content.tableName || tr.name });
                        } else if (evt.type === 'law.firm.schema.field' && evt.content) {
                            await saveField({ tableId: tr.tableId, fieldId: evt.content.fieldId || evt.content.field_id || evt.state_key, fieldName: evt.content.name, fieldType: evt.content.type, options: evt.content.options });
                            totalFieldsFound++;
                        }
                    }
                    updateLoadingOverlay('Downloading ' + tr.name + '...', 'Table ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, totalFieldsFound, totalRecordsFound, 'Schema loaded \u2014 fetching records...');
                }
            } catch (stateErr) {
                console.warn('[Hydration] State read failed for ' + tr.name + ':', stateErr);
            }

            // 2. Paginate full timeline for law.firm.schema.object + law.firm.record.mutate events
            var from = null;
            var roomEvents = 0;
            while (true) {
                try {
                    var msgUrl = SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/rooms/' + encodeURIComponent(tr.roomId) + '/messages?dir=f&limit=100';
                    if (from) msgUrl += '&from=' + encodeURIComponent(from);
                    msgUrl += '&filter=' + encodeURIComponent(JSON.stringify({ types: ['law.firm.schema.object', 'law.firm.record.mutate'] }));

                    var msgRes = await fetch(msgUrl, {
                        headers: { 'Authorization': 'Bearer ' + session.accessToken }
                    });
                    if (!msgRes.ok) break;

                    var msgData = await safeResponseJson(msgRes, 'Room messages');
                    var chunk = msgData.chunk || [];
                    if (chunk.length === 0) break;

                    // Batch all events in this page for a single processEvents call
                    var batchedChunkEvents = [];
                    for (var j = 0; j < chunk.length; j++) {
                        var mevt = chunk[j];
                        if ((mevt.type === 'law.firm.schema.object' || mevt.type === 'law.firm.record.mutate') && mevt.content) {
                            var synEvent = SynapseSync._convertSchemaObjectEvent(mevt, tr.tableId);
                            if (synEvent) batchedChunkEvents.push(synEvent);
                        }
                    }
                    if (batchedChunkEvents.length > 0) {
                        try {
                            await processEvents(batchedChunkEvents);
                            roomEvents += batchedChunkEvents.length;
                            totalProcessed += batchedChunkEvents.length;
                            totalRecordsFound += batchedChunkEvents.length;
                        } catch (procErr) {
                            console.warn('[Hydration] Event processing error:', procErr);
                        }
                    }

                    // Update loading overlay with record progress at page boundary
                    updateLoadingOverlay('Downloading ' + tr.name + '...', 'Table ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, totalFieldsFound, totalRecordsFound, roomEvents.toLocaleString() + ' records in this table...');

                    from = msgData.end;
                    if (!from) break;
                } catch (pageErr) {
                    console.warn('[Hydration] Pagination error for ' + tr.name + ':', pageErr);
                    break;
                }
            }

            console.log('[Hydration] ' + tr.name + ': ' + roomEvents + ' events processed');
        }

        updateLoadingOverlay('Encrypting and saving...', 'Finalizing ' + totalProcessed.toLocaleString() + ' records', 95, tableRooms.length, totalFieldsFound, totalRecordsFound, 'Writing to local storage...');

        // Save sync token for incremental updates going forward
        try {
            var syncRes = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/sync?timeout=0&filter=' + encodeURIComponent(JSON.stringify({ room: { rooms: tableRooms.map(function(r) { return r.roomId; }), timeline: { limit: 0 } } })), {
                headers: { 'Authorization': 'Bearer ' + session.accessToken }
            });
            if (syncRes.ok) {
                var syncData = await safeResponseJson(syncRes, 'Sync token');
                SynapseSync.since = syncData.next_batch;
                await setSyncMeta('synapseSyncToken', syncData.next_batch);
            }
        } catch (tokenErr) {
            console.warn('[Hydration] Could not save sync token:', tokenErr);
        }

        // Unsuppress edge rebuilds  triggers one rebuild if any were requested
        unsuppressEdgeRebuilds();

        updateLoadingOverlay('Sync complete', totalProcessed.toLocaleString() + ' records downloaded and encrypted', 100, tableRooms.length, totalFieldsFound, totalRecordsFound, '');
        updateStatus('Hydration complete: ' + totalProcessed + ' events', true, 100, null);
        return totalProcessed > 0;
    } catch (err) {
        unsuppressEdgeRebuilds(); // ensure unsuppress even on error
        console.error('[Hydration] Failed:', err);
        return false;
    }
}

// ============ Matrix History Backfill ============

// After hydrating current record state from the webhook DB API, replay
// Matrix room timelines to build field-level change history.  Uses
// processEvents({ historyOnly: true }) so that data records in IndexedDB
// are NOT overwritten  the webhook-hydrated state remains authoritative.
// Only field history entries and schema metadata are written.
// Each room is processed in full (all pages collected first) so that
// records spanning multiple pages have accurate oldValue tracking.
async function backfillHistoryFromMatrix() {
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) {
            console.warn('[HistoryBackfill] No Synapse session  skipping');
            return false;
        }

        // Use SynapseSync.tableRooms (already populated by ensureRoomMembership)
        var tableRooms = (SynapseSync.tableRooms || []).filter(function(tr) { return !!tr.roomId; });
        if (tableRooms.length === 0) {
            console.log('[HistoryBackfill] No table rooms  skipping history backfill');
            return false;
        }

        console.log('[HistoryBackfill] Backfilling history from ' + tableRooms.length + ' Matrix rooms');
        SyncStatusFeed.log('Backfilling field history from Matrix...');
        updateLoadingOverlay('Backfilling history...', 'Reading ' + tableRooms.length + ' rooms', 0, tableRooms.length, 0, 0, null);

        // Suppress edge rebuilds during the entire backfill  one rebuild at the end
        suppressEdgeRebuilds();
        var totalEvents = 0;

        for (var idx = 0; idx < tableRooms.length; idx++) {
            var tr = tableRooms[idx];
            var tableName = tr.name || tr.tableId;
            var progressPct = Math.round((idx / tableRooms.length) * 100);
            updateLoadingOverlay('Backfilling history  ' + tableName, 'Room ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, 0, totalEvents, null);

            // Read schema state events (fields) for this room
            try {
                var stateRes = await fetch(SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/rooms/' + encodeURIComponent(tr.roomId) + '/state', {
                    headers: { 'Authorization': 'Bearer ' + session.accessToken }
                });
                if (stateRes.ok) {
                    var stateEvents = await safeResponseJson(stateRes, 'Room state');
                    for (var si = 0; si < stateEvents.length; si++) {
                        var sevt = stateEvents[si];
                        if (sevt.type === 'law.firm.schema.field' && sevt.content) {
                            var fieldMeta = {
                                tableId: tr.tableId,
                                fieldId: sevt.content.fieldId || sevt.content.field_id || sevt.state_key,
                                fieldName: sevt.content.name || sevt.content.fieldName || sevt.state_key,
                                fieldType: sevt.content.type || sevt.content.fieldType || 'unknown',
                                options: sevt.content.options
                            };
                            if (!META_FIELDS[tr.tableId]) META_FIELDS[tr.tableId] = {};
                            // Only update if currently a placeholder or missing
                            var existing = META_FIELDS[tr.tableId][fieldMeta.fieldId];
                            if (!existing || existing._placeholder) {
                                META_FIELDS[tr.tableId][fieldMeta.fieldId] = fieldMeta;
                                await saveField(fieldMeta);
                            }
                        }
                    }
                }
            } catch (stateErr) {
                console.warn('[HistoryBackfill] State read failed for ' + tableName + ':', stateErr);
            }

            // Paginate the full timeline to collect ALL mutation events for
            // this room, then process them in a single historyOnly call.
            // Collecting all events first ensures that records spanning
            // multiple pages have accurate oldValue tracking (the in-memory
            // state is maintained across the full chronological sequence).
            var from = null;
            var allRoomEvents = [];
            while (true) {
                try {
                    var msgUrl = SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/rooms/' + encodeURIComponent(tr.roomId) + '/messages?dir=f&limit=100';
                    if (from) msgUrl += '&from=' + encodeURIComponent(from);
                    msgUrl += '&filter=' + encodeURIComponent(JSON.stringify({ types: ['law.firm.schema.object', 'law.firm.record.mutate'] }));

                    var msgRes = await fetch(msgUrl, {
                        headers: { 'Authorization': 'Bearer ' + session.accessToken }
                    });
                    if (!msgRes.ok) break;

                    var msgData = await safeResponseJson(msgRes, 'Room messages');
                    var chunk = msgData.chunk || [];
                    if (chunk.length === 0) break;

                    // Convert Matrix events to the synthetic format
                    for (var j = 0; j < chunk.length; j++) {
                        var mevt = chunk[j];
                        if ((mevt.type === 'law.firm.schema.object' || mevt.type === 'law.firm.record.mutate') && mevt.content) {
                            var synEvent = SynapseSync._convertSchemaObjectEvent(mevt, tr.tableId);
                            if (synEvent) allRoomEvents.push(synEvent);
                        }
                    }

                    if (allRoomEvents.length % 50 === 0 && allRoomEvents.length > 0) {
                        updateLoadingOverlay('Backfilling history  ' + tableName, 'Room ' + (idx + 1) + ' of ' + tableRooms.length, progressPct, tableRooms.length, 0, totalEvents + allRoomEvents.length, allRoomEvents.length + ' events collected...');
                    }

                    from = msgData.end;
                    if (!from) break;
                } catch (pageErr) {
                    console.warn('[HistoryBackfill] Pagination error for ' + tableName + ':', pageErr);
                    break;
                }
            }

            // Process all collected events for this room in one call with
            // historyOnly: true  writes field history and schema metadata
            // but does NOT overwrite the webhook-hydrated record data.
            if (allRoomEvents.length > 0) {
                await processEvents(allRoomEvents, { historyOnly: true });
                totalEvents += allRoomEvents.length;
                console.log('[HistoryBackfill] ' + tableName + ': ' + allRoomEvents.length + ' events (history only)');
            }
            allRoomEvents = null; // release memory for this room
        }

        // Unsuppress edge rebuilds  triggers one rebuild if any were requested
        unsuppressEdgeRebuilds();

        SyncStatusFeed.success('History backfill complete: ' + totalEvents + ' events from ' + tableRooms.length + ' rooms');
        console.log('[HistoryBackfill] Complete: ' + totalEvents + ' total events (history only  record data preserved from webhook)');
        return totalEvents > 0;
    } catch (err) {
        unsuppressEdgeRebuilds(); // ensure unsuppress even on error
        console.error('[HistoryBackfill] Failed:', err);
        SyncStatusFeed.error('History backfill failed: ' + err.message);
        return false;
    }
--- END REMOVED ROOM SYNC CODE --- */

// ============ Webhook Hydration ============

// Fetch from n8n webhook API using the Synapse access token.
// Uses POST with query-parameter + JSON body auth.  Includes the Matrix
// access_token so the n8n webhook can authenticate against the homeserver
// on behalf of the user.  Falls back to Authorization header if the
// primary request fails or returns 401.
// options.method: HTTP method override (default: 'GET')
// options.body:   JSON body for POST/PATCH requests
async function webhookFetch(path, options) {
    var session = _loadSynapseSession();
    if (!session || !session.accessToken) throw new Error('No Synapse session');

    options = options || {};
    var method = (options.method || 'GET').toUpperCase();

    // Prefer the live Matrix access token (may have been refreshed since
    // the session was persisted to localStorage).
    var matrixToken = (typeof MatrixClient !== 'undefined' && MatrixClient.getAccessToken && MatrixClient.getAccessToken())
        ? MatrixClient.getAccessToken()
        : session.accessToken;

    var MAX_RETRIES = 2;
    var lastErr = null;

    for (var attempt = 0; attempt <= MAX_RETRIES; attempt++) {
        if (attempt > 0) {
            // Exponential backoff: 1s, 3s
            var delay = attempt === 1 ? 1000 : 3000;
            console.log('[webhookFetch] Retry ' + attempt + '/' + MAX_RETRIES + ' for ' + path + ' (waiting ' + delay + 'ms)');
            await new Promise(function(r) { setTimeout(r, delay); });
        }

        // Auth: access_token in query-param (+ JSON body for non-GET)
        var separator = path.indexOf('?') === -1 ? '?' : '&';
        var url = N8N_WEBHOOK_BASE + path + separator + 'access_token=' + encodeURIComponent(matrixToken);

        var fetchOpts = {
            method: method,
            headers: {}
        };
        if (method !== 'GET' && method !== 'HEAD') {
            fetchOpts.headers['Content-Type'] = 'application/json';
            fetchOpts.body = JSON.stringify(options.body || { access_token: matrixToken });
        }

        var response;
        try {
            response = await fetch(url, fetchOpts);
        } catch (fetchErr) {
            // Network / CORS failure  try header auth as last resort
            console.warn('[webhookFetch] ' + method + ' fetch failed (' + fetchErr.message + '), retrying with header auth for ' + path);
            try {
                var retryOpts = {
                    method: method,
                    headers: { 'Authorization': 'Bearer ' + matrixToken }
                };
                if (method !== 'GET' && method !== 'HEAD') {
                    retryOpts.headers['Content-Type'] = 'application/json';
                    retryOpts.body = JSON.stringify(options.body || { access_token: matrixToken });
                }
                response = await fetch(N8N_WEBHOOK_BASE + path, retryOpts);
            } catch (headerErr) {
                lastErr = new Error('Webhook unreachable (CORS/network): ' + headerErr.message);
                continue;
            }
        }

        if (response.status === 401) {
            // Token may not have been picked up  retry with header auth
            console.warn('[webhookFetch] 401, retrying with header auth for ' + path);
            try {
                var authRetryOpts = {
                    method: method,
                    headers: { 'Authorization': 'Bearer ' + matrixToken }
                };
                if (method !== 'GET' && method !== 'HEAD') {
                    authRetryOpts.headers['Content-Type'] = 'application/json';
                    authRetryOpts.body = JSON.stringify(options.body || { access_token: matrixToken });
                }
                response = await fetch(N8N_WEBHOOK_BASE + path, authRetryOpts);
            } catch (headerErr) {
                throw new Error('Webhook auth retry failed (CORS/network): ' + headerErr.message);
            }
            if (response.status === 401) {
                throw new Error('Webhook auth failed (Matrix token rejected)');
            }
        }

        // Retry on 5xx server errors (transient failures, n8n overload, etc.)
        if (response.status >= 500) {
            var errBody = '';
            try { errBody = await response.text(); } catch (e) {}
            console.warn('[webhookFetch] Server error ' + response.status + ' for ' + path + (errBody ? '  body: ' + errBody.substring(0, 200) : ''));
            lastErr = new Error('Webhook API error: ' + response.status + (errBody ? ' (' + errBody.substring(0, 100) + ')' : ''));
            continue;
        }

        if (!response.ok) {
            var errBody2 = '';
            try { errBody2 = await response.text(); } catch (e) {}
            throw new Error('Webhook API error: ' + response.status + (errBody2 ? ' (' + errBody2.substring(0, 100) + ')' : ''));
        }

        try {
            return await safeResponseJson(response, 'Webhook API');
        } catch (parseErr) {
            // n8n returns HTTP 200 with an empty body when there are no
            // records to return (e.g. no changes since the given cursor).
            // Treat this as a successful empty response, not a transient error.
            if (parseErr.message && parseErr.message.indexOf('Empty response body') !== -1) {
                console.log('[webhookFetch] Empty response for ' + path + '  treating as empty result set');
                return { records: [] };
            }
            // Other parse failures (non-JSON body from proxy, etc.) may be
            // transient  retry with backoff.
            console.warn('[webhookFetch] JSON parse failed for ' + path + ': ' + parseErr.message);
            lastErr = parseErr;
            continue;
        }
    }

    // All retries exhausted
    throw lastErr || new Error('Webhook API failed after ' + (MAX_RETRIES + 1) + ' attempts');
}

// hydrateFromWebhooks: fetch current state from n8n webhook API and store in main app IndexedDB
function _extractWebhookCursorTimestamp(record) {
    if (!record || typeof record !== 'object') return null;
    var candidates = [record.lastSynced, record.updatedAt, record.updated_at, record.modifiedTime, record.modified_time, record._updatedAt];
    for (var i = 0; i < candidates.length; i++) {
        var value = candidates[i];
        if (!value) continue;
        var ts = new Date(value).getTime();
        if (!isNaN(ts)) return ts;
    }
    return null;
}

function _cursorIsoWithSafetyOverlap(tsMs) {
    if (!tsMs || isNaN(tsMs)) return null;
    var overlapMs = 2000; // small overlap to reduce edge-window drops
    return new Date(Math.max(0, tsMs - overlapMs)).toISOString();
}

async function hydrateFromWebhooks() {
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) {
            console.warn('[WebhookHydration] No Synapse session  cannot hydrate');
            return { success: false, partial: false, totalTables: 0, failedTables: 0, totalRecords: 0, nextCursor: null };
        }

        console.log('[WebhookHydration] Starting hydration from n8n webhook API');
        SyncStatusFeed.log('Hydrating from webhook API...');

        // 1. Fetch table list
        updateStatus('Fetching tables from webhook API...', false, 0, null);
        var tablesData = await webhookFetch('/amino-tables');
        var webhookTables = tablesData.tables || [];

        if (webhookTables.length === 0) {
            console.log('[WebhookHydration] No tables returned from webhook API');
            SyncStatusFeed.warn('Webhook API returned 0 tables');
            return { success: false, partial: false, totalTables: 0, failedTables: 0, totalRecords: 0, nextCursor: null };
        }

        console.log('[WebhookHydration] Found ' + webhookTables.length + ' tables');
        SyncStatusFeed.info('Found ' + webhookTables.length + ' tables via webhook API');

        // Backfill table display names from API response into META_TABLES
        for (var tn = 0; tn < webhookTables.length; tn++) {
            var wt = webhookTables[tn];
            if (wt.table_name && wt.table_id && META_TABLES[wt.table_id]) {
                var meta = META_TABLES[wt.table_id];
                if (!meta.tableName || _looksLikeTableId(meta.tableName) || meta._placeholder) {
                    meta.tableName = wt.table_name;
                    if (meta._placeholder) delete meta._placeholder;
                }
            }
        }

        var totalRecords = 0;
        var totalFields = 0;
        var failedTables = 0;
        var successfulTables = 0;
        var maxCursorTimestamp = 0;

        // Reset speed tracking for this hydration run
        _loadingStartTime = null;
        _loadingPrevRecords = 0;
        _loadingPrevTime = null;
        _loadingSmoothedSpeed = 0;

        updateLoadingOverlay('Downloading from API...', 'Found ' + webhookTables.length + ' tables', 0, webhookTables.length, 0, 0, null);

        // 2. For each table, fetch records and store in main app IndexedDB.
        // Processes up to CONCURRENCY tables in parallel to overlap network I/O
        // with encryption/IDB writes. IDB transactions are per-batch so they
        // don't conflict across concurrent tables.
        var HYDRATION_CONCURRENCY = 3;
        var _tablesCompleted = 0;

        async function _hydrateOneTable(wt) {
            var tableId = wt.table_id;
            var tableName = wt.table_name || tableId;

            // Save table metadata
            await saveTable({ tableId: tableId, tableName: tableName });
            META_TABLES[tableId] = { tableId: tableId, tableName: tableName };

            try {
                var recordsData = await webhookFetch('/amino-records?tableId=' + encodeURIComponent(tableId));
                var records = recordsData.records || [];

                if (records.length > 0) {
                    var BATCH = 200;
                    for (var b = 0; b < records.length; b += BATCH) {
                        var batch = records.slice(b, b + BATCH);
                        var dataRecords = [];
                        var fieldsToSave = [];

                        for (var r = 0; r < batch.length; r++) {
                            var rec = batch[r];
                            var recId = rec.id || '';

                            // Postgres amino.current_state stores both actual record data (rec*)
                            // and schema metadata (fld*, viw*, etc.) in the same table.
                            // Only rec* entries are data records  fld* are field definitions.
                            if (recId.startsWith('fld')) {
                                // Extract field metadata for proper column headers
                                var fMeta = rec.fields;
                                if (typeof fMeta === 'string') {
                                    try { fMeta = JSON.parse(fMeta); } catch (e) { fMeta = null; }
                                }
                                if (fMeta && typeof fMeta === 'object' && !Array.isArray(fMeta) && fMeta.fieldName) {
                                    if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
                                    var existing = META_FIELDS[tableId][recId];
                                    var fieldMeta = {
                                        tableId: tableId,
                                        fieldId: recId,
                                        fieldName: fMeta.fieldName || recId,
                                        fieldType: fMeta.fieldType || 'singleLineText'
                                    };
                                    META_FIELDS[tableId][recId] = fieldMeta;
                                    fieldsToSave.push(fieldMeta);
                                    if (!existing) totalFields++;
                                }
                                continue;
                            }
                            if (!recId.startsWith('rec')) continue;  // Skip viw*, etc.

                            var fields = rec.fields;
                            if (!fields) continue;

                            // n8n Postgres node may return JSONB columns as
                            // strings  parse them before the object guard.
                            if (typeof fields === 'string') {
                                try { fields = JSON.parse(fields); } catch (e) { continue; }
                            }

                            if (typeof fields !== 'object' || Array.isArray(fields)) continue;

                            var cursorTs = _extractWebhookCursorTimestamp(rec);
                            if (cursorTs && cursorTs > maxCursorTimestamp) {
                                maxCursorTimestamp = cursorTs;
                            }

                            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
                            var fieldIds = Object.keys(fields);
                            for (var fi = 0; fi < fieldIds.length; fi++) {
                                var fid = fieldIds[fi];
                                if (!META_FIELDS[tableId][fid]) {
                                    var fieldMeta = {
                                        tableId: tableId,
                                        fieldId: fid,
                                        fieldName: fid,
                                        fieldType: inferFieldType(fields[fid]),
                                        _placeholder: true
                                    };
                                    META_FIELDS[tableId][fid] = fieldMeta;
                                    fieldsToSave.push(fieldMeta);
                                    totalFields++;
                                }
                            }

                            dataRecords.push({
                                tableId: tableId,
                                recordId: rec.id,
                                fields: fields
                            });
                        }

                        if (dataRecords.length > 0 || fieldsToSave.length > 0) {
                            await saveBatch([], fieldsToSave, [], dataRecords);
                        }

                        totalRecords += dataRecords.length;

                        var recordsSoFar = Math.min(b + BATCH, records.length);
                        var progressPct = Math.round((_tablesCompleted / webhookTables.length) * 100);
                        updateLoadingOverlay('Downloading ' + tableName + '...', _tablesCompleted + ' of ' + webhookTables.length + ' tables done', progressPct, webhookTables.length, totalFields, totalRecords, recordsSoFar.toLocaleString() + ' of ' + records.length.toLocaleString() + ' records saved');
                    }
                }

                successfulTables++;
                _tablesCompleted++;
                var progressPct = Math.round((_tablesCompleted / webhookTables.length) * 100);
                console.log('[WebhookHydration] ' + tableName + ': ' + records.length + ' records');
                updateLoadingOverlay('Downloaded ' + tableName, _tablesCompleted + ' of ' + webhookTables.length + ' tables done', progressPct, webhookTables.length, totalFields, totalRecords, records.length.toLocaleString() + ' records ');
                if (typeof SyncBanner !== 'undefined') SyncBanner.updateProgress(progressPct, 'Downloading: ' + _tablesCompleted + '/' + webhookTables.length + ' tables (' + totalRecords.toLocaleString() + ' records)');

            } catch (recErr) {
                failedTables++;
                _tablesCompleted++;
                console.warn('[WebhookHydration] Failed to fetch records for ' + tableName + ':', recErr);
                SyncStatusFeed.error('Failed to fetch records for ' + tableName + ': ' + recErr.message);
            }
        }

        // Concurrency pool: run up to HYDRATION_CONCURRENCY tables at a time.
        // Each slot is independent  when one finishes, the next table fills it.
        var _tableIdx = 0;
        async function _hydrateSlot() {
            while (_tableIdx < webhookTables.length) {
                var myIdx = _tableIdx++;
                await _hydrateOneTable(webhookTables[myIdx]);
            }
        }
        var slots = [];
        for (var s = 0; s < Math.min(HYDRATION_CONCURRENCY, webhookTables.length); s++) {
            slots.push(_hydrateSlot());
        }
        await Promise.all(slots);

        updateLoadingOverlay('Sync complete', totalRecords.toLocaleString() + ' records downloaded', 100, webhookTables.length, totalFields, totalRecords, '');
        updateStatus('Webhook hydration complete: ' + totalRecords + ' records', true, 100, null);
        SyncStatusFeed.success('Webhook hydration complete: ' + totalRecords + ' records across ' + webhookTables.length + ' tables' + (failedTables > 0 ? ' (' + failedTables + ' tables failed)' : ''));

        SyncHistory.record({
            type: 'full',
            result: totalRecords > 0 ? 'success' : 'no-change',
            eventsFound: totalRecords,
            detail: 'Webhook hydration: ' + totalRecords + ' records from ' + webhookTables.length + ' tables' + (failedTables > 0 ? ' (' + failedTables + ' tables failed)' : '')
        });

        // Capture a Matrix sync token so SynapseSync doesn't do a full initial sync.
        // timeout=0 returns immediately with just the token.
        // timeline limit=0 means we don't download any events (we already have the data from Postgres).
        try {
            var tokenFilter = JSON.stringify({
                room: {
                    timeline: { limit: 0 },
                    state: { lazy_load_members: true }
                },
                presence: { types: [] }
            });
            var tokenRes = await fetch(
                SYNAPSE_HOMESERVER_URL + '/_matrix/client/v3/sync?timeout=0&filter=' +
                encodeURIComponent(tokenFilter),
                { headers: { 'Authorization': 'Bearer ' + session.accessToken } }
            );
            if (tokenRes.ok) {
                var tokenData = await tokenRes.json();
                if (tokenData.next_batch) {
                    SynapseSync.since = tokenData.next_batch;
                    await setSyncMeta('synapseSyncToken', tokenData.next_batch);
                    console.log('[WebhookHydration] Captured sync token:', tokenData.next_batch);
                }
            }
        } catch (e) {
            console.warn('[WebhookHydration] Failed to capture sync token (non-fatal):', e.message);
        }

        var nextCursor = _cursorIsoWithSafetyOverlap(maxCursorTimestamp);
        var success = successfulTables > 0;
        var partial = failedTables > 0;
        return {
            success: success,
            partial: partial,
            totalTables: webhookTables.length,
            successfulTables: successfulTables,
            failedTables: failedTables,
            totalRecords: totalRecords,
            nextCursor: nextCursor
        };
    } catch (err) {
        console.error('[WebhookHydration] Failed:', err);
        SyncStatusFeed.error('Webhook hydration failed: ' + err.message);
        return { success: false, partial: false, totalTables: 0, successfulTables: 0, failedTables: 0, totalRecords: 0, nextCursor: null };
    }
}

// Cached table list for webhookIncrementalSync  refreshed every 10 minutes
var _webhookTablesCache = null;
var _webhookTablesCacheTime = 0;
var WEBHOOK_TABLES_CACHE_TTL = 600000; // 10 minutes

// Incremental sync from webhooks  fetch records updated since last webhook sync
async function webhookIncrementalSync() {
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) return 0;

        // Get the last webhook sync timestamp
        var lastWebhookSync = null;
        try {
            lastWebhookSync = await getSyncMeta('lastWebhookSync');
        } catch (e) {}

        if (!lastWebhookSync) {
            // No previous webhook sync  do a full hydration instead
            return 0;
        }

        // Use cached table list if fresh enough (table list rarely changes)
        var tables;
        if (_webhookTablesCache && (Date.now() - _webhookTablesCacheTime) < WEBHOOK_TABLES_CACHE_TTL) {
            tables = _webhookTablesCache;
        } else {
            var tablesData = await webhookFetch('/amino-tables');
            tables = tablesData.tables || [];
            _webhookTablesCache = tables;
            _webhookTablesCacheTime = Date.now();
        }
        var totalUpdated = 0;
        var failedTableIds = [];
        var maxCursorTimestamp = new Date(lastWebhookSync).getTime() || 0;

        for (var i = 0; i < tables.length; i++) {
            var tableId = tables[i].table_id;
            try {
                var data = await webhookFetch(
                    '/amino-records-since?tableId=' + encodeURIComponent(tableId) +
                    '&since=' + encodeURIComponent(lastWebhookSync)
                );
                var records = data.records || [];
                if (records.length === 0) continue;

                var dataRecords = [];
                for (var r = 0; r < records.length; r++) {
                    var rec = records[r];
                    // Only sync actual records (rec*), skip schema metadata (fld*, viw*)
                    var recId = rec.id || '';
                    if (!recId.startsWith('rec')) continue;

                    var fields = rec.fields;
                    if (!fields) continue;
                    if (typeof fields === 'string') {
                        try { fields = JSON.parse(fields); } catch (e) { continue; }
                    }
                    if (typeof fields !== 'object' || Array.isArray(fields)) continue;
                    var cursorTs = _extractWebhookCursorTimestamp(rec);
                    if (cursorTs && cursorTs > maxCursorTimestamp) {
                        maxCursorTimestamp = cursorTs;
                    }
                    dataRecords.push({
                        tableId: tableId,
                        recordId: rec.id,
                        fields: fields
                    });
                }

                if (dataRecords.length > 0) {
                    await saveBatch([], [], [], dataRecords);
                    totalUpdated += dataRecords.length;
                }
            } catch (tableErr) {
                failedTableIds.push(tableId);
                console.warn('[WebhookSync] Failed to sync table ' + tableId + ':', tableErr);
                // Continue with remaining tables; isolate failures.
            }
        }

        // Update sync cursor using source-derived high-water mark
        var nextCursor = _cursorIsoWithSafetyOverlap(maxCursorTimestamp) || lastWebhookSync;
        await setSyncMeta('lastWebhookSync', nextCursor);

        if (failedTableIds.length > 0) {
            SyncStatusFeed.warn('Webhook incremental sync failed for ' + failedTableIds.length + ' table' + (failedTableIds.length !== 1 ? 's' : '') + ': ' + failedTableIds.join(', '));
        }

        if (totalUpdated > 0) {
            window.dispatchEvent(new CustomEvent('amino:record-updated', {
                detail: { source: 'webhook-poll', count: totalUpdated }
            }));
        }

        return totalUpdated;
    } catch (err) {
        console.error('[WebhookSync] Incremental sync failed:', err);
        return 0;
    }
}

// ============ Room Membership ============

// Populate SynapseSync tableroom mappings from the webhook API.
// The webhook API is the canonical source for tableroom associations
// (discoverTableRooms() relies on state events that may not exist in
// Room membership population removed  no longer needed since room-based sync is removed.
var _roomMembershipPopulated = false;
async function ensureRoomMembership() {
    _roomMembershipPopulated = true;
}

// ============ Deferred Network Init ============
// Runs non-critical network operations in the background after the UI is
// already visible and interactive. This avoids blocking the initial render
// on slow network calls (ensureRoomMembership, SharedViews, OrgSpace discovery).
var _deferredNetworkInitDone = false;
function _deferNetworkInit() {
    if (_deferredNetworkInitDone) return;
    _deferredNetworkInitDone = true;

    // Use setTimeout to avoid blocking the main thread during idle callbacks.
    // Previously used requestIdleCallback which caused 95ms+ violations because
    // async network calls (ensureRoomMembership, SharedViews) exceeded the idle deadline.
    setTimeout(function() {
        (async function() {
            // 1. Populate room mappings (ensureRoomMembership)
            try {
                await ensureRoomMembership();
            } catch (e) {
                console.warn('[DeferredInit] ensureRoomMembership failed:', e);
            }

            // 2. Initialize shared views module (requires network)
            try {
                if (MatrixClient.isLoggedIn()) {
                    var orgSpaceId = await MatrixClient.findOrgSpace();
                    if (orgSpaceId) {
                        SharedViews.setOrgSpaceId(orgSpaceId);
                        try {
                            AminoData.startViewDeletionSync(orgSpaceId);
                        } catch (vdsErr) {
                            console.warn('[DeferredInit] Failed to start view deletion sync:', vdsErr);
                        }
                    }
                }
                await SharedViews.load();
            } catch (e) {
                console.warn('[DeferredInit] Failed to load shared views:', e);
            }
        })();
    }, 100);
}

var _backgroundHydrationInFlight = null;
function _startBackgroundHydration() {
    if (_backgroundHydrationInFlight) return _backgroundHydrationInFlight;

    _backgroundHydrationInFlight = (async function() {
        var hydrated = false;
        var source = AminoHydration.getHydrationSource(); // default: 'postgres'
        SyncBanner.show('Downloading your data in the background...', { progress: 0 });
        console.log('[BackgroundHydration] Hydration source:', source);

        // Source: none  enable online-only mode, skip local hydration
        if (source === 'none') {
            console.log('[BackgroundHydration] No-local-data mode: enabling online-only');
            if (typeof AminoData !== 'undefined' && AminoData.setOnlineOnlyMode) {
                AminoData.setOnlineOnlyMode(true);
            }
            // Still hydrate from Postgres into memory for current state
            SyncBanner.updateProgress(10, 'Fetching current state...');
            SyncStatusFeed.info('No-local-data mode: fetching current state from Postgres...');
            updateLoadingOverlay('Loading from database...', 'Fetching current state (online-only)...', 0, 0, 0, 0, null);
            try {
                var webhookResult = await hydrateFromWebhooks();
                if (webhookResult && webhookResult.success) {
                    hydrated = true;
                    SyncStatusFeed.success('Online-only: loaded ' + (webhookResult.totalRecords || 0).toLocaleString() + ' records from Postgres');
                    console.log('[BackgroundHydration] Online-only Postgres hydration succeeded:', webhookResult.totalRecords, 'records');
                }
            } catch (pgErr) {
                console.warn('[BackgroundHydration] Online-only Postgres hydration failed:', pgErr.message || pgErr);
            }
        }

        // Source: csv  hydrate from a pending CSV file
        if (!hydrated && source === 'csv') {
            var csvFile = AminoHydration.getPendingCSVFile();
            if (csvFile) {
                SyncBanner.updateProgress(10, 'Parsing CSV file...');
                SyncStatusFeed.info('Hydrating from CSV file: ' + csvFile.name);
                updateLoadingOverlay('Loading from CSV...', 'Parsing ' + csvFile.name + '...', 0, 0, 0, 0, null);
                console.log('[BackgroundHydration] Hydrating from CSV file:', csvFile.name);
                try {
                    var csvText = await new Promise(function(resolve, reject) {
                        var reader = new FileReader();
                        reader.onload = function() { resolve(reader.result); };
                        reader.onerror = function() { reject(reader.error); };
                        reader.readAsText(csvFile);
                    });
                    var parsed = AminoHydration.parseCSVEvents(csvText);
                    if (parsed.events.length > 0) {
                        // Process events through the standard hydration pipeline
                        var state = AminoHydration.buildStateFromCSVEvents(parsed.events);
                        var tableIds = Object.keys(state.byTable);
                        var totalRecords = 0;
                        for (var ti = 0; ti < tableIds.length; ti++) {
                            var tblId = tableIds[ti];
                            var recordMap = state.byTable[tblId];
                            var recordIds = Object.keys(recordMap);
                            for (var ri = 0; ri < recordIds.length; ri++) {
                                var recId = recordIds[ri];
                                await saveRecord(tblId, recId, recordMap[recId]);
                                totalRecords++;
                            }
                        }
                        hydrated = true;
                        SyncStatusFeed.success('CSV hydrated: ' + totalRecords + ' records from ' + tableIds.length + ' tables');
                        SyncBanner.updateProgress(80, 'Processing CSV data...');
                        console.log('[BackgroundHydration] CSV hydration succeeded:', totalRecords, 'records');
                        await setSyncMeta('lastWebhookSync', new Date().toISOString());
                        try { localStorage.setItem('amino_hydration_complete', new Date().toISOString()); } catch(e) {}
                    }
                } catch (csvErr) {
                    console.warn('[BackgroundHydration] CSV hydration failed:', csvErr.message || csvErr);
                    SyncStatusFeed.error('CSV hydration failed: ' + csvErr.message);
                }
            } else {
                console.warn('[BackgroundHydration] CSV source selected but no file provided');
                SyncStatusFeed.warn('CSV source selected but no file was provided. Use Settings to select a file.');
            }
        }

        // Source: url  fetch from a URL
        if (!hydrated && source === 'url') {
            var hydrationUrl = AminoHydration.getHydrationURL();
            if (hydrationUrl) {
                SyncBanner.updateProgress(10, 'Fetching from URL...');
                SyncStatusFeed.info('Hydrating from URL: ' + hydrationUrl);
                updateLoadingOverlay('Loading from URL...', 'Fetching ' + hydrationUrl + '...', 0, 0, 0, 0, null);
                console.log('[BackgroundHydration] Hydrating from URL:', hydrationUrl);
                try {
                    var urlResponse = await fetch(hydrationUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json, text/csv, text/plain' }
                    });
                    if (!urlResponse.ok) throw new Error('HTTP ' + urlResponse.status);
                    var urlContentType = (urlResponse.headers.get('content-type') || '').toLowerCase();
                    var urlText = await urlResponse.text();

                    var isCSV = urlContentType.indexOf('csv') !== -1 || urlContentType.indexOf('text/plain') !== -1;
                    if (!isCSV) {
                        var firstCh = urlText.trim().charAt(0);
                        if (firstCh !== '[' && firstCh !== '{') isCSV = true;
                    }

                    if (isCSV) {
                        var urlParsed = AminoHydration.parseCSVEvents(urlText);
                        if (urlParsed.events.length > 0) {
                            var urlState = AminoHydration.buildStateFromCSVEvents(urlParsed.events);
                            var urlTableIds = Object.keys(urlState.byTable);
                            var urlTotalRecords = 0;
                            for (var uti = 0; uti < urlTableIds.length; uti++) {
                                var utId = urlTableIds[uti];
                                var uRecordMap = urlState.byTable[utId];
                                var uRecordIds = Object.keys(uRecordMap);
                                for (var uri = 0; uri < uRecordIds.length; uri++) {
                                    await saveRecord(utId, uRecordIds[uri], uRecordMap[uRecordIds[uri]]);
                                    urlTotalRecords++;
                                }
                            }
                            hydrated = true;
                            SyncStatusFeed.success('URL (CSV) hydrated: ' + urlTotalRecords + ' records');
                        }
                    } else {
                        // JSON path
                        var urlData = JSON.parse(urlText);
                        var urlRecords = [];
                        if (Array.isArray(urlData)) {
                            urlRecords = urlData;
                        } else if (urlData && Array.isArray(urlData.records)) {
                            urlRecords = urlData.records;
                        } else if (urlData && typeof urlData.tables === 'object') {
                            var tblKeys = Object.keys(urlData.tables);
                            for (var tk = 0; tk < tblKeys.length; tk++) {
                                var tblRecs = urlData.tables[tblKeys[tk]];
                                if (Array.isArray(tblRecs)) {
                                    for (var tr = 0; tr < tblRecs.length; tr++) {
                                        tblRecs[tr].tableId = tblRecs[tr].tableId || tblRecs[tr].table_id || tblKeys[tk];
                                        urlRecords.push(tblRecs[tr]);
                                    }
                                }
                            }
                        }
                        if (urlRecords.length > 0) {
                            for (var ur = 0; ur < urlRecords.length; ur++) {
                                var uRec = urlRecords[ur];
                                var uTblId = uRec.tableId || uRec.table_id || 'unknown';
                                var uRecIdVal = uRec.id || uRec.record_id || uRec.recordId;
                                if (uRecIdVal) {
                                    await saveRecord(uTblId, uRecIdVal, uRec.fields || uRec);
                                }
                            }
                            hydrated = true;
                            SyncStatusFeed.success('URL (JSON) hydrated: ' + urlRecords.length + ' records');
                        }
                    }

                    if (hydrated) {
                        console.log('[BackgroundHydration] URL hydration succeeded');
                        await setSyncMeta('lastWebhookSync', new Date().toISOString());
                        try { localStorage.setItem('amino_hydration_complete', new Date().toISOString()); } catch(e) {}
                    }
                } catch (urlErr) {
                    console.warn('[BackgroundHydration] URL hydration failed:', urlErr.message || urlErr);
                    SyncStatusFeed.error('URL hydration failed: ' + urlErr.message);
                }
            } else {
                console.warn('[BackgroundHydration] URL source selected but no URL provided');
                SyncStatusFeed.warn('URL source selected but no URL was provided. Use Settings to enter a URL.');
            }
        }

        // Source: box  Box AMO snapshot (bulk download)
        if (!hydrated && (source === 'box' || source === 'postgres')) {
            if (source === 'box') {
                SyncStatusFeed.info('Attempting Box snapshot hydration...');
                updateLoadingOverlay('Loading from Box...', 'Downloading hydration snapshot...', 0, 0, 0, 0, null);
                console.log('[BackgroundHydration] Attempting hydration via Box AMO snapshot');
                try {
                    var boxResult = await hydrateFromBoxAmoFile();
                    if (boxResult && boxResult.importedEvents > 0 && Object.keys(META_TABLES).length > 0) {
                        hydrated = true;
                        SyncStatusFeed.success('Box snapshot hydrated: ' + boxResult.importedEvents.toLocaleString() + ' events');
                        SyncBanner.updateProgress(80, 'Processing downloaded data...');
                        console.log('[BackgroundHydration] Box AMO hydration succeeded:', boxResult.importedEvents, 'events');
                        await setSyncMeta('lastWebhookSync', new Date().toISOString());
                        try { localStorage.setItem('amino_hydration_complete', new Date().toISOString()); } catch(e) {}
                    }
                } catch (boxErr) {
                    console.warn('[BackgroundHydration] Box AMO hydration failed:', boxErr.message || boxErr);
                }
            }
        }

        // Source: postgres (default)  or fallback from box/other failed sources
        if (!hydrated && source !== 'none') {
            SyncBanner.updateProgress(10, 'Downloading from database...');
            SyncStatusFeed.info('Hydrating from Postgres current_state webhook API...');
            updateLoadingOverlay('Loading from database...', 'Fetching from current_state webhooks...', 0, 0, 0, 0, null);
            console.log('[BackgroundHydration] Hydrating from Postgres webhook API (source: ' + source + ')');
            try {
                var webhookResult2 = await hydrateFromWebhooks();
                if (webhookResult2 && webhookResult2.success) {
                    hydrated = true;
                    SyncStatusFeed.success('Hydrated from Postgres current_state (' + (webhookResult2.totalRecords || 0).toLocaleString() + ' records)');
                    console.log('[BackgroundHydration] Postgres webhook hydration succeeded:', webhookResult2.totalRecords, 'records');
                    await setSyncMeta('lastWebhookSync', webhookResult2.nextCursor || new Date().toISOString());
                    try { localStorage.setItem('amino_hydration_complete', new Date().toISOString()); } catch(e) {}
                }
            } catch (pgErr) {
                console.warn('[BackgroundHydration] Postgres webhook hydration failed:', pgErr.message || pgErr);
            }
        }

        if (!hydrated && source !== 'none') {
            SyncStatusFeed.warn('All hydration sources unavailable. Use Settings  Refresh Database to retry.');
            SyncBanner.show('Data sync failed  use Settings to retry', { error: true });
            updateLoadingOverlay('Hydration failed', 'Use Settings  Refresh Database to retry', 0, 0, 0, 0, null);
            console.warn('[BackgroundHydration] All hydration sources failed.');
        }

        if (hydrated) {
            // Reload metadata after hydration  in parallel.
            // When Box AMO hydration populated IN_MEMORY_DATA, the IDB save is
            // still in-flight so IDB may not yet contain the Box data.  Merge
            // IDB metadata additively so we don't overwrite the in-memory state
            // that processEventsMemoryOnly already built.
            var reloadResults = await Promise.all([getAllTables(), getAllFields(), getAllViews()]);
            var tables = reloadResults[0];
            var fields = reloadResults[1];
            var views = reloadResults[2];

            var hasInMemoryData = window.IN_MEMORY_DATA && Object.keys(window.IN_MEMORY_DATA).length > 0;
            if (!hasInMemoryData) {
                // Non-Box path: IDB is the sole source, replace metadata
                META_TABLES = {};
                META_FIELDS = {};
                META_VIEWS = {};
            }
            // Merge IDB metadata (additive  preserves Box AMO entries)
            tables.forEach(t => META_TABLES[t.tableId] = META_TABLES[t.tableId] || t);
            fields.forEach(f => {
                if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
                META_FIELDS[f.tableId][f.fieldId] = META_FIELDS[f.tableId][f.fieldId] || f;
            });
            views.forEach(v => {
                if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
                META_VIEWS[v.tableId][v.viewId] = META_VIEWS[v.tableId][v.viewId] || v;
            });

            // Schedule edge rebuild after hydration (debounced)
            scheduleEdgeRebuild();

            // Refresh sidebar/table once hydration completes.
            await renderSidebar(true);
            if (currentTable) {
                // Table is already displayed  clear stale field metadata so
                // showTable re-reads from IDB with the freshly hydrated data,
                // then re-render the table to pick up new records.
                clearRecordCache();
                delete META_FIELDS[currentTable];
                await showTable(currentTable);
            } else {
                var firstTable = Object.keys(META_TABLES)[0];
                if (firstTable) {
                    await showTable(firstTable);
                }
            }

            // Notify Interface and other listeners that data has been hydrated
            // so they can refresh their views with the complete dataset.
            window.dispatchEvent(new CustomEvent('amino:sync', {
                detail: { source: 'hydration', tables: Object.keys(META_TABLES).length }
            }));

            // Backfill field history in background (do not block app access)
            try {
                updateLoadingOverlay('Backfilling history...', 'Reading Matrix room timelines...', 0, 0, 0, 0, null);
                await backfillHistoryFromMatrix();
            } catch (backfillErr) {
                console.warn('[init] History backfill failed (non-fatal):', backfillErr);
                SyncStatusFeed.warn('History backfill failed: ' + backfillErr.message);
            }

            updateStatus('Up to date', true, null, null);
            SyncBanner.hide();
        } else {
            updateStatus('No data available  waiting for sync', true, null, null);
            await renderSidebar(true);
        }
    })().finally(function() {
        _backgroundHydrationInFlight = null;
        // Ensure banner is hidden on completion (success path already hides it)
        if (SyncBanner._currentMode === 'syncing') SyncBanner.hide();
    });

    return _backgroundHydrationInFlight;
}

// ============ Hydration Source Picker ============
// Shows a modal on startup when hydration hasn't completed yet, letting the
// user choose how to load data. Defaults to postgres. Persisted in localStorage.

function showHydrationPicker() {
    var modal = document.getElementById('hydration-picker-modal');
    if (!modal) return Promise.resolve('postgres');

    return new Promise(function(resolve) {
        modal.style.display = 'flex';

        // Toggle CSV/URL sub-rows based on radio selection
        var radios = modal.querySelectorAll('input[name="hydration-source-pick"]');
        for (var i = 0; i < radios.length; i++) {
            radios[i].addEventListener('change', function() {
                var csvRow = document.getElementById('hydration-picker-csv-row');
                var urlRow = document.getElementById('hydration-picker-url-row');
                if (csvRow) csvRow.style.display = this.value === 'csv' ? 'block' : 'none';
                if (urlRow) urlRow.style.display = this.value === 'url' ? 'block' : 'none';
            });
        }

        window._hydrationPickerResolve = resolve;
    });
}

function confirmHydrationPicker() {
    var modal = document.getElementById('hydration-picker-modal');
    var selected = 'postgres';

    var radios = modal ? modal.querySelectorAll('input[name="hydration-source-pick"]') : [];
    for (var i = 0; i < radios.length; i++) {
        if (radios[i].checked) {
            selected = radios[i].value;
            break;
        }
    }

    // Persist the choice
    AminoHydration.setHydrationSource(selected);

    // Handle CSV file
    if (selected === 'csv') {
        var csvInput = document.getElementById('hydration-picker-csv');
        if (csvInput && csvInput.files && csvInput.files[0]) {
            AminoHydration.setPendingCSVFile(csvInput.files[0]);
        }
    }

    // Handle URL
    if (selected === 'url') {
        var urlInput = document.getElementById('hydration-picker-url');
        if (urlInput && urlInput.value) {
            AminoHydration.setHydrationURL(urlInput.value);
        }
    }

    // Handle no-local-data mode
    if (selected === 'none') {
        if (typeof AminoData !== 'undefined' && AminoData.setOnlineOnlyMode) {
            AminoData.setOnlineOnlyMode(true);
        }
    }

    // Hide modal
    if (modal) modal.style.display = 'none';

    // Resolve the promise
    if (window._hydrationPickerResolve) {
        window._hydrationPickerResolve(selected);
        window._hydrationPickerResolve = null;
    }
}

// Settings page handler for hydration source dropdown
function onHydrationSourceChanged(value) {
    AminoHydration.setHydrationSource(value);

    var csvRow = document.getElementById('settings-hydration-csv-row');
    var urlRow = document.getElementById('settings-hydration-url-row');
    var desc = document.getElementById('settings-hydration-source-desc');

    if (csvRow) csvRow.style.display = value === 'csv' ? 'block' : 'none';
    if (urlRow) urlRow.style.display = value === 'url' ? 'block' : 'none';

    var descriptions = {
        'postgres': 'Fetch current state table-by-table from the Postgres-backed webhook API.',
        'csv': 'Load data from a local CSV file with columns: id, created_at, recordId, operator, payload, uuid, set.',
        'box': 'Download a bulk AMO snapshot from the Box webhook.',
        'url': 'Fetch data from a URL (JSON array or CSV).',
        'none': 'No data stored locally. Postgres for current state, room data for historical. Online-only mode.'
    };
    if (desc) desc.textContent = descriptions[value] || '';

    // Enable/disable online-only based on 'none' selection
    if (value === 'none') {
        if (typeof AminoData !== 'undefined' && AminoData.setOnlineOnlyMode) {
            AminoData.setOnlineOnlyMode(true);
        }
        var toggle = document.getElementById('pref-online-only-mode');
        if (toggle) toggle.checked = true;
    }
}

// Initialize the settings hydration source dropdown on page load
function _initSettingsHydrationSource() {
    var dropdown = document.getElementById('settings-hydration-source');
    if (!dropdown) return;

    var current = AminoHydration.getHydrationSource();
    dropdown.value = current;
    onHydrationSourceChanged(current);

    // Populate URL field if saved
    var urlInput = document.getElementById('settings-hydration-url');
    if (urlInput) {
        urlInput.value = AminoHydration.getHydrationURL();
    }
}

// ============ Session Render Cache (OPTIMIZATION 4) ============
// Snapshots the first table's first page of decrypted records + metadata into
// sessionStorage so on page refresh we can render the table grid instantly
// without waiting for IDB reads + AES-GCM decryption of each record.
// sessionStorage survives refresh but is cleared on tab close (privacy-safe).

var _SESSION_RENDER_CACHE_KEY = 'amino_render_cache';
var _SESSION_RENDER_CACHE_MAX_RECORDS = 100; // PAGE_SIZE

function _saveRenderCacheToSession(tableId, records, recordIds) {
    try {
        var cache = {
            tableId: tableId,
            recordIds: recordIds.slice(0, _SESSION_RENDER_CACHE_MAX_RECORDS),
            records: {},
            tables: META_TABLES,
            fields: META_FIELDS[tableId] || {},
            views: META_VIEWS[tableId] || {},
            ts: Date.now()
        };
        // Only cache the first page of decrypted record data
        var pageIds = cache.recordIds;
        for (var i = 0; i < pageIds.length; i++) {
            var rid = pageIds[i];
            // Try _recordCache first (already decrypted), then IN_MEMORY_DATA
            var ck = _rcKey(tableId, rid);
            var cached = _recordCache.get(ck);
            if (cached) {
                cache.records[rid] = cached.fields || {};
            } else if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][rid]) {
                cache.records[rid] = window.IN_MEMORY_DATA[tableId][rid];
            }
        }
        var json = JSON.stringify(cache);
        // sessionStorage quota is ~5MB; skip if too large
        if (json.length < 4 * 1024 * 1024) {
            sessionStorage.setItem(_SESSION_RENDER_CACHE_KEY, json);
        }
    } catch (e) {
        // Quota exceeded or serialization error  non-fatal
    }
}

function _loadRenderCacheFromSession() {
    try {
        var raw = sessionStorage.getItem(_SESSION_RENDER_CACHE_KEY);
        if (!raw) return null;
        var cache = JSON.parse(raw);
        // Expire after 10 minutes (stale data guard)
        if (!cache || !cache.ts || (Date.now() - cache.ts) > 600000) {
            sessionStorage.removeItem(_SESSION_RENDER_CACHE_KEY);
            return null;
        }
        return cache;
    } catch (e) {
        return null;
    }
}

// ============ Init ============

async function init() {
    META_TABLES = {};
    META_FIELDS = {};
    META_VIEWS = {};
    TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
    currentTable = null;
    currentPage = 0;
    currentRecordIds = [];
    originalRecordIds = [];
    totalRecords = 0;
    lastEventTimestamp = null;

    // Ensure loading overlay is visible during init  prevents blank screen
    // between auth/login screen dismissal and first content render.
    // Callers should have already shown it, but this is a safety net.
    var overlay = document.getElementById('loading-overlay');
    if (overlay && overlay.classList.contains('hidden')) {
        showLoadingOverlay();
        setLoadingOverlayMode('local-memory');
    }

    // Load sidebar state (pinned, recent, expanded sections)
    loadSidebarState();
    initSidebarSearch();

    // OPTIMIZATION 3: Use the DB connection started early in the startup IIFE
    // (runs in parallel with session verify + crypto key import). Falls back
    // to opening fresh if the early promise failed or wasn't set.
    db = (window._earlyDbPromise ? await window._earlyDbPromise : null) || await openDB();

    updateStatus('Loading local data...', false, null, null);

    // OPTIMIZATION 2: Check IDB for existing data FIRST before attempting
    // Box AMO hydration. If we already have tables+records from a previous
    // session, skip the blocking network fetch entirely and defer Box AMO
    // to a background refresh. This removes 0-45s from the critical path.
    var _boxHydrationSucceeded = false;
    var _boxHydrationDeferred = false;

    // Quick IDB metadata read to check if we have cached data
    var metaResults = await Promise.all([
        getAllTables(),
        getAllFields(),
        getAllViews(),
        loadTableSettings(),
        getMaxEventId()
    ]);
    var tables = metaResults[0];
    var fields = metaResults[1];
    var views = metaResults[2];
    appOpenedEventId = metaResults[4];

    // Check if IDB has enough data to skip Box AMO
    var _idbHasData = tables.length > 0;
    var _lsHydrationComplete = false;
    try { _lsHydrationComplete = !!localStorage.getItem('amino_hydration_complete'); } catch(e) {}

    if (_idbHasData && _lsHydrationComplete) {
        // IDB has tables and a previous hydration completed  use cached data,
        // defer Box AMO to background refresh after UI is visible.
        console.log('[init] IDB cache hit (' + tables.length + ' tables, hydration complete)  skipping blocking Box AMO');
        SyncStatusFeed.info('Using cached data  Box refresh deferred to background');
        _boxHydrationDeferred = true;
    } else {
        // No IDB data or incomplete hydration  need Box AMO synchronously
        try {
            console.log('[init] Attempting Tier 1 hydration via Box AMO snapshot');
            SyncStatusFeed.info('Attempting Box snapshot hydration...');
            // Switch loading overlay to full progress mode for the long download
            setLoadingOverlayMode('default');
            updateLoadingOverlay('Loading from Box...', 'Downloading hydration snapshot...', 0, 0, 0, 0, null);
            var boxResult = await hydrateFromBoxAmoFile();
            if (boxResult && boxResult.importedEvents > 0 && Object.keys(META_TABLES).length > 0) {
                _boxHydrationSucceeded = true;
                console.log('[init] Box AMO hydration succeeded:', boxResult.importedEvents, 'events across', Object.keys(META_TABLES).length, 'tables');
                SyncStatusFeed.success('Box snapshot hydrated: ' + boxResult.importedEvents.toLocaleString() + ' events');
                try { localStorage.setItem('amino_hydration_complete', new Date().toISOString()); } catch(e) {}
            }
        } catch (boxErr) {
            console.warn('[init] Box AMO hydration failed (will fall back to Postgres):', boxErr.message || boxErr);
            SyncStatusFeed.warn('Box snapshot unavailable  falling back to Postgres...');
        }

        // Re-read metadata in case Box hydration populated new tables
        if (_boxHydrationSucceeded) {
            var freshMeta = await Promise.all([getAllTables(), getAllFields(), getAllViews()]);
            tables = freshMeta[0];
            fields = freshMeta[1];
            views = freshMeta[2];
        }
    }

    // Merge IDB metadata into in-memory state.  When Box AMO hydration
    // succeeded, use additive merge (||) so the fresh snapshot data takes
    // precedence over potentially stale IDB entries.
    if (_boxHydrationSucceeded) {
        tables.forEach(t => META_TABLES[t.tableId] = META_TABLES[t.tableId] || t);
        fields.forEach(f => {
            if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
            META_FIELDS[f.tableId][f.fieldId] = META_FIELDS[f.tableId][f.fieldId] || f;
        });
        views.forEach(v => {
            if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
            META_VIEWS[v.tableId][v.viewId] = META_VIEWS[v.tableId][v.viewId] || v;
        });
    } else {
        tables.forEach(t => META_TABLES[t.tableId] = t);
        fields.forEach(f => {
            if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
            META_FIELDS[f.tableId][f.fieldId] = f;
        });
        views.forEach(v => {
            if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
            META_VIEWS[v.tableId][v.viewId] = v;
        });
    }

    // Build edges from field metadata on startup (debounced  may coalesce with hydration)
    scheduleEdgeRebuild();

    // Use in-memory META_TABLES as the authoritative table list. After Box
    // AMO hydration, processEventsMemoryOnly populates META_TABLES before
    // the background IDB save finishes, so the IDB read above may return
    // fewer tables than actually exist in memory.
    var tableCount = Object.keys(META_TABLES).length;

    // Load user preferences (local-only, fast)  don't await network-dependent prefs yet
    try {
        await UserPreferences.load();
        // Apply stored table settings from user preferences if they exist
        var storedTableSettings = UserPreferences.get('tableSettings');
        if (storedTableSettings && storedTableSettings.tables && Object.keys(storedTableSettings.tables).length > 0) {
            if (storedTableSettings.tables) TABLE_SETTINGS.tables = Object.assign(TABLE_SETTINGS.tables, storedTableSettings.tables);
            if (storedTableSettings.tableOrder && storedTableSettings.tableOrder.length > 0) TABLE_SETTINGS.tableOrder = storedTableSettings.tableOrder;
            if (storedTableSettings.views) TABLE_SETTINGS.views = Object.assign(TABLE_SETTINGS.views, storedTableSettings.views);
        }
    } catch (e) {
        console.warn('[init] Failed to load user preferences:', e);
    }

    hideAuthScreen();

    // Initialize online-only mode UI state from localStorage
    _initOnlineOnlyModeUI();

    // Check if records actually exist AND previous hydration completed fully.
    // After Box AMO hydration, records live in IN_MEMORY_DATA (IDB save is
    // still in flight), so check both IDB and memory.
    var hasRecords = false;
    var hydrationWasComplete = false;

    // Box hydration is considered complete for rendering purposes  we have
    // tables and records in memory and will catch up via room sync.
    if (_boxHydrationSucceeded && window.IN_MEMORY_DATA) {
        var inMemoryRecordCount = 0;
        var memTableIds = Object.keys(window.IN_MEMORY_DATA);
        for (var mt = 0; mt < memTableIds.length; mt++) {
            inMemoryRecordCount += Object.keys(window.IN_MEMORY_DATA[memTableIds[mt]]).length;
        }
        hasRecords = inMemoryRecordCount > 0;
        hydrationWasComplete = hasRecords;
    }

    // When Box was deferred (IDB cache hit), check IDB directly for records
    if (_boxHydrationDeferred) {
        hydrationWasComplete = _lsHydrationComplete;
    }

    if (!hasRecords && tableCount > 0) {
        try {
            var existenceResults = await Promise.all([
                getCurrentRecordsCount().catch(function() { return 0; }),
                getSyncMeta('lastWebhookSync').catch(function() { return null; })
            ]);
            hasRecords = existenceResults[0] > 0;
            // Check both IDB sync meta AND localStorage flag (localStorage is more
            // reliable since it persists synchronously even if IDB transactions were
            // still in-flight when the page was navigated away).
            var lsHydrationComplete = false;
            try { lsHydrationComplete = !!localStorage.getItem('amino_hydration_complete'); } catch(e) {}
            hydrationWasComplete = hasRecords && (!!existenceResults[1] || lsHydrationComplete);
        } catch (e) { /* treat as no records */ }
    }

    if (tableCount > 0 && hasRecords && hydrationWasComplete) {
        // Data exists (from local IDB cache or Box AMO hydration)  render it
        updateStatus('Found ' + tableCount + ' tables', false, null, 'Loading data...');

        // OPTIMIZATION 4: Restore first table's decrypted records from sessionStorage.
        // This pre-populates IN_MEMORY_DATA and the record cache so showTable() can
        // render the grid without waiting for IDB reads + AES-GCM decryption.
        var _renderCache = _loadRenderCacheFromSession();
        if (_renderCache && _renderCache.records && Object.keys(_renderCache.records).length > 0) {
            var cacheTableId = _renderCache.tableId;
            console.log('[init] Restoring render cache for table', cacheTableId, '(' + Object.keys(_renderCache.records).length + ' records)');
            // Populate IN_MEMORY_DATA so getRecordsByIds() finds immediate cache hits
            if (!window.IN_MEMORY_DATA) window.IN_MEMORY_DATA = {};
            if (!window.IN_MEMORY_DATA[cacheTableId]) window.IN_MEMORY_DATA[cacheTableId] = {};
            var cacheRecordIds = Object.keys(_renderCache.records);
            for (var cri = 0; cri < cacheRecordIds.length; cri++) {
                var crid = cacheRecordIds[cri];
                window.IN_MEMORY_DATA[cacheTableId][crid] = _renderCache.records[crid];
            }
            // Also pre-populate field metadata from cache if not already loaded
            if (_renderCache.fields && !META_FIELDS[cacheTableId]) {
                META_FIELDS[cacheTableId] = _renderCache.fields;
            }
            if (_renderCache.views && !META_VIEWS[cacheTableId]) {
                META_VIEWS[cacheTableId] = _renderCache.views;
            }
        }

        // Determine the first table early so we can pre-warm its record IDs
        // in parallel with the sidebar render (sidebar counts + first table data)
        var firstTable = (_renderCache && _renderCache.tableId && META_TABLES[_renderCache.tableId])
            ? _renderCache.tableId
            : Object.keys(META_TABLES)[0];
        var preWarmPromise = firstTable
            ? getRecordIdsForTable(firstTable).catch(function() { return []; })
            : Promise.resolve([]);

        // Render sidebar and pre-warm first table concurrently
        var sidebarAndWarm = await Promise.all([
            renderSidebar(true),
            preWarmPromise
        ]);
        var preWarmedRecordIds = sidebarAndWarm[1];

        // Pre-load first page of records into cache while we still have time
        if (firstTable && preWarmedRecordIds.length > 0) {
            var firstPageIds = preWarmedRecordIds.slice(0, PAGE_SIZE);
            // Fire-and-forget: warm the cache so showTable finds records already loaded
            getRecordsByIds(firstTable, firstPageIds).catch(function() {});
        }

        // Auto-select first table (will be faster since records are pre-cached)
        if (firstTable) {
            await showTable(firstTable);
        }

        // Local data loaded  dismiss loading overlay
        hideLoadingOverlay();

        // OPTIMIZATION 4: Snapshot first table's decrypted records to sessionStorage
        // so the next page refresh can render instantly without IDB reads + decryption.
        if (firstTable && preWarmedRecordIds && preWarmedRecordIds.length > 0) {
            // Defer to avoid blocking the main thread right after render
            setTimeout(function() {
                _saveRenderCacheToSession(firstTable, null, preWarmedRecordIds);
            }, 1000);
        }

        // After Box hydration: kick off room-data catch-up in the background
        // to apply any mutations that occurred after the AMO snapshot timestamp,
        // and to backfill field-level edit history from room timelines.
        if (_boxHydrationSucceeded) {
            (async function _boxCatchUp() {
                try {
                    await ensureRoomMembership();
                    await backfillHistoryFromMatrix();
                } catch (err) {
                    console.warn('[init] Post-Box room catch-up failed (non-fatal):', err);
                }
            })();
        }

        // OPTIMIZATION 2 (cont.): When Box AMO was deferred because we had
        // IDB cache, run it now in the background to freshen the local data.
        // This catches up any changes since the last session without blocking startup.
        if (_boxHydrationDeferred) {
            (async function _deferredBoxRefresh() {
                try {
                    console.log('[init] Running deferred Box AMO refresh in background');
                    var boxResult = await hydrateFromBoxAmoFile();
                    if (boxResult && boxResult.importedEvents > 0) {
                        console.log('[init] Deferred Box refresh completed:', boxResult.importedEvents, 'events');
                        SyncStatusFeed.success('Background refresh: ' + boxResult.importedEvents.toLocaleString() + ' events');
                        try { localStorage.setItem('amino_hydration_complete', new Date().toISOString()); } catch(e) {}
                    }
                    await ensureRoomMembership();
                    await backfillHistoryFromMatrix();
                } catch (err) {
                    console.warn('[init] Deferred Box refresh failed (non-fatal):', err);
                }
            })();
        }

        // Defer non-critical network operations to AFTER the UI is visible.
        // These run in the background and don't block the user from interacting.
        _deferNetworkInit();
    } else {
        // Missing tables, records, or previous hydration was incomplete 
        // need hydration (retry on every load until it fully succeeds so
        // transient API failures don't strand the user with partial data).
        if (tableCount > 0 && hasRecords) {
            console.log('[init] Tables and records exist but hydration was incomplete  retrying');
            SyncStatusFeed.info('Previous hydration incomplete  retrying...');
            // Render table sidebar immediately for better UX while hydrating
            await renderSidebar(true);
        } else if (tableCount > 0) {
            console.log('[init] Tables exist but no records  retrying hydration');
            SyncStatusFeed.info('Records missing  retrying hydration...');
            // Render table sidebar immediately for better UX while hydrating
            await renderSidebar(true);
        }

        // Prioritize app access: enter UI immediately, run room/data hydration in background.
        hideLoadingOverlay();
        updateStatus('Syncing data in background...', false, null, null);

        // Show the hydration source picker if this is the first hydration
        // (no prior successful hydration in localStorage). Otherwise use the
        // persisted source preference (default: postgres).
        var hasHydratedBefore = false;
        try { hasHydratedBefore = !!localStorage.getItem('amino_hydration_complete'); } catch(e) {}

        if (!hasHydratedBefore) {
            // First time  show picker, then start hydration with chosen source
            showHydrationPicker().then(function(chosenSource) {
                console.log('[init] User chose hydration source:', chosenSource);
                _startBackgroundHydration().catch(function(err) {
                    console.warn('[init] Background hydration failed:', err);
                });
            });
        } else {
            // Returning user  use persisted source (default: postgres)
            _startBackgroundHydration().catch(function(err) {
                console.warn('[init] Background hydration failed:', err);
            });
        }

        // Defer non-critical network operations for the hydration path too
        _deferNetworkInit();
    }

    updateStatus('Up to date', true, null, null);

    // Initialize UI badges and settings
    OfflineBadgeUI.refresh();
    _initSettingsHydrationSource();
    if (!navigator.onLine) SyncIndicatorUI.setState('offline');

    // Start the refresh indicator countdown
    lastSyncTime = Date.now();
    startRefreshCountdown();

    // Start Synapse real-time sync (long-poll /sync for room events)
    SynapseSync.start();

    // Poll Postgres for changes via webhookIncrementalSync.
    // This catches external Airtable edits faster than waiting for SynapseSync
    // to pick up the n8n-written Matrix events (up to 30-minute n8n poll gap).
    // Polls every 5 minutes (safety-net role), pauses when tab is hidden,
    // and skips if SynapseSync recently delivered data.
    var WEBHOOK_POLL_INTERVAL = 300000; // 5 minutes
    var _webhookPollTimer = null;

    function _scheduleWebhookPoll() {
        if (_webhookPollTimer) clearTimeout(_webhookPollTimer);
        _webhookPollTimer = setTimeout(async function _webhookPollTick() {
            _webhookPollTimer = null;
            // Skip if tab is hidden  will resume on visibilitychange
            if (document.hidden) return;
            // Skip if SynapseSync delivered data in the last 4 minutes
            // (the real-time sync is already keeping us current)
            if (SynapseSync._lastEventTime && (Date.now() - SynapseSync._lastEventTime) < 240000) {
                console.log('[IncrementalSync] Skipping  SynapseSync active recently');
                _scheduleWebhookPoll();
                return;
            }
            try {
                await webhookIncrementalSync();
            } catch (e) {
                console.warn('[IncrementalSync] Poll failed:', e.message);
            }
            _scheduleWebhookPoll();
        }, WEBHOOK_POLL_INTERVAL);
    }

    _scheduleWebhookPoll();

    // Pause/resume webhook polling on tab visibility changes
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            // Tab hidden  cancel pending poll
            if (_webhookPollTimer) {
                clearTimeout(_webhookPollTimer);
                _webhookPollTimer = null;
            }
        } else {
            // Tab visible again  schedule next poll (won't fire immediately;
            // the auto-sync on tab refocus already handles the immediate case)
            if (!_webhookPollTimer) {
                _scheduleWebhookPoll();
            }
        }
    });

    // Start periodic client-side .amo snapshot uploads for future hydrations.
    startBoxAmoSnapshotUploads();

    // Drain any offline-queued edits from a previous session
    try {
        var queuedCount = await OfflineSyncQueue.getCount();
        if (queuedCount > 0 && navigator.onLine) {
            SyncStatusFeed.info('Found ' + queuedCount + ' queued edit' + (queuedCount !== 1 ? 's' : '') + ' from previous session  retrying');
            OfflineSyncQueue.drain();
        } else if (queuedCount > 0) {
            SyncStatusFeed.warn(queuedCount + ' edit' + (queuedCount !== 1 ? 's' : '') + ' queued offline  will sync when connection returns');
        }
    } catch (e) {
        console.warn('[init] Failed to check offline queue:', e);
    }
}

// ============ Field History Modal ============

var currentHistoryData = [];
var currentHistoryRecordId = null;
var currentHistoryTableId = null;

async function openHistoryModal(tableId, recordId) {
    currentHistoryTableId = tableId;
    currentHistoryRecordId = recordId;

    // Set modal title
    var tableName = resolveTableName(tableId);
    document.getElementById('history-modal-title').textContent = 'Field History - ' + tableName;

    // Show modal with loading state
    var overlay = document.getElementById('history-modal-overlay');
    var body = document.getElementById('history-modal-body');
    body.innerHTML = '<div class="modal-empty"><div class="loading-spinner"></div><h3>Loading history...</h3></div>';
    overlay.classList.add('open');

    // Fetch history data
    try {
        // Check for local events first (in-memory from CSV import, or IndexedDB events store)
        var rawEvents = await getRawEventsByRecordId(recordId);
        if (rawEvents && rawEvents.length > 0) {
            currentHistoryData = buildFieldHistoryFromRawEvents(tableId, recordId, rawEvents);
        } else {
            // Fetch on-demand from Postgres events API (activity stream)
            currentHistoryData = await fetchHistoryFromPostgresEvents(tableId, recordId);
        }
        renderHistoryModal();
    } catch (err) {
        console.error('Error loading history:', err);
        body.innerHTML = '<div class="modal-empty"><h3>Error loading history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closeHistoryModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('history-modal-overlay').classList.remove('open');
    currentHistoryData = [];
    currentHistoryRecordId = null;
    currentHistoryTableId = null;
}

function renderHistoryModal() {
    var body = document.getElementById('history-modal-body');
    var filterSelect = document.getElementById('history-field-filter');
    var countEl = document.getElementById('history-count');

    if (!currentHistoryData || currentHistoryData.length === 0) {
        body.innerHTML = '<div class="modal-empty"><h3>No history available</h3><p>Field changes will appear here after the next sync</p></div>';
        filterSelect.innerHTML = '<option value="">All Fields</option>';
        countEl.textContent = '0 changes';
        return;
    }

    // Build field filter options
    var fieldIds = [...new Set(currentHistoryData.map(h => h.fieldId))];
    var fields = META_FIELDS[currentHistoryTableId] || {};

    var filterHtml = '<option value="">All Fields</option>';
    fieldIds.forEach(fid => {
        var fieldName = fields[fid]?.fieldName || fid;
        filterHtml += '<option value="' + esc(fid) + '">' + esc(fieldName) + '</option>';
    });
    filterSelect.innerHTML = filterHtml;

    // Get selected filter
    var selectedField = filterSelect.value;
    var filteredData = selectedField
        ? currentHistoryData.filter(h => h.fieldId === selectedField)
        : currentHistoryData;

    countEl.textContent = filteredData.length + ' change' + (filteredData.length !== 1 ? 's' : '');

    // Render history items
    var html = '<div class="history-timeline">';

    for (var item of filteredData) {
        var fieldName = getHistoryFieldName(currentHistoryTableId, item.fieldId);
        var changeTypeClass = item.changeType || 'updated';
        var _histTs = item.timestamp || item.sourceTimestamp || null;
        var timestamp = _histTs ? formatTimestamp(_histTs) : 'Unknown time';
        var histActor = item.actor || null;
        var histDevice = item.device || null;
        var histSource = item.source || null;

        html += '<div class="history-item">';
        html += '<div class="history-item-header">';
        html += '<span class="history-field-name">' + esc(fieldName) + '</span>';
        html += '<span class="history-change-type ' + changeTypeClass + '">' + changeTypeClass + '</span>';
        if (histActor) {
            html += '<span class="history-actor">' + esc(histActor) + '</span>';
        }
        if (histDevice) {
            html += '<span class="history-device">' + esc(histDevice) + '</span>';
        }
        if (histSource) {
            html += '<span class="history-source">' + esc(histSource.replace(/_/g, ' ')) + '</span>';
        }
        html += '<span class="history-timestamp">' + esc(timestamp) + '</span>';
        html += '<span class="history-event-id">Event #' + (item.eventId || '?') + '</span>';
        html += '</div>';

        html += '<div class="history-values">';

        // Old value
        if (item.changeType !== 'created') {
            html += '<div class="history-value-box ' + (item.oldValue === null ? 'null' : 'old') + '">';
            html += '<div class="history-value-label">Previous</div>';
            html += '<div class="history-value-content">' + formatHistoryValue(item.oldValue) + '</div>';
            html += '</div>';
            html += '<span class="history-arrow">&#8594;</span>';
        }

        // New value
        html += '<div class="history-value-box ' + (item.newValue === null ? 'null' : 'new') + '">';
        html += '<div class="history-value-label">' + (item.changeType === 'created' ? 'Initial Value' : 'New Value') + '</div>';
        html += '<div class="history-value-content">' + formatHistoryValue(item.newValue) + '</div>';
        html += '</div>';

        html += '</div>'; // .history-values

        // Revert button
        var revertValue = JSON.stringify(item.newValue);
        html += '<div class="history-item-actions">';
        html += '<button class="history-revert-btn" onclick="this.disabled=true;this.textContent=\'Reverting...\';revertFieldToHistoryState(';
        html += '\'' + esc(item.tableId) + '\',';
        html += '\'' + esc(item.recordId) + '\',';
        html += '\'' + esc(item.fieldId) + '\',';
        html += 'JSON.parse(decodeURIComponent(\'' + encodeURIComponent(revertValue) + '\'))';
        html += ')" title="Revert this field to this value">';
        html += '<svg viewBox="0 0 16 16" fill="none"><path d="M2 8a6 6 0 1 1 1.76 4.24" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M2 12V8h4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        html += 'Revert to this state';
        html += '</button>';
        html += '</div>';

        html += '</div>'; // .history-item
    }

    html += '</div>';
    body.innerHTML = html;
}

function filterHistoryByField() {
    renderHistoryModal();
}

async function revertFieldToHistoryState(tableId, recordId, fieldId, targetValue) {
    // Resolve the field key used in the record (fieldId or fieldName)
    var field = META_FIELDS[tableId]?.[fieldId];
    var fieldKey = fieldId;
    var recordData = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId])
        ? window.IN_MEMORY_DATA[tableId][recordId]
        : null;
    if (!recordData) {
        var rec = await getRecord(tableId, recordId);
        recordData = rec ? rec.fields : null;
    }
    if (recordData && recordData[fieldId] === undefined && field?.fieldName && recordData[field.fieldName] !== undefined) {
        fieldKey = field.fieldName;
    }

    // Get the current value before reverting (for history tracking)
    var currentValue = recordData ? (recordData[fieldKey] !== undefined ? recordData[fieldKey] : null) : null;

    // Build field changes
    var revertChanges = {};
    revertChanges[fieldKey] = targetValue !== undefined ? targetValue : null;

    try {
        await editRecord(tableId, recordId, revertChanges);

        // Refresh the history modal  fetch on-demand from Postgres events API
        currentHistoryData = await fetchHistoryFromPostgresEvents(tableId, recordId);
        renderHistoryModal();
    } catch (err) {
        console.error('[Revert] Failed to revert field:', err);
        // editRecord already handles rollback and error toast
    }
}

function formatTimestamp(ts) {
    if (!ts) return 'Unknown';
    var date = new Date(ts);
    var now = new Date();
    var diff = now - date;

    // If less than 24 hours, show relative time
    if (diff < 86400000) {
        if (diff < 60000) return 'Just now';
        if (diff < 3600000) return Math.floor(diff / 60000) + ' min ago';
        return Math.floor(diff / 3600000) + ' hour' + (Math.floor(diff / 3600000) !== 1 ? 's' : '') + ' ago';
    }

    // Otherwise show date and time
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatHistoryValue(value) {
    if (value === null || value === undefined) {
        return '<span style="color: #999; font-style: italic;">empty</span>';
    }

    if (Array.isArray(value)) {
        if (value.length === 0) return '<span style="color: #999; font-style: italic;">empty array</span>';

        // Check if it's an array of objects
        if (typeof value[0] === 'object' && value[0] !== null) {
            var items = value.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return items.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(i) + '</span>').join('');
        }

        return value.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(String(i)) + '</span>').join('');
    }

    if (typeof value === 'object') {
        if (value.name) return esc(value.name);
        if (value.filename) return esc(value.filename);
        if (value.email) return esc(value.email);
        return esc(JSON.stringify(value).slice(0, 100));
    }

    if (typeof value === 'boolean') {
        return '<span style="padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; ' +
            (value ? 'background: #d4edda; color: #155724;' : 'background: #f8d7da; color: #721c24;') + '">' +
            (value ? 'Yes' : 'No') + '</span>';
    }

    if (typeof value === 'number') {
        return '<span style="font-family: monospace;">' + value.toLocaleString() + '</span>';
    }

    return esc(String(value));
}

// Keyboard handler for modal
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        var overlay = document.getElementById('history-modal-overlay');
        if (overlay && overlay.classList.contains('open')) {
            closeHistoryModal();
        }
        // Also close PIT modal
        var pitOverlay = document.getElementById('pit-modal-overlay');
        if (pitOverlay && pitOverlay.classList.contains('open')) {
            closePitModal();
        }
        // Also close view selector and fields dropdown
        closeAllDropdowns();
    }
});

// ============ Events View ============

async function showEventsView() {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Open tab for events
    openTableInTab('_events', 'Events Stream', '\u26A1');

    // Clean up sync status listener
    if (syncStatusUnsubscribe) { syncStatusUnsubscribe(); syncStatusUnsubscribe = null; }

    currentTable = '_events';
    currentView = null;

    // Update sidebar selection
    document.querySelectorAll('.sidebar .table-item').forEach(el => el.classList.remove('active', 'expanded'));
    document.querySelectorAll('.sidebar .table-view-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.sidebar .table-item.events-item')?.classList.add('active');

    // Hide view controls and show events view
    document.getElementById('view-controls-bar').style.display = 'none';
    document.getElementById('title').textContent = 'Events Stream';
    document.getElementById('pagination').style.display = 'none';

    // Hide toolbar views section for events view
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = 'none';

    await renderEventsView();
    // Navigation guard check after async work (renderEventsView handles its own loading state)
}

async function renderEventsView() {
    var container = document.querySelector('.table-container');

    if (eventsActiveTab !== 'room-access') stopRoomAccessRefresh();

    // Clean up previous scroll handlers
    if (eventsScrollHandler) {
        container.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }
    if (changelogScrollHandler) {
        container.removeEventListener('scroll', changelogScrollHandler);
        changelogScrollHandler = null;
    }

    // Build tab bar + content shell
    var tabBarHtml = '<div class="events-tab-bar">';
    tabBarHtml += '<div class="events-tab' + (eventsActiveTab === 'events' ? ' active' : '') + '" onclick="switchEventsTab(\'events\')">Events</div>';
    tabBarHtml += '<div class="events-tab' + (eventsActiveTab === 'changelog' ? ' active' : '') + '" onclick="switchEventsTab(\'changelog\')">Changelog</div>';
    tabBarHtml += '<div class="events-tab' + (eventsActiveTab === 'room-access' ? ' active' : '') + '" onclick="switchEventsTab(\'room-access\')">Room Access</div>';
    tabBarHtml += '</div>';
    tabBarHtml += '<div id="events-tab-content" style="flex:1; overflow-y: auto; display: flex; flex-direction: column;"></div>';
    container.innerHTML = tabBarHtml;

    // Render the active tab's content
    if (eventsActiveTab === 'changelog') {
        await renderChangelogContent();
    } else if (eventsActiveTab === 'room-access') {
        await renderRoomAccessContent();
    } else {
        await renderEventsContent();
    }
}

function switchEventsTab(tab) {
    if (eventsActiveTab === tab) return;
    eventsActiveTab = tab;
    renderEventsView();
}

function stopRoomAccessRefresh() {
    if (roomAccessRefreshTimer) {
        clearTimeout(roomAccessRefreshTimer);
        roomAccessRefreshTimer = null;
    }
}

function scheduleRoomAccessRefresh() {
    stopRoomAccessRefresh();
    roomAccessRefreshTimer = setTimeout(async function() {
        if (eventsActiveTab !== 'room-access') return;
        await refreshRoomAccessSnapshot({ preserveSelection: true });
        scheduleRoomAccessRefresh();
    }, ROOM_ACCESS_REFRESH_MS);
}

function getRoomAccessTableMap() {
    if (typeof SynapseSync !== 'undefined' && SynapseSync && typeof SynapseSync.getRoomTableMap === 'function') {
        return SynapseSync.getRoomTableMap() || {};
    }
    if (typeof _getRoomTableMap === 'function') {
        return _getRoomTableMap() || {};
    }
    return {};
}

async function refreshRoomAccessSnapshot(opts) {
    opts = opts || {};
    if (roomAccessRefreshInFlight) return;
    roomAccessRefreshInFlight = true;
    try {
        var roomIds = MatrixClient.getJoinedRooms();
        var roomTableMap = getRoomAccessTableMap();
        var nextSnapshot = [];

        for (var i = 0; i < roomIds.length; i++) {
            var roomId = roomIds[i];
            var state = MatrixClient.getRoomStateFromCache(roomId) || {};
            var stateValues = Object.values(state);
            var tableId = roomTableMap[roomId] || null;
            var tableName = tableId ? resolveTableName(tableId) : null;

            var latestEvents = [];
            try {
                var msgRes = await MatrixClient.getRoomMessages(roomId, { dir: 'b', limit: 5 });
                latestEvents = (msgRes && msgRes.chunk) ? msgRes.chunk : [];
            } catch (err) {
                latestEvents = [{ type: 'error', content: { message: err.message || 'Unable to fetch room timeline' } }];
            }

            nextSnapshot.push({
                roomId: roomId,
                roomName: MatrixClient.getRoomName(roomId) || roomId,
                tableId: tableId,
                tableName: tableName,
                isSpace: MatrixClient.isSpace(roomId),
                stateCount: stateValues.length,
                timelinePreview: latestEvents
            });
        }

        nextSnapshot.sort(function(a, b) {
            return (a.roomName || '').localeCompare(b.roomName || '');
        });
        roomAccessSnapshot = nextSnapshot;

        if (eventsActiveTab === 'room-access') {
            renderRoomAccessSnapshot(opts.preserveSelection);
        }
    } finally {
        roomAccessRefreshInFlight = false;
    }
}

function renderRoomTimelinePreview(ev) {
    if (!ev) return '<div class="room-access-preview-item">(empty)</div>';
    var type = ev.type || 'unknown';
    var sender = ev.sender || 'unknown';
    var ts = ev.origin_server_ts ? formatTimestamp(ev.origin_server_ts) : 'unknown time';
    var summary = '';

    if (type === 'law.firm.schema.object' && ev.content) {
        var c = ev.content;
        summary = (c.tableId || '?') + '  ' + (c.recordId || '?') + '  ' + (c.op || 'ALT');
    } else if (type === 'm.room.message' && ev.content) {
        summary = (ev.content.body || '').slice(0, 120);
    } else if (type === 'error' && ev.content) {
        summary = ev.content.message || 'error';
    } else {
        summary = JSON.stringify(ev.content || {}).slice(0, 140);
    }

    return '<div class="room-access-preview-item"><strong>' + esc(type) + '</strong>  ' + esc(sender) + '<br><span style="color:var(--text-muted)">' + esc(ts) + '</span><br>' + esc(summary) + '</div>';
}

function renderRoomAccessSnapshot(preserveSelection) {
    var container = document.getElementById('events-tab-content');
    if (!container) return;

    var connected = MatrixClient.isLoggedIn();
    var html = '<div class="room-access-layout">';
    html += '<div class="room-access-header">';
    html += '<div><h3 style="margin:0; font-size:16px;">Matrix Rooms + Live Data</h3><div class="room-access-meta">Auto-refreshes every ' + Math.round(ROOM_ACCESS_REFRESH_MS / 1000) + 's while this tab is active.</div></div>';
    html += '<div class="events-actions">';
    html += '<button class="btn" onclick="refreshRoomAccessSnapshot()">Refresh now</button>';
    html += '</div></div>';

    if (!connected) {
        html += '<div class="changelog-empty"><h3>Not connected</h3><p>Sign in with Synapse to inspect rooms and incoming timeline data.</p></div>';
        html += '</div>';
        container.innerHTML = html;
        return;
    }

    html += '<div class="room-access-meta">Showing ' + roomAccessSnapshot.length.toLocaleString() + ' accessible room' + (roomAccessSnapshot.length === 1 ? '' : 's') + '.</div>';
    html += '<div class="room-access-grid">';

    for (var i = 0; i < roomAccessSnapshot.length; i++) {
        var room = roomAccessSnapshot[i];
        html += '<div class="room-access-card">';
        html += '<div class="room-access-title"><div><div class="room-access-name">' + esc(room.roomName) + '</div><div class="room-access-id">' + esc(room.roomId) + '</div></div>';
        html += '<div class="room-access-badges">';
        if (room.isSpace) html += '<span class="room-access-badge space">Space</span>';
        if (room.tableId) html += '<span class="room-access-badge table">Table</span>';
        html += '<span class="room-access-badge timeline">Live</span>';
        html += '</div></div>';

        html += '<div class="room-access-summary">';
        html += '<div class="label">Table</div><div class="value">' + esc(room.tableId ? resolveTableName(room.tableId) : (room.tableName || '')) + '</div>';
        html += '<div class="label">State events</div><div class="value">' + room.stateCount.toLocaleString() + '</div>';
        html += '</div>';

        html += '<div class="room-access-preview"><h4>Recent timeline events</h4>';
        if (!room.timelinePreview || room.timelinePreview.length === 0) {
            html += '<div class="room-access-preview-item">No recent timeline events.</div>';
        } else {
            for (var t = 0; t < room.timelinePreview.length; t++) {
                html += renderRoomTimelinePreview(room.timelinePreview[t]);
            }
        }
        html += '</div>';
        html += '</div>';
    }

    html += '</div></div>';
    container.innerHTML = html;
}

async function renderRoomAccessContent() {
    var container = document.getElementById('events-tab-content');
    if (!container) return;

    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading accessible rooms...</h3></div>';
    stopRoomAccessRefresh();
    await refreshRoomAccessSnapshot();
    scheduleRoomAccessRefresh();
}

async function renderEventsContent() {
    var container = document.getElementById('events-tab-content');
    if (!container) return;
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading events...</h3></div>';

    // Reset infinite scroll state
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;

    try {
        var totalEventsCount = await getRawEventsCount();
        var totalRecordsCount = await getCurrentRecordsCount();

        // Load initial batch of events
        var events = await fetchEventsForInfiniteScroll(eventsOffset, eventsPageSize);
        loadedEvents = events;
        eventsOffset = events.length;
        hasMoreEvents = events.length === eventsPageSize;

        // Count new events (events with ID > appOpenedEventId)
        var newEventsCount = events.filter(e => e.id > appOpenedEventId).length;
        await prefetchEventRecordLabels(events);

        var html = '';

        // Events controls bar
        html += '<div class="events-controls">';
        html += '<div class="events-filter-group">';
        html += '<label>Type:</label>';
        html += '<select onchange="setEventsTypeFilter(this.value)">';
        html += '<option value=""' + (!eventsTypeFilter ? ' selected' : '') + '>All Events</option>';
        html += '<option value="current"' + (eventsTypeFilter === 'current' ? ' selected' : '') + '>All Records (' + ENTITY_TYPE_NAMES['current'] + ')</option>';
        ['INS', 'ALT', 'NUL', 'SYN', 'table', 'field', 'view', 'viewConfig'].forEach(function(t) {
            html += '<option value="' + t + '"' + (eventsTypeFilter === t ? ' selected' : '') + '>' + ENTITY_TYPE_NAMES[t] + '</option>';
        });
        html += '</select>';
        html += '</div>';

        html += '<div class="events-filter-group">';
        html += '<label>Table:</label>';
        html += '<select onchange="setEventsSetFilter(this.value)">';
        html += '<option value="">All Tables</option>';
        for (var tid in META_TABLES) {
            var tableName = resolveTableName(tid);
            var setVal = 'airtable:' + tid;
            html += '<option value="' + esc(setVal) + '"' + (eventsSetFilter === setVal ? ' selected' : '') + '>' + esc(tableName) + '</option>';
        }
        html += '</select>';
        html += '</div>';

        html += '<div class="events-filter-group">';
        html += '<label>Search:</label>';
        html += '<input type="text" placeholder="Search events..." value="' + esc(eventsSearchQuery) + '" onkeydown="if(event.key===\'Enter\')setEventsSearch(this.value)">';
        html += '</div>';

        // Show loaded count and total
        html += '<div class="events-stats" id="events-stats">';
        if (eventsTypeFilter === 'current') {
            html += 'Loaded ' + loadedEvents.length.toLocaleString();
            html += ' <span style="color: #666;">(' + totalRecordsCount.toLocaleString() + ' total records)</span>';
        } else {
            html += 'Loaded ' + loadedEvents.length.toLocaleString();
            html += ' <span style="color: #666;">(' + totalEventsCount.toLocaleString() + ' total events)</span>';
            if (newEventsCount > 0) {
                html += ' <span class="new-event-badge">' + newEventsCount + ' new</span>';
            }
        }
        html += '</div>';

        // Import/Export buttons
        html += '<div class="events-actions">';
        html += '<button class="btn" onclick="exportEventsToCSV()" title="Export events to CSV">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>';
        html += ' Export CSV';
        html += '</button>';
        html += '<button class="btn" onclick="exportEventsToAmo()" title="Export all events as .amo snapshot file">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>';
        html += ' Export .amo';
        html += '</button>';
        html += '<button class="btn" onclick="importEventsFromCSV()" title="Import events from CSV (deduplicates by ID)">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>';
        html += ' Import CSV';
        html += '</button>';
        html += '</div>';

        html += '</div>';

        // Events table
        html += '<table class="events-table">';
        html += '<thead><tr>';
        html += '<th style="width: 190px;">Record</th>';
        html += '<th style="width: 140px;">Timestamp</th>';
        html += '<th style="width: 90px;">Type</th>';
        html += '<th style="width: 140px;">Set</th>';
        html += '<th style="width: 260px;">Details</th>';
        html += '<th>Payload</th>';
        html += '<th style="width: 140px;">Actions</th>';
        html += '</tr></thead>';
        html += '<tbody id="events-tbody">';

        if (events.length === 0) {
            html += '<tr><td colspan="7" style="text-align: center; padding: 40px; color: #666;">No events found</td></tr>';
        } else {
            html += renderEventRows(events, newEventsCount);
        }

        html += '</tbody></table>';

        // Infinite scroll loading indicator
        html += '<div id="events-load-more" class="events-load-more" style="display: ' + (hasMoreEvents ? 'flex' : 'none') + ';">';
        html += '<div class="loading-spinner-small"></div>';
        html += '<span>Loading more events...</span>';
        html += '</div>';

        // End of events message
        html += '<div id="events-end-message" class="events-end-message" style="display: ' + (hasMoreEvents ? 'none' : 'block') + ';">';
        html += 'All events loaded';
        html += '</div>';

        container.innerHTML = html;

        // Set up infinite scroll on the actual scrolling parent (.table-container)
        var scrollParent = document.querySelector('.table-container');
        setupEventsInfiniteScroll(scrollParent, totalEventsCount, totalRecordsCount);

    } catch (err) {
        console.error('Error loading events:', err);
        container.innerHTML = '<div class="empty-state"><h3>Error loading events</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Helper function to fetch events based on current filters
async function fetchEventsForInfiniteScroll(offset, limit) {
    var events = [];

    if (eventsTypeFilter === 'current') {
        events = await getCurrentRecordsPaginated(offset, limit, eventsSetFilter, eventsSearchQuery);
    } else {
        if (eventsSearchQuery) {
            events = await searchRawEvents(eventsSearchQuery, limit, offset);
        } else if (eventsSetFilter) {
            events = await getRawEventsBySetPaginated(eventsSetFilter, offset, limit);
        } else {
            events = await getRawEventsPaginated(offset, limit);
        }

        // Apply type filter if set (post-filter since we need to parse payload)
        if (eventsTypeFilter) {
            events = events.filter(e => {
                var payload = parsePayload(e.payload);
                var baseType = payload?._set || 'data';
                // For data events, resolve to operator type (INS/ALT/NUL)
                var type = baseType;
                if (baseType === 'data') {
                    if (e.operator) {
                        type = e.operator;
                    } else if (payload && payload.fields) {
                        if (payload.fields.INS) type = 'INS';
                        else if (payload.fields.ALT) type = 'ALT';
                        else if (payload.fields.NUL) type = 'NUL';
                        else if (payload.fields.SYN) type = 'SYN';
                    }
                }
                return type === eventsTypeFilter;
            });
        }
    }

    return events;
}

function getEventRecordLabel(tableId, recordId, fields) {
    if (!recordId) return '';

    var cacheKey = (tableId || '') + '::' + recordId;
    if (cachedEventRecordLabels[cacheKey]) {
        return cachedEventRecordLabels[cacheKey];
    }

    var value = null;
    var tableFields = META_FIELDS[tableId] || {};
    var displayNameFieldId = getDisplayNameFieldId(tableId);
    var displayField = displayNameFieldId ? tableFields[displayNameFieldId] : null;

    if (displayNameFieldId && fields) {
        value = fields[displayNameFieldId];
        if ((value === undefined || value === null || value === '') && displayField) {
            value = fields[displayField.fieldName];
        }
    }

    if ((value === undefined || value === null || value === '') && fields) {
        var firstFieldId = Object.keys(tableFields)[0];
        if (firstFieldId) {
            var firstField = tableFields[firstFieldId];
            value = fields[firstFieldId];
            if ((value === undefined || value === null || value === '') && firstField) {
                value = fields[firstField.fieldName];
            }
        }
    }

    var label = (value === undefined || value === null || value === '') ? recordId : String(value);
    cachedEventRecordLabels[cacheKey] = label;
    return label;
}

async function prefetchEventRecordLabels(events) {
    var byTable = {};

    for (var i = 0; i < events.length; i++) {
        var event = events[i] || {};
        var tableId = (event.set || '').replace('airtable:', '');
        var recordId = event.recordId;
        if (!tableId || !recordId) continue;

        var cacheKey = tableId + '::' + recordId;
        if (cachedEventRecordLabels[cacheKey]) continue;
        if (!byTable[tableId]) byTable[tableId] = [];
        if (byTable[tableId].indexOf(recordId) === -1) byTable[tableId].push(recordId);
    }

    var tableIds = Object.keys(byTable);
    for (var t = 0; t < tableIds.length; t++) {
        var tableId = tableIds[t];
        try {
            var records = await getRecordsByIds(tableId, byTable[tableId]);
            var mapped = {};
            for (var r = 0; r < records.length; r++) {
                var rec = records[r];
                mapped[rec.recordId] = rec;
            }

            for (var j = 0; j < byTable[tableId].length; j++) {
                var recordId = byTable[tableId][j];
                var rec = mapped[recordId];
                var fields = rec ? (rec.fields || {}) : null;
                getEventRecordLabel(tableId, recordId, fields);
            }
        } catch (err) {
            for (var k = 0; k < byTable[tableId].length; k++) {
                var fallbackRecordId = byTable[tableId][k];
                cachedEventRecordLabels[tableId + '::' + fallbackRecordId] = fallbackRecordId;
            }
        }
    }
}

// Render multiple event rows and track new events divider
function renderEventRows(events, newEventsCount) {
    var html = '';
    var addedDivider = loadedEvents.length > events.length; // Divider already added if we've loaded more than initial batch

    for (var i = 0; i < events.length; i++) {
        var event = events[i];
        var isNew = event.id > appOpenedEventId;

        // Add divider between new and old events (only once)
        if (!addedDivider && !isNew && newEventsCount > 0) {
            html += '<tr class="new-events-divider"><td colspan="7"><span class="new-events-divider-text">Events when app opened</span></td></tr>';
            addedDivider = true;
        }

        html += renderEventRow(event, isNew);
    }

    return html;
}

// Set up infinite scroll for events
function setupEventsInfiniteScroll(container, totalEventsCount, totalRecordsCount) {
    eventsScrollHandler = function() {
        // Check if we're near the bottom (within 200px)
        var scrollTop = container.scrollTop;
        var scrollHeight = container.scrollHeight;
        var clientHeight = container.clientHeight;

        if (scrollHeight - scrollTop - clientHeight < 200) {
            loadMoreEvents(totalEventsCount, totalRecordsCount);
        }
    };

    container.addEventListener('scroll', eventsScrollHandler);
}

// Load more events for infinite scroll
async function loadMoreEvents(totalEventsCount, totalRecordsCount) {
    if (isLoadingMoreEvents || !hasMoreEvents) return;

    isLoadingMoreEvents = true;
    var loadMoreDiv = document.getElementById('events-load-more');
    if (loadMoreDiv) loadMoreDiv.style.display = 'flex';

    try {
        var newEvents = await fetchEventsForInfiniteScroll(eventsOffset, eventsPageSize);

        if (newEvents.length === 0) {
            hasMoreEvents = false;
        } else {
            // Add new events to loaded array, capping total to prevent memory bloat
            for (var le = 0; le < newEvents.length; le++) loadedEvents.push(newEvents[le]);
            if (loadedEvents.length > MAX_LOADED_EVENTS) {
                loadedEvents = loadedEvents.slice(loadedEvents.length - MAX_LOADED_EVENTS);
            }
            eventsOffset += newEvents.length;
            hasMoreEvents = newEvents.length === eventsPageSize;

            // Count new events in this batch
            var newEventsCount = newEvents.filter(e => e.id > appOpenedEventId).length;
            await prefetchEventRecordLabels(newEvents);

            // Append rows to tbody
            var tbody = document.getElementById('events-tbody');
            if (tbody) {
                var rowsHtml = renderEventRows(newEvents, newEventsCount);
                tbody.insertAdjacentHTML('beforeend', rowsHtml);
            }

            // Update stats
            updateEventsStats(totalEventsCount, totalRecordsCount);
        }
    } catch (err) {
        console.error('Error loading more events:', err);
    } finally {
        isLoadingMoreEvents = false;

        // Update loading indicator visibility
        var loadMoreDiv = document.getElementById('events-load-more');
        var endMessage = document.getElementById('events-end-message');

        if (loadMoreDiv) loadMoreDiv.style.display = hasMoreEvents ? 'none' : 'none';
        if (endMessage) endMessage.style.display = hasMoreEvents ? 'none' : 'block';
    }
}

// Update the events stats display
function updateEventsStats(totalEventsCount, totalRecordsCount) {
    var statsDiv = document.getElementById('events-stats');
    if (!statsDiv) return;

    var newEventsCount = loadedEvents.filter(e => e.id > appOpenedEventId).length;

    var html = '';
    if (eventsTypeFilter === 'current') {
        html += 'Loaded ' + loadedEvents.length.toLocaleString();
        html += ' <span style="color: #666;">(' + totalRecordsCount.toLocaleString() + ' total records)</span>';
    } else {
        html += 'Loaded ' + loadedEvents.length.toLocaleString();
        html += ' <span style="color: #666;">(' + totalEventsCount.toLocaleString() + ' total events)</span>';
        if (newEventsCount > 0) {
            html += ' <span class="new-event-badge">' + newEventsCount + ' new</span>';
        }
    }

    statsDiv.innerHTML = html;
}

function renderEventRow(event, isNew) {
    var payload = parsePayload(event.payload);
    var isEncrypted = !payload && !!event._encryptedPayload;
    var baseType = payload?._set || 'data';
    // For data events, show the operator (INS/ALT/NUL) instead of generic "data"
    var eventType = baseType;
    if (baseType === 'data') {
        if (event.operator) {
            eventType = event.operator;
        } else if (payload && payload.fields) {
            // Infer from payload fields
            if (payload.fields.INS) eventType = 'INS';
            else if (payload.fields.ALT) eventType = 'ALT';
            else if (payload.fields.NUL) eventType = 'NUL';
            else if (payload.fields.SYN) eventType = 'SYN';
        }
    }
    var isCurrentState = event._isCurrentState || eventType === 'current';
    var timestamp = event.created_at ? formatTimestamp(new Date(event.created_at).getTime()) : (isCurrentState ? 'Current' : 'Unknown');
    var isExpanded = expandedPayloads.has(event.id || event.recordId);

    var rowClass = isNew ? 'new-event' : (isCurrentState ? 'current-state-row' : '');
    var html = '<tr data-event-id="' + (event.id || event.recordId) + '"' + (rowClass ? ' class="' + rowClass + '"' : '') + '>';

    var recordLabel = getEventRecordLabel((event.set || '').replace('airtable:', ''), event.recordId, null);
    html += '<td><span class="event-record-id" title="' + esc(event.recordId || '') + '">' + esc(recordLabel) + (isNew ? '<span class="new-event-badge">NEW</span>' : '') + '</span></td>';

    html += '<td><span class="event-timestamp">' + esc(timestamp) + '</span></td>';
    html += '<td><span class="event-type-badge ' + eventType + '">' + esc(ENTITY_TYPE_NAMES[eventType] || eventType) + '</span></td>';
    var setTableId = (event.set || '').replace('airtable:', '');
    var setDisplayName = setTableId ? resolveTableName(setTableId) : (event.set || '');
    html += '<td><span class="event-set" title="' + esc(event.set || '') + '">' + esc(setDisplayName) + '</span></td>';
    // Details column - highlight operator
    html += '<td class="event-details">';
    html += '<div><span class="field-op-badge ' + eventType + '">Operator: ' + esc(ENTITY_TYPE_NAMES[eventType] || eventType) + '</span></div>';
    html += '</td>';

    // Payload preview
    html += '<td class="payload-preview-container">';
    html += '<div class="payload-preview' + (isExpanded ? ' expanded' : '') + '" onclick="togglePayloadExpand(\'' + (event.id || event.recordId) + '\')">';
    html += isEncrypted ? '<span class="json-null" title="Payload is encrypted. Unlock encryption to view.">encrypted</span>' : formatPayloadPreview(payload, isExpanded);
    if (!isExpanded) {
        html += '<span class="payload-expand-btn">Expand</span>';
    } else {
        html += '<span class="payload-expand-btn">Collapse</span>';
    }
    html += '</div>';
    html += '</td>';

    // Actions
    html += '<td class="event-actions">';
    if (event.recordId && event.recordId.startsWith('rec')) {
        if (isCurrentState) {
            // For current state, show "View Record" button that opens profile
            var tableId = (event.set || '').replace('airtable:', '');
            html += '<button class="event-action-btn primary" onclick="openRecordProfile(\'' + esc(tableId) + '\', \'' + esc(event.recordId) + '\')" title="View full record details">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';
            html += 'View Record';
            html += '</button>';
        } else {
            var evtTableId = (event.set || '').replace('airtable:', '');
            html += '<button class="event-action-btn primary" onclick="viewRecordAtPointInTime(\'' + esc(String(event.id)) + '\', \'' + esc(event.recordId) + '\', \'' + esc(event.set || '') + '\')" title="View the full record snapshot at this point in time (all fields)">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M8 3v5l3 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="1.5"/></svg>';
            html += 'View State';
            html += '</button>';
            html += '<button class="event-action-btn" onclick="goToRecordInTable(\'' + esc(evtTableId) + '\', \'' + esc(event.recordId) + '\')" title="View current record">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';
            html += 'View Record';
            html += '</button>';
        }
    }
    html += '</td>';

    html += '</tr>';
    return html;
}

function getFieldOperationDetails(payload) {
    if (!payload || !payload.fields) return null;

    var fields = payload.fields;
    var details = [];

    if (fields.INS && typeof fields.INS === 'object') {
        var count = Object.keys(fields.INS).length;
        details.push({ type: 'INS', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    if (fields.ALT && typeof fields.ALT === 'object') {
        var count = Object.keys(fields.ALT).length;
        details.push({ type: 'ALT', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    if (fields.NUL && Array.isArray(fields.NUL)) {
        var count = fields.NUL.length;
        if (count > 0) {
            details.push({ type: 'NUL', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
        }
    }

    if (fields.SYN && typeof fields.SYN === 'object') {
        var count = Object.keys(fields.SYN).length;
        details.push({ type: 'SYN', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    return details.length > 0 ? details : null;
}

function formatPayloadPreview(payload, expanded) {
    if (!payload) return '<span class="json-null">null</span>';

    // Try to extract INS/ALT/NUL field data for nice display
    var fields = payload.fields;
    var hasFieldData = fields && (fields.INS || fields.ALT || fields.NUL || fields.SYN);

    if (hasFieldData) {
        return formatPayloadFields(fields, expanded);
    }

    // Check if payload has context.data (alternative structure)
    if (payload.context && payload.context.data) {
        return formatPayloadFields({ INS: payload.context.data }, expanded);
    }

    // Fallback to raw JSON display
    try {
        var str = typeof payload === 'string' ? payload : JSON.stringify(payload, null, expanded ? 2 : 0);

        // Apply syntax highlighting
        str = esc(str)
            .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span>:')
            .replace(/: "([^"]*)"([,\n\}])/g, ': <span class="json-string">"$1"</span>$2')
            .replace(/: (-?\d+\.?\d*)([,\n\}])/g, ': <span class="json-number">$1</span>$2')
            .replace(/: (true|false)([,\n\}])/g, ': <span class="json-boolean">$1</span>$2')
            .replace(/: (null)([,\n\}])/g, ': <span class="json-null">$1</span>$2');

        return str;
    } catch (e) {
        return esc(String(payload));
    }
}

function formatPayloadFields(fields, expanded) {
    var html = '<div class="payload-fields">';
    var ops = ['INS', 'ALT', 'NUL', 'SYN'];
    var hasAnyFields = false;

    for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        var data = fields[op];
        if (!data) continue;

        // NUL is an array of field names, INS/ALT are objects
        if (op === 'NUL' && Array.isArray(data) && data.length > 0) {
            hasAnyFields = true;
            html += '<div class="payload-op-group">';
            html += '<span class="payload-op-label ' + op + '">' + op + '</span>';
            html += '<div class="payload-field-row">';
            html += '<span class="payload-field-value null">' + esc(data.join(', ')) + '</span>';
            html += '</div></div>';
        } else if (typeof data === 'object' && !Array.isArray(data)) {
            var keys = Object.keys(data);
            if (keys.length === 0) continue;

            hasAnyFields = true;
            html += '<div class="payload-op-group">';
            html += '<span class="payload-op-label ' + op + '">' + op + '</span>';

            // In collapsed mode, show limited fields
            var displayKeys = expanded ? keys : keys.slice(0, 3);

            for (var j = 0; j < displayKeys.length; j++) {
                var key = displayKeys[j];
                var value = data[key];
                html += '<div class="payload-field-row">';
                html += '<span class="payload-field-name">' + esc(getFieldDisplayName(key)) + '</span>';
                html += '<span class="payload-field-value ' + getValueClass(value) + '">' + formatFieldValue(value, expanded) + '</span>';
                html += '</div>';
            }

            if (!expanded && keys.length > 3) {
                html += '<div class="payload-field-row" style="color: #9ca3af; font-style: italic;">+' + (keys.length - 3) + ' more fields</div>';
            }

            html += '</div>';
        }
    }

    html += '</div>';
    return hasAnyFields ? html : '<span class="json-null">no field data</span>';
}

function getFieldDisplayName(fieldId) {
    // Try to get human-readable field name from schema
    if (window.fields && window.fields[fieldId]) {
        return window.fields[fieldId].name || fieldId;
    }
    // Truncate long field IDs
    if (fieldId.length > 20) {
        return fieldId.substring(0, 17) + '...';
    }
    return fieldId;
}

function getValueClass(value) {
    if (value === null || value === undefined) return 'null';
    if (Array.isArray(value)) return 'array';
    if (typeof value === 'object') return 'object';
    if (typeof value === 'number') return 'number';
    if (typeof value === 'boolean') return 'boolean';
    return 'string';
}

function formatFieldValue(value, expanded) {
    if (value === null || value === undefined) return 'null';

    if (Array.isArray(value)) {
        if (value.length === 0) return '[]';
        if (!expanded && value.length > 2) {
            return '[' + esc(String(value[0])) + ', ... +' + (value.length - 1) + ']';
        }
        return '[' + value.map(function(v) { return esc(String(v)); }).join(', ') + ']';
    }

    if (typeof value === 'object') {
        var keys = Object.keys(value);
        if (keys.length === 0) return '{}';
        if (!expanded) return '{' + keys.length + ' keys}';
        return esc(JSON.stringify(value));
    }

    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'number') return String(value);

    // String value - truncate if too long
    var str = String(value);
    if (!expanded && str.length > 50) {
        return esc(str.substring(0, 47)) + '...';
    }
    return esc(str);
}

function togglePayloadExpand(eventId) {
    if (expandedPayloads.has(eventId)) {
        expandedPayloads.delete(eventId);
    } else {
        expandedPayloads.add(eventId);
    }

    // Find the row and update just the payload cell instead of re-rendering everything
    var row = document.querySelector('tr[data-event-id="' + eventId + '"]');
    if (row) {
        var event = loadedEvents.find(e => (e.id || e.recordId) == eventId);
        if (event) {
            var payload = parsePayload(event.payload);
            var isExpanded = expandedPayloads.has(eventId);
            var payloadCell = row.querySelector('.payload-preview-container');
            if (payloadCell) {
                var html = '<div class="payload-preview' + (isExpanded ? ' expanded' : '') + '" onclick="togglePayloadExpand(\'' + eventId + '\')">';
                html += formatPayloadPreview(payload, isExpanded);
                if (!isExpanded) {
                    html += '<span class="payload-expand-btn">Expand</span>';
                } else {
                    html += '<span class="payload-expand-btn">Collapse</span>';
                }
                html += '</div>';
                payloadCell.innerHTML = html;
            }
        }
    }
}

function setEventsTypeFilter(type) {
    eventsTypeFilter = type;
    renderEventsView();
}

function setEventsSetFilter(set) {
    eventsSetFilter = set;
    renderEventsView();
}

function setEventsSearch(query) {
    eventsSearchQuery = query;
    renderEventsView();
}

// ============ Changelog Tab (drawn from Matrix room data) ============

// Fetch a changelog of mutations from Matrix rooms using SynapseSync room map.
// Paginates backwards (newest first) through law.firm.record.mutate events
// in each room, merges across rooms, and returns a unified list.
async function _fetchRoomChangelog(options) {
    options = options || {};
    var limit = options.limit || 50;
    var prevTokens = options.paginationTokens || {};
    var tableFilter = options.tableFilter || null;

    var roomTableMap = _getRoomTableMap();
    var roomIds = Object.keys(roomTableMap);

    if (tableFilter) {
        var filterRoom = _getRoomForTable(tableFilter);
        if (!filterRoom) throw new Error('No Matrix room for table: ' + tableFilter);
        roomIds = [filterRoom];
    }

    var perRoomEntries = [];
    var nextTokens = {};
    var anyHasMore = false;

    for (var r = 0; r < roomIds.length; r++) {
        var roomId = roomIds[r];
        var tableId = roomTableMap[roomId];
        var fromToken = prevTokens[roomId] || undefined;

        if (fromToken === 'exhausted') {
            nextTokens[roomId] = 'exhausted';
            continue;
        }

        try {
            var msgOpts = {
                dir: 'b',
                limit: limit,
                filter: { types: ['law.firm.schema.object', 'law.firm.record.mutate'] }
            };
            if (fromToken) msgOpts.from = fromToken;

            var response = await MatrixClient.getRoomMessages(roomId, msgOpts);
            if (!response || !response.chunk) {
                nextTokens[roomId] = 'exhausted';
                continue;
            }

            var chunk = response.chunk;
            for (var i = 0; i < chunk.length; i++) {
                var evt = chunk[i];
                var content = evt.content || {};
                if (!content.recordId) continue; // skip schema-level events (field definitions, etc.)


                // Decrypt if needed (gracefully skip failures)
                if (typeof AminoData !== 'undefined' && AminoData.isEncryptedPayload(content)) {
                    try {
                        var decryptedFields = await AminoData.decryptEventPayload(content);
                        content = {
                            recordId: content.recordId,
                            tableId: content.tableId,
                            op: content.op || 'ALT',
                            payload: content.payload,
                            set: content.set,
                            source: content.source,
                            sourceTimestamp: content.sourceTimestamp,
                            fields: decryptedFields
                        };
                    } catch (decErr) {
                        // Cannot decrypt  still show the entry with whatever metadata is available
                    }
                }

                var payload = content.payload || {};
                var fieldOps = payload.fields || {};

                // Handle flat format
                if (!fieldOps.ALT && !fieldOps.INS && !fieldOps.NUL && content.op && content.fields) {
                    fieldOps = {};
                    if (content.op === 'INS' || content.op === 'ALT') {
                        fieldOps[content.op] = content.fields;
                    } else if (content.op === 'NUL') {
                        fieldOps.NUL = content.fields;
                    }
                }

                perRoomEntries.push({
                    eventId: evt.event_id || null,
                    sender: evt.sender || null,
                    timestamp: evt.origin_server_ts || null,
                    tableId: tableId,
                    recordId: content.recordId || null,
                    op: content.op || 'ALT',
                    source: content.source || null,
                    sourceTimestamp: content.sourceTimestamp || null,
                    actor: payload._a || null,
                    fieldOps: fieldOps
                });
            }

            if (response.end && chunk.length >= limit) {
                nextTokens[roomId] = response.end;
                anyHasMore = true;
            } else {
                nextTokens[roomId] = 'exhausted';
            }
        } catch (err) {
            console.warn('[Changelog] Error fetching room', roomId, err.message);
            nextTokens[roomId] = prevTokens[roomId] || 'exhausted';
        }
    }

    // Sort newest first
    perRoomEntries.sort(function(a, b) {
        return (b.timestamp || 0) - (a.timestamp || 0);
    });

    var entries = perRoomEntries.slice(0, limit);
    if (perRoomEntries.length > limit) anyHasMore = true;

    return {
        entries: entries,
        paginationTokens: nextTokens,
        hasMore: anyHasMore
    };
}

async function renderChangelogContent() {
    var container = document.getElementById('events-tab-content');
    if (!container) return;
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading changelog from room data...</h3></div>';

    // Reset changelog state
    changelogEntries = [];
    changelogPaginationTokens = {};
    changelogHasMore = true;
    changelogIsLoading = false;

    // Clean up previous scroll handler
    if (changelogScrollHandler) {
        var scrollParent = document.querySelector('.table-container');
        if (scrollParent) scrollParent.removeEventListener('scroll', changelogScrollHandler);
        changelogScrollHandler = null;
    }

    try {
        // Check if Matrix is available and we have room mappings
        var roomTableMap = _getRoomTableMap();
        if (!MatrixClient.isLoggedIn() || Object.keys(roomTableMap).length === 0) {
            container.innerHTML = '<div class="changelog-empty"><h3>Not connected</h3><p>Changelog requires an active Matrix connection. Sign in with Synapse to view all changes from room data.</p></div>';
            return;
        }

        var result = await _fetchRoomChangelog({
            limit: 50,
            tableFilter: changelogTableFilter || undefined
        });

        changelogEntries = result.entries;
        changelogPaginationTokens = result.paginationTokens;
        changelogHasMore = result.hasMore;

        var html = '';

        // Changelog controls bar
        html += '<div class="events-controls">';
        html += '<div class="events-filter-group">';
        html += '<label>Table:</label>';
        html += '<select onchange="setChangelogTableFilter(this.value)">';
        html += '<option value="">All Tables</option>';
        for (var tid in META_TABLES) {
            var tableName = resolveTableName(tid);
            html += '<option value="' + esc(tid) + '"' + (changelogTableFilter === tid ? ' selected' : '') + '>' + esc(tableName) + '</option>';
        }
        html += '</select>';
        html += '</div>';

        html += '<div class="events-stats">';
        html += 'Loaded ' + changelogEntries.length.toLocaleString() + ' changes';
        if (changelogHasMore) html += ' <span style="color: var(--text-muted);">(scroll for more)</span>';
        html += '</div>';
        html += '</div>';

        // Changelog entry list
        html += '<div class="changelog-list" id="changelog-list">';

        if (changelogEntries.length === 0) {
            html += '<div class="changelog-empty"><h3>No changes found</h3><p>No mutations have been recorded in the room data yet.</p></div>';
        } else {
            for (var i = 0; i < changelogEntries.length; i++) {
                html += renderChangelogEntry(changelogEntries[i], i === changelogEntries.length - 1);
            }
        }

        html += '</div>';

        // Infinite scroll loading indicator
        html += '<div id="changelog-load-more" class="events-load-more" style="display: ' + (changelogHasMore ? 'flex' : 'none') + ';">';
        html += '<div class="loading-spinner-small"></div>';
        html += '<span>Loading more changes...</span>';
        html += '</div>';

        html += '<div id="changelog-end-message" class="events-end-message" style="display: ' + (changelogHasMore ? 'none' : 'block') + ';">';
        html += 'All changes loaded';
        html += '</div>';

        container.innerHTML = html;

        // Set up infinite scroll on the actual scrolling parent
        var scrollParent = document.querySelector('.table-container');
        setupChangelogInfiniteScroll(scrollParent);

    } catch (err) {
        console.error('Error loading changelog:', err);
        container.innerHTML = '<div class="changelog-empty"><h3>Error loading changelog</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function renderChangelogEntry(entry, isLast) {
    var op = entry.op || 'ALT';
    var opLabel = ENTITY_TYPE_NAMES[op] || op;
    var tableName = entry.tableId ? resolveTableName(entry.tableId) : 'Unknown';
    var _ts = entry.timestamp || entry.sourceTimestamp || null;
    var timeStr = _ts ? formatTimestamp(_ts) : 'Unknown';
    var fieldsMeta = META_FIELDS[entry.tableId] || {};

    var html = '<div class="changelog-entry">';

    // Timeline dot and line
    html += '<div class="changelog-timeline">';
    html += '<div class="changelog-dot ' + esc(op) + '"></div>';
    if (!isLast) html += '<div class="changelog-line"></div>';
    html += '</div>';

    // Content
    html += '<div class="changelog-content">';

    // Header row: op badge, table, record ID, source badge, timestamp
    html += '<div class="changelog-header">';
    html += '<span class="changelog-op ' + esc(op) + '">' + esc(opLabel) + '</span>';
    html += '<span class="changelog-table-badge">' + esc(tableName) + '</span>';
    if (entry.recordId) {
        html += '<a class="changelog-record-id changelog-record-link" href="#" onclick="event.preventDefault();goToRecordInTable(\'' + esc(entry.tableId) + '\',\'' + esc(entry.recordId) + '\')" title="View record ' + esc(entry.recordId) + '">' + esc(entry.recordId) + '</a>';
    }
    if (entry.source) {
        html += '<span class="changelog-source-badge" title="Source: ' + esc(entry.source) + '">' + esc(entry.source.replace(/_/g, ' ')) + '</span>';
    }
    html += '<span class="changelog-time">' + esc(timeStr) + '</span>';
    html += '</div>';

    // Changed fields
    var fieldOps = entry.fieldOps || {};
    var hasFields = false;
    html += '<div class="changelog-fields">';

    // INS fields
    if (fieldOps.INS) {
        var insKeys = Object.keys(fieldOps.INS);
        for (var a = 0; a < insKeys.length; a++) {
            hasFields = true;
            var fname = resolveFieldName(fieldsMeta, insKeys[a]);
            html += '<div class="changelog-field">';
            html += '<span class="changelog-field-name">' + esc(fname) + '</span>';
            html += '<span class="changelog-field-arrow">&#8592;</span>';
            html += '<span class="changelog-field-value">' + esc(truncateValue(fieldOps.INS[insKeys[a]])) + '</span>';
            html += '</div>';
        }
    }

    // ALT fields
    if (fieldOps.ALT) {
        var altKeys = Object.keys(fieldOps.ALT);
        for (var b = 0; b < altKeys.length; b++) {
            hasFields = true;
            var fname = resolveFieldName(fieldsMeta, altKeys[b]);
            html += '<div class="changelog-field">';
            html += '<span class="changelog-field-name">' + esc(fname) + '</span>';
            html += '<span class="changelog-field-arrow">&#8592;</span>';
            html += '<span class="changelog-field-value">' + esc(truncateValue(fieldOps.ALT[altKeys[b]])) + '</span>';
            html += '</div>';
        }
    }

    // SYN fields
    if (fieldOps.SYN) {
        var synKeys = Object.keys(fieldOps.SYN);
        for (var s = 0; s < synKeys.length; s++) {
            hasFields = true;
            var fname = resolveFieldName(fieldsMeta, synKeys[s]);
            html += '<div class="changelog-field">';
            html += '<span class="changelog-field-name">' + esc(fname) + '</span>';
            html += '<span class="changelog-field-arrow">&#8592;</span>';
            html += '<span class="changelog-field-value">' + esc(truncateValue(fieldOps.SYN[synKeys[s]])) + '</span>';
            html += '</div>';
        }
    }

    // NUL fields
    if (fieldOps.NUL) {
        var nulFields = Array.isArray(fieldOps.NUL) ? fieldOps.NUL : Object.keys(fieldOps.NUL);
        for (var c = 0; c < nulFields.length; c++) {
            hasFields = true;
            var fname = resolveFieldName(fieldsMeta, nulFields[c]);
            html += '<div class="changelog-field">';
            html += '<span class="changelog-field-name">' + esc(fname) + '</span>';
            html += '<span class="changelog-field-arrow">&#8592;</span>';
            html += '<span class="changelog-field-value" style="font-style: italic; opacity: 0.6;">deleted</span>';
            html += '</div>';
        }
    }

    if (!hasFields) {
        html += '<div class="changelog-field" style="opacity: 0.5; font-style: italic;">No field details available</div>';
    }

    html += '</div>';

    // Actor/sender info
    if (entry.actor || entry.sender || entry.source) {
        html += '<div class="changelog-actor">';
        if (entry.actor) html += 'by ' + esc(entry.actor);
        else if (entry.sender) html += 'by ' + esc(entry.sender);
        if (entry.source) html += ' via ' + esc(entry.source);
        html += '</div>';
    }

    html += '</div>'; // .changelog-content
    html += '</div>'; // .changelog-entry

    return html;
}

function resolveFieldName(fieldsMeta, fieldId) {
    if (fieldsMeta[fieldId] && fieldsMeta[fieldId].fieldName) {
        return fieldsMeta[fieldId].fieldName;
    }
    return fieldId;
}

function truncateValue(val) {
    if (val === null || val === undefined) return '';
    var str = typeof val === 'object' ? JSON.stringify(val) : String(val);
    if (str.length > 120) return str.substring(0, 117) + '...';
    return str;
}

function setChangelogTableFilter(tableId) {
    changelogTableFilter = tableId;
    renderChangelogContent();
}

function setupChangelogInfiniteScroll(scrollParent) {
    changelogScrollHandler = function() {
        var scrollTop = scrollParent.scrollTop;
        var scrollHeight = scrollParent.scrollHeight;
        var clientHeight = scrollParent.clientHeight;

        if (scrollHeight - scrollTop - clientHeight < 200) {
            loadMoreChangelog();
        }
    };
    scrollParent.addEventListener('scroll', changelogScrollHandler);
}

async function loadMoreChangelog() {
    if (changelogIsLoading || !changelogHasMore) return;
    changelogIsLoading = true;

    var loadMoreDiv = document.getElementById('changelog-load-more');
    if (loadMoreDiv) loadMoreDiv.style.display = 'flex';

    try {
        var result = await _fetchRoomChangelog({
            limit: 50,
            paginationTokens: changelogPaginationTokens,
            tableFilter: changelogTableFilter || undefined
        });

        if (result.entries.length === 0) {
            changelogHasMore = false;
        } else {
            for (var i = 0; i < result.entries.length; i++) {
                changelogEntries.push(result.entries[i]);
            }
            changelogPaginationTokens = result.paginationTokens;
            changelogHasMore = result.hasMore;

            // Append to the list
            var list = document.getElementById('changelog-list');
            if (list) {
                // Remove isLast styling from previously last entry
                var lastEntry = list.querySelector('.changelog-entry:last-child .changelog-timeline');
                if (lastEntry && !lastEntry.querySelector('.changelog-line')) {
                    var line = document.createElement('div');
                    line.className = 'changelog-line';
                    lastEntry.appendChild(line);
                }
                var newHtml = '';
                for (var j = 0; j < result.entries.length; j++) {
                    var isLast = (j === result.entries.length - 1) && !changelogHasMore;
                    newHtml += renderChangelogEntry(result.entries[j], isLast);
                }
                list.insertAdjacentHTML('beforeend', newHtml);
            }

            // Update stats
            var statsDiv = document.querySelector('.events-controls .events-stats');
            if (statsDiv) {
                var statsHtml = 'Loaded ' + changelogEntries.length.toLocaleString() + ' changes';
                if (changelogHasMore) statsHtml += ' <span style="color: var(--text-muted);">(scroll for more)</span>';
                statsDiv.innerHTML = statsHtml;
            }
        }
    } catch (err) {
        console.error('Error loading more changelog:', err);
    } finally {
        changelogIsLoading = false;
        var loadMoreDiv = document.getElementById('changelog-load-more');
        var endMessage = document.getElementById('changelog-end-message');
        if (loadMoreDiv) loadMoreDiv.style.display = changelogHasMore ? 'none' : 'none';
        if (endMessage) endMessage.style.display = changelogHasMore ? 'none' : 'block';
    }
}

// ============ Events CSV Export/Import ============

async function exportEventsToCSV() {
    try {
        // Show progress
        showImportStatus('Exporting...', 'Collecting events from database...', 'progress', 0);

        // Get all events from IndexedDB
        var allEvents = [];
        var batchSize = 1000;
        var offset = 0;
        var totalCount = await getRawEventsCount();

        while (true) {
            var batch = await getRawEventsPaginated(offset, batchSize);
            if (batch.length === 0) break;
            for (var bi = 0; bi < batch.length; bi++) allEvents.push(batch[bi]);
            offset += batch.length;

            var progress = Math.round((allEvents.length / totalCount) * 50);
            showImportStatus('Exporting...', 'Collected ' + allEvents.length.toLocaleString() + ' of ' + totalCount.toLocaleString() + ' events', 'progress', progress);
        }

        if (allEvents.length === 0) {
            showImportStatus('No Events', 'No events to export.', 'error');
            return;
        }

        showImportStatus('Exporting...', 'Building CSV file...', 'progress', 60);

        // CSV header
        var csvLines = ['id,set,recordId,operator,created_at,payload'];

        // Convert events to CSV rows
        for (var i = 0; i < allEvents.length; i++) {
            var event = allEvents[i];
            var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);

            // Escape CSV fields
            var row = [
                event.id,
                escapeCSVField(event.set || ''),
                escapeCSVField(event.recordId || ''),
                escapeCSVField(event.operator || ''),
                escapeCSVField(event.created_at || ''),
                escapeCSVField(payloadStr)
            ];
            csvLines.push(row.join(','));

            if (i % 1000 === 0) {
                var progress = 60 + Math.round((i / allEvents.length) * 30);
                showImportStatus('Exporting...', 'Processing event ' + i.toLocaleString() + ' of ' + allEvents.length.toLocaleString(), 'progress', progress);
            }
        }

        showImportStatus('Exporting...', 'Creating download...', 'progress', 95);

        // Create and download file
        var csvContent = csvLines.join('\n');
        var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        var url = URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = url;
        link.download = 'events_export_' + new Date().toISOString().slice(0, 10) + '.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        showImportStatus('Export Complete', 'Exported ' + allEvents.length.toLocaleString() + ' events to CSV.', 'success');

    } catch (err) {
        console.error('Error exporting events:', err);
        showImportStatus('Export Failed', err.message, 'error');
    }
}

async function exportEventsToAmo() {
    try {
        showImportStatus('Exporting...', 'Collecting events from database...', 'progress', 0);

        var allEvents = [];
        var batchSize = 1000;
        var offset = 0;
        var totalCount = await getRawEventsCount();

        while (true) {
            var batch = await getRawEventsPaginated(offset, batchSize);
            if (batch.length === 0) break;
            for (var bi = 0; bi < batch.length; bi++) allEvents.push(batch[bi]);
            offset += batch.length;

            var progress = Math.round((allEvents.length / totalCount) * 50);
            showImportStatus('Exporting...', 'Collected ' + allEvents.length.toLocaleString() + ' of ' + totalCount.toLocaleString() + ' events', 'progress', progress);
        }

        if (allEvents.length === 0) {
            showImportStatus('No Events', 'No events to export.', 'error');
            return;
        }

        // Decrypt any remaining encrypted events (getRawEventsPaginated already decrypts,
        // but this handles edge cases where the key became available after retrieval)
        if (encryptionKey) {
            showImportStatus('Exporting...', 'Decrypting events...', 'progress', 52);
            allEvents = await Promise.all(allEvents.map(function(e) { return decryptEventFromStorage(e); }));
        }

        // History lives in Matrix rooms only  AMO export contains current state only
        showImportStatus('Exporting...', 'Building .amo file (' + allEvents.length.toLocaleString() + ' events, current state only)...', 'progress', 70);

        var binary = AmoFormat.produceEvents(allEvents, { tables: META_TABLES, fields: META_FIELDS });

        showImportStatus('Exporting...', 'Creating download...', 'progress', 95);

        var blob = new Blob([binary], { type: 'application/x-amino-snapshot' });
        var url = URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = url;
        link.download = 'amino_snapshot_' + new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-') + '.amo';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        var sizeStr = binary.length < 1024
            ? binary.length + ' B'
            : binary.length < 1048576
                ? (binary.length / 1024).toFixed(1) + ' KB'
                : (binary.length / 1048576).toFixed(1) + ' MB';

        showImportStatus('Export Complete', 'Exported ' + allEvents.length.toLocaleString() + ' events (' + sizeStr + ')  current state only.', 'success');

    } catch (err) {
        console.error('Error exporting .amo:', err);
        showImportStatus('Export Failed', err.message, 'error');
    }
}

function escapeCSVField(value) {
    if (value === null || value === undefined) return '';
    var str = String(value);
    // If contains comma, newline, or quote, wrap in quotes and escape inner quotes
    if (str.includes(',') || str.includes('\n') || str.includes('"') || str.includes('\r')) {
        return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
}

function parseCSVLine(line) {
    var result = [];
    var current = '';
    var inQuotes = false;
    var i = 0;

    while (i < line.length) {
        var char = line[i];

        if (inQuotes) {
            if (char === '"') {
                // Check for escaped quote
                if (i + 1 < line.length && line[i + 1] === '"') {
                    current += '"';
                    i += 2;
                    continue;
                } else {
                    inQuotes = false;
                    i++;
                    continue;
                }
            }
            current += char;
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === ',') {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        i++;
    }
    result.push(current);
    return result;
}

async function importEventsFromCSV() {
    // Create file input
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;

        try {
            showImportStatus('Importing...', 'Reading file...', 'progress', 0);

            var text = await file.text();
            var lines = text.split(/\r?\n/);
            text = null; // Release original text string to free memory

            if (lines.length < 2) {
                showImportStatus('Import Failed', 'CSV file is empty or has no data rows.', 'error');
                return;
            }

            // Parse header
            var header = parseCSVLine(lines[0]);
            var idIndex = header.indexOf('id');
            var setIndex = header.indexOf('set');
            var recordIdIndex = header.indexOf('recordId');
            var operatorIndex = header.indexOf('operator');
            var createdAtIndex = header.indexOf('created_at');
            var payloadIndex = header.indexOf('payload');

            if (idIndex === -1) {
                showImportStatus('Import Failed', 'CSV must have an "id" column.', 'error');
                return;
            }

            showImportStatus('Importing...', 'Parsing CSV data...', 'progress', 10);

            // Parse all event rows
            var events = [];
            for (var i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                var fields = parseCSVLine(lines[i]);
                var event = {
                    id: parseInt(fields[idIndex], 10)
                };

                if (isNaN(event.id)) continue; // Skip invalid IDs

                if (setIndex !== -1) event.set = fields[setIndex] || '';
                if (recordIdIndex !== -1) event.recordId = fields[recordIdIndex] || '';
                if (operatorIndex !== -1 && fields[operatorIndex]) event.operator = fields[operatorIndex];
                if (createdAtIndex !== -1) event.created_at = fields[createdAtIndex] || '';
                if (payloadIndex !== -1) {
                    var payloadStr = fields[payloadIndex] || '{}';
                    try {
                        event.payload = JSON.parse(payloadStr);
                    } catch (e) {
                        event.payload = payloadStr;
                    }
                }

                events.push(event);

                if (i % 1000 === 0) {
                    showImportStatus('Importing...', 'Parsed ' + events.length.toLocaleString() + ' events...', 'progress', 10 + Math.round((i / lines.length) * 20));
                }
            }

            if (events.length === 0) {
                showImportStatus('Import Failed', 'No valid events found in CSV.', 'error');
                return;
            }

            showImportStatus('Importing...', 'Checking for duplicates...', 'progress', 35);

            // Get existing event IDs from IndexedDB for deduplication
            var existingIds = await getExistingEventIds();

            showImportStatus('Importing...', 'Found ' + existingIds.size.toLocaleString() + ' existing events. Filtering duplicates...', 'progress', 50);

            // Filter out duplicates
            var newEvents = events.filter(function(e) {
                return !existingIds.has(e.id);
            });
            existingIds = null; // Release

            var totalEventCount = events.length;
            var duplicateCount = totalEventCount - newEvents.length;
            events = null; // Release original array  only newEvents needed now

            if (newEvents.length === 0) {
                showImportStatus('Import Complete', 'All ' + totalEventCount.toLocaleString() + ' events already exist (no new events to import).', 'success');
                return;
            }

            showImportStatus('Importing...', 'Importing ' + newEvents.length.toLocaleString() + ' new events (skipping ' + duplicateCount.toLocaleString() + ' duplicates)...', 'progress', 60);

            // Import events in batches
            var batchSize = 500;
            var imported = 0;

            for (var j = 0; j < newEvents.length; j += batchSize) {
                var batch = newEvents.slice(j, j + batchSize);
                await saveRawEvents(batch);
                imported += batch.length;

                var progress = 60 + Math.round((imported / newEvents.length) * 35);
                showImportStatus('Importing...', 'Imported ' + imported.toLocaleString() + ' of ' + newEvents.length.toLocaleString() + ' events...', 'progress', progress);
            }

            showImportStatus('Import Complete',
                'Imported ' + newEvents.length.toLocaleString() + ' new events' +
                (duplicateCount > 0 ? ' (skipped ' + duplicateCount.toLocaleString() + ' duplicates)' : '') + '.',
                'success');

            // Refresh the events view
            if (currentTable === '_events') {
                renderEventsView();
            }

        } catch (err) {
            console.error('Error importing events:', err);
            showImportStatus('Import Failed', err.message, 'error');
        }
    };

    input.click();
}

async function getExistingEventIds() {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var ids = new Set();

        var req = store.openKeyCursor();
        req.onsuccess = function(e) {
            var cursor = e.target.result;
            if (cursor) {
                ids.add(cursor.key);
                cursor.continue();
            } else {
                resolve(ids);
            }
        };
        req.onerror = function() {
            reject(req.error);
        };
    });
}

function showImportStatus(title, details, type, progress) {
    var existing = document.querySelector('.import-status');
    if (existing) existing.remove();

    var div = document.createElement('div');
    div.className = 'import-status' + (type === 'success' ? ' success' : type === 'error' ? ' error' : '');

    var icon = type === 'success' ? '' : type === 'error' ? '' : '';
    var titleClass = type === 'success' ? ' success' : type === 'error' ? ' error' : '';

    div.innerHTML = '<div class="import-status-title' + titleClass + '">' + icon + ' ' + esc(title) + '</div>' +
                    '<div class="import-status-details">' + esc(details) + '</div>' +
                    (type === 'progress' ? '<div class="import-progress"><div class="import-progress-bar" style="width: ' + (progress || 0) + '%"></div></div>' : '');

    document.body.appendChild(div);

    // Auto-remove success/error messages after 5 seconds
    if (type === 'success' || type === 'error') {
        setTimeout(function() {
            if (div.parentNode) div.remove();
        }, 5000);
    }
}

// Skip setup and upload CSV file directly
var skipSyncAbortController = null;

// Build in-memory lookup map for events by recordId
function buildInMemoryEventsByRecord(events) {
    var map = new Map();
    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (e.recordId) {
            if (!map.has(e.recordId)) {
                map.set(e.recordId, []);
            }
            map.get(e.recordId).push(e);
        }
    }
    return map;
}

// Background save events to IndexedDB (non-blocking)
async function backgroundSaveToIndexedDB(events, onProgress) {
    isBackgroundSaveInProgress = true;
    var batchSize = 500;
    var saved = 0;
    var total = events.length;

    try {
        // Phase 1: Save raw events
        for (var j = 0; j < events.length; j += batchSize) {
            var batch = events.slice(j, j + batchSize);
            await saveRawEvents(batch);
            saved += batch.length;

            if (onProgress) {
                onProgress(saved, total);
            }

            // Yield to main thread periodically to keep UI responsive
            if (j % 2000 === 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Phase 2: Save metadata (tables, fields, views)
        var tables = Object.values(META_TABLES);
        var fields = [];
        for (var tid in META_FIELDS) {
            for (var fid in META_FIELDS[tid]) {
                fields.push(META_FIELDS[tid][fid]);
            }
        }
        var views = [];
        for (var tid in META_VIEWS) {
            for (var vid in META_VIEWS[tid]) {
                views.push(META_VIEWS[tid][vid]);
            }
        }

        // Save metadata first (tables, fields, views)
        if (tables.length || fields.length || views.length) {
            await saveBatch(tables, fields, views, []);
        }

        // Phase 3: Save data records from IN_MEMORY_DATA per-table and free each table's data after save
        var totalDataRecords = 0;
        if (window.IN_MEMORY_DATA) {
            var tableIds = Object.keys(window.IN_MEMORY_DATA);
            for (var ti = 0; ti < tableIds.length; ti++) {
                var tableId = tableIds[ti];
                var tableData = window.IN_MEMORY_DATA[tableId];
                if (!tableData) continue;
                var dataRecords = [];
                for (var recordId in tableData) {
                    dataRecords.push({
                        tableId: tableId,
                        recordId: recordId,
                        fields: tableData[recordId]
                    });
                }
                if (dataRecords.length > 0) {
                    totalDataRecords += dataRecords.length;
                    // Save in sub-batches to avoid large transactions
                    for (var di = 0; di < dataRecords.length; di += batchSize) {
                        var dataBatch = dataRecords.slice(di, di + batchSize);
                        await saveBatch([], [], [], dataBatch);
                    }
                }
                // Yield to UI periodically (memory freed in bulk after all tables saved)
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Phase 4: Build and save field history from raw events
        // Group events by tableId and recordId, then build history per-record
        // Save incrementally to avoid accumulating a huge array
        var eventsByTableAndRecord = {};
        var maxId = 0;
        var lastEventCreatedAt = null;
        for (var i = 0; i < events.length; i++) {
            var evt = events[i];
            if (evt.id > maxId) { maxId = evt.id; lastEventCreatedAt = evt.created_at; }
            if (evt.recordId && evt.set && evt.set.startsWith('airtable:')) {
                var tableId = evt.set.replace('airtable:', '');
                var key = tableId + '|' + evt.recordId;
                if (!eventsByTableAndRecord[key]) {
                    eventsByTableAndRecord[key] = { tableId: tableId, recordId: evt.recordId, events: [] };
                }
                eventsByTableAndRecord[key].events.push(evt);
            }
        }

        // Field history is not stored locally  it lives in Matrix rooms only.
        // Release event groupings immediately.
        eventsByTableAndRecord = null;

        // Update the last event timestamp in IndexedDB
        var lastEvent = lastEventCreatedAt ? { created_at: lastEventCreatedAt } : null;
        if (lastEvent && lastEvent.created_at) {
            await setSyncMeta('lastEventTimestamp', lastEvent.created_at);
        }

        console.log('Background IndexedDB save complete: ' + saved + ' events, ' + totalDataRecords + ' records');

        // Clear in-memory cache after successful IndexedDB save to free memory
        // (functions will now read from IndexedDB)
        inMemoryEvents = null;
        inMemoryEventsByRecord = null;
        window.IN_MEMORY_DATA = null;

    } catch (err) {
        console.error('Background IndexedDB save failed:', err);
        // Keep in-memory cache if save failed
    } finally {
        isBackgroundSaveInProgress = false;
    }
}

// Process a CSV file directly (called from skipAuthAndUploadCSV or loading overlay)
async function processCSVFile(file) {
        try {
            // Update the loading overlay to show import progress
            updateLoadingOverlay('Importing from file...', 'Reading CSV...', 5, 0, 0, 0, 'Starting import...');

            var text = await file.text();
            var lines = text.split(/\r?\n/);

            if (lines.length < 2) {
                alert('CSV file is empty or has no data rows.');
                return;
            }

            // Parse header
            var header = parseCSVLine(lines[0]);
            var idIndex = header.indexOf('id');
            var setIndex = header.indexOf('set');
            var recordIdIndex = header.indexOf('recordId');
            var operatorIndex = header.indexOf('operator');
            var createdAtIndex = header.indexOf('created_at');
            var payloadIndex = header.indexOf('payload');

            if (idIndex === -1) {
                alert('CSV must have an "id" column.');
                return;
            }

            updateLoadingOverlay('Importing from file...', 'Parsing CSV data...', 10, 0, 0, 0, '');

            // Parse all event rows
            var events = [];
            var tablesCount = 0;
            var fieldsCount = 0;
            var recordsCount = 0;

            for (var i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                var fields = parseCSVLine(lines[i]);
                var event = {
                    id: parseInt(fields[idIndex], 10)
                };

                if (isNaN(event.id)) continue;

                if (setIndex !== -1) event.set = fields[setIndex] || '';
                if (recordIdIndex !== -1) event.recordId = fields[recordIdIndex] || '';
                if (operatorIndex !== -1 && fields[operatorIndex]) event.operator = fields[operatorIndex];
                if (createdAtIndex !== -1) event.created_at = fields[createdAtIndex] || '';
                if (payloadIndex !== -1) {
                    var payloadStr = fields[payloadIndex] || '{}';
                    try {
                        event.payload = JSON.parse(payloadStr);
                    } catch (err) {
                        event.payload = payloadStr;
                    }
                }

                events.push(event);

                // Count types for progress display
                if (event.payload && event.payload._set) {
                    if (event.payload._set === 'table') tablesCount++;
                    else if (event.payload._set === 'field') fieldsCount++;
                    else recordsCount++;
                } else {
                    recordsCount++;
                }

                if (i % 5000 === 0) {
                    var progress = 10 + Math.round((i / lines.length) * 40);
                    updateLoadingOverlay('Importing from file...', 'Parsed ' + events.length.toLocaleString() + ' events...', progress, tablesCount, fieldsCount, recordsCount, '');
                }
            }

            if (events.length === 0) {
                alert('No valid events found in CSV.');
                return;
            }

            // Sort events by ID to ensure proper order
            events.sort(function(a, b) { return a.id - b.id; });

            updateLoadingOverlay('Importing from file...', 'Processing ' + events.length.toLocaleString() + ' events...', 55, tablesCount, fieldsCount, recordsCount, '');

            // Store events in memory for instant access (before IndexedDB save)
            inMemoryEvents = events;
            inMemoryEventsByRecord = buildInMemoryEventsByRecord(events);

            // Process events using fast memory-only approach (no IndexedDB)
            await processEventsMemoryOnly(events, function(processed, total, tableCount) {
                var pct = 55 + Math.round((processed / total) * 30);
                updateLoadingOverlay('Importing from file...', 'Processing events: ' + processed.toLocaleString() + ' / ' + total.toLocaleString(), pct, tableCount, fieldsCount, recordsCount, '');
            });

            // Update the last event timestamp in memory
            var maxId = events.reduce(function(max, e) { return Math.max(max, e.id); }, 0);
            var lastEvent = events.find(function(e) { return e.id === maxId; });
            if (lastEvent && lastEvent.created_at) {
                lastEventTimestamp = lastEvent.created_at;
            }

            updateLoadingOverlay('Import complete!', 'Rendering interface...', 90, tablesCount, fieldsCount, recordsCount, '');

            // Render the UI immediately - data is in memory
            await renderSidebar();

            // Auto-select first table
            var firstTable = Object.keys(META_TABLES)[0];
            if (firstTable) {
                await showTable(firstTable);
            }

            // Hide overlay - app is ready to use!
            updateLoadingOverlay('Import complete!', events.length.toLocaleString() + ' events loaded', 100, tablesCount, fieldsCount, recordsCount, '');
            setTimeout(hideLoadingOverlay, 300);

            updateStatus('Up to date', true, null, null);

            // Start the refresh indicator countdown
            lastSyncTime = Date.now();
            startRefreshCountdown();

            // Synapse sync is started after init()  no API_KEY polling needed.

            // Background: Save to IndexedDB for next visit (non-blocking)
            // This happens after the UI is ready, so user can start working immediately
            updateStatus('Caching locally...', true, null, null);
            backgroundSaveToIndexedDB(events, function(saved, total) {
                var pct = Math.round((saved / total) * 100);
                updateStatus('Caching: ' + pct + '%', true, null, null);
            }).then(function() {
                updateStatus('Up to date', true, null, null);
            });

        } catch (err) {
            console.error('Error importing file:', err);
            alert('Error importing file: ' + err.message);
        }
}

// Also keep the original function for calls from the loading overlay (opens file picker)
async function skipSetupAndUploadFile() {
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;
        await processCSVFile(file);
    };
    input.click();
}

// ============ .amo Snapshot Import ============

// Process an .amo file directly (called from skipAuthAndUploadAmo or loading overlay)
async function processAmoFile(file) {

        try {
            updateLoadingOverlay('Importing .amo snapshot...', 'Reading file...', 5, 0, 0, 0, '');

            var buffer = await file.arrayBuffer();

            // Detect and validate format
            var format;
            try {
                format = AmoFormat.detectFormat(buffer);
            } catch (err) {
                alert('Unrecognized file format. Please select a valid .amo snapshot file.');
                return;
            }

            updateLoadingOverlay('Importing .amo snapshot...', 'Parsing snapshot data...', 15, 0, 0, 0, '');

            var amoData;
            if (format === 'amo') {
                amoData = AmoFormat.read(buffer);
            } else if (format === 'json-gz') {
                var decompressed = pako.ungzip(new Uint8Array(buffer), { to: 'string' });
                var records = JSON.parse(decompressed);
                amoData = { tables: {}, cursor: 0, ts: Math.floor(Date.now() / 1000) };
                // Convert flat snapshot records to table-grouped format
                for (var i = 0; i < records.length; i++) {
                    var rec = records[i];
                    var tbl = rec.source_table || 'unknown';
                    if (!amoData.tables[tbl]) amoData.tables[tbl] = [];
                    var rowData = Object.assign({}, rec.data || {});
                    if (rec.record_id) rowData.record_id = rec.record_id;
                    amoData.tables[tbl].push(rowData);
                    if (rec.last_amino_event > amoData.cursor) amoData.cursor = rec.last_amino_event;
                }
            } else if (format === 'json') {
                var text = new TextDecoder().decode(buffer);
                var records = JSON.parse(text);
                amoData = { tables: {}, cursor: 0, ts: Math.floor(Date.now() / 1000) };
                for (var i = 0; i < records.length; i++) {
                    var rec = records[i];
                    var tbl = rec.source_table || 'unknown';
                    if (!amoData.tables[tbl]) amoData.tables[tbl] = [];
                    var rowData = Object.assign({}, rec.data || {});
                    if (rec.record_id) rowData.record_id = rec.record_id;
                    amoData.tables[tbl].push(rowData);
                    if (rec.last_amino_event > amoData.cursor) amoData.cursor = rec.last_amino_event;
                }
            } else {
                alert('Unsupported snapshot format.');
                return;
            }

            var tableNames = Object.keys(amoData.tables);
            if (tableNames.length === 0) {
                alert('Snapshot file contains no data.');
                return;
            }

            updateLoadingOverlay('Importing .amo snapshot...', 'Building tables and fields...', 40, tableNames.length, 0, 0, '');

            // Restore table/field metadata from snapshot if available
            var savedMeta = amoData.meta || {};
            if (savedMeta.tables) {
                var savedTableIds = Object.keys(savedMeta.tables);
                for (var m = 0; m < savedTableIds.length; m++) {
                    var tid = savedTableIds[m];
                    META_TABLES[tid] = savedMeta.tables[tid];
                }
            }
            if (savedMeta.fields) {
                var savedFieldTableIds = Object.keys(savedMeta.fields);
                for (var m = 0; m < savedFieldTableIds.length; m++) {
                    var tid = savedFieldTableIds[m];
                    if (!META_FIELDS[tid]) META_FIELDS[tid] = {};
                    var fieldIds = Object.keys(savedMeta.fields[tid]);
                    for (var f = 0; f < fieldIds.length; f++) {
                        META_FIELDS[tid][fieldIds[f]] = savedMeta.fields[tid][fieldIds[f]];
                    }
                }
            }

            // Build IN_MEMORY_DATA, META_TABLES, and META_FIELDS from snapshot
            var tableDataMap = {};
            var totalRecords = 0;
            var totalFields = 0;

            for (var t = 0; t < tableNames.length; t++) {
                var fullTableName = tableNames[t];
                var tableId = fullTableName.replace('airtable:', '');
                var rows = amoData.tables[fullTableName];

                // Create placeholder table metadata only if not already restored from snapshot meta
                if (!META_TABLES[tableId]) {
                    META_TABLES[tableId] = {
                        tableId: tableId,
                        tableName: tableId,
                        _placeholder: true
                    };
                }

                if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
                if (!tableDataMap[tableId]) tableDataMap[tableId] = {};

                for (var r = 0; r < rows.length; r++) {
                    var row = rows[r];
                    var recordId = row.record_id;
                    if (!recordId) continue;

                    // Build data object excluding record_id
                    var data = {};
                    var keys = Object.keys(row);
                    for (var k = 0; k < keys.length; k++) {
                        if (keys[k] !== 'record_id') {
                            data[keys[k]] = row[keys[k]];

                            // Auto-create placeholder field metadata only if not already restored
                            if (!META_FIELDS[tableId][keys[k]]) {
                                META_FIELDS[tableId][keys[k]] = {
                                    tableId: tableId,
                                    fieldId: keys[k],
                                    fieldName: keys[k],
                                    fieldType: inferFieldType(row[keys[k]]),
                                    _placeholder: true
                                };
                                totalFields++;
                            }
                        }
                    }

                    tableDataMap[tableId][recordId] = data;
                    totalRecords++;

                    if (totalRecords % 5000 === 0) {
                        var pct = 40 + Math.round((t / tableNames.length) * 40);
                        updateLoadingOverlay('Importing .amo snapshot...', 'Processed ' + totalRecords.toLocaleString() + ' records...', pct, tableNames.length, totalFields, totalRecords, '');
                        await new Promise(function(resolve) { setTimeout(resolve, 0); });
                    }
                }
            }

            // Store in memory for immediate UI access
            window.IN_MEMORY_DATA = tableDataMap;

            // Set the snapshot cursor so incremental sync only fetches records newer than the file
            if (amoData.cursor > 0) {
                await AminoSync.setLastSnapshotEventId(amoData.cursor);
                console.log('[AmoImport] Set lastSnapshotEventId to ' + amoData.cursor + ' from imported file');
            }

            updateLoadingOverlay('Import complete!', 'Rendering interface...', 90, tableNames.length, totalFields, totalRecords, '');

            // Render the UI
            await renderSidebar();

            // Auto-select first table
            var firstTable = Object.keys(META_TABLES)[0];
            if (firstTable) {
                await showTable(firstTable);
            }

            // Hide overlay
            updateLoadingOverlay('Import complete!', totalRecords.toLocaleString() + ' records from ' + tableNames.length + ' tables', 100, tableNames.length, totalFields, totalRecords, '');
            setTimeout(hideLoadingOverlay, 300);

            updateStatus('Up to date', true, null, null);

            // Start the refresh indicator countdown
            lastSyncTime = Date.now();
            startRefreshCountdown();

            console.log('AMO import complete: ' + totalRecords + ' records across ' + tableNames.length + ' tables');

        } catch (err) {
            console.error('Error importing .amo file:', err);
            alert('Error importing .amo file: ' + err.message);
        }
}

// Also keep the original function for calls from the loading overlay (opens file picker)
async function skipSetupAndUploadAmoFile() {
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.amo';
    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;
        await processAmoFile(file);
    };
    input.click();
}


// ============ Point in Time View ============

var _pitRevertState = null; // Stores reconstructed state for revert

async function viewRecordAtPointInTime(eventId, recordId, set) {
    // Coerce numeric-looking IDs back to numbers for consistent comparison
    if (typeof eventId === 'string' && /^\d+$/.test(eventId)) {
        eventId = Number(eventId);
    }
    var overlay = document.getElementById('pit-modal-overlay');
    var body = document.getElementById('pit-modal-body');

    // Show loading state
    body.innerHTML = '<div class="pit-empty-state"><div class="loading-spinner"></div><h3>Replaying events...</h3><p>Building record state at event #' + eventId + '</p></div>';
    overlay.classList.add('open');

    try {
        // Get all events for this record up to the specified event ID
        var events = await getRawEventsByRecordId(recordId, eventId);

        if (events.length === 0) {
            body.innerHTML = '<div class="pit-empty-state"><h3>No events found</h3><p>Could not find any events for this record.</p></div>';
            return;
        }

        // Determine the table ID from the set
        var tableId = set ? set.replace('airtable:', '') : null;

        // Replay events to build the record state
        var recordState = {};
        var lastTimestamp = null;

        for (var e of events) {
            var payload = parsePayload(e.payload);
            if (!payload || !payload.fields) continue;

            var fields = payload.fields;

            // Default first ALT as INS if record state is empty and no INS exists
            if (Object.keys(recordState).length === 0 && !fields.INS && fields.ALT) {
                fields = { INS: fields.ALT, NUL: fields.NUL };
            }

            // Apply INS (insert)
            if (fields.INS) {
                Object.assign(recordState, fields.INS);
            }

            // Apply ALT (alter)
            if (fields.ALT) {
                Object.assign(recordState, fields.ALT);
            }

            // Apply SYN (sync)
            if (fields.SYN) {
                Object.assign(recordState, fields.SYN);
            }

            // Apply NUL (nullify)
            if (fields.NUL && Array.isArray(fields.NUL)) {
                fields.NUL.forEach(k => delete recordState[k]);
            }

            if (e.created_at) {
                lastTimestamp = e.created_at;
            }
        }

        // Update modal header
        var tableName = resolveTableName(tableId);
        document.getElementById('pit-modal-title').textContent = tableName;
        document.getElementById('pit-modal-event-badge').textContent = 'Event #' + eventId;
        document.getElementById('pit-modal-timestamp').textContent = lastTimestamp ? formatTimestamp(new Date(lastTimestamp).getTime()) : '';

        // Render the record state
        var html = '<div class="pit-record-card">';
        html += '<div class="pit-record-header">';
        html += '<span class="pit-table-name">' + esc(tableName) + '</span>';
        html += '<span class="pit-record-id">' + esc(recordId) + '</span>';
        if (tableId && META_TABLES[tableId]) {
            html += '<button class="event-action-btn pit-go-to-table" onclick="goToRecordInTable(\'' + esc(tableId) + '\', \'' + esc(recordId) + '\')">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M6 3L11 8L6 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
            html += 'View Current Record';
            html += '</button>';
        }
        html += '</div>';

        html += '<div class="pit-record-fields">';

        var fieldIds = Object.keys(recordState);
        if (fieldIds.length === 0) {
            var hasEncryptedEvents = events.some(function(e) { return !!e._encryptedPayload; });
            var emptyMsg = hasEncryptedEvents
                ? 'Event payloads are encrypted. Unlock encryption to view field data.'
                : 'No fields recorded at this point in time';
            html += '<div class="pit-empty-state">' + esc(emptyMsg) + '</div>';
        } else {
            // Sort fields by name
            var fieldsInfo = META_FIELDS[tableId] || {};
            fieldIds.sort((a, b) => {
                var nameA = (fieldsInfo[a]?.fieldName || a).toLowerCase();
                var nameB = (fieldsInfo[b]?.fieldName || b).toLowerCase();
                return nameA.localeCompare(nameB);
            });

            for (var fieldId of fieldIds) {
                var fieldName = fieldsInfo[fieldId]?.fieldName || fieldId;
                var value = recordState[fieldId];

                html += '<div class="pit-field-row">';
                html += '<div class="pit-field-name">' + esc(fieldName) + '</div>';
                html += '<div class="pit-field-value">' + formatHistoryValue(value) + '</div>';
                html += '</div>';
            }
        }

        html += '</div>'; // .pit-record-fields

        // Revert action
        html += '<div class="pit-record-actions">';
        html += '<button class="pit-revert-btn" onclick="revertRecordToPointInTime()" title="Revert this record to the state shown above">';
        html += '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M2 2v5h5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.5 7A6.5 6.5 0 1 1 3 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';
        html += 'Revert to This State';
        html += '</button>';
        html += '</div>';

        html += '</div>'; // .pit-record-card

        // Store state for revert
        _pitRevertState = { tableId: tableId, recordId: recordId, fields: recordState, eventId: eventId };

        body.innerHTML = html;

    } catch (err) {
        console.error('Error viewing record at point in time:', err);
        _pitRevertState = null;
        body.innerHTML = '<div class="pit-empty-state"><h3>Error</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closePitModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('pit-modal-overlay').classList.remove('open');
    _pitRevertState = null;
}

async function revertRecordToPointInTime() {
    if (!_pitRevertState) return;

    var state = _pitRevertState;
    var btn = document.querySelector('.pit-revert-btn');

    // Two-click confirmation
    if (!btn.classList.contains('pit-revert-confirm')) {
        btn.classList.add('pit-revert-confirm');
        btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M8 3v5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><circle cx="8" cy="11.5" r="0.75" fill="currentColor"/><circle cx="8" cy="8" r="6.5" stroke="currentColor" stroke-width="1.5"/></svg> Confirm Revert?';
        return;
    }

    btn.disabled = true;
    btn.textContent = 'Reverting...';

    try {
        await editRecord(state.tableId, state.recordId, state.fields);
        btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M3 8.5L6.5 12L13 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg> Reverted';
        btn.style.background = 'rgba(34, 197, 94, 0.15)';
        btn.style.color = '#4ade80';
        _pitRevertState = null;
        setTimeout(function() { closePitModal(); }, 1200);
    } catch (err) {
        console.error('Error reverting record:', err);
        btn.disabled = false;
        btn.classList.remove('pit-revert-confirm');
        btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M2 2v5h5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.5 7A6.5 6.5 0 1 1 3 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg> Revert Failed - Retry';
        btn.style.background = 'rgba(239, 68, 68, 0.15)';
        btn.style.color = '#f87171';
    }
}

function goToRecordInTable(tableId, recordId) {
    closePitModal();
    showTable(tableId);
    // Open the record profile after navigating
    setTimeout(function() {
        openRecordProfile(tableId, recordId);
    }, 100);
}

// ============ Record Profile Panel ============

var profileCurrentTableId = null;
var profileCurrentRecordId = null;
var profileConfigureMode = false;
var profileFieldPicker = null;

// Default profile configuration - one block with all visible fields in 2 columns
function getDefaultProfileConfig(tableId, viewId) {
    var visibleFields = getVisibleFieldsForView(tableId, viewId || '_default');
    return {
        blocks: [
            {
                id: 'block-1',
                columns: 2,
                fieldIds: visibleFields.slice()
            }
        ]
    };
}

// Get profile configuration for a view
// Returns { config: {...}, isDefault: boolean }
function getProfileConfig(tableId, viewId) {
    var view = META_VIEWS[tableId]?.[viewId || '_default'];
    if (view && view.profileConfig && view.profileConfig.blocks && view.profileConfig.blocks.length > 0) {
        return { config: view.profileConfig, isDefault: false };
    }
    return { config: getDefaultProfileConfig(tableId, viewId), isDefault: true };
}

// Save profile configuration for a view
async function saveProfileConfig(tableId, viewId, config) {
    viewId = viewId || '_default';
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId
        };
    }
    META_VIEWS[tableId][viewId].profileConfig = config;
    await saveView(META_VIEWS[tableId][viewId]);
}

// Open record profile panel
async function openRecordProfile(tableId, recordId, viewId) {
    profileCurrentTableId = tableId;
    profileCurrentRecordId = recordId;

    // Use current view if not specified
    if (!viewId && tableId === currentTable) {
        viewId = currentView;
    }

    var overlay = document.getElementById('record-profile-overlay');
    overlay.classList.add('open');

    // Update header - use display name field value if set, otherwise table name
    var tableName = resolveTableName(tableId);
    var profileDisplayTitle = tableName;
    var dnFieldId = getDisplayNameFieldId(tableId);
    if (dnFieldId) {
        var dnRecords = await getRecordsByIds(tableId, [recordId]);
        if (dnRecords.length > 0) {
            var dnFields = dnRecords[0].fields || {};
            var dnFieldMeta = (META_FIELDS[tableId] || {})[dnFieldId];
            var dnValue = dnFields[dnFieldId];
            if (dnValue === undefined && dnFieldMeta) dnValue = dnFields[dnFieldMeta.fieldName];
            if (dnValue != null && dnValue !== '') {
                profileDisplayTitle = String(dnValue);
            }
        }
    }
    document.getElementById('profile-title').textContent = profileDisplayTitle;

    // Show view name
    var actualViewId = viewId || currentView || '_default';
    var viewData = META_VIEWS[tableId]?.[actualViewId];
    var viewName = viewData?.viewName || (actualViewId === '_default' ? 'All Fields' : actualViewId);
    document.getElementById('profile-view-name').textContent = viewName;

    document.getElementById('profile-record-id').textContent = recordId;

    try {
        _saveRecentProfileRecord({
            recordId: recordId,
            tableId: tableId || '',
            title: profileDisplayTitle || recordId,
            subtitle: tableName || ''
        });
    } catch (e) {}

    // Reset configure mode
    profileConfigureMode = false;
    document.getElementById('profile-body').classList.remove('configure-mode');
    document.getElementById('profile-add-block-btn').style.display = 'none';
    document.getElementById('profile-configure-btn').innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg> Configure';

    // Reset to details tab
    profileCurrentTab = 'details';
    document.querySelectorAll('.profile-tab').forEach(function(tab) {
        tab.classList.toggle('active', tab.dataset.tab === 'details');
    });
    document.getElementById('profile-tab-details').classList.add('active');
    document.getElementById('profile-tab-sync-history').classList.remove('active');
    document.getElementById('profile-tab-record-history').classList.remove('active');

    // Render profile content
    await renderRecordProfile();

    // Update navigation
    updateProfileNavigation();
}

// Close record profile panel
function closeRecordProfile(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('record-profile-overlay').classList.remove('open');
    closeFieldPicker();
    profileCurrentTableId = null;
    profileCurrentRecordId = null;
}

// Render the record profile content
async function renderRecordProfile() {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var body = document.getElementById('profile-body');
    var viewId = currentView || '_default';

    // Get record data  try cache/IndexedDB first, then fall back to room history
    var records = await getRecordsByIds(profileCurrentTableId, [profileCurrentRecordId]);
    var recordSource = null; // Track where the record came from
    var record;
    if (records.length > 0) {
        record = records[0];
        recordSource = 'db';
    } else {
        // Record not in IndexedDB or in-memory  try to reconstruct from Matrix room history
        try {
            if (typeof AminoData !== 'undefined' && AminoData.getRecordMutationHistory) {
                var histResult = await AminoData.getRecordMutationHistory(profileCurrentTableId, profileCurrentRecordId, { rebuildState: true });
                if (histResult && histResult.state && Object.keys(histResult.state).length > 0) {
                    record = { tableId: profileCurrentTableId, recordId: profileCurrentRecordId, fields: histResult.state };
                    recordSource = 'room_history';
                }
            }
        } catch (roomHistErr) {
            console.warn('[Profile] Could not reconstruct record from room history:', roomHistErr.message);
        }
    }
    if (!record) {
        body.innerHTML = '<div class="profile-empty-state">Record not found in local database or room history</div>';
        return;
    }

    var recordFields = record.fields || {};
    var fields = META_FIELDS[profileCurrentTableId] || {};

    // Compute formula column values for this record
    _applyFormulaSingleRecord(profileCurrentTableId, fields, recordFields, profileCurrentRecordId);

    // Get profile configuration
    var profileResult = getProfileConfig(profileCurrentTableId, viewId);
    var config = profileResult.config;
    var isDefaultConfig = profileResult.isDefault;

    var html = '';

    // Show source banner when record was resolved from room history
    if (recordSource === 'room_history') {
        html += '<div class="profile-source-banner room-history">';
        html += '<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><path d="M8 3v5l3 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="1.5"/></svg>';
        html += '<span>Reconstructed from room history &mdash; this record is not yet in the local database</span>';
        html += '</div>';
    }

    config.blocks.forEach(function(block, blockIndex) {
        html += '<div class="profile-block" data-block-index="' + blockIndex + '">';

        // Block header (visible in configure mode)
        html += '<div class="profile-block-header">';
        html += '<span class="block-drag-handle" draggable="true" ondragstart="handleBlockDragStart(event, ' + blockIndex + ')" ondragover="handleBlockDragOver(event)" ondrop="handleBlockDrop(event, ' + blockIndex + ')">&#8942;&#8942;</span>';
        html += '<span class="block-title">Block ' + (blockIndex + 1) + '</span>';
        html += '<select class="block-cols-select" onchange="setBlockColumns(' + blockIndex + ', this.value)">';
        html += '<option value="1"' + (block.columns === 1 ? ' selected' : '') + '>1 column</option>';
        html += '<option value="2"' + (block.columns === 2 ? ' selected' : '') + '>2 columns</option>';
        html += '<option value="3"' + (block.columns === 3 ? ' selected' : '') + '>3 columns</option>';
        html += '</select>';
        html += '<button class="block-remove-btn" onclick="removeProfileBlock(' + blockIndex + ')" title="Remove block">&times;</button>';
        html += '</div>';

        // Block content
        html += '<div class="profile-block-content">';
        html += '<div class="profile-field-grid cols-' + block.columns + '">';

        block.fieldIds.forEach(function(fieldId, fieldIndex) {
            var field = fields[fieldId];
            var fieldName = field?.fieldName || fieldId;
            var value = recordFields[fieldId];
            if (value === undefined) value = recordFields[fieldName];

            // Skip fields with no data when using default config and not in configure mode
            var isEmpty = value == null || value === '' || (Array.isArray(value) && value.length === 0);
            if (isEmpty && isDefaultConfig && !profileConfigureMode) {
                return; // Skip this field
            }

            html += '<div class="profile-field-card" data-field-id="' + esc(fieldId) + '" data-block-index="' + blockIndex + '" data-field-index="' + fieldIndex + '" draggable="true" ondragstart="handleFieldDragStart(event)" ondragover="handleFieldDragOver(event)" ondragleave="handleFieldDragLeave(event)" ondrop="handleFieldDrop(event)">';
            var pfIsComputed = field && isComputedFieldType(field.fieldType);
            var pfIsReadOnly = (!field) || (!pfIsComputed && field && isReadOnlyField(field));
            html += '<div class="profile-field-name">';
            html += '<span class="field-drag-handle">&#8942;&#8942;</span>';
            html += esc(fieldName);
            if (pfIsComputed) {
                var _pfVisual = computedFieldVisual(field.fieldType);
                html += '<span class="' + _pfVisual.badgeClass + '" onclick="event.stopPropagation(); showFormulaInfoPopover(this, META_FIELDS[\'' + esc(profileCurrentTableId) + '\'][\'' + esc(fieldId) + '\'])" title="Click to see ' + esc(computedFieldLabel(field.fieldType).toLowerCase()) + ' details">' + esc(computedFieldLabel(field.fieldType)) + '</span>';
            } else if (pfIsReadOnly) {
                html += '<span class="readonly-badge" title="This field is read-only">' + esc(field ? readOnlyFieldLabel(field) : 'Linked') + '</span>';
            }
            if (profileConfigureMode) {
                html += '<button style="margin-left: auto; background: none; border: none; color: #ccc; cursor: pointer; font-size: 12px;" onclick="removeFieldFromBlock(' + blockIndex + ', ' + fieldIndex + ')">&times;</button>';
            }
            html += '</div>';
            if (pfIsComputed) {
                // Formula fields: show value as read-only, click shows info popover
                if (isEmpty) {
                    html += '<div class="profile-field-value empty formula-readonly" data-edit-field-id="' + esc(fieldId) + '"></div>';
                } else {
                    html += '<div class="profile-field-value formula-readonly" data-edit-field-id="' + esc(fieldId) + '">' + formatCell(value, field?.fieldType) + '</div>';
                }
            } else if (pfIsReadOnly) {
                // Read-only fields: show value without edit handler
                if (isEmpty) {
                    html += '<div class="profile-field-value empty field-readonly" data-edit-field-id="' + esc(fieldId) + '"></div>';
                } else {
                    html += '<div class="profile-field-value field-readonly" data-edit-field-id="' + esc(fieldId) + '">' + formatCell(value, field?.fieldType) + '</div>';
                }
            } else if (isEmpty) {
                html += '<div class="profile-field-value empty" data-edit-field-id="' + esc(fieldId) + '" onclick="startProfileFieldEdit(this)"></div>';
            } else {
                html += '<div class="profile-field-value" data-edit-field-id="' + esc(fieldId) + '" onclick="startProfileFieldEdit(this)">' + formatCell(value, field?.fieldType) + '</div>';
            }
            html += '</div>';
        });

        html += '</div>'; // .profile-field-grid

        // Add field button (visible in configure mode)
        html += '<button class="profile-add-field-btn" onclick="showFieldPicker(event, ' + blockIndex + ')">+ Add Field</button>';

        html += '</div>'; // .profile-block-content
        html += '</div>'; // .profile-block
    });

    body.innerHTML = html;

    // Maintain configure mode if active
    if (profileConfigureMode) {
        body.classList.add('configure-mode');
    }
}

// Toggle configure mode
function toggleProfileConfigureMode() {
    profileConfigureMode = !profileConfigureMode;
    var body = document.getElementById('profile-body');
    var addBlockBtn = document.getElementById('profile-add-block-btn');
    var configureBtn = document.getElementById('profile-configure-btn');

    if (profileConfigureMode) {
        body.classList.add('configure-mode');
        addBlockBtn.style.display = '';
        configureBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"/></svg> Done';
    } else {
        body.classList.remove('configure-mode');
        addBlockBtn.style.display = 'none';
        configureBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg> Configure';
        closeFieldPicker();
    }

    renderRecordProfile();
}

// Set block columns
async function setBlockColumns(blockIndex, columns) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].columns = parseInt(columns);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Add a new block
async function addProfileBlock() {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    config.blocks.push({
        id: 'block-' + (config.blocks.length + 1) + '-' + Date.now(),
        columns: 2,
        fieldIds: []
    });

    await saveProfileConfig(profileCurrentTableId, viewId, config);
    renderRecordProfile();
}

// Remove a block
async function removeProfileBlock(blockIndex) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks.length > 1) {
        config.blocks.splice(blockIndex, 1);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Show field picker dropdown
async function showFieldPicker(event, blockIndex) {
    event.stopPropagation();
    closeFieldPicker();

    var recordFields = {};
    if (profileCurrentTableId && profileCurrentRecordId) {
        var pickerRecords = await getRecordsByIds(profileCurrentTableId, [profileCurrentRecordId]);
        if (pickerRecords.length > 0) recordFields = pickerRecords[0].fields || {};
    }
    var fieldOptions = getProfileLayoutFieldOptions(recordFields);

    var picker = document.createElement('div');
    picker.className = 'profile-field-picker';
    picker.innerHTML = '<div class="profile-field-picker-header">Add Field</div>';

    fieldOptions.forEach(function(option) {
        var fieldId = option.fieldId;
        var fieldName = option.fieldName;
        var fieldType = option.fieldType;

        var item = document.createElement('div');
        item.className = 'profile-field-picker-item';
        item.innerHTML = '<span>' + esc(fieldName) + '</span><span class="field-type-badge">' + esc(fieldType) + '</span>';
        item.onclick = function() {
            addFieldToBlock(blockIndex, fieldId);
            closeFieldPicker();
        };
        picker.appendChild(item);
    });

    // Position the picker
    var rect = event.target.getBoundingClientRect();
    picker.style.left = rect.left + 'px';
    picker.style.top = (rect.bottom + 4) + 'px';

    document.body.appendChild(picker);
    profileFieldPicker = picker;

    // Close on outside click
    setTimeout(function() {
        document.addEventListener('click', closeFieldPickerOnOutsideClick);
    }, 0);
}

function closeFieldPickerOnOutsideClick(event) {
    if (profileFieldPicker && !profileFieldPicker.contains(event.target)) {
        closeFieldPicker();
    }
}

function closeFieldPicker() {
    if (profileFieldPicker) {
        profileFieldPicker.remove();
        profileFieldPicker = null;
        document.removeEventListener('click', closeFieldPickerOnOutsideClick);
    }
}

function getProfileLayoutFieldOptions(recordFields) {
    var tableFields = META_FIELDS[profileCurrentTableId] || {};
    var optionsById = {};

    Object.keys(tableFields).forEach(function(fieldId) {
        var field = tableFields[fieldId] || {};
        optionsById[fieldId] = {
            fieldId: fieldId,
            fieldName: field.fieldName || fieldId,
            fieldType: field.fieldType || 'text'
        };
    });

    Object.keys(recordFields || {}).forEach(function(fieldKey) {
        if (optionsById[fieldKey]) return;
        optionsById[fieldKey] = {
            fieldId: fieldKey,
            fieldName: fieldKey,
            fieldType: 'linked'
        };
    });

    return Object.keys(optionsById).map(function(fid) { return optionsById[fid]; }).sort(function(a, b) {
        return String(a.fieldName || a.fieldId).toLowerCase().localeCompare(String(b.fieldName || b.fieldId).toLowerCase());
    });
}

// Add field to a block
async function addFieldToBlock(blockIndex, fieldId) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].fieldIds.push(fieldId);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Remove field from a block
async function removeFieldFromBlock(blockIndex, fieldIndex) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].fieldIds.splice(fieldIndex, 1);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Field drag and drop
var profileDragData = null;

function handleFieldDragStart(event) {
    if (!profileConfigureMode) {
        event.preventDefault();
        return;
    }
    var card = event.target.closest('.profile-field-card');
    profileDragData = {
        type: 'field',
        blockIndex: parseInt(card.dataset.blockIndex),
        fieldIndex: parseInt(card.dataset.fieldIndex),
        fieldId: card.dataset.fieldId
    };
    card.classList.add('dragging');
    event.dataTransfer.effectAllowed = 'move';
}

function handleFieldDragOver(event) {
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'field') return;
    event.preventDefault();
    var card = event.target.closest('.profile-field-card');
    if (card) {
        card.classList.add('drag-over');
    }
}

function handleFieldDragLeave(event) {
    var card = event.target.closest('.profile-field-card');
    if (card) {
        card.classList.remove('drag-over');
    }
}

async function handleFieldDrop(event) {
    event.preventDefault();
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'field') return;

    var targetCard = event.target.closest('.profile-field-card');
    if (!targetCard) return;

    var targetBlockIndex = parseInt(targetCard.dataset.blockIndex);
    var targetFieldIndex = parseInt(targetCard.dataset.fieldIndex);

    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    // Remove from source
    var fieldId = config.blocks[profileDragData.blockIndex].fieldIds.splice(profileDragData.fieldIndex, 1)[0];

    // Adjust target index if in same block and after source
    if (targetBlockIndex === profileDragData.blockIndex && targetFieldIndex > profileDragData.fieldIndex) {
        targetFieldIndex--;
    }

    // Insert at target
    config.blocks[targetBlockIndex].fieldIds.splice(targetFieldIndex, 0, fieldId);

    await saveProfileConfig(profileCurrentTableId, viewId, config);

    profileDragData = null;
    renderRecordProfile();
}

// Block drag and drop
function handleBlockDragStart(event, blockIndex) {
    if (!profileConfigureMode) {
        event.preventDefault();
        return;
    }
    profileDragData = {
        type: 'block',
        blockIndex: blockIndex
    };
    event.dataTransfer.effectAllowed = 'move';
}

function handleBlockDragOver(event) {
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'block') return;
    event.preventDefault();
}

async function handleBlockDrop(event, targetBlockIndex) {
    event.preventDefault();
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'block') return;

    if (targetBlockIndex === profileDragData.blockIndex) return;

    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    // Remove from source
    var block = config.blocks.splice(profileDragData.blockIndex, 1)[0];

    // Adjust target index if after source
    if (targetBlockIndex > profileDragData.blockIndex) {
        targetBlockIndex--;
    }

    // Insert at target
    config.blocks.splice(targetBlockIndex, 0, block);

    await saveProfileConfig(profileCurrentTableId, viewId, config);

    profileDragData = null;
    renderRecordProfile();
}

// ============ Inline Field Editing ============

var profileEditingFieldId = null;
var _profileEditCommitExplicit = false;

async function startProfileFieldEdit(element) {
    if (profileConfigureMode) return;
    if (profileEditingFieldId) return;

    // Don't edit if clicking a link
    if (event && event.target.tagName === 'A') return;

    var fieldId = element.dataset.editFieldId;
    if (!fieldId) return;

    // Don't edit formula/computed/read-only fields
    var pfField = META_FIELDS[profileCurrentTableId]?.[fieldId];
    if (!pfField) return;
    if (pfField && isReadOnlyField(pfField)) return;

    profileEditingFieldId = fieldId;

    // Get current record data
    var records = await getRecordsByIds(profileCurrentTableId, [profileCurrentRecordId]);
    if (records.length === 0) { profileEditingFieldId = null; return; }

    var record = records[0];
    var recordFields = record.fields || {};
    var field = META_FIELDS[profileCurrentTableId]?.[fieldId];
    var fieldType = field?.fieldType || 'text';

    // Resolve the value (try fieldId first, then fieldName)
    var currentValue = recordFields[fieldId];
    if (currentValue === undefined && field?.fieldName) {
        currentValue = recordFields[field.fieldName];
    }

    var input;
    if (fieldType === 'checkbox' || typeof currentValue === 'boolean') {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = !!currentValue;
        input.className = 'profile-edit-checkbox';
        input.onchange = function() {
            _profileEditCommitExplicit = true;
            commitProfileFieldEdit(fieldId, input.checked, currentValue);
        };
    } else if (Array.isArray(currentValue) || (typeof currentValue === 'object' && currentValue !== null)) {
        input = document.createElement('textarea');
        input.className = 'profile-edit-input';
        input.value = JSON.stringify(currentValue, null, 2);
        input.rows = 4;
    } else {
        var strValue = currentValue != null ? String(currentValue) : '';
        if (strValue.length > 100 || strValue.includes('\n')) {
            input = document.createElement('textarea');
            input.className = 'profile-edit-input';
            input.value = strValue;
            input.rows = 3;
        } else {
            input = document.createElement('input');
            input.type = (fieldType === 'number' || typeof currentValue === 'number') ? 'number' : 'text';
            input.className = 'profile-edit-input';
            input.value = strValue;
        }
    }

    if (input.type !== 'checkbox') {
        input.onkeydown = function(e) {
            if (e.key === 'Enter' && !e.shiftKey && input.tagName !== 'TEXTAREA') {
                e.preventDefault();
                _profileEditCommitExplicit = true;
                commitProfileFieldEdit(fieldId, parseProfileEditValue(input.value, currentValue, fieldType), currentValue);
            }
            if (e.key === 'Escape') {
                cancelProfileFieldEdit();
            }
        };
        input.onblur = function() {
            setTimeout(function() {
                if (profileEditingFieldId === fieldId) {
                    _profileEditCommitExplicit = false;
                    commitProfileFieldEdit(fieldId, parseProfileEditValue(input.value, currentValue, fieldType), currentValue);
                }
            }, 150);
        };
    }

    element.innerHTML = '';
    element.appendChild(input);
    element.classList.add('editing');

    input.focus();
    if (input.select) input.select();
}

function parseProfileEditValue(strValue, originalValue, fieldType) {
    if (strValue === '') return '';

    if (typeof originalValue === 'number' || fieldType === 'number') {
        var num = Number(strValue);
        if (!isNaN(num)) return num;
    }

    if (Array.isArray(originalValue) || (typeof originalValue === 'object' && originalValue !== null)) {
        try { return JSON.parse(strValue); } catch (e) { return strValue; }
    }

    return strValue;
}

async function commitProfileFieldEdit(fieldId, newValue, originalValueFromInput) {
    if (!profileEditingFieldId) return;
    var wasExplicit = _profileEditCommitExplicit;
    _profileEditCommitExplicit = false;

    var tableId = profileCurrentTableId;
    var recordId = profileCurrentRecordId;
    if (!tableId || !recordId) { profileEditingFieldId = null; return; }

    // Safety: if the edit would clear a non-empty field and the commit was
    // triggered by blur (not an explicit Enter), cancel instead of saving.
    var preEditValue = originalValueFromInput;
    var wouldClear = (newValue === '' || newValue === null || newValue === undefined) &&
                     preEditValue != null && preEditValue !== '' &&
                     !(typeof preEditValue === 'boolean');
    if (wouldClear && !wasExplicit) {
        profileEditingFieldId = null;
        renderRecordProfile();
        return;
    }

    profileEditingFieldId = null;

    // Get current record
    var records = await getRecordsByIds(tableId, [recordId]);
    if (records.length === 0) return;

    var record = records[0];
    var recordFields = record.fields || {};
    var field = META_FIELDS[tableId]?.[fieldId];

    // Determine the key used in the record fields
    var fieldKey = fieldId;
    var oldValue = recordFields[fieldId];
    if (oldValue === undefined && field?.fieldName && recordFields[field.fieldName] !== undefined) {
        fieldKey = field.fieldName;
        oldValue = recordFields[fieldKey];
    }

    // Skip if value hasn't changed
    if (JSON.stringify(oldValue) === JSON.stringify(newValue)) {
        renderRecordProfile();
        return;
    }

    // Build the field changes payload using the field key (name or id)
    var fieldChanges = {};
    fieldChanges[fieldKey] = newValue;

    // Use editRecord for optimistic write + server sync.
    // editRecord handles IndexedDB update, API call, offline queue, and
    // dispatches amino:record-updated which re-renders the UI.
    try {
        var result = await editRecord(tableId, recordId, fieldChanges);
        if (result && result.queued) {
            // Edit was queued offline  don't show undo toast
        } else {
            // Show undo toast after successful save
            showUndoToast(tableId, recordId, fieldId, fieldKey, oldValue);
        }
    } catch (err) {
        console.error('[WriteAPI] Edit failed for', recordId, fieldKey, err);
        // editRecord already handled rollback/queue and showed error toast.
        renderRecordProfile();
    }
}

function cancelProfileFieldEdit() {
    profileEditingFieldId = null;
    renderRecordProfile();
}

// ============ Toast Notifications ============

var _appDialogResolver = null;

function _closeAppDialog(result) {
    var overlay = document.getElementById('app-dialog-overlay');
    if (overlay) {
        overlay.classList.remove('open');
        overlay.setAttribute('aria-hidden', 'true');
        overlay.inert = true;
    }
    document.removeEventListener('keydown', _onAppDialogKeydown);
    if (_appDialogResolver) {
        var resolver = _appDialogResolver;
        _appDialogResolver = null;
        resolver(result);
    }
}

function _onAppDialogKeydown(event) {
    if (event.key === 'Escape') {
        event.preventDefault();
        _closeAppDialog({ confirmed: false });
    }
}

function showAppDialog(options) {
    options = options || {};
    var overlay = document.getElementById('app-dialog-overlay');
    var titleEl = document.getElementById('app-dialog-title');
    var messageEl = document.getElementById('app-dialog-message');
    var errorEl = document.getElementById('app-dialog-error');
    var inputEl = document.getElementById('app-dialog-input');
    var selectEl = document.getElementById('app-dialog-select');
    var cancelBtn = document.getElementById('app-dialog-cancel');
    var confirmBtn = document.getElementById('app-dialog-confirm');
    if (!overlay || !titleEl || !messageEl || !cancelBtn || !confirmBtn) return Promise.resolve({ confirmed: false });

    titleEl.textContent = options.title || 'Confirm';
    messageEl.textContent = options.message || '';
    errorEl.textContent = '';
    cancelBtn.textContent = options.cancelText || 'Cancel';
    confirmBtn.textContent = options.confirmText || 'Confirm';

    inputEl.style.display = options.input ? '' : 'none';
    inputEl.value = options.defaultValue || '';
    inputEl.placeholder = options.placeholder || '';

    selectEl.style.display = options.selectOptions ? '' : 'none';
    selectEl.innerHTML = '';
    if (options.selectOptions) {
        options.selectOptions.forEach(function(opt, idx) {
            var option = document.createElement('option');
            option.value = String(idx);
            option.textContent = opt.label;
            option.disabled = !!opt.disabled;
            selectEl.appendChild(option);
        });
        if (typeof options.defaultSelectedIndex === 'number') {
            selectEl.value = String(options.defaultSelectedIndex);
        }
    }

    var overlayClick = function(e) {
        if (e.target === overlay) _closeAppDialog({ confirmed: false });
    };
    var onCancel = function() { _closeAppDialog({ confirmed: false }); };
    var onConfirm = function() {
        var value = options.input ? inputEl.value : null;
        var selectedIndex = options.selectOptions ? parseInt(selectEl.value, 10) : null;
        if (options.validate) {
            var validation = options.validate({ value: value, selectedIndex: selectedIndex });
            if (validation) {
                errorEl.textContent = validation;
                return;
            }
        }
        _closeAppDialog({ confirmed: true, value: value, selectedIndex: selectedIndex });
    };

    cancelBtn.onclick = onCancel;
    confirmBtn.onclick = onConfirm;
    overlay.onclick = overlayClick;
    document.addEventListener('keydown', _onAppDialogKeydown);

    overlay.classList.add('open');
    overlay.setAttribute('aria-hidden', 'false');
    overlay.inert = false;

    setTimeout(function() {
        if (options.input) inputEl.focus();
        else if (options.selectOptions) selectEl.focus();
        else confirmBtn.focus();
    }, 0);

    return new Promise(function(resolve) {
        _appDialogResolver = function(result) {
            overlay.onclick = null;
            resolve(result);
        };
    });
}

function showToast(type, message, durationMs) {
    var container = document.getElementById('toast-container');
    if (!container) return;

    if (durationMs === undefined) {
        durationMs = type === 'error' ? 0 : (type === 'saving' ? 2000 : 3000);
    }

    var toast = document.createElement('div');
    toast.className = 'toast toast-' + type;

    if (type === 'saving') {
        toast.innerHTML = '<div class="toast-spinner"></div>';
    }

    var span = document.createElement('span');
    span.textContent = message;
    toast.appendChild(span);

    if (type === 'error' || durationMs === 0) {
        var btn = document.createElement('button');
        btn.className = 'toast-dismiss';
        btn.innerHTML = '&times;';
        btn.onclick = function() { dismissToast(toast); };
        toast.appendChild(btn);
    }

    container.appendChild(toast);

    if (durationMs > 0) {
        setTimeout(function() { dismissToast(toast); }, durationMs);
    }

    return toast;
}

function dismissToast(toast) {
    if (!toast || toast.classList.contains('removing')) return;
    toast.classList.add('removing');
    toast.addEventListener('animationend', function() {
        if (toast.parentNode) toast.parentNode.removeChild(toast);
    });
    // Fallback removal
    setTimeout(function() {
        if (toast.parentNode) toast.parentNode.removeChild(toast);
    }, 300);
}

// ============ Undo Toast ============

function showUndoToast(tableId, recordId, fieldId, fieldKey, previousValue) {
    var container = document.getElementById('toast-container');
    if (!container) return;

    var toast = document.createElement('div');
    toast.className = 'toast toast-undo';

    var span = document.createElement('span');
    span.textContent = 'Field updated';
    toast.appendChild(span);

    var undoBtn = document.createElement('button');
    undoBtn.className = 'toast-undo-btn';
    undoBtn.textContent = 'Undo';
    var undoUsed = false;
    undoBtn.onclick = function() {
        if (undoUsed) return;
        undoUsed = true;
        dismissToast(toast);
        // Revert the field to its previous value
        var revertChanges = {};
        revertChanges[fieldKey] = previousValue !== undefined ? previousValue : null;
        editRecord(tableId, recordId, revertChanges).then(function() {
            showToast('success', 'Change reverted');
        }).catch(function(err) {
            console.error('[Undo] Revert failed', err);
        });
    };
    toast.appendChild(undoBtn);

    var dismissBtn = document.createElement('button');
    dismissBtn.className = 'toast-dismiss';
    dismissBtn.innerHTML = '&times;';
    dismissBtn.onclick = function() { dismissToast(toast); };
    toast.appendChild(dismissBtn);

    container.appendChild(toast);

    // Auto-dismiss after 5 seconds
    setTimeout(function() { dismissToast(toast); }, 5000);

    return toast;
}

// ============ Write API  editRecord ============

var WRITE_API_BASE = 'https://n8n.intelechia.com/webhook/amino-write';

async function editRecord(tableId, recordId, fieldChanges) {
    var session = _loadSynapseSession();
    if (!session || !session.accessToken) {
        throw new Error('Not authenticated  cannot save to server');
    }

    //  Stage 1: Optimistic local update 
    var previousRecord = await getRecord(tableId, recordId);
    if (!previousRecord) {
        throw new Error('Record not found in local store');
    }
    var previousFields = previousRecord.fields || {};
    var optimisticFields = {};
    for (var k in previousFields) {
        optimisticFields[k] = previousFields[k];
    }
    for (var k2 in fieldChanges) {
        optimisticFields[k2] = fieldChanges[k2];
    }

    // Write optimistic state to IndexedDB immediately
    await saveDataRecord({
        tableId: tableId,
        recordId: recordId,
        fields: optimisticFields
    });

    // Track this write so the /sync echo from n8n can be suppressed 
    // the room event will carry the same fields we already applied locally.
    if (typeof AminoData !== 'undefined' && AminoData.trackOptimisticWrite) {
        AminoData.trackOptimisticWrite(recordId, fieldChanges);
    }

    // Update in-memory data if present
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
        for (var k3 in fieldChanges) {
            window.IN_MEMORY_DATA[tableId][recordId][k3] = fieldChanges[k3];
        }
    }

    // Dispatch optimistic UI update
    window.dispatchEvent(new CustomEvent('amino:record-updated', {
        detail: { recordId: recordId, tableId: tableId, fields: optimisticFields, optimistic: true }
    }));

    // Toast: saving
    var savingToast = showToast('saving', 'Saving...');
    var editStartTime = Date.now();
    var changedFieldCount = Object.keys(fieldChanges).length;

    try {
        //  Stage 2: Write to server 
        // Flat endpoint: PATCH /webhook/amino-write with {tableId, recordId, fields} in body
        var writeUrl = WRITE_API_BASE;
        var writeBody = JSON.stringify({ tableId: tableId, recordId: recordId, fields: fieldChanges, access_token: session.accessToken });
        var response;

        try {
            response = await fetch(
                writeUrl + '?access_token=' + encodeURIComponent(session.accessToken),
                {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: writeBody
                }
            );
        } catch (patchErr) {
            // CORS preflight failure  retry with header auth
            console.warn('[editRecord] Query-param PATCH failed (' + patchErr.message + '), retrying with header auth');
            response = await fetch(writeUrl, {
                method: 'PATCH',
                headers: {
                    'Authorization': 'Bearer ' + session.accessToken,
                    'Content-Type': 'application/json'
                },
                body: writeBody
            });
        }

        // Dismiss the saving toast
        dismissToast(savingToast);

        if (!response.ok) {
            throw new Error('Server returned ' + response.status);
        }

        var result = await response.json();

        //  Stage 3: Confirm with canonical data 
        if (result.fields) {
            await saveDataRecord({
                tableId: tableId,
                recordId: recordId,
                fields: result.fields
            });

            // Update in-memory data with canonical snapshot
            if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
                window.IN_MEMORY_DATA[tableId][recordId] = result.fields;
            }

            // Dispatch canonical UI update
            window.dispatchEvent(new CustomEvent('amino:record-updated', {
                detail: { recordId: recordId, tableId: tableId, fields: result.fields, optimistic: false }
            }));
        }

        // Matrix event is NOT sent from the client  n8n handles it after
        // writing to Airtable, ensuring the event only fires on successful
        // Airtable write and keeping Postgres current_state consistent.

        // Record successful local edit in sync history
        var editDuration = Date.now() - editStartTime;
        SyncHistory.record({
            type: 'edit',
            result: 'success',
            eventsFound: changedFieldCount,
            duration: editDuration,
            detail: 'Local edit propagated: ' + recordId + ' (' + changedFieldCount + ' field' + (changedFieldCount !== 1 ? 's' : '') + ')'
        });
        SyncStatusFeed.success('Edit propagated: ' + recordId + ' \u2192 ' + changedFieldCount + ' field' + (changedFieldCount !== 1 ? 's' : '') + ' updated (' + editDuration + 'ms)');

        showToast('success', 'Saved \u2713');
        return result;

    } catch (err) {
        // Dismiss saving toast if still visible
        dismissToast(savingToast);

        //  Stage 4: Queue for offline retry instead of rolling back 
        // Keep the optimistic local data so the user sees their edit.
        // Enqueue the edit so it can be replayed when connectivity returns.
        try {
            await OfflineSyncQueue.enqueue(tableId, recordId, fieldChanges, err.message);
        } catch (queueErr) {
            console.error('[editRecord] Failed to enqueue offline edit:', queueErr);
            // If we can't even queue, roll back as last resort
            await saveDataRecord({ tableId: tableId, recordId: recordId, fields: previousFields });
            if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
                window.IN_MEMORY_DATA[tableId][recordId] = previousFields;
            }
            window.dispatchEvent(new CustomEvent('amino:record-updated', {
                detail: { recordId: recordId, tableId: tableId, fields: previousFields, optimistic: false, rolledBack: true }
            }));
            showToast('error', 'Save failed \u2014 please try again');
            throw err;
        }

        // Record the queued edit in sync history
        var editDuration = Date.now() - editStartTime;
        SyncHistory.record({
            type: 'edit',
            result: 'queued',
            eventsFound: changedFieldCount,
            duration: editDuration,
            error: err.message,
            detail: 'Edit queued offline: ' + recordId + ' \u2014 ' + err.message
        });

        showToast('warning', 'Saved locally \u2014 will sync when online');
        return { queued: true, recordId: recordId, tableId: tableId };
    }
}

// ============ Case Notes  Creation & Client Linking ============
// Case Notes are ingested as a regular table through the standard webhook
// pipeline (/amino-tables, /amino-records). This module handles creation
// of new case notes and linking them to clients via airtableId.

var CaseNotesAPI = (function() {
    'use strict';

    // Resolve a table ID from META_TABLES by name pattern
    function _normalizeTableName(value) {
        return String(value || '')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '')
            .replace(/s$/, '');
    }

    function _resolveTableId(pattern, fallback) {
        var tables = Object.keys(META_TABLES || {});
        var p = (pattern || '').toLowerCase();
        var fb = (fallback || '').toLowerCase();
        var pn = _normalizeTableName(pattern);
        var fbn = _normalizeTableName(fallback);
        for (var i = 0; i < tables.length; i++) {
            var name = resolveTableName(tables[i]).toLowerCase();
            if (name === p) return tables[i];
        }
        // Normalized exact match to handle punctuation/plurals (e.g., Case_Notes)
        if (pn) {
            for (var i2 = 0; i2 < tables.length; i2++) {
                var nExact = _normalizeTableName(resolveTableName(tables[i2]));
                if (nExact === pn) return tables[i2];
            }
        }
        for (var j = 0; j < tables.length; j++) {
            var n = resolveTableName(tables[j]).toLowerCase();
            if (n.includes(p)) return tables[j];
        }
        if (pn) {
            for (var j2 = 0; j2 < tables.length; j2++) {
                var nContains = _normalizeTableName(resolveTableName(tables[j2]));
                if (nContains.includes(pn)) return tables[j2];
            }
        }
        if (fb) {
            for (var k = 0; k < tables.length; k++) {
                var fn = resolveTableName(tables[k]).toLowerCase();
                if (fn.includes(fb)) return tables[k];
            }
        }
        if (fbn) {
            for (var k2 = 0; k2 < tables.length; k2++) {
                var fnNorm = _normalizeTableName(resolveTableName(tables[k2]));
                if (fnNorm.includes(fbn)) return tables[k2];
            }
        }
        return null;
    }

    function getCaseNotesTableId() {
        return _resolveTableId('case note', 'note');
    }

    function getClientsTableId() {
        return _resolveTableId('client info', 'client');
    }

    var CASE_NOTES_WEBHOOK = 'https://n8n.intelechia.com/webhook/caseNotes';

    // Generate a unique ID for new case notes
    function _generateNoteId() {
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
            return crypto.randomUUID();
        }
        // Fallback for older browsers
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0;
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    }

    // Create a new case note by POSTing to the dedicated caseNotes webhook.
    // Sends a flat JSON body  only "id" is required; all other fields are optional.
    async function createCaseNote(noteData) {
        if (!noteData || !noteData.client_airtable_id) {
            throw new Error('client_airtable_id is required to link the case note to a client');
        }

        var session = _loadSynapseSession();
        if (!session || !session.accessToken) {
            throw new Error('Not authenticated');
        }

        var tableId = getCaseNotesTableId();

        var now = new Date();
        var noteId = _generateNoteId();

        // Set creation metadata
        var userId = session.userId || '';
        var createdBy = userId.replace(/@([^:]+):.*/, '$1');

        // Build flat payload matching the caseNotes webhook schema.
        // Only "id" is truly required; everything else defaults to empty string if missing.
        var payload = {
            id: noteId,
            Activity: noteData.Activity || '',
            Type: noteData.Type || '',
            Date: noteData.Date || now.toISOString(),
            Description: noteData.Description || '',
            Contact: noteData.Contact || '',
            Client_PP_ID: noteData.Client_PP_ID || '',
            Matter: noteData.Matter || '',
            RecordId: noteData.RecordId || '',
            Created_By: createdBy,
            Softr_Link_to_clients: noteData.client_airtable_id,
            Updated: now.toISOString(),
            Modified: now.toISOString(),
            Due_Date: noteData.Due_Date || '',
            Last_Update_By: createdBy,
            unix_timestamp: String(Math.floor(now.getTime() / 1000)),
            time_raw: now.toISOString(),
            tags: Array.isArray(noteData.tags) ? noteData.tags.join(', ') : (noteData.tags || ''),
            pp_note_id: noteData.pp_note_id || '',
            matter_id: noteData.matter_id || '',
            source: noteData.source || '',
            client_airtable_id: noteData.client_airtable_id,
            eventId: noteData.eventId || ''
        };

        // POST to the dedicated caseNotes webhook (access_token in body for auth)
        payload.access_token = session.accessToken;
        var response;
        try {
            response = await fetch(
                CASE_NOTES_WEBHOOK + '?access_token=' + encodeURIComponent(session.accessToken),
                { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }
            );
        } catch (fetchErr) {
            response = await fetch(CASE_NOTES_WEBHOOK, {
                method: 'POST',
                headers: { 'Authorization': 'Bearer ' + session.accessToken, 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
        }

        if (!response.ok) {
            var errText = '';
            try { errText = await response.text(); } catch (e) {}
            throw new Error('Failed to create case note: ' + response.status + (errText ? ' (' + errText.substring(0, 100) + ')' : ''));
        }

        var result;
        try { result = await response.json(); } catch (e) { result = { id: noteId }; }

        // Store locally so it appears in the table immediately
        var rid = result.recordId || result.id || noteId;
        var localFields = {
            Activity: payload.Activity,
            Type: payload.Type,
            Date: payload.Date,
            Description: payload.Description,
            Contact: payload.Contact,
            Client_PP_ID: payload.Client_PP_ID,
            Matter: payload.Matter,
            Created_By: payload.Created_By,
            Softr_Link_to_clients: payload.Softr_Link_to_clients,
            Updated: payload.Updated,
            Modified: payload.Modified,
            Due_Date: payload.Due_Date,
            Last_Update_By: payload.Last_Update_By,
            tags: payload.tags,
            matter_id: payload.matter_id,
            source: payload.source,
            client_airtable_id: payload.client_airtable_id
        };
        if (tableId) {
            try {
                await saveDataRecord({ tableId: tableId, recordId: rid, fields: localFields });
                if (window.IN_MEMORY_DATA) {
                    if (!window.IN_MEMORY_DATA[tableId]) window.IN_MEMORY_DATA[tableId] = {};
                    window.IN_MEMORY_DATA[tableId][rid] = localFields;
                }
                window.dispatchEvent(new CustomEvent('amino:record-updated', {
                    detail: { recordId: rid, tableId: tableId, fields: localFields, optimistic: false }
                }));
            } catch (e) { /* non-fatal */ }
        }

        return result;
    }

    // Populate the client dropdown from the existing Clients table data
    async function _populateClientDropdown() {
        var select = document.getElementById('cn-client');
        if (!select) return;
        select.innerHTML = '<option value="">Select a client...</option>';

        var clientsTableId = getClientsTableId();
        if (!clientsTableId) {
            select.innerHTML = '<option value="">No clients table found</option>';
            return;
        }

        // Read clients from the same data stores the rest of the app uses
        var records = [];
        if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[clientsTableId]) {
            var memData = window.IN_MEMORY_DATA[clientsTableId];
            Object.keys(memData).forEach(function(rid) {
                records.push({ recordId: rid, fields: memData[rid] });
            });
        } else if (typeof db !== 'undefined' && db) {
            try {
                var tx = db.transaction('data', 'readonly');
                var dataStore = tx.objectStore('data');
                var index = null;
                try {
                    index = dataStore.index('by_table');
                } catch (e) {
                    index = dataStore.index('byTable');
                }
                var results = await new Promise(function(resolve, reject) {
                    var req = index.getAll(clientsTableId);
                    req.onsuccess = function() { resolve(req.result || []); };
                    req.onerror = function() { reject(req.error); };
                });
                for (var i = 0; i < results.length; i++) {
                    var rec = results[i];
                    if (encryptionEnabled && encryptionKey && (rec._encryptedFields || rec.encrypted || rec._encrypted)) {
                        try { rec = await decryptRecordFromStorage(rec); } catch (e) { continue; }
                    }
                    records.push({ recordId: rec.recordId || rec.id, fields: rec.fields || rec });
                }
            } catch (e) { /* non-fatal */ }
        }

        records.sort(function(a, b) {
            var na = (a.fields['Full Name Client'] || a.fields['Client Name'] || a.fields['Name'] || '').toLowerCase();
            var nb = (b.fields['Full Name Client'] || b.fields['Client Name'] || b.fields['Name'] || '').toLowerCase();
            return na.localeCompare(nb);
        });

        records.forEach(function(r) {
            var name = r.fields['Full Name Client'] || r.fields['Client Name'] || r.fields['Name'] || r.recordId;
            var opt = document.createElement('option');
            opt.value = r.recordId;
            opt.textContent = name;
            select.appendChild(opt);
        });
    }

    function openModal() {
        var modal = document.getElementById('case-note-modal');
        if (!modal) return;
        document.getElementById('cn-activity').value = '';
        document.getElementById('cn-type').value = '';
        document.getElementById('cn-date').value = new Date().toISOString().slice(0, 16);
        document.getElementById('cn-matter').value = '';
        document.getElementById('cn-contact').value = '';
        document.getElementById('cn-description').value = '';
        document.getElementById('cn-due-date').value = '';
        document.getElementById('cn-source').value = '';
        document.getElementById('cn-tags').value = '';
        document.getElementById('cn-status').textContent = '';
        document.getElementById('cn-submit').disabled = false;
        _populateClientDropdown();
        modal.classList.add('open');
    }

    function closeModal(event) {
        if (event && event.target !== event.currentTarget) return;
        var modal = document.getElementById('case-note-modal');
        if (modal) modal.classList.remove('open');
    }

    async function submitNote() {
        var clientId = document.getElementById('cn-client').value;
        if (!clientId) {
            document.getElementById('cn-status').textContent = 'Please select a client.';
            return;
        }

        var submitBtn = document.getElementById('cn-submit');
        var statusEl = document.getElementById('cn-status');
        submitBtn.disabled = true;
        statusEl.textContent = 'Creating case note...';

        var dateVal = document.getElementById('cn-date').value;
        var dueDateVal = document.getElementById('cn-due-date').value;
        var tagsVal = document.getElementById('cn-tags').value.trim();

        try {
            var matterVal = document.getElementById('cn-matter').value.trim();
            await createCaseNote({
                client_airtable_id: clientId,
                Activity: document.getElementById('cn-activity').value.trim(),
                Type: document.getElementById('cn-type').value,
                Date: dateVal ? new Date(dateVal).toISOString() : new Date().toISOString(),
                Description: document.getElementById('cn-description').value.trim(),
                Contact: document.getElementById('cn-contact').value.trim(),
                Matter: matterVal,
                matter_id: matterVal,
                Due_Date: dueDateVal ? new Date(dueDateVal).toISOString() : '',
                source: document.getElementById('cn-source').value.trim() || 'Portal',
                tags: tagsVal ? tagsVal.split(',').map(function(t) { return t.trim(); }).filter(Boolean) : []
            });
            statusEl.textContent = '';
            closeModal();
            showToast('success', 'Case note created');

            // Refresh: invalidate sidebar cache so new record count shows,
            // and re-render current interface page or database table.
            invalidateSidebarCache();
            renderSidebar(true);
            if (typeof InterfaceApp !== 'undefined' && InterfaceApp.activePage) {
                InterfaceApp.renderPage(InterfaceApp.activePage);
            }
            var cnTableId = getCaseNotesTableId();
            if (cnTableId && currentTable === cnTableId) {
                renderTable(cnTableId);
            }
        } catch (err) {
            console.error('[CaseNotesAPI] Creation failed:', err);
            statusEl.textContent = 'Error: ' + err.message;
            submitBtn.disabled = false;
        }
    }

    return {
        createCaseNote: createCaseNote,
        getCaseNotesTableId: getCaseNotesTableId,
        getClientsTableId: getClientsTableId,
        openModal: openModal,
        closeModal: closeModal,
        submitNote: submitNote
    };
})();

// ============ Record Update Event Listener ============

// Debounce sync-triggered re-renders: collect record-update events over a short
// window and apply a single batched re-render instead of N re-renders per burst.
var _syncRenderTimer = null;
var _syncRenderPendingUpdates = []; // { tableId, recordId, fields }

function _flushSyncRenderUpdates() {
    _syncRenderTimer = null;
    var pending = _syncRenderPendingUpdates;
    _syncRenderPendingUpdates = [];
    if (pending.length === 0) return;

    // Check if any updates are for the current table
    var currentTableUpdates = pending.filter(function(u) { return u.tableId === currentTable; });
    if (currentTableUpdates.length === 0) return;

    // Try targeted cell updates for each changed record on the current page
    var didFullRender = false;
    for (var i = 0; i < currentTableUpdates.length; i++) {
        var upd = currentTableUpdates[i];
        var row = document.querySelector('tr[data-record-id="' + CSS.escape(upd.recordId) + '"]');
        if (row && upd.fields) {
            // Record is visible on current page  update cells in place
            var cells = row.querySelectorAll('td.inline-editable, td.cell-computed, td.cell-readonly');
            cells.forEach(function(cell) {
                if (cell === _inlineEditingCell) return;
                var fid = cell.dataset.fieldId;
                if (fid) {
                    var val = upd.fields[fid];
                    var f = META_FIELDS[upd.tableId]?.[fid];
                    if (val === undefined && f?.fieldName) val = upd.fields[f.fieldName];
                    if (val !== undefined) cell.innerHTML = formatCell(val, f?.fieldType);
                }
            });
        } else if (!didFullRender) {
            // Record not visible or no field data  full re-render (once)
            _inlineEditingCell = null;
            renderTable();
            didFullRender = true;
        }
    }
}

window.addEventListener('amino:record-updated', function(e) {
    var detail = e.detail;
    if (!detail || !detail.tableId || !detail.recordId) return;

    // Evict this record from the shared LRU cache so the next read
    // (by Database View or Interface) re-fetches from IDB/IN_MEMORY_DATA.
    var cacheKey = _rcKey(detail.tableId, detail.recordId);
    _recordCache.delete(cacheKey);

    // Only invalidate filter cache when the update is for the current table.
    // Updates to other tables don't affect the currently displayed filter results.
    if (detail.tableId === currentTable) {
        _recordSearchDataVersion++;
        invalidateFilterCache();
    }
    invalidateLocalSearchIndex(detail.tableId, detail.recordId);
    invalidateFormulaResultCache(detail.tableId, detail.recordId);

    // Re-render the record profile if it's showing this record
    if (profileCurrentTableId === detail.tableId && profileCurrentRecordId === detail.recordId) {
        renderRecordProfile();
    }

    // Re-render the table grid if showing the same table
    if (currentTable === detail.tableId) {
        // If an inline edit just committed, update only the affected cells immediately
        // (no debounce for user's own edits  they expect instant feedback).
        if (_inlineEditJustCommitted) {
            _inlineEditJustCommitted = false;
            var row = document.querySelector('tr[data-record-id="' + CSS.escape(detail.recordId) + '"]');
            if (row) {
                var cells = row.querySelectorAll('td.inline-editable, td.cell-computed, td.cell-readonly');
                cells.forEach(function(cell) {
                    if (cell === _inlineEditingCell) return;
                    var fid = cell.dataset.fieldId;
                    if (fid && detail.fields) {
                        var val = detail.fields[fid];
                        var f = META_FIELDS[detail.tableId]?.[fid];
                        if (val === undefined) {
                            if (f?.fieldName) val = detail.fields[f.fieldName];
                        }
                        cell.innerHTML = formatCell(val, f?.fieldType);
                    }
                });
            }
            return;
        }

        // Debounce background sync updates: collect over 300ms, then batch render
        _syncRenderPendingUpdates.push({
            tableId: detail.tableId,
            recordId: detail.recordId,
            fields: detail.fields || null
        });
        if (!_syncRenderTimer) {
            _syncRenderTimer = setTimeout(_flushSyncRenderUpdates, 300);
        }
    }
});

// ============ View Deletion / Restoration from Matrix Sync ============

// When another client (or this client via AminoData) deletes a view, remove it
// from the local UI immediately.
window.addEventListener('amino:view-delete', function(e) {
    var d = e.detail;
    if (!d || !d.tableId || !d.viewId) return;

    var tableId = d.tableId;
    var viewId = d.viewId;

    // Skip if already removed locally (e.g. this client initiated the delete)
    if (META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        delete META_VIEWS[tableId][viewId];
    }

    // Remove from IndexedDB (fire-and-forget)
    if (db) {
        try {
            var tx = db.transaction('views', 'readwrite');
            tx.objectStore('views').delete([tableId, viewId]);
        } catch (e) {
            console.warn('[amino:view-delete] IndexedDB cleanup failed:', e);
        }
    }

    // If the deleted view was active, switch to default
    if (currentTable === tableId && currentView === viewId) {
        currentView = '_default';
        renderViewSelector();
        renderFieldsDropdown();
        updateFieldsCount();
        renderTable();
    }

    // Re-render sidebar view list for the affected table
    var viewsList = document.getElementById('views-list-' + tableId);
    if (viewsList) {
        viewsList.innerHTML = renderViewsListHTML(tableId);
    }

    // Also update the view selector dropdown if showing this table
    if (currentTable === tableId) {
        renderViewSelector();
    }

    console.log('[amino:view-delete] View removed from UI:', viewId, 'in table', tableId,
                '(by', d.deletedBy || 'unknown', ')');
});

// When another client restores a previously deleted view, add it back.
window.addEventListener('amino:view-restore', function(e) {
    var d = e.detail;
    if (!d || !d.tableId || !d.viewId || !d.viewSnapshot) return;

    var tableId = d.tableId;
    var viewId = d.viewId;
    var snapshot = d.viewSnapshot;

    // Re-add to META_VIEWS
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId] = snapshot;
    }

    // Persist back to IndexedDB (fire-and-forget)
    if (db) {
        try {
            var tx = db.transaction('views', 'readwrite');
            tx.objectStore('views').put(snapshot);
        } catch (e) {
            console.warn('[amino:view-restore] IndexedDB persist failed:', e);
        }
    }

    // Re-render sidebar view list for the affected table
    var viewsList = document.getElementById('views-list-' + tableId);
    if (viewsList) {
        viewsList.innerHTML = renderViewsListHTML(tableId);
    }

    // Update view selector dropdown if showing this table
    if (currentTable === tableId) {
        renderViewSelector();
    }

    console.log('[amino:view-restore] View restored to UI:', viewId, 'in table', tableId,
                '(by', d.restoredBy || 'unknown', ')');
});

// ============ Live Field History from Matrix Sync ============

window.addEventListener('amino:record-mutate', function(e) {
    var d = e.detail;
    if (!d || !d.tableId || !d.recordId) return;

    var entries = [];
    var tableId = d.tableId;
    var recordId = d.recordId;
    var eventId = d.eventId || null;
    var timestamp = d.timestamp || Date.now();
    var sender = d.sender || null;
    var source = d.source || null;
    var sourceTimestamp = d.sourceTimestamp || null;
    var actor = d.actor || null;
    var fieldOps = d.fieldOps || {};
    var hasStructuredOps = !!(fieldOps.ALT || fieldOps.INS || fieldOps.NUL || fieldOps.SYN);

    // Common metadata for each history entry
    var baseMeta = {
        tableId: tableId, recordId: recordId,
        eventId: eventId, timestamp: timestamp, sender: sender,
        source: source, sourceTimestamp: sourceTimestamp, actor: actor
    };

    if (hasStructuredOps) {
        if (fieldOps.INS) {
            for (var fid in fieldOps.INS) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: fid, changeType: 'created', oldValue: null, newValue: fieldOps.INS[fid] }));
            }
        }
        if (fieldOps.ALT) {
            for (var fid in fieldOps.ALT) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: fid, changeType: 'updated', oldValue: null, newValue: fieldOps.ALT[fid] }));
            }
        }
        if (fieldOps.SYN) {
            for (var fid in fieldOps.SYN) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: fid, changeType: 'synced', oldValue: null, newValue: fieldOps.SYN[fid] }));
            }
        }
        if (fieldOps.NUL) {
            var nulFields = Array.isArray(fieldOps.NUL) ? fieldOps.NUL : Object.keys(fieldOps.NUL);
            for (var n = 0; n < nulFields.length; n++) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: nulFields[n], changeType: 'deleted', oldValue: null, newValue: null }));
            }
        }
    } else if (d.flatOp && d.flatFields) {
        var op = d.flatOp;
        var ff = d.flatFields;
        if (op === 'INS' || op === 'ALT') {
            var ct = op === 'INS' ? 'created' : 'updated';
            for (var fid in ff) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: fid, changeType: ct, oldValue: null, newValue: ff[fid] }));
            }
        } else if (op === 'NUL') {
            var rk = Array.isArray(ff) ? ff : Object.keys(ff);
            for (var r = 0; r < rk.length; r++) {
                entries.push(Object.assign({}, baseMeta, {
                    fieldId: rk[r], changeType: 'deleted', oldValue: null, newValue: null }));
            }
        }
    }

    // Field history is not stored locally  it lives in Matrix rooms only.
    // Refresh sync history tab if currently viewing this record (will fetch from Matrix).
    if (entries.length > 0 &&
        profileCurrentTab === 'sync-history' &&
        profileCurrentTableId === tableId &&
        profileCurrentRecordId === recordId) {
        renderProfileSyncHistory();
    }
});

// Navigation between records
function updateProfileNavigation() {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var recordIndex = currentRecordIds.indexOf(profileCurrentRecordId);
    var total = currentRecordIds.length;

    document.getElementById('profile-nav-info').textContent = (recordIndex + 1) + ' of ' + total;
    document.getElementById('profile-prev-btn').disabled = recordIndex <= 0;
    document.getElementById('profile-next-btn').disabled = recordIndex >= total - 1;
}

async function navigateProfile(direction) {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var recordIndex = currentRecordIds.indexOf(profileCurrentRecordId);
    var newIndex = recordIndex + direction;

    if (newIndex >= 0 && newIndex < currentRecordIds.length) {
        profileCurrentRecordId = currentRecordIds[newIndex];
        document.getElementById('profile-record-id').textContent = profileCurrentRecordId;
        await renderRecordProfile();
        updateProfileNavigation();

        // Refresh sync history or record history if those tabs are active
        if (profileCurrentTab === 'sync-history') {
            renderProfileSyncHistory();
        } else if (profileCurrentTab === 'record-history') {
            renderProfileRecordHistory();
        }
    }
}

// Open history from profile
function openHistoryFromProfile() {
    if (profileCurrentTableId && profileCurrentRecordId) {
        openHistoryModal(profileCurrentTableId, profileCurrentRecordId);
    }
}

// Profile tab state
var profileCurrentTab = 'details';

// Switch profile tab
function switchProfileTab(tabName) {
    profileCurrentTab = tabName;

    // Update tab buttons
    document.querySelectorAll('.profile-tab').forEach(function(tab) {
        if (tab.dataset.tab === tabName) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // Update tab content
    document.querySelectorAll('.profile-tab-content').forEach(function(content) {
        content.classList.remove('active');
    });

    if (tabName === 'details') {
        document.getElementById('profile-tab-details').classList.add('active');
    } else if (tabName === 'sync-history') {
        document.getElementById('profile-tab-sync-history').classList.add('active');
        renderProfileSyncHistory();
    } else if (tabName === 'record-history') {
        document.getElementById('profile-tab-record-history').classList.add('active');
        renderProfileRecordHistory();
    }
}

// Build field history entries from raw events (used for in-memory events from CSV)
function buildFieldHistoryFromRawEvents(tableId, recordId, events) {
    // Sort events by id ascending (oldest first for proper state tracking)
    var sorted = events.slice().sort((a, b) => (a.id || 0) - (b.id || 0));

    var state = {};
    var fieldHistoryEntries = [];

    for (var e of sorted) {
        if (!e || !e.recordId || e.recordId !== recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var pfields = payload.fields;
        if (!pfields || typeof pfields !== 'object') continue;

        var eventId = e.id;
        var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

        // Process INS (insert/create)
        if (pfields.INS) {
            for (var fieldId in pfields.INS) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'created',
                    oldValue: null,
                    newValue: pfields.INS[fieldId]
                });
            }
            Object.assign(state, pfields.INS);
        }

        // Process ALT (alter/update)
        if (pfields.ALT) {
            for (var fieldId in pfields.ALT) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'updated',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: pfields.ALT[fieldId]
                });
            }
            Object.assign(state, pfields.ALT);
        }

        // Process SYN (sync/snapshot)
        if (pfields.SYN) {
            for (var fieldId in pfields.SYN) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'synced',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: pfields.SYN[fieldId]
                });
            }
            Object.assign(state, pfields.SYN);
        }

        // Process NUL (nullify/delete)
        if (pfields.NUL && Array.isArray(pfields.NUL)) {
            pfields.NUL.forEach(fieldId => {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'deleted',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: null
                });
                delete state[fieldId];
            });
        }

        maybeAddSyntheticCreatedAtHistory(fieldHistoryEntries, {
            tableId: tableId,
            recordId: recordId,
            eventId: eventId,
            timestamp: timestamp
        }, payload, state);
    }

    // Return sorted by eventId descending (most recent first) for display
    return fieldHistoryEntries.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
}

// Render sync history in the profile tab
async function renderProfileSyncHistory() {
    var container = document.getElementById('profile-tab-sync-history');
    if (!profileCurrentTableId || !profileCurrentRecordId) {
        container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No record selected</h3><p>Select a record to view its sync history</p></div>';
        return;
    }

    // Show loading state
    container.innerHTML = '<div class="profile-sync-history-empty"><div class="loading-spinner"></div><h3>Loading sync history...</h3></div>';

    try {
        var history;

        // Check if we have in-memory events (from CSV import) - use them for instant display
        if (inMemoryEventsByRecord && inMemoryEventsByRecord.has(profileCurrentRecordId)) {
            var rawEvents = inMemoryEventsByRecord.get(profileCurrentRecordId);
            history = buildFieldHistoryFromRawEvents(profileCurrentTableId, profileCurrentRecordId, rawEvents);
            // Limit to 100 most recent entries
            if (history.length > 100) {
                history = history.slice(0, 100);
            }
        } else {
            // Fetch on-demand from Postgres events API (activity stream)
            history = await fetchHistoryFromPostgresEvents(profileCurrentTableId, profileCurrentRecordId);
            // Limit to 100 most recent entries
            if (history && history.length > 100) {
                history = history.slice(0, 100);
            }
        }

        if (!history || history.length === 0) {
            container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No sync history available for this record</h3><p>Field changes will appear here after syncing</p></div>';
            return;
        }

        // Get field metadata
        var fields = META_FIELDS[profileCurrentTableId] || {};

        // Render history items
        var html = '<div class="profile-sync-history-list">';

        history.forEach(function(item) {
            var fieldName = getHistoryFieldName(profileCurrentTableId, item.fieldId);
            var changeType = item.changeType || 'updated';
            var _itemTs = item.timestamp || item.sourceTimestamp || null;
            var timestamp = _itemTs ? new Date(_itemTs).toLocaleString() : 'Unknown';
            var sender = item.sender || null;
            // Show short sender (strip @...:server part to just the localpart)
            var senderDisplay = sender ? sender.replace(/^@/, '').replace(/:.*$/, '') : null;
            // Extract source metadata (e.g. "airtable_sync") and actor (e.g. "admin@rklacylaw.com")
            var source = item.source || null;
            var actor = item.actor || null;
            var sourceTimestamp = item.sourceTimestamp ? new Date(item.sourceTimestamp).toLocaleString() : null;

            html += '<div class="profile-sync-history-item">';
            html += '<div class="profile-sync-history-item-header">';
            html += '<span class="profile-sync-history-field">' + esc(fieldName) + '</span>';
            html += '<span class="profile-sync-history-type ' + changeType + '">' + changeType.charAt(0).toUpperCase() + changeType.slice(1) + '</span>';
            if (actor) {
                html += '<span class="profile-sync-history-actor" title="Changed by">' + esc(actor) + '</span>';
            } else if (senderDisplay) {
                html += '<span class="profile-sync-history-sender">' + esc(senderDisplay) + '</span>';
            }
            if (item.device) {
                html += '<span class="profile-sync-history-device" title="Device">' + esc(item.device) + '</span>';
            }
            if (source) {
                html += '<span class="profile-sync-history-source" title="Source: ' + esc(source) + '">' + esc(source.replace(/_/g, ' ')) + '</span>';
            }
            html += '<span class="profile-sync-history-time" title="' + (sourceTimestamp ? 'Source: ' + esc(sourceTimestamp) : '') + '">' + esc(timestamp) + '</span>';
            html += '</div>';

            if (changeType !== 'created' || item.oldValue != null) {
                html += '<div class="profile-sync-history-values">';
                if (item.oldValue != null) {
                    html += '<div class="profile-sync-history-value old">';
                    html += '<div class="profile-sync-history-value-label">Old</div>';
                    html += formatSyncHistoryValue(item.oldValue);
                    html += '</div>';
                }
                if (item.newValue != null) {
                    html += '<div class="profile-sync-history-value new">';
                    html += '<div class="profile-sync-history-value-label">New</div>';
                    html += formatSyncHistoryValue(item.newValue);
                    html += '</div>';
                }
                html += '</div>';
            } else if (item.newValue != null) {
                html += '<div class="profile-sync-history-values">';
                html += '<div class="profile-sync-history-value new">';
                html += '<div class="profile-sync-history-value-label">Value</div>';
                html += formatSyncHistoryValue(item.newValue);
                html += '</div>';
                html += '</div>';
            }

            html += '</div>';
        });

        html += '</div>';
        container.innerHTML = html;

    } catch (err) {
        console.error('Error loading sync history:', err);
        container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>Error loading sync history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Format sync history value for display
function formatSyncHistoryValue(value) {
    if (value == null) return '<em>empty</em>';
    if (typeof value === 'object') {
        return esc(JSON.stringify(value));
    }
    return esc(String(value));
}

// ============ Record History Tab (raw event stream from Postgres) ============

// Render the raw event stream for the current record in the profile panel
async function renderProfileRecordHistory() {
    var container = document.getElementById('profile-tab-record-history');
    if (!profileCurrentTableId || !profileCurrentRecordId) {
        container.innerHTML = '<div class="record-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No record selected</h3><p>Select a record to view its event history</p></div>';
        return;
    }

    container.innerHTML = '<div class="record-history-empty"><div class="loading-spinner"></div><h3>Loading event history...</h3></div>';

    try {
        var result = await AminoData.fetchEventsForRecord(profileCurrentRecordId);
        var events = (result && result.events) ? result.events : [];

        if (events.length === 0) {
            container.innerHTML = '<div class="record-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No events found</h3><p>No event history available for this record in the event log</p></div>';
            return;
        }

        // Sort events by id descending (most recent first)
        events.sort(function(a, b) { return (b.id || 0) - (a.id || 0); });

        var html = '';

        // Header with count and refresh
        html += '<div class="record-history-header">';
        html += '<span class="record-history-count">' + events.length + ' event' + (events.length !== 1 ? 's' : '') + '</span>';
        html += '<button class="record-history-refresh-btn" onclick="renderProfileRecordHistory()" title="Refresh events">Refresh</button>';
        html += '</div>';

        html += '<div class="record-history-list">';

        for (var i = 0; i < events.length; i++) {
            var evt = events[i];
            var payload = parsePayload(evt.payload);
            var operator = evt.operator || '';
            if (!operator && payload && payload.fields) {
                if (payload.fields.INS) operator = 'INS';
                else if (payload.fields.ALT) operator = 'ALT';
                else if (payload.fields.NUL) operator = 'NUL';
                else if (payload.fields.SYN) operator = 'SYN';
            }
            var timestamp = evt.created_at ? formatTimestamp(new Date(evt.created_at).getTime()) : 'Unknown';
            var fullTimestamp = evt.created_at ? new Date(evt.created_at).toLocaleString() : '';
            var setTableId = (evt.set || '').replace('airtable:', '');
            var setDisplay = setTableId ? resolveTableName(setTableId) : (evt.set || '');

            html += '<div class="record-history-event">';

            // Event header
            html += '<div class="record-history-event-header">';
            html += '<span class="record-history-event-id">#' + (evt.id || '?') + '</span>';
            if (operator) {
                html += '<span class="record-history-event-operator ' + esc(operator) + '">' + esc(operator) + '</span>';
            }
            if (evt.set) {
                html += '<span class="record-history-event-set" title="' + esc(evt.set) + '">' + esc(setDisplay) + '</span>';
            }
            if (evt.uuid) {
                html += '<span class="record-history-event-uuid" title="' + esc(evt.uuid) + '">' + esc(evt.uuid) + '</span>';
            }
            html += '<span class="record-history-event-time" title="' + esc(fullTimestamp) + '">' + esc(timestamp) + '</span>';
            html += '</div>';

            // Payload
            html += '<div class="record-history-event-payload" onclick="this.classList.toggle(\'expanded\')">';
            if (payload) {
                html += formatRecordHistoryPayload(payload);
            } else {
                html += '<span style="color: var(--text-disabled); font-style: italic;">No payload</span>';
            }
            html += '</div>';

            // Actions
            html += '<div class="record-history-event-actions">';
            if (evt.id && evt.recordId) {
                html += '<button onclick="viewRecordAtPointInTime(\'' + esc(String(evt.id)) + '\', \'' + esc(evt.recordId) + '\', \'' + esc(evt.set || '') + '\')" title="View record state at this event">';
                html += '<svg viewBox="0 0 16 16" fill="none"><path d="M8 3v5l3 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="1.5"/></svg>';
                html += 'View State';
                html += '</button>';
            }
            html += '</div>';

            html += '</div>';
        }

        html += '</div>';
        container.innerHTML = html;

    } catch (err) {
        console.error('Error loading record history:', err);
        container.innerHTML = '<div class="record-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg><h3>Error loading event history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Format a raw event payload for display in the record history tab
function formatRecordHistoryPayload(payload) {
    if (!payload) return '';

    var fields = payload.fields;
    if (!fields) {
        // Non-field payload, show as JSON
        try {
            return esc(JSON.stringify(payload, null, 2));
        } catch (e) {
            return esc(String(payload));
        }
    }

    var html = '';
    var ops = ['INS', 'ALT', 'SYN', 'NUL'];
    for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        var data = fields[op];
        if (!data) continue;

        if (op === 'NUL' && Array.isArray(data) && data.length > 0) {
            html += '<div style="margin-bottom: 4px;">';
            html += '<span class="record-history-event-operator ' + op + '" style="font-size:10px;">' + op + '</span> ';
            for (var n = 0; n < data.length; n++) {
                var nulFieldName = resolveFieldNameByTable(profileCurrentTableId, data[n]);
                html += '<span style="color: var(--text-muted);">' + esc(nulFieldName) + '</span>';
                if (n < data.length - 1) html += ', ';
            }
            html += '</div>';
        } else if (typeof data === 'object' && !Array.isArray(data)) {
            var keys = Object.keys(data);
            for (var k = 0; k < keys.length; k++) {
                var fieldId = keys[k];
                var fieldName = resolveFieldNameByTable(profileCurrentTableId, fieldId);
                var value = data[fieldId];
                var displayValue = (value === null || value === undefined) ? 'null' : (typeof value === 'object' ? JSON.stringify(value) : String(value));
                // Truncate long values
                if (displayValue.length > 200) displayValue = displayValue.slice(0, 200) + '...';
                html += '<div style="margin-bottom: 2px;">';
                html += '<span class="record-history-event-operator ' + op + '" style="font-size:10px;">' + op + '</span> ';
                html += '<span style="color: var(--text-primary); font-weight: 500;">' + esc(fieldName) + '</span>';
                html += ' <span style="color: var(--text-muted);">=</span> ';
                html += '<span style="color: var(--text-secondary);">' + esc(displayValue) + '</span>';
                html += '</div>';
            }
        }
    }

    return html || esc(JSON.stringify(payload, null, 2));
}

// Resolve field ID to human-readable field name (by table ID)
function resolveFieldNameByTable(tableId, fieldId) {
    if (!tableId || !fieldId) return fieldId || '';
    var fields = META_FIELDS[tableId];
    if (!fields) return fieldId;
    var field = fields[fieldId];
    return field ? (field.fieldName || fieldId) : fieldId;
}

// Handle row click to open profile
function handleRowClick(event, tableId, recordId) {
    // Don't open profile if clicking on a button, link, or interactive element
    if (event.target.closest('button, a, input, select, textarea')) {
        return;
    }
    openRecordProfile(tableId, recordId);
}

// Double-click opens the record profile panel (modal on right)
function handleRowDblClick(event, tableId, recordId) {
    if (event.target.closest('button, a, input, select, textarea')) return;
    // Cancel any pending inline edit on this cell
    var cell = event.target.closest('td.inline-editable');
    if (cell && cell.classList.contains('inline-editing')) {
        cancelInlineCellEdit(cell);
    }
    openRecordProfile(tableId, recordId);
}

// ============ Computed / Formula Field Detection ============

// Airtable field types that are computed (read-only, not user-editable)
var COMPUTED_FIELD_TYPES = ['formula', 'rollup', 'lookup', 'count', 'autoNumber', 'createdTime', 'lastModifiedTime', 'createdBy', 'lastModifiedBy'];

// Additional Airtable field types that are inherently read-only (not computed, but not editable)
var READONLY_FIELD_TYPES = ['button', 'externalSyncSource'];

function isComputedFieldType(fieldType) {
    return COMPUTED_FIELD_TYPES.indexOf(fieldType) !== -1;
}

// Check if a field is read-only (not editable). This includes:
// - Computed field types (formula, rollup, lookup, etc.)
// - Explicitly read-only fields (readOnly flag from Airtable API)
// - Inherently non-editable field types (button, externalSyncSource)
function isReadOnlyField(field) {
    if (!field) return false;
    if (field.readOnly === true) return true;
    if (isComputedFieldType(field.fieldType)) return true;
    if (READONLY_FIELD_TYPES.indexOf(field.fieldType) !== -1) return true;
    return false;
}

// Get a human-readable label for why a field is read-only
function readOnlyFieldLabel(field) {
    if (!field) return 'Read-only';
    if (isComputedFieldType(field.fieldType)) return computedFieldLabel(field.fieldType);
    if (READONLY_FIELD_TYPES.indexOf(field.fieldType) !== -1) {
        var rtLabels = { button: 'Button', externalSyncSource: 'Sync Source' };
        return rtLabels[field.fieldType] || field.fieldType;
    }
    return 'Read-only';
}

// Get a human-readable label for a computed field type
function computedFieldLabel(fieldType) {
    var labels = { formula: 'Formula', rollup: 'Rollup', lookup: 'Lookup', count: 'Count', autoNumber: 'Auto Number', createdTime: 'Created Time', lastModifiedTime: 'Modified Time', createdBy: 'Created By', lastModifiedBy: 'Modified By' };
    return labels[fieldType] || fieldType;
}

// Visual style configuration for computed field types  lookup-driven, not hardcoded.
// Add new computed field types here to automatically get distinct visual treatment
// across the grid, column headers, profile badges, and info popovers.
var COMPUTED_FIELD_VISUALS = {
    lookup: {
        cellClass: 'cell-lookup',
        badgeClass: 'lookup-badge',
        headerIconClass: 'lookup-icon',
        popoverColor: '#0284c7',
        popoverBg: 'rgba(2, 132, 199, 0.15)',
        headerSvg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 0 10h-3m-6 0H6a5 5 0 0 1 0-10h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg>'
    },
    rollup: {
        cellClass: 'cell-rollup',
        badgeClass: 'rollup-badge',
        headerIconClass: 'rollup-icon',
        popoverColor: '#d97706',
        popoverBg: 'rgba(217, 119, 6, 0.15)',
        headerSvg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 2 7 12 12 22 7"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>'
    }
};

// Default visual style for computed types not in the lookup (formula, count, autoNumber, etc.)
var _defaultComputedVisual = {
    cellClass: 'cell-formula',
    badgeClass: 'formula-badge',
    headerIconClass: 'formula-icon',
    popoverColor: '#a78bfa',
    popoverBg: 'rgba(124, 58, 237, 0.15)',
    headerSvg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 2H4a1 1 0 0 0-1 1v5"/><path d="M15 2h5a1 1 0 0 1 1 1v5"/><path d="M20 15v5a1 1 0 0 1-1 1h-5"/><path d="M4 15v5a1 1 0 0 0 1 1h5"/><path d="m9 12 2 2 4-4"/></svg>'
};

// Look up the visual style for a computed field type from the config
function computedFieldVisual(fieldType) {
    return COMPUTED_FIELD_VISUALS[fieldType] || _defaultComputedVisual;
}

// ============ Formula Column Computation ============
// Compute formula-type column values for every record in a recordMap.
// Uses the formula engine exposed by src/formulas/bridge.js (ES module).
//  Field registry fetch  pulls formula/lookup/rollup definitions 
// The amino.field_registry table in Postgres stores Airtable field metadata
// including the options JSONB column which contains formula expressions,
// lookup/rollup configuration, and result type info. This data is critical
// for client-side formula evaluation but isn't included in the /amino-records
// response. We fetch it separately and merge into META_FIELDS.

var _fieldRegistryFetched = {};  // tableId -> true (avoids redundant fetches)

async function fetchFieldRegistry(tableId) {
    if (_fieldRegistryFetched[tableId]) return;

    try {
        var matrixToken = (typeof MatrixClient !== 'undefined' && MatrixClient.getAccessToken && MatrixClient.getAccessToken())
            ? MatrixClient.getAccessToken()
            : (typeof session !== 'undefined' && session && session.accessToken ? session.accessToken : null);

        if (!matrixToken) return;

        var url = N8N_WEBHOOK_BASE + '/amino-fields?tableId=' + encodeURIComponent(tableId) +
                  '&access_token=' + encodeURIComponent(matrixToken);

        var response = await fetch(url);
        if (!response.ok) return;

        var data = await response.json();
        var fields = data.fields;
        if (!Array.isArray(fields) || fields.length === 0) return;

        if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};

        for (var i = 0; i < fields.length; i++) {
            var f = fields[i];
            if (!f.fieldId) continue;

            var existing = META_FIELDS[tableId][f.fieldId];
            if (existing) {
                // Merge: preserve existing data but fill in missing metadata
                if (f.fieldType && (!existing.fieldType || existing.fieldType === 'unknown' || existing._placeholder)) {
                    existing.fieldType = f.fieldType;
                }
                if (f.fieldName && (!existing.fieldName || existing.fieldName === f.fieldId)) {
                    existing.fieldName = f.fieldName;
                }
                // Always update options from field_registry  this is the
                // authoritative source for formula/lookup/rollup definitions.
                if (f.options && typeof f.options === 'object' && Object.keys(f.options).length > 0) {
                    existing.options = f.options;
                }
                if (f.isComputed != null) {
                    existing.isComputed = f.isComputed;
                }
                delete existing._placeholder;
            } else {
                // New field from registry
                META_FIELDS[tableId][f.fieldId] = {
                    tableId: f.tableId || tableId,
                    fieldId: f.fieldId,
                    fieldName: f.fieldName || f.fieldId,
                    fieldType: f.fieldType || 'unknown',
                    options: f.options || {},
                    isComputed: f.isComputed || false
                };
            }

            // Persist to IndexedDB so formulas work offline
            try {
                var fieldToSave = META_FIELDS[tableId][f.fieldId];
                if (typeof saveField === 'function') {
                    await saveField(fieldToSave);
                }
            } catch (_e) {
                // IndexedDB write failed  field metadata still in memory
            }
        }

        // Invalidate compiled formula cache for this table since options changed
        delete _compiledFormulaCache[tableId];
        delete _compiledFormulaCacheKeys[tableId];
        _formulaCompileWarned = {};

        _fieldRegistryFetched[tableId] = true;

        // Also fetch field registries for linked tables (needed for lookups/rollups).
        // We discover linked table IDs from multipleRecordLinks fields' options.
        var linkedTableIds = new Set();
        var tableFields = META_FIELDS[tableId] || {};
        for (var fid in tableFields) {
            var tf = tableFields[fid];
            if (tf && tf.options && tf.options.linkedTableId) {
                linkedTableIds.add(tf.options.linkedTableId);
            }
        }
        // Fetch each linked table's field registry in parallel (non-blocking)
        var linkedPromises = [];
        linkedTableIds.forEach(function(ltid) {
            if (!_fieldRegistryFetched[ltid]) {
                linkedPromises.push(fetchFieldRegistry(ltid));
            }
        });
        if (linkedPromises.length > 0) {
            await Promise.all(linkedPromises);
        }
    } catch (err) {
        console.warn('[FieldRegistry] Failed to fetch field registry for ' + tableId + ':', err.message);
    }
}

// Called from renderTable() and renderRecordProfile() so that ALL rows
// display computed formula values, not just rows that had values stored.

var _compiledFormulaCache = {};   // tableId -> { fieldId -> { fn, deps, fieldName } }
var _compiledFormulaCacheKeys = {}; // tableId -> invalidation key
var _formulaCompileWarned = {};   // fieldId -> true (suppress repeated warnings)
var _disableFormulaEvaluation = false;

// Formula result memoization  caches computed values keyed by
// "tableId|recordId|fieldId" -> { inputHash, value }.
// Avoids re-evaluating formulas when input fields haven't changed.
var _formulaResultCache = {};  // key -> { inputHash, value }
var _FORMULA_RESULT_CACHE_MAX = 20000;

function _formulaInputHash(row, deps) {
    // Fast string hash of the dependency values. Uses JSON.stringify for
    // correctness (handles objects/arrays) with a length cap for speed.
    var parts = '';
    for (var i = 0; i < deps.length; i++) {
        var v = row[deps[i]];
        if (v === undefined || v === null) {
            parts += '|_';
        } else if (typeof v === 'object') {
            parts += '|' + JSON.stringify(v).slice(0, 100);
        } else {
            parts += '|' + String(v);
        }
    }
    return parts;
}

function invalidateFormulaResultCache(tableId, recordId) {
    // Invalidate all formula results for a specific record
    if (!tableId || !recordId) { _formulaResultCache = {}; return; }
    var prefix = tableId + '|' + recordId + '|';
    var keys = Object.keys(_formulaResultCache);
    for (var i = 0; i < keys.length; i++) {
        if (keys[i].indexOf(prefix) === 0) delete _formulaResultCache[keys[i]];
    }
}

function _shouldSkipFormulaColumns(recordCount, formulaCount) {
    if (_disableFormulaEvaluation) return true;
    // Budget guard for very large formula workloads.
    return (recordCount * formulaCount) > 50000;
}

//  Relational field helpers (count, lookup, rollup) 

/**
 * Synchronously fetch a linked record's fields from in-memory caches.
 * Returns null if the record is not available in memory.
 */
function _getLinkedRecordFields(linkedTableId, recordId) {
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[linkedTableId] &&
        window.IN_MEMORY_DATA[linkedTableId][recordId]) {
        return window.IN_MEMORY_DATA[linkedTableId][recordId];
    }
    var cacheKey = linkedTableId + '|' + recordId;
    var cached = _recordCache.get(cacheKey);
    if (cached && cached.fields) return cached.fields;
    return null;
}

/**
 * Apply a rollup aggregation function to an array of values.
 */
function _rollupAggregate(values, aggName) {
    switch (aggName) {
        case 'SUM':
            return values.reduce(function(a, b) { return (a || 0) + (b || 0); }, 0);
        case 'MAX': {
            var nums = values.filter(function(v) { return typeof v === 'number'; });
            return nums.length ? Math.max.apply(null, nums) : null;
        }
        case 'MIN': {
            var nums = values.filter(function(v) { return typeof v === 'number'; });
            return nums.length ? Math.min.apply(null, nums) : null;
        }
        case 'AVERAGE': {
            var nums = values.filter(function(v) { return typeof v === 'number'; });
            return nums.length ? nums.reduce(function(a, b) { return a + b; }, 0) / nums.length : null;
        }
        case 'COUNT':
            return values.filter(function(v) { return typeof v === 'number'; }).length;
        case 'COUNTA':
            return values.filter(function(v) { return v != null && v !== ''; }).length;
        case 'COUNTALL':
            return values.length;
        case 'CONCATENATE':
        case 'ARRAYJOIN':
            return values.map(function(v) { return v != null ? String(v) : ''; }).join(', ');
        case 'ARRAYUNIQUE':
            var seen = {};
            return values.filter(function(v) {
                var k = String(v);
                if (seen[k]) return false;
                seen[k] = true;
                return true;
            });
        case 'ARRAYCOMPACT':
            return values.filter(function(v) { return v != null && v !== ''; });
        case 'AND':
            return values.every(Boolean);
        case 'OR':
            return values.some(Boolean);
        default:
            return values.join(', ');
    }
}

/**
 * Resolve linked record IDs from a record's link field value.
 * Handles both array-of-IDs and array-of-objects formats.
 */
function _resolveLinkedIds(value) {
    if (!Array.isArray(value)) return [];
    return value.map(function(v) {
        if (typeof v === 'string') return v;
        if (v && typeof v === 'object' && v.id) return v.id;
        return null;
    }).filter(Boolean);
}

/**
 * Compute count, lookup, and rollup fields for all records in recordMap.
 * These are relational computations that resolve linked record data.
 * Runs synchronously using in-memory data caches.
 */
function _applyRelationalColumns(tableId, fields, recordMap) {
    if (_disableFormulaEvaluation) return;

    var countFields = [];
    var lookupFields = [];
    var rollupFields = [];

    for (var fid in fields) {
        var f = fields[fid];
        if (!f) continue;
        var opts = f.options || {};
        switch (f.fieldType) {
            case 'count':
                if (opts.recordLinkFieldId) countFields.push(f);
                break;
            case 'lookup':
                if (opts.recordLinkFieldId && opts.fieldIdInLinkedTable) lookupFields.push(f);
                break;
            case 'rollup':
                if (opts.recordLinkFieldId && opts.fieldIdInLinkedTable) rollupFields.push(f);
                break;
        }
    }

    if (countFields.length === 0 && lookupFields.length === 0 && rollupFields.length === 0) return;

    // Build fieldIdfieldName map for current table
    var _fIdToName = {};
    for (var _fid in fields) {
        var _f = fields[_fid];
        if (_f && _f.fieldName) _fIdToName[_fid] = _f.fieldName;
    }

    //  Count fields 
    for (var ci = 0; ci < countFields.length; ci++) {
        var cf = countFields[ci];
        var linkFieldId = cf.options.recordLinkFieldId;
        var linkFieldName = _fIdToName[linkFieldId] || linkFieldId;
        for (var rid in recordMap) {
            var row = recordMap[rid];
            var linkedIds = _resolveLinkedIds(row[linkFieldId] || row[linkFieldName]);
            row[cf.fieldId] = linkedIds.length;
            if (cf.fieldName && cf.fieldName !== cf.fieldId) {
                row[cf.fieldName] = linkedIds.length;
            }
        }
    }

    //  Lookup and rollup fields 
    var relFields = lookupFields.concat(rollupFields);
    if (relFields.length === 0) return;

    for (var ri = 0; ri < relFields.length; ri++) {
        var rf = relFields[ri];
        var linkFieldId = rf.options.recordLinkFieldId;
        var linkField = fields[linkFieldId];
        if (!linkField || !linkField.options || !linkField.options.linkedTableId) continue;

        var linkedTableId = linkField.options.linkedTableId;
        var linkedTableFields = META_FIELDS[linkedTableId] || {};
        var foreignFieldId = rf.options.fieldIdInLinkedTable;
        var foreignFieldEntry = linkedTableFields[foreignFieldId];
        var foreignFieldName = (foreignFieldEntry && foreignFieldEntry.fieldName) || foreignFieldId;
        var linkFieldName = _fIdToName[linkFieldId] || linkFieldId;

        var isRollup = rf.fieldType === 'rollup';
        var aggName = '';
        if (isRollup) {
            var aggFormula = rf.options.formula || 'ARRAYJOIN(values)';
            aggName = aggFormula.replace(/\(values\)/i, '').trim().toUpperCase();
        }

        for (var rid in recordMap) {
            var row = recordMap[rid];
            var linkedIds = _resolveLinkedIds(row[linkFieldId] || row[linkFieldName]);

            if (linkedIds.length === 0) {
                var emptyVal = isRollup ? null : [];
                row[rf.fieldId] = emptyVal;
                if (rf.fieldName && rf.fieldName !== rf.fieldId) row[rf.fieldName] = emptyVal;
                continue;
            }

            // Resolve values from linked records
            var values = [];
            for (var li = 0; li < linkedIds.length; li++) {
                var linkedFields = _getLinkedRecordFields(linkedTableId, linkedIds[li]);
                if (!linkedFields) continue;
                var val = linkedFields[foreignFieldId];
                if (val === undefined) val = linkedFields[foreignFieldName];
                values.push(val);
            }

            var result;
            if (isRollup) {
                result = _rollupAggregate(values, aggName);
            } else {
                result = values;
            }

            row[rf.fieldId] = result;
            if (rf.fieldName && rf.fieldName !== rf.fieldId) {
                row[rf.fieldName] = result;
            }
        }
    }
}

function _applyFormulaColumns(tableId, fields, recordMap) {
    if (_disableFormulaEvaluation) return;

    // Compute count, lookup, and rollup fields first (they don't need the
    // formula parser/compiler and may feed into formula fields).
    _applyRelationalColumns(tableId, fields, recordMap);

    var engine = window._formulaEngine;
    if (!engine) return;

    // Collect formula fields for this table
    var formulaFields = [];
    for (var fid in fields) {
        var f = fields[fid];
        var formulaExpr = f && f.options && (f.options.formula || f.options.expression);
        if (f.fieldType === 'formula' && formulaExpr) {
            formulaFields.push(f);
        }
    }
    if (formulaFields.length === 0) return;

    var recordCount = Object.keys(recordMap).length;
    if (_shouldSkipFormulaColumns(recordCount, formulaFields.length)) {
        // On very large tables, prioritize key display-name formulas so
        // interface views can still render primary identifiers.
        var highPriorityFormulaFields = {
            'Client Name': true,
            'Full Name Client': true,
            'Display Name': true,
            'Name': true
        };
        formulaFields = formulaFields.filter(function(field) {
            return !!highPriorityFormulaFields[field.fieldName] || !!highPriorityFormulaFields[field.fieldId];
        });
        if (!formulaFields.length) return;
        if (_shouldSkipFormulaColumns(recordCount, formulaFields.length)) return;
    }

    // Build / reuse compiled formula cache per table
    var cacheKey = tableId + ':' + formulaFields.map(function(f) {
        var expr = f && f.options && (f.options.formula || f.options.expression) || '';
        return f.fieldId + ':' + expr;
    }).join(',');
    var cached = _compiledFormulaCache[tableId];
    if (!cached || _compiledFormulaCacheKeys[tableId] !== cacheKey) {
        cached = {};
        var compiledList = [];
        for (var i = 0; i < formulaFields.length; i++) {
            var f = formulaFields[i];
            try {
                var formulaExpr = f.options.formula || f.options.expression;
                // Resolve field IDs in the formula expression to human-readable
                // names so that {fldXYZ} references match the aliased record keys.
                formulaExpr = resolveFormulaFieldNames(formulaExpr, tableId);
                var ast = engine.parseAirtableFormula(formulaExpr);
                var refs = engine.collectFieldRefs(ast);
                var fn = engine.compileFormula(ast);
                var entry = { fieldId: f.fieldId, fieldName: f.fieldName, fn: fn, deps: refs };
                cached[f.fieldId] = entry;
                compiledList.push(entry);
            } catch (e) {
                // Log formula compile errors once per field to avoid console spam
                if (!_formulaCompileWarned) _formulaCompileWarned = {};
                if (!_formulaCompileWarned[f.fieldId]) {
                    _formulaCompileWarned[f.fieldId] = true;
                    console.warn('Formula compile error for ' + (f.fieldName || f.fieldId) + ':', e.message);
                }
                // Still register a no-op entry so dependent formulas can resolve
                // their dependency chain (they'll just see null for this field).
                var fallbackEntry = { fieldId: f.fieldId, fieldName: f.fieldName, fn: function() { return null; }, deps: [] };
                cached[f.fieldId] = fallbackEntry;
                compiledList.push(fallbackEntry);
            }
        }

        // Topological sort so dependent formulas execute after their inputs
        var sorted = [];
        var visited = {};
        var visiting = {};
        function visit(entry) {
            if (visited[entry.fieldId]) return;
            if (visiting[entry.fieldId]) return; // circular  skip
            visiting[entry.fieldId] = true;
            for (var j = 0; j < entry.deps.length; j++) {
                var dep = entry.deps[j];
                // dep could be a fieldId or fieldName; check both
                var depEntry = cached[dep];
                if (!depEntry) {
                    // Try matching by fieldName
                    for (var k in cached) {
                        if (cached[k].fieldName === dep) { depEntry = cached[k]; break; }
                    }
                }
                if (depEntry) visit(depEntry);
            }
            delete visiting[entry.fieldId];
            visited[entry.fieldId] = true;
            sorted.push(entry);
        }
        for (var i = 0; i < compiledList.length; i++) visit(compiledList[i]);

        cached._sorted = sorted;
        _compiledFormulaCache[tableId] = cached;
        _compiledFormulaCacheKeys[tableId] = cacheKey;
    }

    var sorted = cached._sorted;
    if (!sorted || sorted.length === 0) return;

    // Build fieldId  fieldName map so formulas (which reference fields by
    // name like {Price}) can resolve values in records keyed by field ID.
    var _idToName = {};
    for (var _fid in fields) {
        var _fm = fields[_fid];
        if (_fm.fieldName && _fm.fieldName !== _fid) {
            _idToName[_fid] = _fm.fieldName;
        }
    }

    // Execute every formula on every record in dependency order.
    // Uses memoization: if the input values (deps) haven't changed since last
    // evaluation, return the cached result instead of re-executing the formula.
    var _frcSize = Object.keys(_formulaResultCache).length;
    if (_frcSize > _FORMULA_RESULT_CACHE_MAX) _formulaResultCache = {};

    for (var rid in recordMap) {
        var row = recordMap[rid];
        // Populate bidirectional nameid aliases so formulas can resolve refs
        for (var _afid in _idToName) {
            var _aname = _idToName[_afid];
            if (row[_afid] !== undefined && row[_aname] === undefined) {
                row[_aname] = row[_afid];
            } else if (row[_aname] !== undefined && row[_afid] === undefined) {
                row[_afid] = row[_aname];
            }
        }
        for (var i = 0; i < sorted.length; i++) {
            var c = sorted[i];
            try {
                // Check formula result cache
                var frcKey = tableId + '|' + rid + '|' + c.fieldId;
                var inputHash = _formulaInputHash(row, c.deps);
                var frcEntry = _formulaResultCache[frcKey];
                if (frcEntry && frcEntry.inputHash === inputHash) {
                    // Cache hit  reuse previous value
                    row[c.fieldId] = frcEntry.value;
                    if (c.fieldName && c.fieldName !== c.fieldId) {
                        row[c.fieldName] = frcEntry.value;
                    }
                    continue;
                }

                var value = c.fn(row, { recordId: rid });
                if (value !== null && value !== undefined && !(value && value.__error)) {
                    row[c.fieldId] = value;
                    if (c.fieldName && c.fieldName !== c.fieldId) {
                        row[c.fieldName] = value;
                    }
                    _formulaResultCache[frcKey] = { inputHash: inputHash, value: value };
                }
            } catch (_e) {
                // Formula runtime error  leave cell empty
            }
        }
    }
}

// Compute formula values for a single record (used by profile view).
// Returns augmented copy of recordFields.
function _applyFormulaSingleRecord(tableId, fields, recordFields, recordId) {
    if (_disableFormulaEvaluation) return recordFields;

    // Compute count, lookup, and rollup fields for this single record.
    var singleMap = {};
    singleMap[recordId] = recordFields;
    _applyRelationalColumns(tableId, fields, singleMap);
    recordFields = singleMap[recordId];

    var engine = window._formulaEngine;
    if (!engine) return recordFields;

    // Use the same cache built by _applyFormulaColumns
    var cached = _compiledFormulaCache[tableId];
    if (!cached || !cached._sorted) {
        // Build cache by running _applyFormulaColumns with a temp map
        var tmp = {};
        tmp[recordId] = recordFields;
        _applyFormulaColumns(tableId, fields, tmp);
        return tmp[recordId];
    }

    var sorted = cached._sorted;

    // Populate bidirectional nameid aliases (same as _applyFormulaColumns)
    for (var _fid in fields) {
        var _fm = fields[_fid];
        if (_fm.fieldName && _fm.fieldName !== _fid) {
            if (recordFields[_fid] !== undefined && recordFields[_fm.fieldName] === undefined) {
                recordFields[_fm.fieldName] = recordFields[_fid];
            } else if (recordFields[_fm.fieldName] !== undefined && recordFields[_fid] === undefined) {
                recordFields[_fid] = recordFields[_fm.fieldName];
            }
        }
    }

    for (var i = 0; i < sorted.length; i++) {
        var c = sorted[i];
        try {
            var value = c.fn(recordFields, { recordId: recordId });
            if (value !== null && value !== undefined && !(value && value.__error)) {
                recordFields[c.fieldId] = value;
                if (c.fieldName && c.fieldName !== c.fieldId) {
                    recordFields[c.fieldName] = value;
                }
            }
        } catch (_e) {
            // skip
        }
    }
    return recordFields;
}

// Resolve field ID references in a formula expression to human-readable names.
// Replaces {fldXYZ} with {Pretty Name} using META_FIELDS for the given table.
function resolveFormulaFieldNames(expression, tableId) {
    var tableFields = tableId ? META_FIELDS[tableId] : null;
    if (!tableFields || !expression) return expression;
    return expression.replace(/\{([^}]+)\}/g, function(match, ref) {
        // If ref is a field ID (exists as a key in tableFields), use its name
        if (tableFields[ref] && tableFields[ref].fieldName && tableFields[ref].fieldName !== ref) {
            return '{' + tableFields[ref].fieldName + '}';
        }
        return match;
    });
}

// Show a formula/computed info popover next to a target element
var _formulaInfoPopover = null;
function showFormulaInfoPopover(targetEl, field) {
    closeFormulaInfoPopover();
    var fieldType = field?.fieldType || 'formula';
    var label = computedFieldLabel(fieldType);
    var expression = field?.options?.formula || field?.options?.expression || null;
    var referencedFieldIds = field?.options?.referencedFieldIds || null;
    var result = field?.options?.result || null;
    var tableId = field?.tableId || null;

    // Resolve field IDs to pretty names in the expression
    if (expression) {
        expression = resolveFormulaFieldNames(expression, tableId);
    }

    var popover = document.createElement('div');
    popover.className = 'formula-info-popover';
    var _popVisual = computedFieldVisual(fieldType);

    var html = '<div class="formula-info-header">';
    html += _popVisual.headerSvg;
    html += label + ' Field</div>';
    html += '<div class="formula-info-type" style="color: ' + _popVisual.popoverColor + '; background: ' + _popVisual.popoverBg + ';">' + esc(label) + '</div>';

    if (expression) {
        html += '<div class="formula-info-expression">' + esc(expression) + '</div>';
    } else if (fieldType === 'rollup' && field?.options?.recordLinkFieldId) {
        var rollupDesc = 'Rollup of field via linked records';
        if (field.options.fieldIdInLinkedTable) {
            var linkedTableFields = null;
            // Try to resolve the referenced field name
            for (var tid in META_FIELDS) {
                if (META_FIELDS[tid][field.options.fieldIdInLinkedTable]) {
                    var linkedField = META_FIELDS[tid][field.options.fieldIdInLinkedTable];
                    rollupDesc = 'Rollup of "' + (linkedField.fieldName || field.options.fieldIdInLinkedTable) + '"';
                    break;
                }
            }
        }
        if (field.options.result?.type) rollupDesc += '  ' + field.options.result.type;
        html += '<div class="formula-info-expression">' + esc(rollupDesc) + '</div>';
    } else if (fieldType === 'lookup' && field?.options?.recordLinkFieldId) {
        var lookupDesc = 'Looks up values from linked records';
        if (field.options.fieldIdInLinkedTable) {
            for (var tid in META_FIELDS) {
                if (META_FIELDS[tid][field.options.fieldIdInLinkedTable]) {
                    var linkedField = META_FIELDS[tid][field.options.fieldIdInLinkedTable];
                    lookupDesc = 'Lookup of "' + (linkedField.fieldName || field.options.fieldIdInLinkedTable) + '"';
                    break;
                }
            }
        }
        html += '<div class="formula-info-expression">' + esc(lookupDesc) + '</div>';
    } else if (fieldType === 'count') {
        html += '<div class="formula-info-expression">Counts linked records</div>';
    }

    html += '<div class="formula-info-note">This field is computed automatically and cannot be edited directly.</div>';

    popover.innerHTML = html;

    var rect = targetEl.getBoundingClientRect();
    document.body.appendChild(popover);

    // Position below the target, clamped to viewport
    var popRect = popover.getBoundingClientRect();
    var top = rect.bottom + 6;
    var left = rect.left;
    if (top + popRect.height > window.innerHeight - 10) top = rect.top - popRect.height - 6;
    if (left + popRect.width > window.innerWidth - 10) left = window.innerWidth - popRect.width - 10;
    if (left < 10) left = 10;
    popover.style.top = top + 'px';
    popover.style.left = left + 'px';

    _formulaInfoPopover = popover;
    setTimeout(function() {
        document.addEventListener('click', _closeFormulaInfoOnOutsideClick);
        document.addEventListener('keydown', _closeFormulaInfoOnEscape);
    }, 0);
}

function _closeFormulaInfoOnOutsideClick(event) {
    if (_formulaInfoPopover && !_formulaInfoPopover.contains(event.target)) {
        closeFormulaInfoPopover();
    }
}
function _closeFormulaInfoOnEscape(event) {
    if (event.key === 'Escape') closeFormulaInfoPopover();
}
function closeFormulaInfoPopover() {
    if (_formulaInfoPopover) {
        _formulaInfoPopover.remove();
        _formulaInfoPopover = null;
    }
    document.removeEventListener('click', _closeFormulaInfoOnOutsideClick);
    document.removeEventListener('keydown', _closeFormulaInfoOnEscape);
}

// Handle click on a formula/computed cell in the grid  show info popover
function handleFormulaCellClick(event, td) {
    if (event.target.closest('a')) return; // Allow link clicks
    event.stopPropagation();
    var fieldId = td.dataset.fieldId;
    var tableId = td.closest('tr')?.dataset.tableId || currentTable;
    var field = META_FIELDS[tableId]?.[fieldId];
    if (field) {
        showFormulaInfoPopover(td, field);
    }
}

// ============ Inline Cell Editing (Grid) ============

var _inlineEditingCell = null; // Currently editing cell element
var _inlineEditJustCommitted = false; // Suppress re-render right after inline commit
var _inlineEditCommitExplicit = false; // True when commit triggered by Enter/Tab (not blur)

async function startInlineCellEdit(event, td) {
    // Don't start edit if clicking a link, button, or already in an input
    if (event.target.closest('button, a, input, select, textarea')) return;

    // Don't edit formula/computed/read-only fields
    if (td.classList.contains('cell-computed') || td.classList.contains('cell-readonly')) return;

    // Already editing this cell
    if (td.classList.contains('inline-editing')) return;

    var shouldConfirmInlineEdit = UserPreferences.get('confirmInlineCellEdit') !== false;
    if (shouldConfirmInlineEdit) {
        var confirmResult = await showAppDialog({
            title: 'Start editing cell?',
            message: 'This cell will enter inline edit mode. Continue?',
            confirmText: 'Edit',
            cancelText: 'Cancel'
        });
        if (!confirmResult.confirmed) return;
    }

    // Close any other inline edit first
    if (_inlineEditingCell && _inlineEditingCell !== td) {
        commitInlineCellEdit(_inlineEditingCell);
    }

    var fieldId = td.dataset.fieldId;
    var recordId = td.dataset.recordId;
    var tableId = td.closest('tr')?.dataset.tableId || currentTable;
    if (!fieldId || !recordId || !tableId) return;

    // Double-check field metadata for read-only fields (computed, explicit readOnly, etc.)
    var fieldMeta = META_FIELDS[tableId]?.[fieldId];
    if (fieldMeta && isReadOnlyField(fieldMeta)) return;

    // Get field metadata and current value
    var field = META_FIELDS[tableId]?.[fieldId];
    var fieldType = field?.fieldType || 'text';
    var recordData = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) ? window.IN_MEMORY_DATA[tableId][recordId] : null;
    // Fall back to IndexedDB when IN_MEMORY_DATA doesn't have the record
    if (!recordData) {
        try {
            var dbRecord = await getRecord(tableId, recordId);
            if (dbRecord && dbRecord.fields) recordData = dbRecord.fields;
        } catch (e) { /* ignore, will proceed with undefined */ }
    }
    var currentValue;
    if (recordData) {
        currentValue = recordData[fieldId];
        if (currentValue === undefined && field?.fieldName) currentValue = recordData[field.fieldName];
    }

    // Infer field type from value when metadata type is generic
    if (fieldType === 'text' || fieldType === 'singleLineText' || !fieldType) {
        if (typeof currentValue === 'boolean') fieldType = 'checkbox';
        else if (typeof currentValue === 'number') fieldType = 'number';
        else if (typeof currentValue === 'string') {
            if (/^\d{4}-\d{2}-\d{2}/.test(currentValue)) fieldType = 'date';
            else if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(currentValue)) fieldType = 'email';
            else if (/^https?:\/\//.test(currentValue)) fieldType = 'url';
        }
    }

    _inlineEditingCell = td;
    td.classList.add('inline-editing');
    td._inlineOriginalHTML = td.innerHTML;
    td._inlineFieldId = fieldId;
    td._inlineRecordId = recordId;
    td._inlineTableId = tableId;
    td._inlineOriginalValue = currentValue;

    var input;
    var isSelectInput = false;

    if (fieldType === 'checkbox' || typeof currentValue === 'boolean') {
        // Checkbox  toggle immediately on click
        input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = !!currentValue;
        input.className = 'inline-edit-checkbox';
        input.onchange = function() {
            commitInlineCellEdit(td, input.checked);
        };
    } else if (fieldType === 'singleSelect' && field?.options?.choices) {
        // Single select dropdown
        isSelectInput = true;
        input = document.createElement('select');
        input.className = 'inline-edit-input';
        var emptyOpt = document.createElement('option');
        emptyOpt.value = '';
        emptyOpt.textContent = '';
        input.appendChild(emptyOpt);
        field.options.choices.forEach(function(choice) {
            var opt = document.createElement('option');
            var choiceName = typeof choice === 'string' ? choice : (choice.name || choice.value || String(choice));
            opt.value = choiceName;
            opt.textContent = choiceName;
            if (choiceName === currentValue) opt.selected = true;
            input.appendChild(opt);
        });
        input.onchange = function() {
            commitInlineCellEdit(td, input.value || '');
        };
    } else if (fieldType === 'date' || fieldType === 'dateTime') {
        // Date picker
        input = document.createElement('input');
        input.type = fieldType === 'dateTime' ? 'datetime-local' : 'date';
        input.className = 'inline-edit-input';
        if (currentValue) {
            // Normalize ISO date strings for the input
            var dateStr = String(currentValue);
            if (input.type === 'date') {
                input.value = dateStr.slice(0, 10);
            } else {
                // datetime-local needs "YYYY-MM-DDTHH:MM" format
                input.value = dateStr.slice(0, 16);
            }
        }
    } else if (fieldType === 'email') {
        input = document.createElement('input');
        input.type = 'email';
        input.className = 'inline-edit-input';
        input.value = currentValue != null ? String(currentValue) : '';
    } else if (fieldType === 'url') {
        input = document.createElement('input');
        input.type = 'url';
        input.className = 'inline-edit-input';
        input.value = currentValue != null ? String(currentValue) : '';
    } else if (fieldType === 'number' || fieldType === 'currency' || fieldType === 'percent' || typeof currentValue === 'number') {
        input = document.createElement('input');
        input.type = 'number';
        input.className = 'inline-edit-input';
        input.value = currentValue != null ? String(currentValue) : '';
        if (fieldType === 'percent') input.step = '0.01';
        if (fieldType === 'currency') input.step = '0.01';
    } else if (Array.isArray(currentValue) || (typeof currentValue === 'object' && currentValue !== null)) {
        // JSON / arrays / objects  textarea
        input = document.createElement('textarea');
        input.className = 'inline-edit-input';
        input.value = currentValue != null ? JSON.stringify(currentValue, null, 2) : '';
        input.rows = 3;
    } else {
        // Default: text or multiline
        var strValue = currentValue != null ? String(currentValue) : '';
        if (strValue.length > 80 || strValue.includes('\n') || fieldType === 'multilineText' || fieldType === 'richText') {
            input = document.createElement('textarea');
            input.className = 'inline-edit-input';
            input.value = strValue;
            input.rows = Math.min(6, Math.max(2, strValue.split('\n').length));
        } else {
            input = document.createElement('input');
            input.type = 'text';
            input.className = 'inline-edit-input';
            input.value = strValue;
        }
    }

    if (input.type !== 'checkbox' && !isSelectInput) {
        input.onkeydown = function(e) {
            if (e.key === 'Enter' && !e.shiftKey && input.tagName !== 'TEXTAREA') {
                e.preventDefault();
                e.stopPropagation();
                _inlineEditCommitExplicit = true;
                commitInlineCellEdit(td);
            } else if (e.key === 'Escape') {
                e.stopPropagation();
                cancelInlineCellEdit(td);
            } else if (e.key === 'Tab') {
                e.preventDefault();
                e.stopPropagation();
                _inlineEditCommitExplicit = true;
                commitInlineCellEdit(td);
                // Move to adjacent cell
                moveToAdjacentCell(td, e.shiftKey);
            }
        };
        input.onblur = function() {
            setTimeout(function() {
                if (_inlineEditingCell === td) {
                    _inlineEditCommitExplicit = false;
                    commitInlineCellEdit(td);
                }
            }, 150);
        };
    } else if (isSelectInput) {
        // Select: Escape to cancel, blur to commit, Enter to commit
        input.onkeydown = function(e) {
            if (e.key === 'Escape') {
                e.stopPropagation();
                cancelInlineCellEdit(td);
            } else if (e.key === 'Tab') {
                e.preventDefault();
                e.stopPropagation();
                commitInlineCellEdit(td, input.value || '');
                moveToAdjacentCell(td, e.shiftKey);
            }
        };
        input.onblur = function() {
            setTimeout(function() {
                if (_inlineEditingCell === td) {
                    commitInlineCellEdit(td, input.value || '');
                }
            }, 150);
        };
    }

    // Prevent double-click from bubbling to row
    input.ondblclick = function(e) { e.stopPropagation(); };

    td.innerHTML = '';
    td.appendChild(input);
    input.focus();
    if (input.select && !isSelectInput) input.select();
}

// Move focus to adjacent editable cell (for Tab navigation)
function moveToAdjacentCell(td, backwards) {
    // Walk siblings to find the next editable (non-formula) cell
    var nextTd = backwards ? td.previousElementSibling : td.nextElementSibling;
    while (nextTd && !nextTd.classList.contains('inline-editable')) {
        nextTd = backwards ? nextTd.previousElementSibling : nextTd.nextElementSibling;
    }
    if (nextTd) {
        startInlineCellEdit({ target: nextTd, stopPropagation: function(){} }, nextTd);
        return;
    }
    // If no sibling cell, try next/prev row
    var row = td.closest('tr');
    var nextRow = backwards ? row?.previousElementSibling : row?.nextElementSibling;
    if (nextRow && !nextRow.classList.contains('group-header-row')) {
        var cells = nextRow.querySelectorAll('td.inline-editable');
        if (cells.length > 0) {
            var target = backwards ? cells[cells.length - 1] : cells[0];
            startInlineCellEdit({ target: target, stopPropagation: function(){} }, target);
        }
    }
}

function parseInlineCellValue(strValue, originalValue, fieldType) {
    if (strValue === '') return '';
    if (typeof originalValue === 'number' || fieldType === 'number') {
        var num = Number(strValue);
        if (!isNaN(num)) return num;
    }
    if (Array.isArray(originalValue) || (typeof originalValue === 'object' && originalValue !== null)) {
        try { return JSON.parse(strValue); } catch (e) { return strValue; }
    }
    return strValue;
}

async function commitInlineCellEdit(td, explicitValue) {
    if (!td || !td.classList.contains('inline-editing')) return;

    var fieldId = td._inlineFieldId;
    var recordId = td._inlineRecordId;
    var tableId = td._inlineTableId;
    var originalValue = td._inlineOriginalValue;
    var wasExplicit = _inlineEditCommitExplicit;
    _inlineEditCommitExplicit = false;

    // Get the new value from the input
    var inputEl = td.querySelector('input, textarea, select');
    var newValue;
    if (explicitValue !== undefined) {
        newValue = explicitValue;
    } else if (inputEl) {
        if (inputEl.type === 'checkbox') {
            newValue = inputEl.checked;
        } else if (inputEl.tagName === 'SELECT') {
            newValue = inputEl.value;
        } else {
            var field = META_FIELDS[tableId]?.[fieldId];
            var fieldType = field?.fieldType || 'text';
            newValue = parseInlineCellValue(inputEl.value, originalValue, fieldType);
        }
    } else {
        // No input found  just restore
        cancelInlineCellEdit(td);
        return;
    }

    // Safety: if the edit would clear a non-empty field and the commit was
    // triggered by blur (not an explicit Enter/Tab), cancel instead of saving.
    // This prevents accidental wipes from clicking away.
    var wouldClear = (newValue === '' || newValue === null || newValue === undefined) &&
                     originalValue != null && originalValue !== '' &&
                     !(typeof originalValue === 'boolean');
    if (wouldClear && !wasExplicit) {
        cancelInlineCellEdit(td);
        return;
    }

    // Clean up cell state
    td.classList.remove('inline-editing');
    _inlineEditingCell = null;

    // Check if value changed
    if (JSON.stringify(originalValue) === JSON.stringify(newValue)) {
        // No change  restore display
        td.innerHTML = td._inlineOriginalHTML;
        return;
    }

    // Determine the field key used in the record (fieldId or fieldName)
    var field = META_FIELDS[tableId]?.[fieldId];

    // Show the new value immediately (optimistic)
    td.innerHTML = formatCell(newValue, field?.fieldType);
    var fieldKey = fieldId;
    var recordData = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) ? window.IN_MEMORY_DATA[tableId][recordId] : null;
    if (recordData && recordData[fieldId] === undefined && field?.fieldName && recordData[field.fieldName] !== undefined) {
        fieldKey = field.fieldName;
    }

    var fieldChanges = {};
    fieldChanges[fieldKey] = newValue;

    // Suppress full table re-render for the optimistic update  the cell is already showing the new value
    _inlineEditJustCommitted = true;

    try {
        var result = await editRecord(tableId, recordId, fieldChanges);
        if (result && result.queued) {
            // Edit was queued offline  don't show undo toast
        } else {
            // Show undo toast after successful save
            showUndoToast(tableId, recordId, fieldId, fieldKey, originalValue);
        }
    } catch (err) {
        console.error('[InlineEdit] Edit failed for', recordId, fieldKey, err);
        // editRecord already handled rollback/queue and showed error toast
        _inlineEditJustCommitted = false;
    }
}

function cancelInlineCellEdit(td) {
    if (!td) return;
    td.classList.remove('inline-editing');
    td.innerHTML = td._inlineOriginalHTML || '';
    if (_inlineEditingCell === td) _inlineEditingCell = null;
}

// ============ Grid Keyboard Navigation ============
// Allows arrow-key navigation between cells and Enter/F2 to start editing.
var _focusedCell = null;

function setFocusedCell(td) {
    if (_focusedCell) _focusedCell.classList.remove('cell-focused');
    _focusedCell = td;
    if (td) {
        td.classList.add('cell-focused');
        td.scrollIntoView({ block: 'nearest', inline: 'nearest' });
    }
}

document.addEventListener('click', function(e) {
    var cell = e.target.closest('td.inline-editable, td.cell-computed, td.cell-readonly');
    if (cell) {
        setFocusedCell(cell);
    }
});

document.addEventListener('keydown', function(e) {
    // Don't interfere if the profile overlay is open
    var overlay = document.getElementById('record-profile-overlay');
    if (overlay && overlay.classList.contains('open')) return;

    // Don't interfere if actively editing (input has its own key handlers)
    if (_inlineEditingCell) return;

    // Don't interfere if focus is in an unrelated input
    if (e.target.matches('input, textarea, select') && !e.target.closest('td.inline-editable')) return;

    if (!_focusedCell) return;

    var table = _focusedCell.closest('table');
    if (!table) return;

    if (e.key === 'Enter' || e.key === 'F2') {
        e.preventDefault();
        // For computed cells (formula/lookup/rollup), show info popover instead of editing
        if (_focusedCell.classList.contains('cell-computed')) {
            handleFormulaCellClick({ target: _focusedCell, stopPropagation: function(){} }, _focusedCell);
        } else if (_focusedCell.classList.contains('cell-readonly')) {
            // Read-only cells: do nothing on Enter/F2
        } else {
            startInlineCellEdit({ target: _focusedCell, stopPropagation: function(){} }, _focusedCell);
        }
        return;
    }

    if (e.key === 'ArrowRight' || e.key === 'ArrowLeft' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        e.preventDefault();
        var row = _focusedCell.closest('tr');
        if (!row) return;

        // Include editable, formula, and read-only cells in keyboard navigation
        var cellsInRow = Array.from(row.querySelectorAll('td.inline-editable, td.cell-computed, td.cell-readonly'));
        var colIdx = cellsInRow.indexOf(_focusedCell);

        if (e.key === 'ArrowRight') {
            if (colIdx < cellsInRow.length - 1) {
                setFocusedCell(cellsInRow[colIdx + 1]);
            }
        } else if (e.key === 'ArrowLeft') {
            if (colIdx > 0) {
                setFocusedCell(cellsInRow[colIdx - 1]);
            }
        } else if (e.key === 'ArrowDown') {
            var nextRow = row.nextElementSibling;
            while (nextRow && nextRow.classList.contains('group-header-row')) nextRow = nextRow.nextElementSibling;
            if (nextRow) {
                var nextCells = nextRow.querySelectorAll('td.inline-editable, td.cell-computed, td.cell-readonly');
                if (nextCells[colIdx]) setFocusedCell(nextCells[colIdx]);
                else if (nextCells.length > 0) setFocusedCell(nextCells[nextCells.length - 1]);
            }
        } else if (e.key === 'ArrowUp') {
            var prevRow = row.previousElementSibling;
            while (prevRow && prevRow.classList.contains('group-header-row')) prevRow = prevRow.previousElementSibling;
            if (prevRow) {
                var prevCells = prevRow.querySelectorAll('td.inline-editable, td.cell-computed, td.cell-readonly');
                if (prevCells[colIdx]) setFocusedCell(prevCells[colIdx]);
                else if (prevCells.length > 0) setFocusedCell(prevCells[prevCells.length - 1]);
            }
        }
    }
});

// Keyboard navigation for profile
document.addEventListener('keydown', function(e) {
    var overlay = document.getElementById('record-profile-overlay');
    if (!overlay.classList.contains('open')) return;

    if (e.key === 'Escape') {
        closeRecordProfile();
    } else if (e.key === 'ArrowLeft' && !e.target.matches('input, textarea, select')) {
        navigateProfile(-1);
    } else if (e.key === 'ArrowRight' && !e.target.matches('input, textarea, select')) {
        navigateProfile(1);
    }
});

// ============ View Selector & Fields Dropdown UI ============

// Toggle view selector dropdown
function toggleViewSelector() {
    var dropdown = document.getElementById('view-selector-dropdown');
    var fieldsDropdown = document.getElementById('fields-dropdown');

    // Close fields dropdown if open
    fieldsDropdown.classList.remove('open');

    dropdown.classList.toggle('open');
}

// Toggle fields dropdown
function toggleFieldsDropdown() {
    var dropdown = document.getElementById('fields-dropdown');
    var viewDropdown = document.getElementById('view-selector-dropdown');

    // Close view dropdown if open
    viewDropdown.classList.remove('open');

    dropdown.classList.toggle('open');

    // Focus search input and clear it when opening
    if (dropdown.classList.contains('open')) {
        var searchInput = document.getElementById('fields-search-input');
        if (searchInput) {
            searchInput.value = '';
            filterFieldsDropdown('');
            setTimeout(function() { searchInput.focus(); }, 50);
        }
    }
}

// Close all dropdowns
function closeAllDropdowns() {
    document.getElementById('view-selector-dropdown')?.classList.remove('open');
    document.getElementById('fields-dropdown')?.classList.remove('open');
}

// Click outside handler to close dropdowns
document.addEventListener('click', function(e) {
    var viewSelector = document.getElementById('view-selector-container');
    var fieldsBtn = document.getElementById('fields-btn');
    var fieldsDropdown = document.getElementById('fields-dropdown');

    // Close view selector if clicked outside
    if (viewSelector && !viewSelector.contains(e.target)) {
        document.getElementById('view-selector-dropdown')?.classList.remove('open');
    }

    // Close fields dropdown if clicked outside
    if (fieldsBtn && fieldsDropdown && !fieldsBtn.contains(e.target) && !fieldsDropdown.contains(e.target)) {
        fieldsDropdown.classList.remove('open');
    }
});

// Get view type icon
function getViewTypeIcon(viewType) {
    switch ((viewType || '').toLowerCase()) {
        case 'grid': return '&#9638;';
        case 'gallery': return '&#128444;';
        case 'kanban': return '&#9636;';
        case 'calendar': return '&#128197;';
        case 'timeline': return '&#8594;';
        case 'form': return '&#128196;';
        default: return '&#9638;';
    }
}

// Render view selector dropdown
function renderViewSelector() {
    if (!currentTable) return;

    var dropdown = document.getElementById('view-selector-dropdown');
    var currentViewIcon = document.getElementById('current-view-icon');
    var currentViewName = document.getElementById('current-view-name');

    var views = META_VIEWS[currentTable] || {};
    var viewIds = Object.keys(views);

    // Update current view display
    var viewId = currentView || '_default';
    var currentViewObj = views[viewId];
    if (currentViewObj) {
        currentViewIcon.innerHTML = getViewTypeIcon(currentViewObj.viewType);
        currentViewName.textContent = currentViewObj.viewName || viewId;
    } else {
        currentViewIcon.innerHTML = '&#9638;';
        currentViewName.textContent = 'All Fields';
    }

    // Build dropdown
    var html = '<div class="view-selector-dropdown-header">Views</div>';

    // Add "All Fields" default option
    var isDefaultActive = !currentView || currentView === '_default';
    html += '<div class="view-selector-option' + (isDefaultActive ? ' active' : '') + '" onclick="selectView(\'_default\')">';
    html += '<span class="view-type-icon">&#9638;</span>';
    html += '<span class="view-option-name">All Fields</span>';
    if (isDefaultActive) html += '<span class="view-check">&#10003;</span>';
    html += '</div>';

    // Add existing views
    for (var vid of viewIds) {
        if (vid === '_default') continue;
        var view = views[vid];
        var isActive = currentView === vid;
        var viewSharing = view._sharing;
        var sharingBadge = '';
        if (viewSharing && viewSharing.sharing && viewSharing.sharing !== 'private') {
            sharingBadge = '<span class="view-sharing-badge shared" title="' +
                esc(SharedViews.getSharingLabel(viewSharing)) + '">' +
                SharedViews.getSharingIcon(viewSharing) + '</span>';
        }
        html += '<div class="view-selector-option' + (isActive ? ' active' : '') + '" onclick="selectView(\'' + esc(vid) + '\')">';
        html += '<span class="view-type-icon">' + getViewTypeIcon(view.viewType) + '</span>';
        html += '<span class="view-option-name">' + esc(view.viewName || vid) + '</span>';
        html += sharingBadge;
        if (isActive) html += '<span class="view-check">&#10003;</span>';
        html += '</div>';
    }

    // Add "Create New View" option at bottom
    html += '<div style="border-top: 1px solid #eee; margin-top: 4px; padding-top: 4px;"></div>';
    html += '<div class="view-selector-option" onclick="openCreateViewModal()" style="color: #2d6cdf;">';
    html += '<span class="view-type-icon">+</span>';
    html += '<span class="view-option-name">Create New View</span>';
    html += '</div>';

    dropdown.innerHTML = html;
}

// Select a view
async function selectView(viewId) {
    // Short-circuit if the requested view is already active (avoids full re-render)
    if (viewId === currentView) {
        closeAllDropdowns();
        return;
    }

    // Auto-save any pending changes before switching views
    await autoSaveBeforeNavigation();

    currentView = viewId;
    invalidateVisibleFieldsCache(); // view changed  stale field order
    closeAllDropdowns();

    if (_urlStateBootstrapped) persistUrlState();

    // Load and apply view filters, sorts, groupBy, and colorBy for the new view
    if (currentTable) {
        var viewConfig = getViewFiltersAndSorts(currentTable, viewId);
        currentFilters = viewConfig.filters;
        currentSorts = viewConfig.sorts;
        currentGroupBy = viewConfig.groupBy;
        currentColorBy = viewConfig.colorBy;
        updateFilterCount();
        updateSortCount();
        updateGroupButtonState();
        updateColorButtonState();
    }

    // Update sidebar to reflect the new active view
    if (currentTable) {
        updateSidebarViewActive(currentTable, viewId);
    }

    // Render view selector to update current view display
    renderViewSelector();

    // Render fields dropdown for new view
    renderFieldsDropdown();
    updateFieldsCount();

    // Re-render table with new view's field configuration
    await renderTable();
}

// Render fields dropdown
function renderFieldsDropdown() {
    if (!currentTable) return;

    var list = document.getElementById('fields-dropdown-list');
    var fields = META_FIELDS[currentTable] || {};
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);
    var hiddenSet = new Set(config.hiddenFieldIds || []);

    // Get all fields in order
    var allFieldIds = getAllFieldsInOrder(currentTable, viewId);

    var html = '';
    for (var i = 0; i < allFieldIds.length; i++) {
        var fid = allFieldIds[i];
        var field = fields[fid];
        if (!field) continue;

        var isVisible = !hiddenSet.has(fid);
        var fieldName = field.fieldName || fid;
        var fieldType = field.fieldType || 'unknown';

        html += '<div class="fields-dropdown-item" data-field-id="' + esc(fid) + '" draggable="true">';

        // Drag handle
        html += '<span class="field-drag-handle" title="Drag to reorder">&#9776;</span>';

        // Checkbox
        html += '<div class="field-checkbox' + (isVisible ? ' checked' : '') + '" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<span class="check-icon">&#10003;</span>';
        html += '</div>';

        // Field info
        html += '<div class="field-info" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<div class="field-name">' + esc(fieldName) + '</div>';
        html += '<div class="field-type">' + esc(fieldType) + '</div>';
        html += '</div>';

        // Move buttons
        html += '<div class="field-move-btns">';
        if (i > 0) {
            html += '<button class="field-move-btn" onclick="moveFieldUp(\'' + esc(fid) + '\')" title="Move up">&#9650;</button>';
        } else {
            html += '<button class="field-move-btn" disabled style="opacity: 0.3;">&#9650;</button>';
        }
        if (i < allFieldIds.length - 1) {
            html += '<button class="field-move-btn" onclick="moveFieldDown(\'' + esc(fid) + '\')" title="Move down">&#9660;</button>';
        } else {
            html += '<button class="field-move-btn" disabled style="opacity: 0.3;">&#9660;</button>';
        }
        html += '</div>';

        html += '</div>';
    }

    list.innerHTML = html;
    initFieldsDropdownDrag();

    // Preserve search filter if active
    var searchInput = document.getElementById('fields-search-input');
    if (searchInput && searchInput.value) {
        filterFieldsDropdown(searchInput.value);
    }
}

// Update visible fields count badge
function updateFieldsCount() {
    if (!currentTable) return;

    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);
    var fields = META_FIELDS[currentTable] || {};
    var totalFields = Object.keys(fields).length;
    var hiddenCount = (config.hiddenFieldIds || []).length;
    var visibleCount = totalFields - hiddenCount;

    var countEl = document.getElementById('fields-visible-count');
    if (countEl) {
        countEl.textContent = visibleCount + '/' + totalFields;
    }
}

// Filter fields dropdown by search query
function filterFieldsDropdown(query) {
    var list = document.getElementById('fields-dropdown-list');
    if (!list) return;
    var items = list.querySelectorAll('.fields-dropdown-item');
    var lowerQuery = (query || '').toLowerCase().trim();

    for (var i = 0; i < items.length; i++) {
        var nameEl = items[i].querySelector('.field-name');
        var name = nameEl ? nameEl.textContent.toLowerCase() : '';
        if (!lowerQuery || name.indexOf(lowerQuery) >= 0) {
            items[i].style.display = '';
        } else {
            items[i].style.display = 'none';
        }
    }
}

// --- Drag-to-reorder for fields dropdown ---
var draggedFieldItem = null;
var draggedFieldId = null;

function initFieldsDropdownDrag() {
    var list = document.getElementById('fields-dropdown-list');
    if (!list) return;

    list.addEventListener('dragstart', function(e) {
        var item = e.target.closest('.fields-dropdown-item');
        if (!item) return;
        draggedFieldItem = item;
        draggedFieldId = item.dataset.fieldId;
        item.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', draggedFieldId);
    });

    list.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        var item = e.target.closest('.fields-dropdown-item');
        if (!item || item === draggedFieldItem) return;

        // Clear previous indicators
        list.querySelectorAll('.drag-over-above, .drag-over-below').forEach(function(el) {
            el.classList.remove('drag-over-above', 'drag-over-below');
        });

        // Determine if above or below midpoint
        var rect = item.getBoundingClientRect();
        var midY = rect.top + rect.height / 2;
        if (e.clientY < midY) {
            item.classList.add('drag-over-above');
        } else {
            item.classList.add('drag-over-below');
        }
    });

    list.addEventListener('dragleave', function(e) {
        var item = e.target.closest('.fields-dropdown-item');
        if (item) {
            item.classList.remove('drag-over-above', 'drag-over-below');
        }
    });

    list.addEventListener('dragend', function() {
        list.querySelectorAll('.dragging, .drag-over-above, .drag-over-below').forEach(function(el) {
            el.classList.remove('dragging', 'drag-over-above', 'drag-over-below');
        });
        draggedFieldItem = null;
        draggedFieldId = null;
    });

    list.addEventListener('drop', function(e) {
        e.preventDefault();

        var item = e.target.closest('.fields-dropdown-item');
        if (!item || !draggedFieldId) return;

        var targetFieldId = item.dataset.fieldId;
        if (targetFieldId === draggedFieldId) return;

        // Determine insert position based on drop location
        var rect = item.getBoundingClientRect();
        var midY = rect.top + rect.height / 2;
        var insertAfter = e.clientY >= midY;

        // Perform reorder
        if (!currentTable) return;
        var viewId = currentView || '_default';
        var config = getViewFieldConfig(currentTable, viewId);

        var fromIdx = config.fieldOrder.indexOf(draggedFieldId);
        var toIdx = config.fieldOrder.indexOf(targetFieldId);
        if (fromIdx < 0 || toIdx < 0) return;

        // Remove from old position
        config.fieldOrder.splice(fromIdx, 1);

        // Recalculate target index after removal
        var newToIdx = config.fieldOrder.indexOf(targetFieldId);
        var insertIdx = insertAfter ? newToIdx + 1 : newToIdx;
        config.fieldOrder.splice(insertIdx, 0, draggedFieldId);

        // Move column in table DOM
        moveColumnInDOM(fromIdx, insertIdx);

        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();

        // Restore search filter if active
        var searchInput = document.getElementById('fields-search-input');
        if (searchInput && searchInput.value) {
            filterFieldsDropdown(searchInput.value);
        }
    });
}

function esc(s) {
    if (s == null) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ============ View Controls (Filter, Sort, Group, etc.) ============

var currentFilters = { logic: 'AND', conditions: [] };
var currentSorts = [];
var currentGroupBy = null;
var currentColorBy = null;
var currentRowHeight = 'medium';
var currentSearchQuery = '';

// --- Filter Group Helpers ---
// Normalize any filter value into the group structure.
// Handles: legacy flat arrays, already-valid groups, or garbage input.
function normalizeFilterGroup(raw) {
    if (raw && raw.logic && Array.isArray(raw.conditions)) return raw; // already a group
    if (Array.isArray(raw) && raw.length > 0) {
        // Legacy flat array  wrap in AND group
        return { logic: 'AND', conditions: raw.map(function(f) {
            if (f && f.logic && Array.isArray(f.conditions)) return f; // nested group
            return { type: 'condition', fieldId: f.fieldId, operator: f.operator, value: f.value || '' };
        })};
    }
    return { logic: 'AND', conditions: [] };
}
// Count total leaf conditions in a group (recursive)
function countFilterConditions(group) {
    if (!group || !group.conditions) return 0;
    var n = 0;
    for (var i = 0; i < group.conditions.length; i++) {
        var c = group.conditions[i];
        if (c.type === 'group' || (c.logic && Array.isArray(c.conditions))) {
            n += countFilterConditions(c);
        } else {
            n++;
        }
    }
    return n;
}
// Check if filter group has any conditions
function hasFilterConditions(group) {
    return countFilterConditions(group) > 0;
}
// Get a condition by path (array of indices into nested conditions arrays)
function getFilterByPath(group, path) {
    var node = group;
    for (var i = 0; i < path.length - 1; i++) {
        node = node.conditions[path[i]];
        if (!node) return null;
    }
    return node.conditions[path[path.length - 1]] || null;
}
// Get the parent group for a path
function getFilterParent(group, path) {
    var node = group;
    for (var i = 0; i < path.length - 1; i++) {
        node = node.conditions[path[i]];
        if (!node) return null;
    }
    return node;
}

// Original unfiltered/unsorted record IDs
var originalRecordIds = [];
var _recordSearchDataVersion = 0;

// ============ Pre-built Search Text Index (local, for records in index.html's own cache) ============
// Maps "tableId|recordId" -> lowercased searchable text string.
// Built once per record, invalidated when records change. Avoids re-computing
// collectSearchableText() on every keystroke.
var _localSearchIndex = {};          // cacheKey -> lowercased searchable string
var _localSearchIndexVersion = 0;    // tracks staleness

function _buildLocalSearchText(record) {
    var parts = [record.recordId || ''];
    var fields = record.fields || {};
    for (var key in fields) {
        if (!Object.prototype.hasOwnProperty.call(fields, key)) continue;
        parts.push(key);
        var text = collectSearchableText(fields[key]);
        if (text) parts.push(text);
    }
    return parts.join(' ').toLowerCase();
}

function getLocalSearchText(tableId, recordId, record) {
    var ck = tableId + '|' + recordId;
    if (_localSearchIndex[ck] !== undefined) return _localSearchIndex[ck];
    var text = _buildLocalSearchText(record);
    _localSearchIndex[ck] = text;
    return text;
}

function invalidateLocalSearchIndex(tableId, recordId) {
    if (recordId) {
        delete _localSearchIndex[tableId + '|' + recordId];
    } else if (tableId) {
        // Clear all entries for a table
        var prefix = tableId + '|';
        for (var k in _localSearchIndex) {
            if (k.substring(0, prefix.length) === prefix) delete _localSearchIndex[k];
        }
    } else {
        _localSearchIndex = {};
    }
    _localSearchIndexVersion++;
}

// Get cell value from a record for filtering/sorting
function getCellValue(record, fieldId) {
    if (!record || !record.fields) return null;
    var value = record.fields[fieldId];
    if (value === undefined) {
        // Try field name lookup
        var fields = META_FIELDS[currentTable] || {};
        var fieldName = fields[fieldId]?.fieldName;
        if (fieldName) value = record.fields[fieldName];
    }
    return value;
}

// Convert value to string for comparison
function valueToString(value) {
    if (value == null) return '';
    if (Array.isArray(value)) {
        return value.map(v => {
            if (typeof v === 'object' && v !== null) {
                return v.name || v.filename || v.email || v.id || JSON.stringify(v);
            }
            return String(v);
        }).join(' ');
    }
    if (typeof value === 'object') {
        return value.name || value.filename || value.email || value.url || JSON.stringify(value);
    }
    return String(value);
}

function collectSearchableText(value) {
    if (value == null) return '';
    if (Array.isArray(value)) {
        var arrayParts = [];
        for (var i = 0; i < value.length; i++) {
            var part = collectSearchableText(value[i]);
            if (part) arrayParts.push(part);
        }
        return arrayParts.join(' ');
    }
    if (typeof value === 'object') {
        var objectParts = [];
        for (var key in value) {
            if (!Object.prototype.hasOwnProperty.call(value, key)) continue;
            var keyPart = collectSearchableText(key);
            if (keyPart) objectParts.push(keyPart);
            var valuePart = collectSearchableText(value[key]);
            if (valuePart) objectParts.push(valuePart);
        }
        return objectParts.join(' ');
    }
    return String(value);
}

function normalizeSearchTokens(query) {
    if (!query) return [];
    return String(query)
        .toLowerCase()
        .trim()
        .split(/\s+/)
        .filter(function(token) { return token.length > 0; });
}

function matchesSearchTokens(text, tokens) {
    if (!tokens || !tokens.length) return true;
    var haystack = (text || '').toLowerCase();
    for (var i = 0; i < tokens.length; i++) {
        if (haystack.indexOf(tokens[i]) === -1) return false;
    }
    return true;
}

// Check if a record matches a single filter
function matchesFilter(record, filter) {
    var value = getCellValue(record, filter.fieldId);
    var strValue = valueToString(value).toLowerCase();
    var filterValue = (filter.value || '').toLowerCase();

    switch (filter.operator) {
        case 'contains':
            return strValue.includes(filterValue);
        case 'equals':
            return strValue === filterValue;
        case 'not_equals':
            return strValue !== filterValue;
        case 'is_empty':
            return value == null || value === '' || (Array.isArray(value) && value.length === 0);
        case 'is_not_empty':
            return value != null && value !== '' && !(Array.isArray(value) && value.length === 0);
        default:
            return true;
    }
}

// Recursively evaluate a filter group against a record.
// group: { logic: 'AND'|'OR', conditions: [...] }
// Each condition is either { type:'condition', fieldId, operator, value }
// or { type:'group', logic, conditions } (nested group).
function matchesFilterGroup(record, group) {
    if (!group || !group.conditions || group.conditions.length === 0) return true;
    var isAnd = group.logic === 'AND';
    for (var i = 0; i < group.conditions.length; i++) {
        var c = group.conditions[i];
        var result;
        if (c.type === 'group' || (c.logic && Array.isArray(c.conditions))) {
            result = matchesFilterGroup(record, c);
        } else {
            result = matchesFilter(record, c);
        }
        if (isAnd && !result) return false;  // AND: short-circuit on first false
        if (!isAnd && result) return true;   // OR: short-circuit on first true
    }
    return isAnd; // AND: all true  true; OR: none true  false
}

// Check if a record matches search query.
// Uses the pre-built local search index for fast substring matching.
// Falls back to field-by-field scanning if index entry is missing.
function matchesSearch(record, query) {
    var tokens = normalizeSearchTokens(query);
    if (!tokens.length) return true;

    // Try the pre-built search index first (single indexOf per token vs. per-field)
    var tableId = record.tableId || currentTable;
    var recordId = record.recordId || record.id;
    if (tableId && recordId) {
        var haystack = getLocalSearchText(tableId, recordId, record);
        for (var i = 0; i < tokens.length; i++) {
            if (haystack.indexOf(tokens[i]) === -1) return false;
        }
        return true;
    }

    // Fallback: scan fields directly
    if (matchesSearchTokens(recordId, tokens)) return true;
    var fields = record.fields || {};
    for (var key in fields) {
        if (!Object.prototype.hasOwnProperty.call(fields, key)) continue;
        if (matchesSearchTokens(key, tokens)) return true;
        var strValue = collectSearchableText(fields[key]);
        if (matchesSearchTokens(strValue, tokens)) return true;
    }
    return false;
}

// Compare two values for sorting
function compareValues(a, b, direction) {
    // Handle nulls
    if (a == null && b == null) return 0;
    if (a == null) return direction === 'asc' ? -1 : 1;
    if (b == null) return direction === 'asc' ? 1 : -1;

    // Convert to strings for comparison
    var strA = valueToString(a).toLowerCase();
    var strB = valueToString(b).toLowerCase();

    // Try numeric comparison
    var numA = parseFloat(strA);
    var numB = parseFloat(strB);
    if (!isNaN(numA) && !isNaN(numB)) {
        var result = numA - numB;
        return direction === 'asc' ? result : -result;
    }

    // String comparison
    var result = strA.localeCompare(strB);
    return direction === 'asc' ? result : -result;
}

// Cache for filtered/sorted results  avoids redundant IndexedDB reads when
// re-rendering the same view with the same filters (e.g. toggling back to a tab).
var _filterCache = { key: null, result: null };
function _filterCacheKey() {
    return currentTable + '|' + currentView + '|' + JSON.stringify(currentFilters) + '|' +
           JSON.stringify(currentSorts) + '|' + currentSearchQuery + '|' + originalRecordIds.length + '|' + _recordSearchDataVersion;
}
function invalidateFilterCache() { _filterCache.key = null; _filterCache.result = null; }

// Apply all filters, search, and sorts to get filtered record IDs.
// Uses pre-built search index for fast text search without loading records.
// Processes records in batches to avoid loading entire dataset into memory at once.
async function getFilteredSortedRecords() {
    if (!currentTable) return [];

    // Return cached result if filters/sorts/search haven't changed
    var cacheKey = _filterCacheKey();
    if (_filterCache.key === cacheKey && _filterCache.result) {
        return _filterCache.result.slice();
    }

    var hasFilters = hasFilterConditions(currentFilters);
    var hasSearch = !!currentSearchQuery;
    var hasSorts = currentSorts.length > 0;
    var needsRecordData = hasFilters || hasSearch || hasSorts;

    // If no filters/search/sorts, just return a copy
    if (!needsRecordData) return originalRecordIds.slice();

    var searchTokens = hasSearch ? normalizeSearchTokens(currentSearchQuery) : [];
    hasSearch = searchTokens.length > 0;

    // Phase 0: Pre-filter with search index (no record loading needed).
    // This eliminates non-matching records before we load them for filters/sorts.
    var candidateIds = originalRecordIds;
    var hasUnverifiedCandidates = false;
    if (hasSearch) {
        var narrowed = [];
        for (var si = 0; si < candidateIds.length; si++) {
            var rid = candidateIds[si];
            var ck = currentTable + '|' + rid;
            var haystack = _localSearchIndex[ck];
            if (haystack !== undefined) {
                var hit = true;
                for (var ti = 0; ti < searchTokens.length; ti++) {
                    if (haystack.indexOf(searchTokens[ti]) === -1) { hit = false; break; }
                }
                if (hit) narrowed.push(rid);
            } else {
                // Index miss  include as candidate (will verify when record is loaded)
                narrowed.push(rid);
                hasUnverifiedCandidates = true;
            }
        }
        candidateIds = narrowed;

        // If only search (no filters, no sorts) AND all candidates were verified
        // via the search index, we can skip Phase 1. If there are unverified
        // candidates (index misses), we must fall through to Phase 1 to load
        // records and verify them against the search query.
        if (!hasFilters && !hasSorts && !hasUnverifiedCandidates) {
            _filterCache.key = cacheKey;
            _filterCache.result = candidateIds;
            return candidateIds;
        }
    }

    // Phase 1: Filter in batches  only load records that survived search pre-filter
    var BATCH_SIZE = 1000;
    var filteredIds = [];

    for (var batchStart = 0; batchStart < candidateIds.length; batchStart += BATCH_SIZE) {
        var batchIds = candidateIds.slice(batchStart, batchStart + BATCH_SIZE);
        var batchRecords = await getRecordsByIds(currentTable, batchIds);
        var batchById = {};
        for (var r = 0; r < batchRecords.length; r++) {
            batchById[batchRecords[r].recordId] = batchRecords[r];
            // Ensure search index is populated for next search
            getLocalSearchText(currentTable, batchRecords[r].recordId, batchRecords[r]);
        }

        for (var b = 0; b < batchIds.length; b++) {
            var id = batchIds[b];
            var record = batchById[id];
            if (!record) continue;

            // Re-check search for records that didn't have an index entry
            if (hasSearch && !matchesSearch(record, currentSearchQuery)) continue;

            // Filter group check (supports nested AND/OR groups)
            if (hasFilters && !matchesFilterGroup(record, currentFilters)) continue;

            filteredIds.push(id);
        }
    }

    // Phase 2: Sort  pre-normalize values so comparisons avoid repeated
    // valueToString/toLowerCase/parseFloat calls (O(n log n) savings).
    if (hasSorts && filteredIds.length > 1) {
        var sortCache = {};
        var sortFieldIds = [];
        for (var ssi = 0; ssi < currentSorts.length; ssi++) {
            sortFieldIds.push(currentSorts[ssi].fieldId);
        }
        for (var s = 0; s < filteredIds.length; s += BATCH_SIZE) {
            var sortBatchIds = filteredIds.slice(s, s + BATCH_SIZE);
            var sortBatchRecords = await getRecordsByIds(currentTable, sortBatchIds);
            for (var sr = 0; sr < sortBatchRecords.length; sr++) {
                var rec = sortBatchRecords[sr];
                var vals = {};
                for (var ssi2 = 0; ssi2 < sortFieldIds.length; ssi2++) {
                    var raw = getCellValue(rec, sortFieldIds[ssi2]);
                    if (raw == null) {
                        vals[sortFieldIds[ssi2]] = null;
                    } else {
                        var str = valueToString(raw).toLowerCase();
                        var num = parseFloat(str);
                        vals[sortFieldIds[ssi2]] = isNaN(num) ? str : num;
                    }
                }
                sortCache[rec.recordId] = vals;
            }
        }

        filteredIds.sort(function(idA, idB) {
            var valsA = sortCache[idA] || {};
            var valsB = sortCache[idB] || {};
            for (var i = 0; i < currentSorts.length; i++) {
                var fid = currentSorts[i].fieldId;
                var dir = currentSorts[i].direction;
                var a = valsA[fid], b = valsB[fid];
                if (a === b) continue;
                if (a == null) return dir === 'asc' ? -1 : 1;
                if (b == null) return dir === 'asc' ? 1 : -1;
                var cmp;
                if (typeof a === 'number' && typeof b === 'number') {
                    cmp = a - b;
                } else {
                    cmp = ('' + a).localeCompare('' + b);
                }
                if (cmp !== 0) return dir === 'asc' ? cmp : -cmp;
            }
            return 0;
        });
        sortCache = null;
    }

    // Cache the result for subsequent renders with the same config
    _filterCache.key = cacheKey;
    _filterCache.result = filteredIds;
    return filteredIds;
}

// Close all view control dropdowns
function closeViewControlDropdowns() {
    document.querySelectorAll('.view-control-dropdown').forEach(d => d.classList.remove('open'));
}

// Toggle filter dropdown
function toggleFilterDropdown() {
    var dropdown = document.getElementById('filter-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        filterDropdownSearch = '';
        var searchInput = document.getElementById('filter-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderFilterDropdown();
    }
}

// Toggle sort dropdown
function toggleSortDropdown() {
    var dropdown = document.getElementById('sort-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        sortDropdownSearch = '';
        var searchInput = document.getElementById('sort-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderSortDropdown();
    }
}

// Toggle group dropdown
function toggleGroupDropdown() {
    var dropdown = document.getElementById('group-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        groupDropdownSearch = '';
        var searchInput = document.getElementById('group-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderGroupDropdown();
    }
}

// Toggle color dropdown
function toggleColorDropdown() {
    var dropdown = document.getElementById('color-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        var searchInput = document.getElementById('color-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderColorDropdown();
    }
}

// Toggle row height dropdown
function toggleRowHeightDropdown() {
    var dropdown = document.getElementById('row-height-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        updateRowHeightDropdown();
    }
}

// Get sorted fields for dropdown: alphabetical, with selected/used fields at top
function getSortedFieldsForDropdown(fields, usedFieldIds, filterText) {
    var filter = (filterText || '').toLowerCase().trim();
    var fieldArray = [];

    for (var fid in fields) {
        var field = fields[fid];
        var fieldName = field.fieldName || fid;

        // Filter by search text
        if (filter && !fieldName.toLowerCase().includes(filter)) {
            continue;
        }

        fieldArray.push({
            fieldId: fid,
            fieldName: fieldName,
            isUsed: usedFieldIds.indexOf(fid) !== -1
        });
    }

    // Sort: used fields first, then alphabetically
    fieldArray.sort(function(a, b) {
        if (a.isUsed !== b.isUsed) {
            return a.isUsed ? -1 : 1;
        }
        return a.fieldName.localeCompare(b.fieldName);
    });

    return fieldArray;
}

// Current search state for dropdowns
var filterDropdownSearch = '';
var sortDropdownSearch = '';
var groupDropdownSearch = '';

// Render filter dropdown  renders the root filter group
function renderFilterDropdown(filterText) {
    if (!currentTable) return;
    var list = document.getElementById('filter-list');

    if (filterText !== undefined) {
        filterDropdownSearch = filterText;
    }

    currentFilters = normalizeFilterGroup(currentFilters);

    if (!hasFilterConditions(currentFilters)) {
        list.innerHTML = '<div class="empty-filters">No filters applied</div>';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};
    var sortedFields = getSortedFieldsForDropdown(fields, [], filterDropdownSearch);

    list.innerHTML = renderFilterGroupHtml(currentFilters, [], fields, sortedFields, true);
    updateFilterCount();
}

// Render a single filter group recursively. Returns HTML string.
// path: array of indices leading to this group in the tree
// isRoot: true for the top-level group (hides the remove-group button)
function renderFilterGroupHtml(group, path, fields, sortedFields, isRoot) {
    var pathStr = JSON.stringify(path);
    var html = '<div class="filter-group">';

    // Group header with AND/OR toggle
    html += '<div class="filter-group-header">';
    html += '<div class="filter-group-logic-toggle">';
    html += '<button class="' + (group.logic === 'AND' ? 'active' : '') + '" onclick="setFilterGroupLogic(' + esc(pathStr) + ', \'AND\')">AND</button>';
    html += '<button class="' + (group.logic === 'OR' ? 'active' : '') + '" onclick="setFilterGroupLogic(' + esc(pathStr) + ', \'OR\')">OR</button>';
    html += '</div>';
    html += '<div class="filter-group-actions">';
    html += '<button class="filter-group-add-btn" onclick="addFilterToGroup(' + esc(pathStr) + ')">+ Rule</button>';
    html += '<button class="filter-group-add-btn" onclick="addSubGroup(' + esc(pathStr) + ')">+ Group</button>';
    if (!isRoot) {
        html += '<button class="filter-group-remove-btn" onclick="removeFilterAtPath(' + esc(pathStr) + ')" title="Remove group">&times;</button>';
    }
    html += '</div>';
    html += '</div>';

    // Conditions
    html += '<div class="filter-group-conditions">';
    for (var i = 0; i < group.conditions.length; i++) {
        var c = group.conditions[i];
        var childPath = path.concat([i]);

        if (c.type === 'group' || (c.logic && Array.isArray(c.conditions))) {
            // Nested group
            c.type = 'group'; // normalize
            html += renderFilterGroupHtml(c, childPath, fields, sortedFields, false);
        } else {
            // Leaf condition row
            var childPathStr = JSON.stringify(childPath);
            html += '<div class="filter-row">';

            // Logic label for 2nd+ conditions
            if (i > 0) {
                html += '<span class="filter-logic-label">' + esc(group.logic) + '</span>';
            } else {
                html += '<span class="filter-logic-label">Where</span>';
            }

            // Field select
            html += '<select onchange="updateFilterAtPath(' + esc(childPathStr) + ', \'fieldId\', this.value)">';
            var selectedInList = false;
            for (var j = 0; j < sortedFields.length; j++) {
                var sf = sortedFields[j];
                var sel = c.fieldId === sf.fieldId ? ' selected' : '';
                if (sel) selectedInList = true;
                html += '<option value="' + esc(sf.fieldId) + '"' + sel + '>' + esc(sf.fieldName) + '</option>';
            }
            if (!selectedInList && fields[c.fieldId]) {
                var selField = fields[c.fieldId];
                html += '<option value="' + esc(c.fieldId) + '" selected>' + esc(selField.fieldName || c.fieldId) + '</option>';
            }
            html += '</select>';

            // Operator select
            html += '<select onchange="updateFilterAtPath(' + esc(childPathStr) + ', \'operator\', this.value)">';
            html += '<option value="contains"' + (c.operator === 'contains' ? ' selected' : '') + '>contains</option>';
            html += '<option value="equals"' + (c.operator === 'equals' ? ' selected' : '') + '>equals</option>';
            html += '<option value="not_equals"' + (c.operator === 'not_equals' ? ' selected' : '') + '>does not equal</option>';
            html += '<option value="is_empty"' + (c.operator === 'is_empty' ? ' selected' : '') + '>is empty</option>';
            html += '<option value="is_not_empty"' + (c.operator === 'is_not_empty' ? ' selected' : '') + '>is not empty</option>';
            html += '</select>';

            // Value input (hidden for empty/not-empty operators)
            if (c.operator !== 'is_empty' && c.operator !== 'is_not_empty') {
                html += '<input type="text" value="' + esc(c.value || '') + '" onchange="updateFilterAtPath(' + esc(childPathStr) + ', \'value\', this.value)" placeholder="Value">';
            }

            html += '<button class="filter-remove-btn" onclick="removeFilterAtPath(' + esc(childPathStr) + ')" title="Remove">&times;</button>';
            html += '</div>';
        }
    }
    html += '</div>';
    html += '</div>';
    return html;
}

// Filter filter dropdown based on search input
function filterFilterDropdown(filterText) {
    renderFilterDropdown(filterText);
}

// Resolve a path to the parent group node
function _resolveFilterParent(path) {
    var node = currentFilters;
    for (var i = 0; i < path.length - 1; i++) {
        node = node.conditions[path[i]];
        if (!node) return null;
    }
    return node;
}

// Set the logic (AND/OR) for a filter group at the given path
function setFilterGroupLogic(path, logic) {
    var node = currentFilters;
    for (var i = 0; i < path.length; i++) {
        node = node.conditions[path[i]];
        if (!node) return;
    }
    if (path.length === 0) node = currentFilters;
    node.logic = logic;
    renderFilterDropdown();
    applyFilters();
}

// Add a leaf condition to the group at the given path
function addFilterToGroup(path) {
    if (!currentTable) return;
    var fields = META_FIELDS[currentTable] || {};
    var sortedFields = getSortedFieldsForDropdown(fields, [], '');
    var firstFieldId = sortedFields.length > 0 ? sortedFields[0].fieldId : null;
    if (!firstFieldId) return;

    var node = currentFilters;
    for (var i = 0; i < path.length; i++) {
        node = node.conditions[path[i]];
        if (!node) return;
    }
    if (path.length === 0) node = currentFilters;

    node.conditions.push({
        type: 'condition',
        fieldId: firstFieldId,
        operator: 'contains',
        value: ''
    });
    renderFilterDropdown();
    applyFilters();
}

// Add a nested sub-group to the group at the given path
function addSubGroup(path) {
    var node = currentFilters;
    for (var i = 0; i < path.length; i++) {
        node = node.conditions[path[i]];
        if (!node) return;
    }
    if (path.length === 0) node = currentFilters;

    // Default to opposite logic of parent for useful nesting
    var childLogic = node.logic === 'AND' ? 'OR' : 'AND';
    node.conditions.push({
        type: 'group',
        logic: childLogic,
        conditions: []
    });
    renderFilterDropdown();
    applyFilters();
}

// Add filter to root group (called from the main "+ Add filter" button)
function addFilter() {
    addFilterToGroup([]);
}

// Update a filter condition property at the given path
function updateFilterAtPath(path, prop, value) {
    var parent = _resolveFilterParent(path);
    if (!parent) return;
    var idx = path[path.length - 1];
    if (parent.conditions[idx]) {
        parent.conditions[idx][prop] = value;
        renderFilterDropdown();
        applyFilters();
    }
}

// Remove a filter condition or group at the given path
function removeFilterAtPath(path) {
    var parent = _resolveFilterParent(path);
    if (!parent) return;
    var idx = path[path.length - 1];
    parent.conditions.splice(idx, 1);
    renderFilterDropdown();
    applyFilters();
}

// Legacy compat: updateFilter and removeFilter by flat index (updates root group)
function updateFilter(index, prop, value) {
    updateFilterAtPath([index], prop, value);
}
function removeFilter(index) {
    removeFilterAtPath([index]);
}

// Update filter count badge
function updateFilterCount() {
    var countEl = document.getElementById('filter-count');
    var btn = document.getElementById('filter-btn');
    var count = countFilterConditions(currentFilters);
    if (count > 0) {
        countEl.textContent = count;
        countEl.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        countEl.style.display = 'none';
        btn.classList.remove('active');
    }
}

// Apply filters (re-render table)
async function applyFilters() {
    updateFilterCount();
    if (_urlStateBootstrapped) persistUrlState();
    await renderTable();
    // Save filters to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('filters', currentFilters);
    }
}

// Render sort dropdown
function renderSortDropdown(filterText) {
    if (!currentTable) return;
    var list = document.getElementById('sort-list');

    if (filterText !== undefined) {
        sortDropdownSearch = filterText;
    }

    if (currentSorts.length === 0) {
        list.innerHTML = '<div class="empty-sorts">No sorts applied</div>';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};

    // Get used field IDs from current sorts
    var usedFieldIds = currentSorts.map(function(s) { return s.fieldId; });
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, sortDropdownSearch);

    var html = '';

    for (var i = 0; i < currentSorts.length; i++) {
        var sort = currentSorts[i];
        html += '<div class="sort-row">';
        html += '<select onchange="updateSort(' + i + ', \'fieldId\', this.value)">';

        // Add sorted fields to dropdown, ensuring selected field is always included
        var selectedInList = false;
        for (var j = 0; j < sortedFields.length; j++) {
            var sf = sortedFields[j];
            var sel = sort.fieldId === sf.fieldId ? ' selected' : '';
            if (sel) selectedInList = true;
            html += '<option value="' + esc(sf.fieldId) + '"' + sel + '>' + esc(sf.fieldName) + '</option>';
        }
        // If selected field was filtered out, still include it
        if (!selectedInList && fields[sort.fieldId]) {
            var selField = fields[sort.fieldId];
            html += '<option value="' + esc(sort.fieldId) + '" selected>' + esc(selField.fieldName || sort.fieldId) + '</option>';
        }

        html += '</select>';
        html += '<div class="sort-direction-btns">';
        html += '<button class="sort-direction-btn' + (sort.direction === 'asc' ? ' active' : '') + '" onclick="updateSort(' + i + ', \'direction\', \'asc\')">AZ</button>';
        html += '<button class="sort-direction-btn' + (sort.direction === 'desc' ? ' active' : '') + '" onclick="updateSort(' + i + ', \'direction\', \'desc\')">ZA</button>';
        html += '</div>';
        html += '<button class="sort-remove-btn" onclick="removeSort(' + i + ')" title="Remove">&times;</button>';
        html += '</div>';
    }

    list.innerHTML = html;
    updateSortCount();
}

// Filter sort dropdown based on search input
function filterSortDropdown(filterText) {
    renderSortDropdown(filterText);
}

// Add sort
function addSort() {
    if (!currentTable) return;
    var fields = META_FIELDS[currentTable] || {};
    // Get sorted fields (alphabetically)
    var sortedFields = getSortedFieldsForDropdown(fields, [], '');
    var firstFieldId = sortedFields.length > 0 ? sortedFields[0].fieldId : null;
    if (!firstFieldId) return;

    currentSorts.push({
        fieldId: firstFieldId,
        direction: 'asc'
    });
    renderSortDropdown();
    applySorts();
}

// Update sort
function updateSort(index, prop, value) {
    if (currentSorts[index]) {
        currentSorts[index][prop] = value;
        renderSortDropdown();
        applySorts();
    }
}

// Remove sort
function removeSort(index) {
    currentSorts.splice(index, 1);
    renderSortDropdown();
    applySorts();
}

// Update sort count badge
function updateSortCount() {
    var countEl = document.getElementById('sort-count');
    var btn = document.getElementById('sort-btn');
    if (currentSorts.length > 0) {
        countEl.textContent = currentSorts.length;
        countEl.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        countEl.style.display = 'none';
        btn.classList.remove('active');
    }
}

// Apply sorts (re-render table)
async function applySorts() {
    updateSortCount();
    await renderTable();
    // Save sorts to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('sorts', currentSorts);
    }
}

// Render group dropdown
function renderGroupDropdown(filterText) {
    if (!currentTable) return;
    var container = document.getElementById('group-options');
    var fields = META_FIELDS[currentTable] || {};

    if (filterText !== undefined) {
        groupDropdownSearch = filterText;
    }

    var filter = (groupDropdownSearch || '').toLowerCase().trim();

    var html = '';

    // Show "None" option only if it matches filter or no filter
    if (!filter || 'none'.includes(filter)) {
        html += '<div class="group-option' + (!currentGroupBy ? ' none-selected' : '') + '" onclick="setGroupBy(null)">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>None</span>';
        html += '</div>';
    }

    // Get sorted fields with selected at top
    var usedFieldIds = currentGroupBy ? [currentGroupBy] : [];
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filter);

    for (var i = 0; i < sortedFields.length; i++) {
        var sf = sortedFields[i];
        var isSelected = currentGroupBy === sf.fieldId;
        html += '<div class="group-option' + (isSelected ? ' selected' : '') + '" onclick="setGroupBy(\'' + esc(sf.fieldId) + '\')">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>' + esc(sf.fieldName) + '</span>';
        html += '</div>';
    }

    if (!html) {
        html = '<div class="group-option" style="color: #999; cursor: default;">No matching fields</div>';
    }

    container.innerHTML = html;
}

// Filter group dropdown based on search input
function filterGroupDropdown(filterText) {
    renderGroupDropdown(filterText);
}

// Update group button state
function updateGroupButtonState() {
    var btn = document.getElementById('group-btn');
    if (currentGroupBy) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

// Set group by field
async function setGroupBy(fieldId) {
    currentGroupBy = fieldId;
    closeViewControlDropdowns();
    updateGroupButtonState();
    await renderTable();
    // Save groupBy to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('groupBy', currentGroupBy);
    }
}

// Color palette: 20 visually distinct colors for row coloring
var COLOR_PALETTE = [
    'rgba(59, 130, 246, 0.12)',   // blue
    'rgba(16, 185, 129, 0.12)',   // emerald
    'rgba(245, 158, 11, 0.12)',   // amber
    'rgba(239, 68, 68, 0.12)',    // red
    'rgba(139, 92, 246, 0.12)',   // violet
    'rgba(236, 72, 153, 0.12)',   // pink
    'rgba(6, 182, 212, 0.12)',    // cyan
    'rgba(249, 115, 22, 0.12)',   // orange
    'rgba(34, 197, 94, 0.12)',    // green
    'rgba(168, 85, 247, 0.12)',   // purple
    'rgba(14, 165, 233, 0.12)',   // sky
    'rgba(251, 146, 60, 0.12)',   // orange-light
    'rgba(52, 211, 153, 0.12)',   // emerald-light
    'rgba(244, 63, 94, 0.12)',    // rose
    'rgba(99, 102, 241, 0.12)',   // indigo
    'rgba(217, 70, 239, 0.12)',   // fuchsia
    'rgba(20, 184, 166, 0.12)',   // teal
    'rgba(234, 179, 8, 0.12)',    // yellow
    'rgba(248, 113, 113, 0.12)',  // red-light
    'rgba(96, 165, 250, 0.12)'   // blue-light
];
var COLOR_SWATCH_SOLID = [
    '#3b82f6','#10b981','#f59e0b','#ef4444','#8b5cf6',
    '#ec4899','#06b6d4','#f97316','#22c55e','#a855f7',
    '#0ea5e9','#fb923c','#34d399','#f43f5e','#6366f1',
    '#d946ef','#14b8a6','#eab308','#f87171','#60a5fa'
];

// Build a value-to-color-index map for the current color field
function buildColorMap(recordIds, recordMap, colorFieldId, colNames) {
    var map = {};
    var idx = 0;
    for (var i = 0; i < recordIds.length; i++) {
        var row = recordMap[recordIds[i]] || {};
        var value = row[colorFieldId];
        if (value === undefined && colNames) value = row[colNames[colorFieldId]];
        var key = getGroupKeyFromValue(value);
        if (!(key in map)) {
            map[key] = idx % COLOR_PALETTE.length;
            idx++;
        }
    }
    return map;
}

function updateColorButtonState() {
    var btn = document.getElementById('color-btn');
    if (currentColorBy) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

// Update record count badge next to filter button
function updateRecordCountBadge() {
    var badge = document.getElementById('record-count-badge');
    if (!badge) return;
    var isFiltered = hasFilterConditions(currentFilters) || currentSearchQuery;
    if (isFiltered) {
        badge.textContent = currentRecordIds.length.toLocaleString() + '/' + originalRecordIds.length.toLocaleString();
        badge.className = 'record-count-badge filtered';
    } else {
        badge.textContent = originalRecordIds.length.toLocaleString() + ' records';
        badge.className = 'record-count-badge';
    }
}

// Render color dropdown
function renderColorDropdown(filterText) {
    if (!currentTable) return;
    var container = document.getElementById('color-options');
    var fields = META_FIELDS[currentTable] || {};
    var filter = (filterText || '').toLowerCase().trim();

    var html = '';

    // Show "None" option only if it matches filter or no filter
    if (!filter || 'none'.includes(filter)) {
        html += '<div class="color-option' + (!currentColorBy ? ' none-selected' : '') + '" onclick="setColorBy(null)">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>None</span>';
        html += '</div>';
    }

    // Get sorted fields with selected at top
    var usedFieldIds = currentColorBy ? [currentColorBy] : [];
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filter);

    for (var i = 0; i < sortedFields.length; i++) {
        var sf = sortedFields[i];
        var isSelected = currentColorBy === sf.fieldId;
        html += '<div class="color-option' + (isSelected ? ' selected' : '') + '" onclick="setColorBy(\'' + esc(sf.fieldId) + '\')">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>' + esc(sf.fieldName) + '</span>';
        html += '</div>';
    }

    if (!html) {
        html = '<div class="color-option" style="color: #999; cursor: default;">No matching fields</div>';
    }

    container.innerHTML = html;
}

// Filter color dropdown based on search input
function filterColorDropdown(filterText) {
    renderColorDropdown(filterText);
}

// Set color by field
async function setColorBy(fieldId) {
    currentColorBy = fieldId;
    closeViewControlDropdowns();
    updateColorButtonState();
    await renderTable();
    // Persist colorBy to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('colorBy', currentColorBy);
    }
}

// Update row height dropdown selection
function updateRowHeightDropdown() {
    document.querySelectorAll('.row-height-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    var options = document.querySelectorAll('.row-height-option');
    options.forEach(opt => {
        if (opt.textContent.trim().toLowerCase().replace(' ', '-') === currentRowHeight ||
            (opt.textContent.trim() === 'Short' && currentRowHeight === 'short') ||
            (opt.textContent.trim() === 'Medium' && currentRowHeight === 'medium') ||
            (opt.textContent.trim() === 'Tall' && currentRowHeight === 'tall') ||
            (opt.textContent.trim() === 'Extra tall' && currentRowHeight === 'extra-tall')) {
            opt.classList.add('selected');
        }
    });
}

// Set row height
function setRowHeight(height) {
    currentRowHeight = height;
    closeViewControlDropdowns();

    var table = document.getElementById('table');
    if (table) {
        table.className = 'row-height-' + height;
    }
}

// Handle view search (debounced  reduced to 80ms since pre-built search index
// makes filtering near-instant for local data)
var _viewSearchTimer = null;
function handleViewSearch(query) {
    clearTimeout(_viewSearchTimer);
    var q = query.toLowerCase();
    _viewSearchTimer = setTimeout(function() {
        currentSearchQuery = q;
        if (_urlStateBootstrapped) persistUrlState();
        renderTable();
    }, 80);
}

// Update closeAllDropdowns to also close view control dropdowns
var originalCloseAllDropdowns = closeAllDropdowns;
closeAllDropdowns = function() {
    originalCloseAllDropdowns();
    closeViewControlDropdowns();
};

// Add click handler for view control dropdowns
document.addEventListener('click', function(e) {
    var wrapper = e.target.closest('.view-control-wrapper');
    if (!wrapper) {
        closeViewControlDropdowns();
    }
});

// ============ Column Drag & Drop Reordering ============

var draggedColumnFieldId = null;

// Optimized DOM-based column movement (no full table re-render)
function moveColumnInDOM(fromIndex, toIndex) {
    var table = document.getElementById('table');
    if (!table) return false;

    // Account for the row-number column at index 0
    var domFromIndex = fromIndex + 1;
    var domToIndex = toIndex + 1;

    // Move header
    var headerRow = table.querySelector('thead tr');
    if (!headerRow) return false;

    var headers = headerRow.children;
    if (domFromIndex >= headers.length || domToIndex >= headers.length) return false;

    var headerToMove = headers[domFromIndex];
    var targetHeader = headers[domToIndex];

    if (domFromIndex < domToIndex) {
        // Moving right: insert after target
        targetHeader.after(headerToMove);
    } else {
        // Moving left: insert before target
        targetHeader.before(headerToMove);
    }

    // Update data-field-index attributes on all headers
    Array.from(headers).forEach((th, idx) => {
        if (idx > 0 && th.dataset.fieldIndex !== undefined) {
            th.dataset.fieldIndex = idx - 1;
        }
    });

    // Move cells in all body rows
    var bodyRows = table.querySelectorAll('tbody tr:not(.group-header-row)');
    bodyRows.forEach(row => {
        var cells = row.children;
        if (domFromIndex >= cells.length || domToIndex >= cells.length) return;

        var cellToMove = cells[domFromIndex];
        var targetCell = cells[domToIndex];

        if (domFromIndex < domToIndex) {
            targetCell.after(cellToMove);
        } else {
            targetCell.before(cellToMove);
        }
    });

    return true;
}

// Update field visibility in memory and trigger debounced save (no IndexedDB await)
function updateFieldVisibilityFast(tableId, viewId, newHiddenFieldIds) {
    // Update in-memory config
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    if (!VIEW_FIELD_CONFIG[tableId][viewId]) {
        VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [], fieldOrder: [] };
    }
    VIEW_FIELD_CONFIG[tableId][viewId].hiddenFieldIds = newHiddenFieldIds;

    // Update META_VIEWS as well for consistency
    if (META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId].hiddenFieldIds = newHiddenFieldIds;
    }

    invalidateVisibleFieldsCache();
    // Mark dirty for debounced auto-save (uses existing system)
    markViewDirty('hiddenFieldIds', newHiddenFieldIds);
}

// Update field order in memory and trigger debounced save
function updateFieldOrderFast(tableId, viewId, newFieldOrder) {
    // Update in-memory config
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    if (!VIEW_FIELD_CONFIG[tableId][viewId]) {
        VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [], fieldOrder: [] };
    }
    VIEW_FIELD_CONFIG[tableId][viewId].fieldOrder = newFieldOrder;

    // Update META_VIEWS as well for consistency
    if (META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId].fieldOrder = newFieldOrder;
    }

    invalidateVisibleFieldsCache();
    // Mark dirty for debounced auto-save (uses existing system)
    markViewDirty('fieldOrder', newFieldOrder);
}

function handleColumnDragStart(event) {
    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId) return;

    draggedColumnFieldId = th.dataset.fieldId;
    th.classList.add('dragging');

    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', draggedColumnFieldId);
}

function handleColumnDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';

    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId) return;

    // Remove drag-over class from all headers
    document.querySelectorAll('th.drag-over').forEach(el => el.classList.remove('drag-over'));

    // Add drag-over class to current target
    if (th.dataset.fieldId !== draggedColumnFieldId) {
        th.classList.add('drag-over');
    }
}

function handleColumnDragEnd(event) {
    // Remove all drag classes
    document.querySelectorAll('th.dragging').forEach(el => el.classList.remove('dragging'));
    document.querySelectorAll('th.drag-over').forEach(el => el.classList.remove('drag-over'));
    draggedColumnFieldId = null;
}

function handleColumnDrop(event) {
    event.preventDefault();

    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId || !draggedColumnFieldId) {
        handleColumnDragEnd(event);
        return;
    }

    var targetFieldId = th.dataset.fieldId;
    if (targetFieldId === draggedColumnFieldId) {
        handleColumnDragEnd(event);
        return;
    }

    // Reorder the fields (synchronous DOM update)
    reorderColumn(draggedColumnFieldId, targetFieldId);

    handleColumnDragEnd(event);
}

function reorderColumn(draggedFieldId, targetFieldId) {
    if (!currentTable) return;

    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var fromIdx = config.fieldOrder.indexOf(draggedFieldId);
    var toIdx = config.fieldOrder.indexOf(targetFieldId);

    if (fromIdx < 0 || toIdx < 0) return;

    // Optimized: Move columns in DOM immediately (no full re-render)
    var domMoved = moveColumnInDOM(fromIdx, toIdx);

    // Update the field order array
    config.fieldOrder.splice(fromIdx, 1);
    var insertIdx = fromIdx < toIdx ? toIdx - 1 : toIdx;
    config.fieldOrder.splice(insertIdx, 0, draggedFieldId);

    // Fast update: in-memory + debounced save (no blocking await)
    updateFieldOrderFast(currentTable, viewId, config.fieldOrder);

    // Update fields dropdown to reflect new order
    renderFieldsDropdown();
}

// ============ Default View Protection & View Creation ============

// Check if current view is the default view (cannot be modified directly)
function isDefaultView() {
    return !currentView || currentView === '_default';
}

// Generate default view name: "{Table Name} {DateTime}"
function generateDefaultViewName() {
    var tableName = 'View';
    if (currentTable) {
        tableName = resolveTableName(currentTable);
    }
    var now = new Date();
    var dateStr = now.toLocaleDateString() + ' ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    return tableName + ' ' + dateStr;
}

// Show create view modal when user tries to modify default view
function promptCreateViewFromDefault(action, data, reason) {
    pendingViewAction = { action: action, data: data };

    // Close any open dropdowns so they don't overlap the modal
    closeAllDropdowns();

    // Set the reason text
    var reasonEl = document.getElementById('create-view-reason');
    if (reasonEl) {
        reasonEl.textContent = reason || 'The default view cannot be modified. Create a new view to customize.';
    }

    // Set default view name
    var nameInput = document.getElementById('create-view-name');
    if (nameInput) {
        nameInput.value = generateDefaultViewName();
    }

    // Reset other fields
    document.getElementById('create-view-type').value = 'grid';
    document.getElementById('create-view-tags').value = '';

    // Populate parent view options
    populateParentViewOptions();

    // Populate workspace options
    populateWorkspaceOptions();

    // Show modal
    document.getElementById('create-view-modal').classList.add('open');

    // Focus name input
    setTimeout(() => nameInput?.focus(), 100);
}

// Populate parent view dropdown for nesting
function populateParentViewOptions() {
    var select = document.getElementById('create-view-parent');
    if (!select || !currentTable) return;

    var html = '<option value="">(No parent - root level)</option>';
    var views = META_VIEWS[currentTable] || {};

    for (var vid in views) {
        if (vid === '_default') continue;
        var view = views[vid];
        html += '<option value="' + esc(vid) + '">' + esc(view.viewName || vid) + '</option>';
    }

    select.innerHTML = html;
}

// Populate workspace dropdown
function populateWorkspaceOptions() {
    var select = document.getElementById('create-view-workspace');
    if (!select) return;

    var html = '<option value="">(None)</option>';

    for (var wid in WORKSPACES) {
        var ws = WORKSPACES[wid];
        html += '<option value="' + esc(wid) + '">' + esc(ws.workspaceName) + '</option>';
    }

    // Add option to create new workspace
    html += '<option value="_new">+ Create new workspace...</option>';

    select.innerHTML = html;
}

// Close create view modal
function closeCreateViewModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('create-view-modal').classList.remove('open');
    pendingViewAction = null;
}

// Submit create view
async function submitCreateView() {
    var nameInput = document.getElementById('create-view-name');
    var typeSelect = document.getElementById('create-view-type');
    var parentSelect = document.getElementById('create-view-parent');
    var tagsInput = document.getElementById('create-view-tags');
    var workspaceSelect = document.getElementById('create-view-workspace');

    var viewName = nameInput.value.trim();
    if (!viewName) {
        alert('Please enter a view name');
        nameInput.focus();
        return;
    }

    // Disable button to prevent double-clicks
    var submitBtn = document.getElementById('create-view-submit');
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Creating...';
    }

    try {
        var viewType = typeSelect.value;
        var parentViewId = parentSelect.value || null;
        var tags = tagsInput.value.split(',').map(t => t.trim()).filter(t => t);
        var workspaceId = workspaceSelect.value;

        // Handle "create new workspace" option
        if (workspaceId === '_new') {
            var wsName = prompt('Enter workspace name:');
            if (wsName) {
                workspaceId = await createWorkspace(wsName);
            } else {
                workspaceId = null;
            }
        }

        // Create the new view
        var newViewId = 'viw_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        var newView = {
            tableId: currentTable,
            viewId: newViewId,
            viewName: viewName,
            viewType: viewType,
            parentViewId: parentViewId,
            tags: tags,
            hiddenFieldIds: [],
            fieldOrder: [],
            filters: [],
            sorts: [],
            groupBy: null,
            folderId: null
        };

        // If there was a pending action (filter, sort, etc.), apply it to the new view
        if (pendingViewAction) {
            switch (pendingViewAction.action) {
                case 'filter':
                    newView.filters = [pendingViewAction.data];
                    break;
                case 'sort':
                    newView.sorts = [pendingViewAction.data];
                    break;
                case 'group':
                    newView.groupBy = pendingViewAction.data;
                    break;
                case 'hideField':
                    newView.hiddenFieldIds = [pendingViewAction.data];
                    break;
            }
        }

        // Add to workspace if selected
        if (workspaceId && WORKSPACES[workspaceId]) {
            WORKSPACES[workspaceId].viewIds.push(newViewId);
            await saveWorkspace(WORKSPACES[workspaceId]);
        }

        // Save the view
        if (!META_VIEWS[currentTable]) META_VIEWS[currentTable] = {};
        META_VIEWS[currentTable][newViewId] = newView;
        await saveView(newView);

        // Set ownership and sharing on the new view
        var currentUserId = MatrixClient.getUserId();
        if (currentUserId) {
            await SharedViews.setViewOwnership(currentTable, newViewId, currentUserId);
        }

        // Apply sharing preference from modal
        var sharingSelect = document.getElementById('create-view-sharing');
        var sharingLevel = sharingSelect ? sharingSelect.value : 'everyone';
        if (sharingLevel !== 'private' && currentUserId) {
            var sharedWith = [];
            if (sharingLevel === 'specific') {
                var checkboxes = document.querySelectorAll('#create-view-users-list input[type="checkbox"]:checked');
                checkboxes.forEach(function(cb) { sharedWith.push(cb.value); });
            }
            await SharedViews.shareView(currentTable, newViewId, sharingLevel, sharedWith);
        }

        // Close modal
        closeCreateViewModal();

        // Refresh sidebar
        await loadTableViewsAsync(currentTable);

        // Switch to the new view
        await selectTableView(currentTable, newViewId);
    } catch (err) {
        console.error('Failed to create view:', err);
        alert('Failed to create view: ' + (err.message || 'Unknown error'));
    } finally {
        // Re-enable button
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Create View';
        }
    }
}

// ============ Workspace Management ============

// Get all workspaces from IndexedDB
function getAllWorkspaces() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readonly');
        var req = tx.objectStore('workspaces').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Save a workspace to IndexedDB
function saveWorkspace(workspace) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readwrite');
        tx.objectStore('workspaces').put(workspace);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Delete a workspace from IndexedDB
function deleteWorkspaceFromDB(workspaceId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readwrite');
        tx.objectStore('workspaces').delete(workspaceId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Create a new workspace
async function createWorkspace(name) {
    var workspaceId = 'ws_' + Date.now();
    var workspace = {
        workspaceId: workspaceId,
        workspaceName: name,
        viewIds: [],
        sortOrder: Object.keys(WORKSPACES).length
    };

    WORKSPACES[workspaceId] = workspace;
    await saveWorkspace(workspace);

    // Sync to backend
    await saveWorkspaceToBackend(workspace, 'create');

    return workspaceId;
}

// Add a view to a workspace
async function addViewToWorkspace(viewId, workspaceId) {
    if (!WORKSPACES[workspaceId]) return;

    if (!WORKSPACES[workspaceId].viewIds.includes(viewId)) {
        WORKSPACES[workspaceId].viewIds.push(viewId);
        await saveWorkspace(WORKSPACES[workspaceId]);
        await saveWorkspaceToBackend(WORKSPACES[workspaceId], 'update');
    }
}

// Remove a view from a workspace
async function removeViewFromWorkspace(viewId, workspaceId) {
    if (!WORKSPACES[workspaceId]) return;

    var idx = WORKSPACES[workspaceId].viewIds.indexOf(viewId);
    if (idx >= 0) {
        WORKSPACES[workspaceId].viewIds.splice(idx, 1);
        await saveWorkspace(WORKSPACES[workspaceId]);
        await saveWorkspaceToBackend(WORKSPACES[workspaceId], 'update');
    }
}

// Delete a workspace
async function deleteWorkspace(workspaceId) {
    if (!confirm('Delete this workspace?')) return;

    delete WORKSPACES[workspaceId];
    await deleteWorkspaceFromDB(workspaceId);
    await saveWorkspaceToBackend({ workspaceId: workspaceId }, 'delete');

    if (currentWorkspace === workspaceId) {
        currentWorkspace = null;
    }

    renderSidebar();
}

// Save workspace to backend (local only  data flows Airtable  n8n  Matrix)
async function saveWorkspaceToBackend(workspace, operator) {
    // Workspace config is stored locally via user preferences (Matrix account data).
    try {
        await UserPreferences.set('workspace:' + workspace.workspaceId, workspace);
    } catch (error) {
        console.error('Failed to save workspace:', error);
    }
}

// Load workspaces into memory
async function loadWorkspaces() {
    try {
        var workspaces = await getAllWorkspaces();
        WORKSPACES = {};
        workspaces.forEach(ws => WORKSPACES[ws.workspaceId] = ws);
    } catch (err) {
        console.error('Error loading workspaces:', err);
    }
}

// ============ Schema View Rendering ============

// Render schema view (card-based vertical layout)
async function renderSchemaView() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');

    // Get records (limited for performance)
    var displayRecordIds = currentRecordIds.slice(0, 50); // Show up to 50 cards

    if (displayRecordIds.length === 0) {
        container.innerHTML = '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        document.getElementById('pagination').style.display = 'none';
        return;
    }

    var records = await getRecordsByIds(currentTable, displayRecordIds);
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);

    var html = '<div class="schema-view-container">';

    for (var record of records) {
        var recordId = record.recordId;
        var recordFields = record.fields || {};

        html += '<div class="schema-card" data-record-id="' + esc(recordId) + '" onclick="handleRowClick(event, \'' + esc(currentTable) + '\', \'' + esc(recordId) + '\')" style="cursor: pointer;">';

        // Card header
        html += '<div class="schema-card-header">';
        html += '<span class="schema-card-id">' + esc(recordId) + '</span>';
        html += '<div class="schema-card-actions">';
        html += '<button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(recordId) + '\')" title="View field history">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
        html += '</button>';
        html += '</div>';
        html += '</div>';

        // Card body - all fields vertically
        html += '<div class="schema-card-body">';

        for (var fid of fieldIds) {
            var field = fields[fid];
            var fieldName = field.fieldName || fid;
            var value = recordFields[fid];
            if (value === undefined) value = recordFields[fieldName];

            html += '<div class="schema-field-row">';
            html += '<div class="schema-field-name">' + esc(fieldName) + '</div>';

            if (value == null || value === '') {
                html += '<div class="schema-field-value empty"></div>';
            } else {
                html += '<div class="schema-field-value">' + formatCell(value, field?.fieldType) + '</div>';
            }

            html += '</div>';
        }

        html += '</div>'; // .schema-card-body
        html += '</div>'; // .schema-card
    }

    html += '</div>'; // .schema-view-container

    container.innerHTML = html;

    // Update pagination info (schema view shows limited records)
    document.getElementById('pagination').style.display = 'none';
    updateStatus('Showing ' + displayRecordIds.length + ' of ' + totalRecords + ' records', true, null, 'Schema view');
}

// ============ View Type Detection & Rendering ============

// Get the current view's type
function getCurrentViewType() {
    if (!currentTable || !currentView || currentView === '_default') {
        return 'grid'; // Default view is always grid
    }

    var view = META_VIEWS[currentTable]?.[currentView];
    return view?.viewType || 'grid';
}

// Override renderTable to handle different view types
var originalRenderTable = renderTable;
renderTable = async function() {
    var viewType = getCurrentViewType();

    if (viewType === 'schema') {
        await renderSchemaView();
    } else {
        await originalRenderTable();
    }
};

// ============ Override Filter/Sort/Field Functions for Default View Protection ============

// Store original functions
var originalAddFilter = addFilter;
var originalAddSort = addSort;
var originalSetGroupBy = setGroupBy;
var originalToggleFieldVisibility = toggleFieldVisibility;

// Override addFilter to protect default view
addFilter = function() {
    if (isDefaultView()) {
        var fields = META_FIELDS[currentTable] || {};
        var firstFieldId = Object.keys(fields)[0];
        promptCreateViewFromDefault('filter', {
            fieldId: firstFieldId,
            operator: 'contains',
            value: ''
        }, 'To add filters, please create a new view. The default view shows all records without filters.');
        return;
    }
    originalAddFilter();
};

// Override addSort to protect default view
addSort = function() {
    if (isDefaultView()) {
        var fields = META_FIELDS[currentTable] || {};
        var firstFieldId = Object.keys(fields)[0];
        promptCreateViewFromDefault('sort', {
            fieldId: firstFieldId,
            direction: 'asc'
        }, 'To add sorting, please create a new view. The default view maintains the original record order.');
        return;
    }
    originalAddSort();
};

// Override setGroupBy to protect default view
setGroupBy = async function(fieldId) {
    if (isDefaultView() && fieldId) {
        promptCreateViewFromDefault('group', fieldId, 'To group records, please create a new view. The default view shows records ungrouped.');
        return;
    }
    await originalSetGroupBy(fieldId);
};

// Override toggleFieldVisibility to protect default view
toggleFieldVisibility = async function(fieldId) {
    if (isDefaultView()) {
        promptCreateViewFromDefault('hideField', fieldId, 'To customize visible fields, please create a new view. The default view shows all fields.');
        return;
    }
    await originalToggleFieldVisibility(fieldId);
};

// ============ View Tags UI ============

// Get tags for a view
function getViewTags(tableId, viewId) {
    var view = META_VIEWS[tableId]?.[viewId];
    return view?.tags || [];
}

// Add tag to a view
async function addTagToView(tableId, viewId, tag) {
    var view = META_VIEWS[tableId]?.[viewId];
    if (!view) return;

    if (!view.tags) view.tags = [];
    if (!view.tags.includes(tag)) {
        view.tags.push(tag);
        await saveView(view);
        markViewDirty('tags', view.tags);
    }
}

// Remove tag from a view
async function removeTagFromView(tableId, viewId, tag) {
    var view = META_VIEWS[tableId]?.[viewId];
    if (!view || !view.tags) return;

    var idx = view.tags.indexOf(tag);
    if (idx >= 0) {
        view.tags.splice(idx, 1);
        await saveView(view);
        markViewDirty('tags', view.tags);
    }
}

// Render tags for a view in sidebar
function renderViewTags(tags) {
    if (!tags || tags.length === 0) return '';

    var html = '<div class="view-tags">';
    tags.slice(0, 3).forEach(tag => {
        html += '<span class="view-tag">' + esc(tag) + '</span>';
    });
    if (tags.length > 3) {
        html += '<span class="view-tag">+' + (tags.length - 3) + '</span>';
    }
    html += '</div>';
    return html;
}

// ============ Enhanced Sidebar View Rendering ============

// Update renderViewItem to show tags, type badges, and nesting
var originalRenderViewItem = renderViewItem;
renderViewItem = function(tableId, view, inFolder) {
    var isActive = currentTable === tableId && currentView === view.viewId;
    var viewName = view.viewName || view.viewId;
    var viewIcon = getViewTypeIcon(view.viewType);
    var paddingClass = inFolder ? ' style="padding-left: 52px;"' : '';

    // Calculate nesting level
    var nestLevel = 0;
    var parentId = view.parentViewId;
    while (parentId && nestLevel < 3) {
        nestLevel++;
        var parentView = META_VIEWS[tableId]?.[parentId];
        parentId = parentView?.parentViewId;
    }

    var nestClass = nestLevel > 0 ? ' nested-level-' + nestLevel : '';

    var html = '<div class="table-view-item' + (isActive ? ' active' : '') + nestClass + '"' + paddingClass + ' ' +
           'onclick="selectTableView(\'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'oncontextmenu="showViewContextMenu(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')">';

    // Nesting indicator
    if (nestLevel > 0) {
        html += '<span class="view-nest-indicator"></span>';
    }

    html += '<span class="view-icon">' + viewIcon + '</span>' +
           '<span class="view-name">' + esc(viewName) + '</span>';

    // View type badge
    if (view.viewType && view.viewType !== 'grid') {
        var badgeLabel = view.viewType === 'schema' ? 'cards' : view.viewType;
        html += '<span class="view-type-badge ' + esc(view.viewType) + '">' + esc(badgeLabel) + '</span>';
    }

    html += '</div>';

    // Tags row (if present)
    var tags = view.tags || [];
    if (tags.length > 0) {
        html += renderViewTags(tags);
    }

    return html;
};

// ============ Matrix Setup Wizard ============

var wizardStep = 0;
var wizardData = {
    orgName: '',
    orgSpaceId: null,
    // Legacy data source
    aminoApiKey: '',
    aminoEndpoints: null,
    // Schema from legacy system
    legacyTables: {},
    legacyFields: {},
    legacyAmoData: null,
    // Client configuration
    clientTable: '',
    clientIdentifierField: '',
    clientVisibleTables: [],
    clientVisibleLinkedTables: [], // "which linked record types can a client see?"
    linkedRecordTables: {} // tableId -> fieldId that links to client table
};

var WIZARD_STEPS = [
    { id: 'org', title: 'Organization', subtitle: 'Set up or join your organization' },
    { id: 'legacy', title: 'Import Data', subtitle: 'Connect your existing data source' },
    { id: 'client-table', title: 'Client Records', subtitle: 'Which record type creates clients?' },
    { id: 'visibility', title: 'Client Visibility', subtitle: 'What can clients see?' },
    { id: 'hydrate', title: 'Hydrating', subtitle: 'Building your Matrix rooms' }
];

async function showMatrixWizard() {
    document.getElementById('matrix-wizard').classList.remove('hidden');
    wizardStep = 0;

    // Reuse existing Synapse session for MatrixClient (no second login needed)
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
        try {
            await MatrixClient.initialSync();
            wizardData.orgSpaceId = await MatrixClient.findOrgSpace();
        } catch (e) {
            console.error('[Wizard] Failed to initialize Matrix session:', e);
        }
    }

    renderWizardStep();
}

function hideMatrixWizard() {
    document.getElementById('matrix-wizard').classList.add('hidden');
}

function renderWizardStep() {
    var step = WIZARD_STEPS[wizardStep];

    // Update header
    document.getElementById('wizard-title').textContent = step.title;
    document.getElementById('wizard-subtitle').textContent = step.subtitle;

    // Update step dots
    var dots = document.querySelectorAll('.wizard-step-dot');
    dots.forEach(function(dot, i) {
        dot.className = 'wizard-step-dot';
        if (i < wizardStep) dot.classList.add('completed');
        if (i === wizardStep) dot.classList.add('active');
    });

    // Update footer buttons
    var backBtn = document.getElementById('wizard-back');
    var nextBtn = document.getElementById('wizard-next');
    backBtn.style.display = wizardStep > 0 ? '' : 'none';
    nextBtn.disabled = false;

    if (wizardStep === WIZARD_STEPS.length - 1) {
        nextBtn.style.display = 'none';
    } else {
        nextBtn.style.display = '';
        nextBtn.textContent = wizardStep === WIZARD_STEPS.length - 2 ? 'Begin Hydration' : 'Next';
    }

    // Render step body
    var body = document.getElementById('wizard-body');
    switch (step.id) {
        case 'org': renderWizardOrg(body); break;
        case 'legacy': renderWizardLegacy(body); break;
        case 'client-table': renderWizardClientTable(body); break;
        case 'visibility': renderWizardVisibility(body); break;
        case 'hydrate': renderWizardHydrate(body); break;
    }
}

// ---- Step 1: Org Setup ----
function renderWizardOrg(container) {
    if (wizardData.orgSpaceId) {
        container.innerHTML =
            '<div class="wizard-success">Connected to existing organization.</div>' +
            '<div class="wizard-info-box">' +
                '<strong>Organization space found.</strong> Your rooms and configuration are already set up.' +
            '</div>';
    } else {
        container.innerHTML =
            '<div class="wizard-error" id="wizard-error"></div>' +
            '<div class="form-group">' +
                '<label>Organization Name</label>' +
                '<input type="text" id="wiz-org-name" placeholder="e.g. Ramirez & Associates" value="' + esc(wizardData.orgName) + '">' +
            '</div>' +
            '<div class="wizard-info-box">' +
                '<strong>This creates a Matrix Space</strong> that will contain all your client rooms and firm data. ' +
                'Staff and clients will be invited to specific rooms within this space.' +
            '</div>';
    }
}

// ---- Step 3: Legacy Data Source ----
function renderWizardLegacy(container) {
    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Amino API Key <span class="label-hint">(your existing key)</span></label>' +
            '<input type="password" id="wiz-amino-key" placeholder="API Key" value="' + esc(wizardData.aminoApiKey) + '">' +
        '</div>' +
        '<div class="wizard-info-box">' +
            '<strong>How this works:</strong> We\'ll download your current data via Matrix Synapse, ' +
            'then build local state from it. Your Airtable data stays untouched until you decide to sever the connection.' +
        '</div>';
}

// ---- Step 4: Client Table Selection ----
function renderWizardClientTable(container) {
    var tableOptions = '<option value="">-- Select a table --</option>';
    var tableIds = Object.keys(wizardData.legacyTables);
    tableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var selected = wizardData.clientTable === tid ? ' selected' : '';
        tableOptions += '<option value="' + esc(tid) + '"' + selected + '>' + esc(resolveTableName(tid)) + '</option>';
    });

    // Field selector (populated when table changes)
    var fieldOptions = '<option value="">-- Select a field --</option>';
    if (wizardData.clientTable && wizardData.legacyFields[wizardData.clientTable]) {
        var fields = wizardData.legacyFields[wizardData.clientTable];
        Object.keys(fields).forEach(function(fid) {
            var f = fields[fid];
            var selected = wizardData.clientIdentifierField === fid ? ' selected' : '';
            fieldOptions += '<option value="' + esc(fid) + '"' + selected + '>' + esc(f.fieldName || fid) + '</option>';
        });
    }

    // Build edges and auto-infer linked record paths
    var wizEdges = buildEdgesFromFields(wizardData.legacyFields);
    var autoLinkedMap = wizardData.clientTable ? computeLinkedRecordTableMap(wizEdges, wizardData.clientTable) : {};

    // Auto-populate linkedRecordTables from edges for direct links (don't overwrite manual choices)
    if (wizardData.clientTable) {
        var autoIds = Object.keys(autoLinkedMap);
        for (var ai = 0; ai < autoIds.length; ai++) {
            var atid = autoIds[ai];
            if (!wizardData.linkedRecordTables[atid] && autoLinkedMap[atid] && autoLinkedMap[atid].hops === 1) {
                wizardData.linkedRecordTables[atid] = autoLinkedMap[atid].fieldId;
            }
        }
    }

    // Linked record field detection per table
    var linkedHtml = '';
    var directCount = 0;
    var multiHopCount = 0;
    var noLinkCount = 0;
    tableIds.forEach(function(tid) {
        if (tid === wizardData.clientTable) return;
        var t = wizardData.legacyTables[tid];
        var fields = wizardData.legacyFields[tid] || {};
        var fids = Object.keys(fields);
        var autoInfo = autoLinkedMap[tid];
        var linkFieldOptions = '<option value="">-- No link --</option>';
        fids.forEach(function(fid) {
            var f = fields[fid];
            var selected = wizardData.linkedRecordTables[tid] === fid ? ' selected' : '';
            linkFieldOptions += '<option value="' + esc(fid) + '"' + selected + '>' + esc(f.fieldName || fid) + '</option>';
        });

        // Show link status indicator
        var statusHtml = '';
        if (wizardData.linkedRecordTables[tid]) {
            statusHtml = '<span style="color:var(--success-500,#22c55e);font-size:0.85em;margin-left:6px">\u2713 direct link</span>';
            directCount++;
        } else if (autoInfo && autoInfo.hops > 1) {
            var pathNames = autoInfo.path.map(function(e) {
                var tbl = wizardData.legacyTables[e.toTableId];
                return tbl ? tbl.tableName : e.toTableId;
            });
            statusHtml = '<span style="color:var(--warning-500,#f59e0b);font-size:0.85em;margin-left:6px">\u2192 via ' + esc(pathNames.join(' \u2192 ')) + ' (' + autoInfo.hops + ' hops)</span>';
            multiHopCount++;
        } else {
            statusHtml = '<span style="color:var(--neutral-400,#9ca3af);font-size:0.85em;margin-left:6px">no path found</span>';
            noLinkCount++;
        }

        linkedHtml +=
            '<div class="linked-record-row">' +
                '<span class="table-name">' + esc(resolveTableName(tid)) + statusHtml + '</span>' +
                '<select onchange="wizardSetLinkedField(\'' + esc(tid) + '\', this.value)">' + linkFieldOptions + '</select>' +
            '</div>';
    });

    var summaryHtml = '';
    if (wizardData.clientTable) {
        summaryHtml =
            '<div class="wizard-info-box" style="margin-bottom:12px">' +
                '<strong>Link summary:</strong> ' +
                directCount + ' tables linked directly, ' +
                multiHopCount + ' reachable via multi-hop, ' +
                noLinkCount + ' with no path to client.' +
            '</div>';
    }

    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Which table represents your clients?</label>' +
            '<select id="wiz-client-table" onchange="wizardClientTableChanged(this.value)">' + tableOptions + '</select>' +
        '</div>' +
        '<div class="form-group">' +
            '<label>Which field identifies each client?</label>' +
            '<select id="wiz-client-field" onchange="wizardData.clientIdentifierField=this.value">' + fieldOptions + '</select>' +
        '</div>' +
        summaryHtml +
        (linkedHtml ?
        '<div class="form-group">' +
            '<label>Which field on each table links to a client record? <span class="label-hint">(auto-detected from linked record fields \u2014 override if needed)</span></label>' +
            '<div class="checkbox-group">' + linkedHtml + '</div>' +
        '</div>' : '') +
        '<div class="wizard-info-box">' +
            '<strong>This is how rooms get created.</strong> Each unique client gets their own Matrix Space with a Matter Room. ' +
            'Records are assigned to clients via direct links or multi-hop paths through the link graph.' +
        '</div>';
}

function wizardClientTableChanged(tableId) {
    wizardData.clientTable = tableId;
    wizardData.clientIdentifierField = '';
    wizardData.linkedRecordTables = {}; // reset so auto-detection re-runs
    renderWizardStep(); // re-render to update field dropdown
}

function wizardSetLinkedField(tableId, fieldId) {
    if (fieldId) {
        wizardData.linkedRecordTables[tableId] = fieldId;
    } else {
        delete wizardData.linkedRecordTables[tableId];
    }
}

// ---- Step 5: Client Visibility ----
function renderWizardVisibility(container) {
    var tableIds = Object.keys(wizardData.legacyTables);

    // Table visibility checkboxes
    var tableCheckboxes = '';
    tableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var checked = wizardData.clientVisibleTables.indexOf(tid) !== -1 ? ' checked' : '';
        tableCheckboxes +=
            '<label class="checkbox-item">' +
                '<input type="checkbox" value="' + esc(tid) + '"' + checked +
                    ' onchange="wizardToggleClientVisibleTable(\'' + esc(tid) + '\', this.checked)">' +
                '<span>' + esc(resolveTableName(tid)) + '</span>' +
            '</label>';
    });

    // Linked record type visibility (which linked record types can a client see?)
    var linkedTableCheckboxes = '';
    var linkedTableIds = Object.keys(wizardData.linkedRecordTables);
    linkedTableIds.forEach(function(tid) {
        var t = wizardData.legacyTables[tid];
        var checked = wizardData.clientVisibleLinkedTables.indexOf(tid) !== -1 ? ' checked' : '';
        linkedTableCheckboxes +=
            '<label class="checkbox-item">' +
                '<input type="checkbox" value="' + esc(tid) + '"' + checked +
                    ' onchange="wizardToggleClientVisibleLinkedTable(\'' + esc(tid) + '\', this.checked)">' +
                '<span>' + esc(resolveTableName(tid)) + '</span>' +
            '</label>';
    });

    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="form-group">' +
            '<label>Which tables can clients see in their portal?</label>' +
            '<div class="checkbox-group">' + tableCheckboxes + '</div>' +
        '</div>' +
        (linkedTableCheckboxes ?
        '<div class="form-group">' +
            '<label>Which linked record types can a client see? <span class="label-hint">(records linked to their client record)</span></label>' +
            '<div class="checkbox-group">' + linkedTableCheckboxes + '</div>' +
        '</div>' : '') +
        '<div class="wizard-info-box">' +
            '<strong>Clients only see their own data.</strong> Tables you check here will be visible in the client portal. ' +
            'Internal notes, billing, and strategy data should remain unchecked.' +
        '</div>';
}

function wizardToggleClientVisibleTable(tableId, checked) {
    var idx = wizardData.clientVisibleTables.indexOf(tableId);
    if (checked && idx === -1) wizardData.clientVisibleTables.push(tableId);
    if (!checked && idx !== -1) wizardData.clientVisibleTables.splice(idx, 1);
}

function wizardToggleClientVisibleLinkedTable(tableId, checked) {
    var idx = wizardData.clientVisibleLinkedTables.indexOf(tableId);
    if (checked && idx === -1) wizardData.clientVisibleLinkedTables.push(tableId);
    if (!checked && idx !== -1) wizardData.clientVisibleLinkedTables.splice(idx, 1);
}

// ---- Step 6: Hydration ----
function renderWizardHydrate(container) {
    container.innerHTML =
        '<div class="wizard-error" id="wizard-error"></div>' +
        '<div class="wizard-progress-section">' +
            '<div class="wizard-progress-bar">' +
                '<div class="wizard-progress-fill" id="wiz-hydrate-progress" style="width: 0%"></div>' +
            '</div>' +
            '<div class="wizard-progress-status" id="wiz-hydrate-status">Preparing...</div>' +
            '<div class="wizard-progress-detail" id="wiz-hydrate-detail"></div>' +
        '</div>';

    // Start hydration automatically
    setTimeout(runHydration, 300);
}

// ============ Wizard Navigation ============

function wizardBack() {
    if (wizardStep > 0) {
        wizardStep--;
        renderWizardStep();
    }
}

async function wizardNext() {
    var nextBtn = document.getElementById('wizard-next');
    nextBtn.disabled = true;

    try {
        switch (WIZARD_STEPS[wizardStep].id) {
            case 'org':
                await wizardValidateOrg();
                break;
            case 'legacy':
                await wizardValidateLegacy();
                break;
            case 'client-table':
                wizardValidateClientTable();
                break;
            case 'visibility':
                // No validation needed, proceed to hydration
                break;
        }
        wizardStep++;
        renderWizardStep();
    } catch (err) {
        showWizardError(err.message);
        nextBtn.disabled = false;
    }
}

function showWizardError(msg) {
    var el = document.getElementById('wizard-error');
    if (el) { el.style.display = 'block'; el.textContent = msg; }
}

function hideWizardError() {
    var el = document.getElementById('wizard-error');
    if (el) el.style.display = 'none';
}

// ============ Wizard Validation ============

async function wizardValidateOrg() {
    if (!wizardData.orgSpaceId) {
        var orgName = document.getElementById('wiz-org-name');
        if (!orgName) throw new Error('Organization already configured');
        var name = orgName.value.trim();
        if (!name) throw new Error('Please enter an organization name');
        wizardData.orgName = name;
        wizardData.orgSpaceId = await MatrixClient.createOrgSpace(name);
    }
}

async function wizardValidateLegacy() {
    // Legacy wizard step  Xano endpoints removed. Data comes from Matrix Synapse.
    // Open IndexedDB
    if (!db) db = await openDB();

    // Hydrate from Synapse rooms
    await hydrateFromSynapse();

    // Reload metadata
    var tables = await getAllTables();
    var fields = await getAllFields();
    tables.forEach(function(t) { wizardData.legacyTables[t.tableId] = t; });
    fields.forEach(function(f) {
        if (!wizardData.legacyFields[f.tableId]) wizardData.legacyFields[f.tableId] = {};
        wizardData.legacyFields[f.tableId][f.fieldId] = f;
    });

    if (Object.keys(wizardData.legacyTables).length === 0) {
        throw new Error('No tables found. Verify your Synapse session and room membership.');
    }
}

function wizardValidateClientTable() {
    if (!wizardData.clientTable) throw new Error('Please select which table represents your clients');
    if (!wizardData.clientIdentifierField) throw new Error('Please select which field identifies each client');
}

// ============ Hydration Execution ============

async function runHydration() {
    var progressEl = document.getElementById('wiz-hydrate-progress');
    var statusEl = document.getElementById('wiz-hydrate-status');
    var detailEl = document.getElementById('wiz-hydrate-detail');

    function updateProgress(pct, status, detail) {
        if (progressEl) progressEl.style.width = pct + '%';
        if (statusEl) statusEl.textContent = status;
        if (detailEl) detailEl.textContent = detail || '';
    }

    try {
        updateProgress(5, 'Preparing data...');

        // Build amo-style data structure from IndexedDB for the bridge
        var allRecords = [];
        var tableIds = Object.keys(wizardData.legacyTables);
        for (var i = 0; i < tableIds.length; i++) {
            var tid = tableIds[i];
            var recordIds = await new Promise(function(resolve, reject) {
                var tx = db.transaction('data', 'readonly');
                var store = tx.objectStore('data');
                var index = store.index('by_table');
                var req = index.getAllKeys(tid);
                req.onsuccess = function() { resolve(req.result || []); };
                req.onerror = function() { reject(req.error); };
            });

            for (var r = 0; r < recordIds.length; r++) {
                var rec = await new Promise(function(resolve, reject) {
                    var tx2 = db.transaction('data', 'readonly');
                    var req2 = tx2.objectStore('data').get(recordIds[r]);
                    req2.onsuccess = function() { resolve(req2.result); };
                    req2.onerror = function() { reject(req2.error); };
                });
                if (rec) {
                    // Decrypt if needed
                    if (encryptionEnabled && (rec._encryptedFields || rec._encrypted)) {
                        rec = await decryptRecordFromStorage(rec);
                    }
                    allRecords.push({
                        tableId: rec.tableId,
                        recordId: rec.recordId,
                        fields: rec.fields || {}
                    });
                }
            }
        }

        updateProgress(15, 'Grouping records by client...', allRecords.length + ' records found');

        // Build edges from field metadata for multi-hop client resolution
        var edgesForGrouping = buildEdgesFromFields(wizardData.legacyFields);
        // Also auto-infer linkedRecordTables from edges (direct links to client table)
        var autoLinked = computeLinkedRecordTableMap(edgesForGrouping, wizardData.clientTable);
        // Merge auto-inferred with any manual overrides
        var mergedLinkedRecordTables = {};
        var autoTableIds = Object.keys(autoLinked);
        for (var al = 0; al < autoTableIds.length; al++) {
            var atid = autoTableIds[al];
            // Manual config takes precedence if set
            if (wizardData.linkedRecordTables[atid]) {
                mergedLinkedRecordTables[atid] = wizardData.linkedRecordTables[atid];
            } else if (autoLinked[atid].hops === 1) {
                // Auto-inferred direct link
                mergedLinkedRecordTables[atid] = autoLinked[atid].fieldId;
            }
        }
        // Keep any manual entries not in auto
        var manualTableIds = Object.keys(wizardData.linkedRecordTables);
        for (var ml = 0; ml < manualTableIds.length; ml++) {
            if (!mergedLinkedRecordTables[manualTableIds[ml]]) {
                mergedLinkedRecordTables[manualTableIds[ml]] = wizardData.linkedRecordTables[manualTableIds[ml]];
            }
        }

        // Configure bridge
        MatrixBridge.setConfig({
            mode: 'bridge',
            orgSpaceId: wizardData.orgSpaceId,
            clientTable: wizardData.clientTable,
            clientIdentifierField: wizardData.clientIdentifierField,
            clientVisibleTables: wizardData.clientVisibleTables,
            clientHiddenTables: tableIds.filter(function(t) {
                return wizardData.clientVisibleTables.indexOf(t) === -1;
            }),
            linkedRecordTables: mergedLinkedRecordTables,
            edges: edgesForGrouping,
            clientRoomMap: {},
            lastSyncCursor: 0
        });

        // Group records (with edges for multi-hop resolution)
        var grouped = MatrixBridge.groupRecordsByClient(
            allRecords,
            wizardData.legacyFields,
            wizardData.clientTable,
            wizardData.clientIdentifierField,
            mergedLinkedRecordTables,
            edgesForGrouping
        );

        var clientNames = Object.keys(grouped.groups);
        var totalClients = clientNames.length;

        updateProgress(20, 'Creating Matrix rooms...', totalClients + ' clients detected');

        // Create firm reference room for unassigned data
        var config = MatrixBridge.getConfig();
        if (grouped.unassigned.length > 0) {
            updateProgress(22, 'Creating firm reference room...', grouped.unassigned.length + ' unassigned records');
            var firmRoomId = await MatrixClient.createRoom({
                name: 'Firm Reference Data',
                preset: 'private_chat'
            });
            await MatrixClient.addChildToSpace(wizardData.orgSpaceId, firmRoomId);
            config.firmRoomId = firmRoomId;

            // Write unassigned records to firm room
            for (var u = 0; u < grouped.unassigned.length; u++) {
                var urec = grouped.unassigned[u];
                await MatrixClient.writeRecord(firmRoomId, urec.tableId, urec.recordId, urec.fields);
                if (u % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
            }
        }

        // For each client, create space + matter room + write data
        for (var c = 0; c < clientNames.length; c++) {
            var clientName = clientNames[c];
            var clientGroup = grouped.groups[clientName];
            var pct = 25 + Math.round((c / totalClients) * 70);
            var recordCount = 0;
            Object.values(clientGroup.records).forEach(function(arr) { recordCount += arr.length; });

            updateProgress(pct, 'Creating room for ' + clientName + '...',
                (c + 1) + ' of ' + totalClients + ' clients (' + recordCount + ' records)');

            // Create client space
            var clientSpaceId = await MatrixClient.createClientSpace(wizardData.orgSpaceId, clientName);

            // Create matter room
            var matterRoomId = await MatrixClient.createMatterRoom(clientSpaceId, clientName);

            // Write schemas
            var clientTableIds = Object.keys(clientGroup.records);
            for (var t = 0; t < clientTableIds.length; t++) {
                var tblId = clientTableIds[t];
                var tblMeta = wizardData.legacyTables[tblId] || { tableName: tblId };
                var isVisible = wizardData.clientVisibleTables.indexOf(tblId) !== -1;
                await MatrixClient.writeTableSchema(matterRoomId, tblId, tblMeta.tableName, tblMeta.icon, isVisible);

                var tblFields = wizardData.legacyFields[tblId] || {};
                var fids = Object.keys(tblFields);
                for (var f = 0; f < fids.length; f++) {
                    await MatrixClient.writeFieldSchema(matterRoomId, fids[f], tblFields[fids[f]]);
                    if (f % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }
            }

            // Write records
            for (var rt = 0; rt < clientTableIds.length; rt++) {
                var recs = clientGroup.records[clientTableIds[rt]];
                for (var ri = 0; ri < recs.length; ri++) {
                    await MatrixClient.writeRecord(matterRoomId, recs[ri].tableId, recs[ri].recordId, recs[ri].fields);
                    if (ri % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }
            }

            // Store room mapping
            config.clientRoomMap[clientName] = {
                spaceId: clientSpaceId,
                matterRoomId: matterRoomId,
                portalRoomId: null
            };
        }

        // Save bridge config
        MatrixBridge.setConfig(config);

        // Save config to org space
        await MatrixClient.sendStateEvent(
            wizardData.orgSpaceId,
            MatrixClient.EVENT_TYPES.BRIDGE_CONFIG,
            '',
            config
        );

        // Save locally
        MatrixClient.saveConfig({
            bridge: config,
            homeserverUrl: MatrixClient.getHomeserverUrl(),
            orgSpaceId: wizardData.orgSpaceId,
            userId: MatrixClient.getUserId()
        });

        updateProgress(100, 'Hydration complete!',
            totalClients + ' client rooms created, ' + allRecords.length + ' records written');

        // Show completion UI
        var body = document.getElementById('wizard-body');
        body.innerHTML =
            '<div class="wizard-success">' +
                'Successfully created ' + totalClients + ' client rooms with ' + allRecords.length + ' records.' +
            '</div>' +
            '<div class="wizard-info-box">' +
                '<strong>Bridge mode is active.</strong> The app will continue syncing from your existing Airtable data and routing updates to the appropriate Matrix rooms. ' +
                'When you\'re ready, you can sever the legacy connection from the admin panel.' +
            '</div>' +
            '<div style="text-align: center; padding-top: 12px; display: flex; gap: 12px; justify-content: center;">' +
                '<button class="btn-next" onclick="hideMatrixWizard(); showRoomManager();" style="background: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-secondary);">Manage Rooms</button>' +
                '<button class="btn-next" onclick="wizardComplete()" style="background: var(--success-500); border-color: var(--success-500);">Open App</button>' +
            '</div>';

        // Hide footer buttons
        document.getElementById('wizard-footer').style.display = 'none';

    } catch (err) {
        console.error('[Wizard] Hydration failed:', err);
        updateProgress(0, 'Hydration failed');
        showWizardError('Hydration failed: ' + err.message);
        // Show back button
        document.getElementById('wizard-footer').style.display = 'flex';
        document.getElementById('wizard-back').style.display = '';
    }
}

// ============ Room Manager (Bulk Delete) ============

function showRoomManager() {
    var config = MatrixBridge.getConfig();
    var clientNames = Object.keys(config.clientRoomMap || {}).sort();

    if (clientNames.length === 0) {
        alert('No client rooms found.');
        return;
    }

    // Reset UI
    document.getElementById('rm-list-section').style.display = '';
    document.getElementById('rm-progress-section').style.display = 'none';
    document.getElementById('rm-result-section').style.display = 'none';
    document.getElementById('rm-footer').style.display = 'flex';
    document.getElementById('rm-delete-btn').disabled = true;
    document.getElementById('rm-delete-btn').textContent = 'Delete Selected';
    document.getElementById('rm-select-all').checked = false;
    document.getElementById('rm-selected-count').textContent = '0 selected';
    document.getElementById('rm-error').style.display = 'none';
    document.getElementById('rm-title').textContent = 'Manage Rooms';
    document.getElementById('rm-subtitle').textContent = 'Select client rooms to delete';

    // Populate client list
    var listEl = document.getElementById('rm-client-list');
    var html = '';
    clientNames.forEach(function(name) {
        var mapping = config.clientRoomMap[name];
        var roomCount = 1; // space
        if (mapping.matterRoomId) roomCount++;
        if (mapping.portalRoomId) roomCount++;
        html +=
            '<label class="rm-client-row">' +
                '<input type="checkbox" class="rm-client-cb" value="' + esc(name) + '" onchange="rmUpdateCount()">' +
                '<span>' + esc(name) + '</span>' +
                '<span class="rm-room-info">' + roomCount + ' room' + (roomCount !== 1 ? 's' : '') + '</span>' +
            '</label>';
    });
    listEl.innerHTML = html;

    document.getElementById('room-manager').classList.remove('hidden');
}

function hideRoomManager() {
    document.getElementById('room-manager').classList.add('hidden');
}

function rmToggleSelectAll(checked) {
    var cbs = document.querySelectorAll('.rm-client-cb');
    cbs.forEach(function(cb) { cb.checked = checked; });
    rmUpdateCount();
}

function rmUpdateCount() {
    var cbs = document.querySelectorAll('.rm-client-cb:checked');
    var count = cbs.length;
    document.getElementById('rm-selected-count').textContent = count + ' selected';
    document.getElementById('rm-delete-btn').disabled = count === 0;

    // Update select-all state
    var allCbs = document.querySelectorAll('.rm-client-cb');
    document.getElementById('rm-select-all').checked = allCbs.length > 0 && count === allCbs.length;
}

function rmGetSelectedClients() {
    var cbs = document.querySelectorAll('.rm-client-cb:checked');
    var names = [];
    cbs.forEach(function(cb) { names.push(cb.value); });
    return names;
}

function rmConfirmDelete() {
    var selected = rmGetSelectedClients();
    if (selected.length === 0) return;

    var msg = 'Are you sure you want to delete ' + selected.length + ' client room' +
        (selected.length !== 1 ? 's' : '') + '?\n\nThis will leave and forget:\n';

    var config = MatrixBridge.getConfig();
    var totalRooms = 0;
    selected.forEach(function(name) {
        var mapping = config.clientRoomMap[name];
        if (mapping) {
            var count = 1;
            if (mapping.matterRoomId) count++;
            if (mapping.portalRoomId) count++;
            totalRooms += count;
        }
    });

    msg += '- ' + totalRooms + ' total rooms (spaces, matter rooms, portal rooms)\n\nThis cannot be undone.';

    if (!confirm(msg)) return;

    rmExecuteDelete(selected);
}

async function rmExecuteDelete(clientNames) {
    // Switch to progress view
    document.getElementById('rm-list-section').style.display = 'none';
    document.getElementById('rm-progress-section').style.display = '';
    document.getElementById('rm-delete-btn').style.display = 'none';

    var progressEl = document.getElementById('rm-progress');
    var statusEl = document.getElementById('rm-status');
    var detailEl = document.getElementById('rm-detail');

    try {
        var result = await MatrixBridge.deleteClientRooms(clientNames, function(info) {
            if (info.phase === 'deleting') {
                var pct = info.total > 0 ? Math.round((info.completed / info.total) * 100) : 0;
                progressEl.style.width = pct + '%';
                statusEl.textContent = 'Deleting ' + info.clientName + '...';
                detailEl.textContent = info.completed + ' of ' + info.total + ' clients processed';
            } else if (info.phase === 'complete') {
                progressEl.style.width = '100%';
                statusEl.textContent = 'Deletion complete';
            }
        });

        // Show results
        document.getElementById('rm-progress-section').style.display = 'none';
        var resultEl = document.getElementById('rm-result-section');
        resultEl.style.display = '';

        var html = '<div class="wizard-success">' +
            'Successfully deleted ' + result.deleted + ' client room' + (result.deleted !== 1 ? 's' : '') + '.' +
            '</div>';

        if (result.failed.length > 0) {
            html += '<div class="wizard-error" style="display: block;">' +
                '<strong>' + result.failed.length + ' failed:</strong><br>';
            result.failed.forEach(function(f) {
                html += esc(f.clientName) + ': ' + esc(f.error) + '<br>';
            });
            html += '</div>';
        }

        var remaining = Object.keys(MatrixBridge.getConfig().clientRoomMap || {}).length;
        html += '<div class="wizard-info-box">' +
            '<strong>' + remaining + ' client room' + (remaining !== 1 ? 's' : '') + ' remaining.</strong> ' +
            'Bridge configuration has been updated.' +
            '</div>';

        resultEl.innerHTML = html;

        // Update footer
        document.getElementById('rm-footer').innerHTML =
            '<button class="btn-back" onclick="hideRoomManager()">Close</button>' +
            (remaining > 0 ?
                '<button class="btn-next" onclick="showRoomManager()" style="background: var(--primary-500); border-color: var(--primary-500);">Delete More</button>' :
                '');

    } catch (err) {
        document.getElementById('rm-progress-section').style.display = 'none';
        document.getElementById('rm-list-section').style.display = '';
        document.getElementById('rm-delete-btn').style.display = '';
        var errEl = document.getElementById('rm-error');
        errEl.style.display = 'block';
        errEl.textContent = 'Deletion failed: ' + err.message;
    }
}

function wizardComplete() {
    hideMatrixWizard();

    // Bridge mode no longer uses Xano endpoints.
    // Data flows Airtable  n8n  Matrix automatically.

    // Show manage rooms button
    var rmBtn = document.getElementById('manage-rooms-btn');
    if (rmBtn) rmBtn.style.display = '';

    // Continue to normal app initialization
    initAuthScreen();
}

// ============ Matrix Status & Manual Room Publishing ============

// Track Matrix connection state in sidebar
function updateMatrixStatus() {
    var btn = document.getElementById('matrix-connect-btn');
    var icon = document.getElementById('matrix-status-icon');
    var label = document.getElementById('matrix-status-label');
    if (!btn) return;

    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        btn.classList.add('matrix-connected');
        icon.textContent = '\u25CF'; // filled circle
        label.textContent = session.userId ? session.userId.split(':')[0].replace('@', '') : 'Connected';
        btn.onclick = showMatrixMenu;
        btn.title = 'Matrix: Connected as ' + (session.userId || 'unknown');

        // Show manage rooms button if bridge config has rooms
        var mConfig = MatrixBridge.getConfig();
        if (mConfig && mConfig.clientRoomMap && Object.keys(mConfig.clientRoomMap).length > 0) {
            var rmBtn = document.getElementById('manage-rooms-btn');
            if (rmBtn) rmBtn.style.display = '';
        }
    } else {
        btn.classList.remove('matrix-connected');
        icon.textContent = '\u25CB'; // empty circle
        label.textContent = 'Connect Matrix';
        btn.onclick = function() { showSynapseLoginScreen(); };
        btn.title = 'Connect to Matrix for room sync';
    }
}

// Context menu for connected Matrix user
function showMatrixMenu() {
    var session = _loadSynapseSession();
    if (!session) return;

    // Simple menu via prompt-style - publish rooms or disconnect
    var choice = confirm(
        'Matrix: ' + (session.userId || 'Connected') + '\n\n' +
        'OK = Open Room Publisher\n' +
        'Cancel = Disconnect Matrix'
    );

    if (choice) {
        showRoomPublishModal();
    } else {
        if (confirm('Disconnect from Matrix? Your local data is not affected.')) {
            synapseLogout();
            updateMatrixStatus();
        }
    }
}

// ============ Room Publishing Modal ============

function showRoomPublishModal() {
    var modal = document.getElementById('room-publish-modal');
    modal.classList.remove('hidden');

    var session = _loadSynapseSession();
    var isConnected = session && session.accessToken;

    document.getElementById('room-publish-not-connected').style.display = isConnected ? 'none' : '';
    document.getElementById('room-publish-content').style.display = isConnected ? '' : 'none';
    document.getElementById('pub-publish-btn').style.display = isConnected ? '' : 'none';

    if (!isConnected) return;

    // Make sure MatrixClient has the session
    if (!MatrixClient.isLoggedIn()) {
        MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
    }

    // Check for existing org space
    var config = MatrixClient.loadConfig();
    if (config && config.orgSpaceId) {
        document.getElementById('pub-org-name').value = config.bridge ? config.bridge.name || '' : '';
        document.getElementById('pub-org-status').textContent = 'Existing org found';
        document.getElementById('pub-org-status').style.color = 'var(--success-500)';
    }

    // Populate table list
    var tableIds = Object.keys(META_TABLES);
    var listEl = document.getElementById('pub-table-list');
    var clientSelect = document.getElementById('pub-client-table');

    var html = '';
    var clientOpts = '<option value="">No client grouping</option>';

    tableIds.forEach(function(tid) {
        var t = META_TABLES[tid];
        var fieldCount = META_FIELDS[tid] ? Object.keys(META_FIELDS[tid]).length : 0;
        // Count records for this table from in-memory data
        var recordCount = (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tid]) ? Object.keys(window.IN_MEMORY_DATA[tid]).length : 0;

        html +=
            '<label class="room-table-item" for="pub-tbl-' + esc(tid) + '">' +
                '<input type="checkbox" id="pub-tbl-' + esc(tid) + '" value="' + esc(tid) + '" checked>' +
                '<div class="table-info">' +
                    '<div class="table-name">' + esc(resolveTableName(tid)) + '</div>' +
                    '<div class="table-meta">' + fieldCount + ' fields, ' + recordCount + ' records</div>' +
                '</div>' +
                '<span class="pub-status local">Local</span>' +
            '</label>';

        clientOpts += '<option value="' + esc(tid) + '">' + esc(resolveTableName(tid)) + '</option>';
    });

    listEl.innerHTML = html;
    clientSelect.innerHTML = clientOpts;

    // Reset progress
    document.getElementById('pub-progress-section').style.display = 'none';
    document.getElementById('pub-publish-btn').disabled = false;
    document.getElementById('pub-publish-btn').textContent = 'Publish Selected';
}

function closeRoomPublishModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('room-publish-modal').classList.add('hidden');
}

function pubClientTableChanged() {
    var tableId = document.getElementById('pub-client-table').value;
    var fieldSelect = document.getElementById('pub-client-field');

    if (!tableId) {
        fieldSelect.disabled = true;
        fieldSelect.innerHTML = '<option value="">Select identifier field</option>';
        return;
    }

    fieldSelect.disabled = false;
    var fields = META_FIELDS[tableId] || {};
    var html = '<option value="">Select identifier field</option>';
    Object.keys(fields).forEach(function(fid) {
        var f = fields[fid];
        html += '<option value="' + esc(fid) + '">' + esc(f.fieldName || fid) + '</option>';
    });
    fieldSelect.innerHTML = html;
}

async function executeRoomPublish() {
    var btn = document.getElementById('pub-publish-btn');
    btn.disabled = true;
    btn.textContent = 'Publishing...';

    var progressSection = document.getElementById('pub-progress-section');
    var progressFill = document.getElementById('pub-progress-fill');
    var progressText = document.getElementById('pub-progress-text');
    progressSection.style.display = '';

    function updatePub(pct, text) {
        progressFill.style.width = pct + '%';
        progressText.textContent = text;
    }

    try {
        // Collect selected tables
        var selectedTables = [];
        document.querySelectorAll('#pub-table-list input[type="checkbox"]:checked').forEach(function(cb) {
            selectedTables.push(cb.value);
        });

        if (selectedTables.length === 0) {
            alert('Please select at least one table to publish.');
            btn.disabled = false;
            btn.textContent = 'Publish Selected';
            progressSection.style.display = 'none';
            return;
        }

        var orgName = document.getElementById('pub-org-name').value.trim() || 'My Organization';
        var clientTable = document.getElementById('pub-client-table').value;
        var clientField = document.getElementById('pub-client-field').value;

        updatePub(5, 'Syncing with Matrix...');

        // Ensure we have a Matrix sync
        await MatrixClient.initialSync();

        // Find or create org space
        updatePub(10, 'Setting up organization space...');
        var orgSpaceId = await MatrixClient.findOrgSpace();
        if (!orgSpaceId) {
            orgSpaceId = await MatrixClient.createOrgSpace(orgName);
        }

        // If no client grouping, publish tables as individual rooms under the org space
        if (!clientTable || !clientField) {
            updatePub(15, 'Publishing ' + selectedTables.length + ' tables as rooms...');

            for (var i = 0; i < selectedTables.length; i++) {
                var tid = selectedTables[i];
                var tMeta = META_TABLES[tid] || { tableName: tid };
                var resolvedName = resolveTableName(tid);
                var pct = 15 + Math.round((i / selectedTables.length) * 80);
                updatePub(pct, 'Publishing ' + resolvedName + '...');

                // Create a room for this table
                var roomId = await MatrixClient.createRoom({
                    name: resolvedName,
                    preset: 'private_chat',
                    initialState: [{
                        type: 'm.room.history_visibility',
                        state_key: '',
                        content: { history_visibility: 'shared' }
                    }]
                });

                await MatrixClient.addChildToSpace(orgSpaceId, roomId);
                await MatrixClient.setRoomParentSpace(roomId, orgSpaceId);

                // Write table schema  use resolved name to ensure display name is stored in room state
                await MatrixClient.writeTableSchema(roomId, tid, resolvedName, tMeta.icon, true);

                // Write field schemas
                var fields = META_FIELDS[tid] || {};
                var fids = Object.keys(fields);
                for (var f = 0; f < fids.length; f++) {
                    await MatrixClient.writeFieldSchema(roomId, fids[f], fields[fids[f]]);
                    if (f % 5 === 4) await new Promise(function(r) { setTimeout(r, 200); });
                }

                // Write records from IndexedDB
                var records = await getRecordsForTableFromDB(tid);
                for (var r = 0; r < records.length; r++) {
                    await MatrixClient.writeRecord(roomId, tid, records[r].recordId, records[r].fields);
                    if (r % 5 === 4) await new Promise(function(r2) { setTimeout(r2, 200); });
                }
            }
        } else {
            // Client-grouped publishing: use the bridge mechanism
            updatePub(15, 'Loading records for grouping...');

            var allRecords = [];
            for (var i = 0; i < selectedTables.length; i++) {
                var records = await getRecordsForTableFromDB(selectedTables[i]);
                records.forEach(function(rec) {
                    allRecords.push({ tableId: selectedTables[i], recordId: rec.recordId, fields: rec.fields });
                });
            }

            updatePub(25, 'Grouping ' + allRecords.length + ' records by client...');

            MatrixBridge.setConfig({
                mode: 'bridge',
                orgSpaceId: orgSpaceId,
                clientTable: clientTable,
                clientIdentifierField: clientField,
                clientVisibleTables: selectedTables,
                linkedRecordTables: {},
                clientRoomMap: {},
                lastSyncCursor: 0
            });

            var result = await MatrixBridge.hydrateToMatrix(
                { tables: buildAmoTablesFromRecords(allRecords) },
                { tables: META_TABLES, fields: META_FIELDS },
                function(info) {
                    if (info.phase === 'hydrating_client') {
                        var pct = 25 + Math.round((info.completed / Math.max(info.total, 1)) * 70);
                        updatePub(pct, 'Creating room for ' + (info.clientName || '...') + ' (' + info.completed + '/' + info.total + ')');
                    }
                }
            );
        }

        // Save config locally
        MatrixClient.saveConfig({
            bridge: MatrixBridge.getConfig(),
            homeserverUrl: MatrixClient.getHomeserverUrl(),
            orgSpaceId: orgSpaceId,
            userId: MatrixClient.getUserId()
        });

        updatePub(100, 'Published successfully!');
        btn.textContent = 'Done';
        updateMatrixStatus();

        // Show manage rooms button
        var rmBtn = document.getElementById('manage-rooms-btn');
        if (rmBtn) rmBtn.style.display = '';

        // Close modal after a short delay
        setTimeout(function() { closeRoomPublishModal(); }, 1500);

    } catch (err) {
        console.error('[RoomPublish] Failed:', err);
        updatePub(0, 'Failed: ' + err.message);
        btn.disabled = false;
        btn.textContent = 'Retry';
    }
}

// Helper: get all records for a table from IndexedDB data store
async function getRecordsForTableFromDB(tableId) {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var index = store.index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = async function() {
            var records = req.result || [];
            // Decrypt if needed
            var result = [];
            for (var i = 0; i < records.length; i++) {
                var rec = records[i];
                if (encryptionEnabled && (rec._encryptedFields || rec._encrypted)) {
                    try { rec = await decryptRecordFromStorage(rec); } catch (e) { continue; }
                }
                result.push({ recordId: rec.recordId, fields: rec.fields || {} });
            }
            resolve(result);
        };
        req.onerror = function() { reject(req.error); };
    });
}

// Helper: convert flat record list to amo-style tables object
function buildAmoTablesFromRecords(records) {
    var tables = {};
    records.forEach(function(rec) {
        var key = 'airtable:' + rec.tableId;
        if (!tables[key]) tables[key] = [];
        var row = Object.assign({ record_id: rec.recordId }, rec.fields);
        tables[key].push(row);
    });
    return tables;
}

// ============ Matrix Mode Detection ============

// Check if Matrix mode should be offered or if we're already in Matrix mode
function checkMatrixMode() {
    var config = MatrixClient.loadConfig();
    if (config && config.orgSpaceId) {
        // Returning Matrix user  try to restore session
        if (MatrixClient.restoreSession()) {
            return 'active'; // Matrix session active, bridge may be running
        }
        return 'login'; // Config exists but session expired
    }
    return 'available'; // Matrix not configured, show option to set up
}

// ============ Workspace UI in Sidebar ============

// Render workspace tabs at top of sidebar
function renderWorkspaceTabs() {
    var sidebarHeader = document.querySelector('.sidebar-header');
    if (!sidebarHeader) return;

    // Remove existing workspace tabs
    var existingTabs = document.querySelector('.workspace-tabs');
    if (existingTabs) existingTabs.remove();

    var wsIds = Object.keys(WORKSPACES);
    if (wsIds.length === 0) return;

    var html = '<div class="workspace-tabs">';

    // "All" tab
    html += '<div class="workspace-tab' + (!currentWorkspace ? ' active' : '') + '" onclick="filterByWorkspace(null)">All</div>';

    // Workspace tabs
    wsIds.forEach(wid => {
        var ws = WORKSPACES[wid];
        var isActive = currentWorkspace === wid;
        html += '<div class="workspace-tab' + (isActive ? ' active' : '') + '" onclick="filterByWorkspace(\'' + esc(wid) + '\')">';
        html += esc(ws.workspaceName);
        html += '<span class="workspace-count">' + ws.viewIds.length + '</span>';
        html += '</div>';
    });

    // Add workspace button
    html += '<div class="workspace-add-btn" onclick="promptCreateWorkspace()" title="Create workspace">+</div>';

    html += '</div>';

    sidebarHeader.insertAdjacentHTML('afterend', html);
}

// Filter sidebar views by workspace
function filterByWorkspace(workspaceId) {
    currentWorkspace = workspaceId;
    renderSidebar();
}

// Prompt to create a new workspace
async function promptCreateWorkspace() {
    var name = prompt('Enter workspace name:');
    if (name) {
        await createWorkspace(name);
        renderWorkspaceTabs();
    }
}

// ============ Utility: HTML Escaping ============

function escapeHtml(str) {
    if (!str) return '';
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
}

// ============ Forms App Module ============
// Renders the form builder sub-app. Lists all forms (views with viewType 'form')
// the current user has access to, and provides a builder UI for creating/editing forms.

var FormsApp = (function() {
    'use strict';

    var _initialized = false;
    var _searchQuery = '';
    var _tableFilter = '';
    var _statusFilter = '';
    var _ownerFilter = '';
    var _allForms = [];
    var _currentFormId = null;
    var _currentFormTableId = null;
    var _selectedFieldId = null;

    //  Helpers 

    function _esc(s) {
        if (s == null) return '';
        return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function _timeAgo(ts) {
        if (!ts) return '';
        var diff = Date.now() - ts;
        var mins = Math.floor(diff / 60000);
        if (mins < 1) return 'just now';
        if (mins < 60) return mins + 'm ago';
        var hrs = Math.floor(mins / 60);
        if (hrs < 24) return hrs + 'h ago';
        var days = Math.floor(hrs / 24);
        if (days < 30) return days + 'd ago';
        return new Date(ts).toLocaleDateString();
    }

    function _getTableName(tableId) {
        var t = META_TABLES[tableId];
        return t ? (t.tableName || tableId) : tableId;
    }

    //  Data collection 

    // Gather all form-type views across all tables that the current user can see
    async function _collectForms() {
        var forms = [];
        var userId = (typeof MatrixClient !== 'undefined' && MatrixClient.getUserId)
            ? MatrixClient.getUserId() : null;
        var tableIds = Object.keys(META_VIEWS);

        for (var i = 0; i < tableIds.length; i++) {
            var tableId = tableIds[i];
            var views = META_VIEWS[tableId] || {};
            var viewIds = Object.keys(views);

            for (var j = 0; j < viewIds.length; j++) {
                var view = views[viewIds[j]];
                if (!view || view.viewType !== 'form') continue;

                // Check visibility
                var sharing = view._sharing || {};
                var ownerId = sharing.ownerId || view.ownerId || null;
                var isOwner = userId && ownerId === userId;
                var sharingLevel = sharing.sharing || view.sharing || 'everyone';

                if (sharingLevel === 'private' && !isOwner) continue;
                if (sharingLevel === 'specific' && !isOwner) {
                    var sharedWith = sharing.sharedWith || view.sharedWith || [];
                    if (sharedWith.indexOf(userId) === -1) continue;
                }

                forms.push({
                    tableId: tableId,
                    viewId: view.viewId || viewIds[j],
                    viewName: view.viewName || 'Untitled Form',
                    description: view.formConfig ? view.formConfig.description : '',
                    status: (view.formConfig && view.formConfig.status) || 'draft',
                    ownerId: ownerId,
                    isOwner: isOwner,
                    sharing: sharingLevel,
                    createdAt: view.createdAt || 0,
                    updatedAt: view.updatedAt || view.createdAt || 0,
                    formConfig: view.formConfig || {},
                    fieldConfig: view.fieldConfig || {},
                    hiddenFieldIds: view.hiddenFieldIds || [],
                    fieldOrder: view.fieldOrder || []
                });
            }
        }

        // Sort: most recently updated first
        forms.sort(function(a, b) { return (b.updatedAt || 0) - (a.updatedAt || 0); });
        return forms;
    }

    //  Rendering 

    function _applyFilters(forms) {
        var result = forms;
        if (_searchQuery) {
            var q = _searchQuery.toLowerCase();
            result = result.filter(function(f) {
                return (f.viewName || '').toLowerCase().indexOf(q) !== -1 ||
                       (f.description || '').toLowerCase().indexOf(q) !== -1 ||
                       _getTableName(f.tableId).toLowerCase().indexOf(q) !== -1;
            });
        }
        if (_tableFilter) {
            result = result.filter(function(f) { return f.tableId === _tableFilter; });
        }
        if (_statusFilter) {
            result = result.filter(function(f) { return f.status === _statusFilter; });
        }
        if (_ownerFilter === 'mine') {
            result = result.filter(function(f) { return f.isOwner; });
        } else if (_ownerFilter === 'shared') {
            result = result.filter(function(f) { return !f.isOwner; });
        }
        return result;
    }

    function _renderFormCard(form) {
        var statusClass = form.status === 'published' ? 'published' : 'draft';
        var statusLabel = form.status === 'published' ? 'Published' : 'Draft';
        var tableName = _getTableName(form.tableId);

        var sharingIcon = '';
        if (form.sharing === 'everyone') {
            sharingIcon = '<span title="Shared with everyone">&#127760;</span>';
        } else if (form.sharing === 'specific') {
            sharingIcon = '<span title="Shared with specific people">&#128101;</span>';
        } else {
            sharingIcon = '<span title="Private">&#128274;</span>';
        }

        var fieldCount = 0;
        if (form.formConfig && form.formConfig.fieldConfigs) {
            fieldCount = form.formConfig.fieldConfigs.length;
        } else {
            var allFields = META_FIELDS[form.tableId] || {};
            var hidden = form.hiddenFieldIds || [];
            fieldCount = Object.keys(allFields).length - hidden.length;
            if (fieldCount < 0) fieldCount = Object.keys(allFields).length;
        }

        return '<div class="forms-card" onclick="FormsApp.openBuilder(\'' + _esc(form.tableId) + '\', \'' + _esc(form.viewId) + '\')">' +
            '<div class="forms-card-header">' +
                '<div class="forms-card-title">' + _esc(form.viewName) + '</div>' +
                '<div style="display:flex;align-items:center;gap:6px;">' +
                    '<span class="forms-card-status ' + statusClass + '">' + statusLabel + '</span>' +
                    '<div class="forms-card-actions">' +
                        '<button class="forms-card-action-btn" onclick="event.stopPropagation();FormsApp.duplicateForm(\'' + _esc(form.tableId) + '\', \'' + _esc(form.viewId) + '\')" title="Duplicate">' +
                            '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>' +
                        '</button>' +
                        '<button class="forms-card-action-btn" onclick="event.stopPropagation();FormsApp.deleteForm(\'' + _esc(form.tableId) + '\', \'' + _esc(form.viewId) + '\')" title="Delete">' +
                            '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>' +
                        '</button>' +
                    '</div>' +
                '</div>' +
            '</div>' +
            (form.description ? '<div style="font-size:13px;color:var(--text-muted);line-height:1.4;">' + _esc(form.description) + '</div>' : '') +
            '<div class="forms-card-table">' +
                '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/><path d="M3 12c0 1.66 4 3 9 3s9-1.34 9-3"/></svg>' +
                _esc(tableName) +
            '</div>' +
            '<div class="forms-card-meta">' +
                '<span class="forms-card-meta-item">' +
                    '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="3" x2="9" y2="21"/></svg>' +
                    fieldCount + ' fields' +
                '</span>' +
                '<span class="forms-card-meta-item">' + sharingIcon + '</span>' +
                '<span class="forms-card-meta-item" style="margin-left:auto;">' + _timeAgo(form.updatedAt) + '</span>' +
            '</div>' +
        '</div>';
    }

    function _renderEmptyState() {
        return '<div class="forms-empty">' +
            '<div class="forms-empty-icon">' +
                '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">' +
                    '<path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>' +
                    '<polyline points="14 2 14 8 20 8"/>' +
                    '<line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/>' +
                    '<polyline points="10 9 9 9 8 9"/>' +
                '</svg>' +
            '</div>' +
            '<h2>No forms yet</h2>' +
            '<p>Forms let you create structured data entry interfaces for your tables. Create your first form to get started.</p>' +
            '<button class="forms-new-btn" onclick="FormsApp.openCreateModal()">' +
                '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>' +
                'Create Your First Form' +
            '</button>' +
        '</div>';
    }

    function _renderNoResults() {
        return '<div class="forms-empty">' +
            '<div class="forms-empty-icon">' +
                '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">' +
                    '<circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>' +
                '</svg>' +
            '</div>' +
            '<h2>No matching forms</h2>' +
            '<p>Try adjusting your search or filters.</p>' +
        '</div>';
    }

    async function _render() {
        _allForms = await _collectForms();
        var filtered = _applyFilters(_allForms);

        var grid = document.getElementById('forms-grid');
        if (!grid) return;

        if (_allForms.length === 0) {
            grid.innerHTML = _renderEmptyState();
            return;
        }

        if (filtered.length === 0) {
            grid.innerHTML = _renderNoResults();
            return;
        }

        var html = '';
        for (var i = 0; i < filtered.length; i++) {
            html += _renderFormCard(filtered[i]);
        }
        grid.innerHTML = html;
    }

    function _populateTableFilter() {
        var select = document.getElementById('forms-table-filter');
        if (!select) return;
        var html = '<option value="">All Tables</option>';
        var tableIds = Object.keys(META_TABLES);
        tableIds.sort(function(a, b) {
            var na = (META_TABLES[a].tableName || a).toLowerCase();
            var nb = (META_TABLES[b].tableName || b).toLowerCase();
            return na < nb ? -1 : na > nb ? 1 : 0;
        });
        for (var i = 0; i < tableIds.length; i++) {
            var t = META_TABLES[tableIds[i]];
            html += '<option value="' + _esc(tableIds[i]) + '">' + _esc(t.tableName || tableIds[i]) + '</option>';
        }
        select.innerHTML = html;
    }

    function _populateCreateTableSelect() {
        var select = document.getElementById('forms-create-table');
        if (!select) return;
        var html = '<option value="">Select a table...</option>';
        var tableIds = Object.keys(META_TABLES);
        tableIds.sort(function(a, b) {
            var na = (META_TABLES[a].tableName || a).toLowerCase();
            var nb = (META_TABLES[b].tableName || b).toLowerCase();
            return na < nb ? -1 : na > nb ? 1 : 0;
        });
        for (var i = 0; i < tableIds.length; i++) {
            var t = META_TABLES[tableIds[i]];
            html += '<option value="' + _esc(tableIds[i]) + '">' + _esc(t.tableName || tableIds[i]) + '</option>';
        }
        select.innerHTML = html;
    }

    //  Form Builder 

    function _getFieldTypeIcon(fieldType) {
        switch ((fieldType || '').toLowerCase()) {
            case 'singlelinetext': return 'Aa';
            case 'multilinetext': case 'richtext': return '&#182;';
            case 'email': return '@';
            case 'phone': case 'phonenumber': return '&#9742;';
            case 'number': case 'currency': case 'percent': return '#';
            case 'date': case 'datetime': return '&#128197;';
            case 'checkbox': return '&#9745;';
            case 'singleselect': return '&#9660;';
            case 'multipleselects': return '&#9660;&#9660;';
            case 'url': return '&#128279;';
            case 'attachment': return '&#128206;';
            default: return '&#9638;';
        }
    }

    function _renderBuilderSidebar(tableId, formView) {
        var fields = META_FIELDS[tableId] || {};
        var fieldIds = Object.keys(fields);
        var hidden = formView.hiddenFieldIds || [];

        // Sort by fieldOrder if available
        var order = formView.fieldOrder || [];
        fieldIds.sort(function(a, b) {
            var ia = order.indexOf(a), ib = order.indexOf(b);
            if (ia === -1) ia = 999;
            if (ib === -1) ib = 999;
            return ia - ib;
        });

        var html = '';
        for (var i = 0; i < fieldIds.length; i++) {
            var f = fields[fieldIds[i]];
            if (!f) continue;
            // Skip formula/rollup/lookup fields (not editable)
            var ft = (f.fieldType || '').toLowerCase();
            if (ft === 'formula' || ft === 'rollup' || ft === 'lookup' || ft === 'autonumber' || ft === 'createdtime' || ft === 'lastmodifiedtime') continue;

            var isAdded = hidden.indexOf(fieldIds[i]) === -1;
            var activeClass = _selectedFieldId === fieldIds[i] ? ' active' : '';

            html += '<div class="forms-builder-field-item' + activeClass + '" onclick="FormsApp.toggleField(\'' + _esc(fieldIds[i]) + '\')" data-field-id="' + _esc(fieldIds[i]) + '">' +
                '<span class="field-icon">' + _getFieldTypeIcon(f.fieldType) + '</span>' +
                '<span>' + _esc(f.fieldName || fieldIds[i]) + '</span>' +
                (isAdded ? '<span class="field-added">&#10003;</span>' : '') +
            '</div>';
        }

        var sidebar = document.getElementById('forms-builder-field-list');
        if (sidebar) sidebar.innerHTML = html || '<p style="font-size:13px;color:var(--text-muted);">No editable fields in this table.</p>';
    }

    function _renderBuilderPreview(tableId, formView) {
        var fields = META_FIELDS[tableId] || {};
        var hidden = formView.hiddenFieldIds || [];
        var order = formView.fieldOrder || [];
        var formConfig = formView.formConfig || {};
        var fieldConfigs = formConfig.fieldConfigs || {};

        // Get visible fields in order
        var visibleFieldIds = [];
        var allFieldIds = Object.keys(fields);

        // Order: fields in fieldOrder first, then remaining
        var ordered = [];
        for (var k = 0; k < order.length; k++) {
            if (fields[order[k]] && hidden.indexOf(order[k]) === -1) ordered.push(order[k]);
        }
        for (var k = 0; k < allFieldIds.length; k++) {
            if (ordered.indexOf(allFieldIds[k]) === -1 && hidden.indexOf(allFieldIds[k]) === -1) ordered.push(allFieldIds[k]);
        }

        // Filter out non-editable fields
        for (var k = 0; k < ordered.length; k++) {
            var f = fields[ordered[k]];
            if (!f) continue;
            var ft = (f.fieldType || '').toLowerCase();
            if (ft === 'formula' || ft === 'rollup' || ft === 'lookup' || ft === 'autonumber' || ft === 'createdtime' || ft === 'lastmodifiedtime') continue;
            visibleFieldIds.push(ordered[k]);
        }

        var formTitle = formConfig.title || formView.viewName || 'Untitled Form';
        var formDesc = formConfig.description || '';
        var submitText = formConfig.submitButtonText || 'Submit';

        var html = '<div class="forms-builder-preview-title">' + _esc(formTitle) + '</div>';
        if (formDesc) html += '<div class="forms-builder-preview-desc">' + _esc(formDesc) + '</div>';

        for (var i = 0; i < visibleFieldIds.length; i++) {
            var fieldId = visibleFieldIds[i];
            var field = fields[fieldId];
            if (!field) continue;
            var fc = fieldConfigs[fieldId] || {};
            var label = fc.label || field.fieldName || fieldId;
            var required = fc.required || false;
            var helpText = fc.helpText || '';
            var placeholder = fc.placeholder || '';
            var selectedClass = _selectedFieldId === fieldId ? ' style="outline:2px solid var(--primary-500);outline-offset:4px;border-radius:var(--radius-md);"' : '';

            html += '<div class="forms-builder-preview-field" onclick="event.stopPropagation();FormsApp.selectField(\'' + _esc(fieldId) + '\')"' + selectedClass + '>';
            html += '<label>' + _esc(label) + (required ? ' <span class="required">*</span>' : '') + '</label>';

            var ft = (field.fieldType || '').toLowerCase();
            if (ft === 'multilinetext' || ft === 'richtext') {
                html += '<textarea placeholder="' + _esc(placeholder) + '" disabled></textarea>';
            } else if (ft === 'checkbox') {
                html += '<input type="checkbox" disabled style="width:auto;">';
            } else if (ft === 'singleselect') {
                html += '<select disabled><option>' + _esc(placeholder || 'Select...') + '</option></select>';
            } else if (ft === 'date' || ft === 'datetime') {
                html += '<input type="date" disabled>';
            } else {
                html += '<input type="text" placeholder="' + _esc(placeholder) + '" disabled>';
            }

            if (helpText) html += '<div class="field-help">' + _esc(helpText) + '</div>';
            html += '</div>';
        }

        html += '<button class="forms-builder-preview-submit" disabled>' + _esc(submitText) + '</button>';

        var preview = document.getElementById('forms-builder-preview');
        if (preview) preview.innerHTML = html;
    }

    function _renderFieldConfig(fieldId, tableId, formView) {
        var field = (META_FIELDS[tableId] || {})[fieldId];
        if (!field) return;
        var formConfig = formView.formConfig || {};
        var fieldConfigs = formConfig.fieldConfigs || {};
        var fc = fieldConfigs[fieldId] || {};

        var html = '<div class="forms-builder-config-field">' +
            '<label>Display Label</label>' +
            '<input type="text" value="' + _esc(fc.label || field.fieldName || '') + '" onchange="FormsApp.updateFieldConfig(\'' + _esc(fieldId) + '\', \'label\', this.value)">' +
        '</div>' +
        '<div class="forms-builder-config-toggle">' +
            '<label>Required</label>' +
            '<input type="checkbox"' + (fc.required ? ' checked' : '') + ' onchange="FormsApp.updateFieldConfig(\'' + _esc(fieldId) + '\', \'required\', this.checked)">' +
        '</div>' +
        '<div class="forms-builder-config-field">' +
            '<label>Placeholder</label>' +
            '<input type="text" value="' + _esc(fc.placeholder || '') + '" onchange="FormsApp.updateFieldConfig(\'' + _esc(fieldId) + '\', \'placeholder\', this.value)">' +
        '</div>' +
        '<div class="forms-builder-config-field">' +
            '<label>Help Text</label>' +
            '<textarea onchange="FormsApp.updateFieldConfig(\'' + _esc(fieldId) + '\', \'helpText\', this.value)">' + _esc(fc.helpText || '') + '</textarea>' +
        '</div>';

        var configBody = document.getElementById('forms-builder-config-body');
        if (configBody) configBody.innerHTML = html;
    }

    //  Public API 

    async function init() {
        _populateTableFilter();
        await _render();
        _initialized = true;
    }

    function onSearch(value) {
        _searchQuery = value;
        _render();
    }

    function onFilterChange() {
        _tableFilter = document.getElementById('forms-table-filter').value;
        _statusFilter = document.getElementById('forms-status-filter').value;
        _ownerFilter = document.getElementById('forms-owner-filter').value;
        _render();
    }

    function openCreateModal() {
        _populateCreateTableSelect();
        document.getElementById('forms-create-name').value = '';
        document.getElementById('forms-create-desc').value = '';
        var tableSelect = document.getElementById('forms-create-table');
        if (tableSelect) tableSelect.selectedIndex = 0;
        var sharingSelect = document.getElementById('forms-create-sharing');
        if (sharingSelect) sharingSelect.selectedIndex = 0;
        document.getElementById('forms-create-modal').classList.add('open');
        setTimeout(function() {
            document.getElementById('forms-create-name').focus();
        }, 100);
    }

    function closeCreateModal(event) {
        if (event && event.target !== event.currentTarget) return;
        document.getElementById('forms-create-modal').classList.remove('open');
    }

    function onCreateTableChange() {
        // Future: could preview field count or table info
    }

    async function submitCreate() {
        var nameInput = document.getElementById('forms-create-name');
        var tableSelect = document.getElementById('forms-create-table');
        var descInput = document.getElementById('forms-create-desc');
        var sharingSelect = document.getElementById('forms-create-sharing');

        var formName = nameInput.value.trim();
        var tableId = tableSelect.value;
        var description = descInput.value.trim();
        var sharingLevel = sharingSelect.value;

        if (!formName) {
            nameInput.focus();
            if (typeof showToast === 'function') showToast('warning', 'Please enter a form name');
            return;
        }
        if (!tableId) {
            tableSelect.focus();
            if (typeof showToast === 'function') showToast('warning', 'Please select a source table');
            return;
        }

        var submitBtn = document.getElementById('forms-create-submit');
        if (submitBtn) { submitBtn.disabled = true; submitBtn.textContent = 'Creating...'; }

        try {
            var newViewId = 'viw_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            var newView = {
                tableId: tableId,
                viewId: newViewId,
                viewName: formName,
                viewType: 'form',
                hiddenFieldIds: [],
                fieldOrder: [],
                filters: [],
                sorts: [],
                groupBy: null,
                folderId: null,
                formConfig: {
                    title: formName,
                    description: description,
                    submitButtonText: 'Submit',
                    successMessage: 'Thank you! Your response has been recorded.',
                    status: 'draft',
                    fieldConfigs: {}
                },
                createdAt: Date.now(),
                updatedAt: Date.now()
            };

            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][newViewId] = newView;
            if (typeof saveView === 'function') await saveView(newView);

            var currentUserId = (typeof MatrixClient !== 'undefined' && MatrixClient.getUserId)
                ? MatrixClient.getUserId() : null;
            if (currentUserId && typeof SharedViews !== 'undefined') {
                await SharedViews.setViewOwnership(tableId, newViewId, currentUserId);
                if (sharingLevel !== 'private') {
                    await SharedViews.shareView(tableId, newViewId, sharingLevel, []);
                }
            }

            closeCreateModal();
            if (typeof showToast === 'function') showToast('success', 'Form created');

            // Open the builder for the new form
            openBuilder(tableId, newViewId);

        } catch (err) {
            console.error('[FormsApp] Failed to create form:', err);
            if (typeof showToast === 'function') showToast('error', 'Failed to create form: ' + (err.message || ''));
        } finally {
            if (submitBtn) { submitBtn.disabled = false; submitBtn.textContent = 'Create Form'; }
        }
    }

    function openBuilder(tableId, viewId) {
        _currentFormTableId = tableId;
        _currentFormId = viewId;
        _selectedFieldId = null;

        var view = (META_VIEWS[tableId] || {})[viewId];
        if (!view) {
            if (typeof showToast === 'function') showToast('error', 'Form not found');
            return;
        }

        // Switch to builder view
        var listView = document.getElementById('forms-list-view');
        var builderView = document.getElementById('forms-builder-view');
        if (listView) listView.style.display = 'none';
        if (builderView) builderView.classList.add('visible');

        // Update title
        var titleEl = document.getElementById('forms-builder-title');
        var subtitleEl = document.getElementById('forms-builder-subtitle');
        if (titleEl) titleEl.textContent = view.viewName || 'Untitled Form';
        if (subtitleEl) subtitleEl.textContent = _getTableName(tableId);

        // Update publish button
        var pubBtn = document.getElementById('forms-publish-btn');
        var status = (view.formConfig && view.formConfig.status) || 'draft';
        if (pubBtn) pubBtn.textContent = status === 'published' ? 'Unpublish' : 'Publish';

        _renderBuilderSidebar(tableId, view);
        _renderBuilderPreview(tableId, view);
    }

    function closeBuilder() {
        _currentFormTableId = null;
        _currentFormId = null;
        _selectedFieldId = null;

        var listView = document.getElementById('forms-list-view');
        var builderView = document.getElementById('forms-builder-view');
        if (listView) listView.style.display = '';
        if (builderView) builderView.classList.remove('visible');

        // Re-render list to pick up any changes
        _render();
    }

    function toggleField(fieldId) {
        if (!_currentFormTableId || !_currentFormId) return;
        var view = (META_VIEWS[_currentFormTableId] || {})[_currentFormId];
        if (!view) return;

        var hidden = view.hiddenFieldIds || [];
        var idx = hidden.indexOf(fieldId);
        if (idx === -1) {
            hidden.push(fieldId);
        } else {
            hidden.splice(idx, 1);
        }
        view.hiddenFieldIds = hidden;
        view.updatedAt = Date.now();
        if (typeof saveView === 'function') saveView(view);

        _renderBuilderSidebar(_currentFormTableId, view);
        _renderBuilderPreview(_currentFormTableId, view);
    }

    function selectField(fieldId) {
        _selectedFieldId = fieldId;
        if (!_currentFormTableId || !_currentFormId) return;
        var view = (META_VIEWS[_currentFormTableId] || {})[_currentFormId];
        if (!view) return;

        _renderBuilderSidebar(_currentFormTableId, view);
        _renderBuilderPreview(_currentFormTableId, view);
        _renderFieldConfig(fieldId, _currentFormTableId, view);
    }

    function updateFieldConfig(fieldId, key, value) {
        if (!_currentFormTableId || !_currentFormId) return;
        var view = (META_VIEWS[_currentFormTableId] || {})[_currentFormId];
        if (!view) return;

        if (!view.formConfig) view.formConfig = {};
        if (!view.formConfig.fieldConfigs) view.formConfig.fieldConfigs = {};
        if (!view.formConfig.fieldConfigs[fieldId]) view.formConfig.fieldConfigs[fieldId] = {};
        view.formConfig.fieldConfigs[fieldId][key] = value;
        view.updatedAt = Date.now();
        if (typeof saveView === 'function') saveView(view);

        _renderBuilderPreview(_currentFormTableId, view);
    }

    async function publishForm() {
        if (!_currentFormTableId || !_currentFormId) return;
        var view = (META_VIEWS[_currentFormTableId] || {})[_currentFormId];
        if (!view) return;

        if (!view.formConfig) view.formConfig = {};
        var newStatus = view.formConfig.status === 'published' ? 'draft' : 'published';
        view.formConfig.status = newStatus;
        view.updatedAt = Date.now();
        if (typeof saveView === 'function') await saveView(view);

        var pubBtn = document.getElementById('forms-publish-btn');
        if (pubBtn) pubBtn.textContent = newStatus === 'published' ? 'Unpublish' : 'Publish';

        if (typeof showToast === 'function') {
            showToast('success', newStatus === 'published' ? 'Form published' : 'Form unpublished');
        }
    }

    function shareForm() {
        // Reuse existing share view modal
        if (!_currentFormTableId || !_currentFormId) return;
        if (typeof _shareViewTableId !== 'undefined') {
            _shareViewTableId = _currentFormTableId;
            _shareViewId = _currentFormId;
        }
        if (typeof openShareViewMenu === 'function') {
            openShareViewMenu();
        }
    }

    function togglePreview() {
        // Toggle sidebar and config panels for a cleaner preview
        var sidebar = document.getElementById('forms-builder-sidebar');
        var config = document.getElementById('forms-builder-config');
        if (sidebar && config) {
            var hidden = sidebar.style.display === 'none';
            sidebar.style.display = hidden ? '' : 'none';
            config.style.display = hidden ? '' : 'none';
        }
    }

    async function duplicateForm(tableId, viewId) {
        var view = (META_VIEWS[tableId] || {})[viewId];
        if (!view) return;

        var newViewId = 'viw_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        var clone = JSON.parse(JSON.stringify(view));
        clone.viewId = newViewId;
        clone.viewName = (clone.viewName || 'Form') + ' (copy)';
        clone.createdAt = Date.now();
        clone.updatedAt = Date.now();
        if (clone.formConfig) clone.formConfig.status = 'draft';

        META_VIEWS[tableId][newViewId] = clone;
        if (typeof saveView === 'function') await saveView(clone);

        var currentUserId = (typeof MatrixClient !== 'undefined' && MatrixClient.getUserId)
            ? MatrixClient.getUserId() : null;
        if (currentUserId && typeof SharedViews !== 'undefined') {
            await SharedViews.setViewOwnership(tableId, newViewId, currentUserId);
        }

        if (typeof showToast === 'function') showToast('success', 'Form duplicated');
        _render();
    }

    async function deleteForm(tableId, viewId) {
        if (!confirm('Delete this form? This cannot be undone.')) return;

        var views = META_VIEWS[tableId];
        if (views && views[viewId]) {
            delete views[viewId];
        }

        if (typeof AminoData !== 'undefined' && AminoData.deleteView) {
            try { await AminoData.deleteView(tableId, viewId); } catch (e) { /* best effort */ }
        } else if (typeof deleteView === 'function') {
            try { await deleteView(tableId, viewId); } catch (e) { /* best effort */ }
        }

        if (typeof showToast === 'function') showToast('success', 'Form deleted');
        _render();
    }

    return {
        init: init,
        onSearch: onSearch,
        onFilterChange: onFilterChange,
        openCreateModal: openCreateModal,
        closeCreateModal: closeCreateModal,
        onCreateTableChange: onCreateTableChange,
        submitCreate: submitCreate,
        openBuilder: openBuilder,
        closeBuilder: closeBuilder,
        toggleField: toggleField,
        selectField: selectField,
        updateFieldConfig: updateFieldConfig,
        publishForm: publishForm,
        shareForm: shareForm,
        togglePreview: togglePreview,
        duplicateForm: duplicateForm,
        deleteForm: deleteForm,
        refresh: _render
    };
})();

// ============ Interface App Module ============
// Renders the Softr-style interface (Home, Clients, Events) using live data
// Schema stored in Matrix room using law.firm.interface state events (EO format)

var InterfaceApp = (function() {
    'use strict';

    var _initialized = false;
    var _editMode = false;
    var _interfaceRoomId = null;
    var _activePage = null;
    var _globalSearchQuery = '';
    var _tableDataCache = {};       // tableId -> { records: [], lastFetch: timestamp }
    var _apiDataCache = {};         // sourceKey -> { records: [], lastFetch: timestamp }
    var _tablePaginationState = {}; // pageId -> { page: 0, pageSize: 50, sort: { field, dir } }
    var _blockSearchState = {};     // blockId -> searchQuery
    var _caseNotesWidgetState = {}; // blockId -> remote case note query state
    var _tableSettingsOpen = {};    // blockId -> boolean (admin settings panel toggle)

    var CASE_NOTES_WIDGET_ENDPOINT = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:l_gEBOGc/get_case_notes';

    // ============ Default Schema (EO Format) ============
    // The schema describes pages and their blocks using EO operators:
    //   DES  = field description / data source binding
    //   SEG  = segmentation (filter, sort, group, paginate)
    //   CON  = connection (linked record traversal)
    //   ALT  = alteration (transform display, compute)

    var DEFAULT_SCHEMA = {
        version: '2',
        schemaType: 'law.firm.interface',
        epistemicStatus: 'GIVEN',
        pages: [
            {
                id: 'home',
                label: 'Home',
                icon: 'home',
                blocks: [
                    {
                        id: 'home-welcome',
                        type: 'welcome-greeting',
                        display: {
                            subtitle: '{tableCount} tables synced'
                        }
                    },
                    {
                        id: 'home-action-cards',
                        type: 'action-cards',
                        items: [
                            { label: 'Database (Admin)', desc: 'Admin console for schema changes, cleanup, and advanced maintenance over synchronized Airtable data.', icon: 'database', color: 'blue', action: 'switchApp:database' },
                            { label: 'Interface', desc: 'Client views, case dashboards, and custom forms \u2014 your workspace for day-to-day operations.', icon: 'interface', color: 'green', action: 'page:clients' },
                            { label: 'Settings', desc: 'Matrix sync configuration, user management, webhook endpoints, and system preferences.', icon: 'settings', color: 'slate', action: 'switchApp:settings' }
                        ]
                    },
                    {
                        id: 'home-stats',
                        type: 'stats-row'
                    },
                    {
                        id: 'home-two-col',
                        type: 'home-columns',
                        children: ['home-hearings', 'home-recent-clients']
                    },
                    {
                        id: 'home-hearings',
                        type: 'recent-list',
                        label: 'Upcoming Hearings',
                        countLabel: 'Today',
                        source: {
                            op: 'DES',
                            tableNamePattern: 'events',
                            fallbackTablePattern: 'event'
                        },
                        display: {
                            titleField: 'Event Title',
                            subtitleField: 'Full Name Client',
                            timeField: 'Hearing Date/Time',
                            detailFields: ['Court/Office']
                        },
                        segment: {
                            op: 'SEG',
                            filter: { field: 'Hearing Date/Time', op: 'isToday' },
                            sort: { field: 'Hearing Date/Time', dir: 'asc' },
                            limit: 5
                        }
                    },
                    {
                        id: 'home-recent-clients',
                        type: 'recent-list',
                        label: 'Recent Clients',
                        source: {
                            op: 'DES',
                            tableNamePattern: 'client info',
                            fallbackTablePattern: 'client'
                        },
                        display: {
                            titleField: 'Full Name Client',
                            subtitleFields: ['ICH Atty', 'A#'],
                            statusField: 'File Case Status (from Case Master View // Activities)'
                        },
                        segment: {
                            op: 'SEG',
                            sort: { field: '_createdTime', dir: 'desc' },
                            limit: 5
                        }
                    },
                    {
                        id: 'home-activity',
                        type: 'activity-log'
                    }
                ]
            },
            {
                id: 'clients',
                label: 'Clients',
                icon: 'clients',
                blocks: [
                    {
                        id: 'clients-table',
                        type: 'data-table',
                        label: 'RK Lacy Law Clients',
                        mirrorViewFields: true,
                        source: {
                            op: 'DES',
                            tableNamePattern: 'client info',
                            fallbackTablePattern: 'client'
                        },
                        columns: [
                            { field: 'Client Name', label: 'Client Name', width: 200 },
                            { field: 'File Case Status (from Case Master View // Activities)', label: 'File Status', width: 100 },
                            { field: 'A#', label: 'A#', width: 100 },
                            { field: 'DOB & Age', label: 'DOB & Age', width: 120 },
                            { field: 'Soonest Event (from Case Master View // Activities)', label: 'Next Event', width: 160 },
                            { field: 'Brief Event Info Rollup (from Case Events) Rollup (from Case Master View // Activities)', label: 'Event Info', width: 200 },
                            { field: 'ICH Atty', label: 'ICH Atty', width: 100 },
                            { field: 'MCH Attny Options', label: 'MCH Atty', width: 100 },
                            { field: 'Case Manager', label: 'Case Manager', width: 120 },
                            { field: 'Country', label: 'Country', width: 100 },
                            { field: 'Phone Number', label: 'Phone', width: 120 },
                            { field: 'Client Email', label: 'Email', width: 180 },
                            { field: 'Last Modified', label: 'Last Modified', width: 160 },
                            { field: 'Last Modified By', label: 'Last Modified By', width: 140 }
                        ],
                        filters: [
                            { id: 'mch', label: 'MCH', field: 'MCH Attny Options' },
                            { id: 'ich', label: 'ICH', field: 'ICH Atty' },
                            { id: 'cm', label: 'Case Manager', field: 'Case Manager' },
                            { id: 'status', label: 'File Status', field: 'File Case Status (from Case Master View // Activities)' }
                        ],
                        segment: {
                            op: 'SEG',
                            sort: { field: 'Last Modified', dir: 'desc' },
                            pageSize: 50
                        }
                    }
                ]
            },
            {
                id: 'client-relationships',
                label: 'Client Relationships',
                icon: 'clients',
                blocks: [
                    {
                        id: 'clients-relationship-graph',
                        type: 'client-relationship-graph',
                        label: 'Client Relationship Graph',
                        source: {
                            op: 'DES',
                            tableNamePattern: 'client info',
                            fallbackTablePattern: 'client'
                        },
                        relationshipSource: {
                            op: 'DES',
                            tableNamePattern: 'client relationships',
                            fallbackTablePattern: 'relationship'
                        }
                    }
                ]
            },
            {
                id: 'events',
                label: 'Events',
                icon: 'events',
                blocks: [
                    {
                        id: 'events-agenda',
                        type: 'events-agenda',
                        label: 'Events',
                        _hidden: true,
                        source: {
                            op: 'DES',
                            tableNamePattern: 'events',
                            fallbackTablePattern: 'event'
                        },
                        display: {
                            titleField: 'Event Title',
                            timeField: 'Hearing Date/Time',
                            clientField: 'Full Name Client',
                            detailFields: ['Court/Office', 'Judge'],
                            attorneyFields: ['ICH Attny', 'MCH Attny']
                        },
                        calendarConfig: {
                            timezone: 'America/New_York',
                            webhookUrl: 'https://n8n.intelechia.com/webhook/users',
                            cacheKey: 'rklUserRoster'
                        },
                        segment: {
                            op: 'SEG',
                            filter: { field: 'Hearing Date/Time', op: 'isFutureOrToday' },
                            sort: { field: 'Hearing Date/Time', dir: 'asc' },
                            limit: 200
                        }
                    },
                    {
                        id: 'events-google-calendar',
                        type: 'google-calendar',
                        label: 'Google Calendar',
                        _hidden: false,
                        config: {
                            timezone: 'America/New_York',
                            webhookUrl: 'https://n8n.intelechia.com/webhook/users',
                            cacheKey: 'rklUserRoster',
                            staticGroups: [
                                { id: 'c_2117d3d5346290d1f9769d5d8a60b1a82da31ecb4080f981cfb0b9f25590a298@group.calendar.google.com', name: 'Hearings & Interviews', grp: 'hear' },
                                { id: 'c_ae631b2171ddcf4f882cd2e6d11a39e19480876fac7794206fca70e734ab9d1f@group.calendar.google.com', name: 'Client Appointments', grp: 'event' }
                            ],
                            fallbackRoster: [
                                { Name: '\uD83D\uDFE0 AMishra', Email: 'abhinav@rklacylaw.com' },
                                { Name: '\u26AA Office', Email: 'office@rklacylaw.com' },
                                { Name: '\u26AB R. Valentin', Email: 'roberto.valentin@rklacylaw.com' },
                                { Name: '\uD83D\uDD34 RKLacy', Email: 'bob@rklacylaw.com' },
                                { Name: '\uD83D\uDD35 GCotto', Email: 'guillermo@rklacylaw.com' },
                                { Name: '\uD83D\uDFE1 NRafi', Email: 'nafisa@rklacylaw.com' },
                                { Name: '\uD83D\uDFE2 CVega', Email: 'christian@rklacylaw.com' },
                                { Name: '\uD83D\uDFE3 MVieraLugo', Email: 'mariana@rklacylaw.com' },
                                { Name: '\uD83D\uDFE4 ABahr', Email: 'andres@asiloymas.com' },
                                { Name: 'Alexis', Email: 'alexis@rklacylaw.com' },
                                { Name: 'Ana', Email: 'ana@rklacylaw.com' },
                                { Name: 'Ariana', Email: 'ariana@rklacylaw.com' },
                                { Name: 'Ashley', Email: 'ashley@rklacylaw.com' },
                                { Name: 'Brian', Email: 'brian@rklacylaw.com' },
                                { Name: 'Carol', Email: 'carol@rklacylaw.com' },
                                { Name: 'Claudia', Email: 'claudiaa@rklacylaw.com' },
                                { Name: 'Darma', Email: 'darma@rklacylaw.com' },
                                { Name: 'Deema', Email: 'deema@rklacylaw.com' },
                                { Name: 'Diana M.', Email: 'dianag@rklacylaw.com' },
                                { Name: 'Edith', Email: 'edith@rklacylaw.com' },
                                { Name: 'Elizabeth', Email: 'elizabethc@rklacylaw.com' },
                                { Name: 'Gaby', Email: 'gaby@rklacylaw.com' },
                                { Name: 'Huascar', Email: 'huascar@rklacylaw.com' },
                                { Name: 'Jairo', Email: 'jairo@rklacylaw.com' },
                                { Name: 'Jessica', Email: 'jessica@rklacylaw.com' },
                                { Name: 'Jocelyn', Email: 'jocelyn@rklacylaw.com' },
                                { Name: 'Kelly', Email: 'kelly@rklacylaw.com' },
                                { Name: 'Kevin', Email: 'kevin@rklacylaw.com' },
                                { Name: 'Luisa', Email: 'luisa@rklacylaw.com' },
                                { Name: 'Lys', Email: 'lys@rklacylaw.com' },
                                { Name: 'Monique', Email: 'monique@rklacylaw.com' },
                                { Name: 'Nilson', Email: 'nilson@rklacylaw.com' },
                                { Name: 'Paula', Email: 'paula@rklacylaw.com' },
                                { Name: 'Saori', Email: 'saori@rklacylaw.com' },
                                { Name: 'Sarahy', Email: 'sarahy@rklacylaw.com' },
                                { Name: 'Sheila', Email: 'sheila@rklacylaw.com' },
                                { Name: 'Tamy', Email: 'tamara@rklacylaw.com' }
                            ]
                        }
                    },
                    {
                        id: 'events-hearings-timeline',
                        type: 'timeline',
                        label: 'Upcoming Hearings & Interviews',
                        _hidden: true,
                        source: {
                            op: 'DES',
                            tableNamePattern: 'events',
                            fallbackTablePattern: 'event'
                        },
                        display: {
                            titleField: 'Event Title',
                            timeField: 'Hearing Date/Time',
                            detailFields: ['Full Name Client', 'ICH Attny', 'MCH Attny', 'Court/Office', 'Judge']
                        },
                        segment: {
                            op: 'SEG',
                            filter: { field: 'Hearing Date/Time', op: 'isFutureOrToday' },
                            sort: { field: 'Hearing Date/Time', dir: 'asc' },
                            limit: 100
                        }
                    },
                    {
                        id: 'events-client-list',
                        type: 'card-list',
                        label: 'Client Events',
                        _hidden: true,
                        source: {
                            op: 'DES',
                            tableNamePattern: 'events',
                            fallbackTablePattern: 'event'
                        },
                        display: {
                            titleField: 'Event Title',
                            subtitleField: 'Full Name Client',
                            metaField: 'Hearing Date/Time',
                            icon: '\uD83D\uDCC5'
                        },
                        segment: {
                            op: 'SEG',
                            sort: { field: 'Hearing Date/Time', dir: 'desc' },
                            limit: 50
                        }
                    },
                    {
                        id: 'events-all-table',
                        type: 'data-table',
                        label: 'All Events',
                        _hidden: true,
                        source: {
                            op: 'DES',
                            tableNamePattern: 'events',
                            fallbackTablePattern: 'event'
                        },
                        columns: [
                            { field: 'Event Title', label: 'Event', width: 220 },
                            { field: 'Full Name Client', label: 'Client', width: 160 },
                            { field: 'Hearing Date/Time', label: 'Date/Time', width: 160 },
                            { field: 'ICH Attny', label: 'ICH', width: 100 },
                            { field: 'MCH Attny', label: 'MCH', width: 100 },
                            { field: 'Court/Office', label: 'Court/Office', width: 140 },
                            { field: 'Judge', label: 'Judge', width: 120 }
                        ],
                        filters: [],
                        segment: {
                            op: 'SEG',
                            sort: { field: 'Hearing Date/Time', dir: 'desc' },
                            pageSize: 50
                        }
                    }
                ]
            },
            {
                id: 'case-notes',
                label: 'Case Notes',
                icon: 'notes',
                blocks: [
                    {
                        id: 'case-notes-widget',
                        type: 'case-notes-widget',
                        label: 'Case Notes',
                        endpoint: CASE_NOTES_WIDGET_ENDPOINT
                    }
                ]
            }
        ]
    };

    var _schema = null;

    // ============ Schema Persistence (Matrix Room, EO Format) ============

    async function _findOrCreateInterfaceRoom() {
        if (_interfaceRoomId) return _interfaceRoomId;
        if (!MatrixClient.isLoggedIn()) return null;

        // Try localStorage cache first to avoid scanning space children on every load
        try {
            var cached = localStorage.getItem('amino.interfaceRoomId');
            if (cached) {
                // Verify the cached room is still valid by checking its type
                var roomType = MatrixClient.getCachedStateEvent(cached, 'law.firm.room.type', '');
                if (roomType && roomType.content && roomType.content.type === 'interface') {
                    _interfaceRoomId = cached;
                    return _interfaceRoomId;
                }
                // Cached room is stale, clear it
                localStorage.removeItem('amino.interfaceRoomId');
            }
        } catch (e) {}

        // Look for existing interface room in org space
        var orgSpaceId = _settingsOrgSpaceId;
        if (!orgSpaceId) {
            try { orgSpaceId = await MatrixClient.findOrgSpace(); } catch (e) {}
        }
        if (orgSpaceId) {
            var children = await MatrixClient.getSpaceChildren(orgSpaceId);
            for (var i = 0; i < children.length; i++) {
                var childId = children[i];
                var roomType = MatrixClient.getCachedStateEvent(childId, 'law.firm.room.type', '');
                if (roomType && roomType.content && roomType.content.type === 'interface') {
                    _interfaceRoomId = childId;
                    try { localStorage.setItem('amino.interfaceRoomId', childId); } catch (e) {}
                    return _interfaceRoomId;
                }
            }
        }

        // Create new interface room
        try {
            var roomId = await MatrixClient.createRoom({
                name: 'Interface Schema',
                preset: 'private_chat',
                initialState: [
                    { type: 'm.room.history_visibility', state_key: '', content: { history_visibility: 'shared' } }
                ]
            });
            // Tag as interface room
            await MatrixClient.sendStateEvent(roomId, 'law.firm.room.type', '', {
                type: 'interface',
                created_by: MatrixClient.getUserId() || 'system',
                created_at: Date.now()
            });
            // Add to org space if available
            if (orgSpaceId) {
                try {
                    var hs = (MatrixClient.getHomeserverUrl() || '').replace(/^https?:\/\//, '').replace(/\/.*$/, '') || 'aminoimmigration.com';
                    await MatrixClient.sendStateEvent(orgSpaceId, 'm.space.child', roomId, { via: [hs] });
                } catch (e) { console.warn('[Interface] Could not add room to org space:', e); }
            }
            _interfaceRoomId = roomId;
            try { localStorage.setItem('amino.interfaceRoomId', roomId); } catch (e) {}
            console.log('[Interface] Created interface room:', roomId);
        } catch (e) {
            console.error('[Interface] Failed to create interface room:', e);
        }
        return _interfaceRoomId;
    }

    async function loadSchema() {
        try {
            var roomId = await _findOrCreateInterfaceRoom();
            if (!roomId) {
                console.warn('[Interface] No interface room, using defaults');
                _schema = JSON.parse(JSON.stringify(DEFAULT_SCHEMA));
                return _schema;
            }
            var stateEvent = await MatrixClient.getStateEvent(roomId, 'law.firm.interface', 'schema');
            if (stateEvent && stateEvent.pages) {
                _schema = stateEvent;
                _schema.pages.forEach(function(page) { _normalizePageRoles(page); });
                console.log('[Interface] Loaded schema from room:', roomId);
            } else {
                _schema = JSON.parse(JSON.stringify(DEFAULT_SCHEMA));
                // Save default schema to room
                await saveSchema();
            }
        } catch (e) {
            console.warn('[Interface] Schema load failed, using defaults:', e.message);
            _schema = JSON.parse(JSON.stringify(DEFAULT_SCHEMA));
        }
        return _schema;
    }

    async function saveSchema() {
        if (!_schema) return;
        try {
            var roomId = await _findOrCreateInterfaceRoom();
            if (!roomId) { console.warn('[Interface] Cannot save schema: no room'); return; }
            _schema.lastModified = new Date().toISOString();
            _schema.modifiedBy = MatrixClient.getUserId() || 'unknown';
            await MatrixClient.sendStateEvent(roomId, 'law.firm.interface', 'schema', _schema);
            console.log('[Interface] Schema saved to room:', roomId);
        } catch (e) {
            console.error('[Interface] Schema save failed:', e);
        }
    }

    // ============ Table Resolution ============
    // Resolves a tableNamePattern from the schema to an actual table ID

    function _normalizeTableName(value) {
        return String(value || '')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '')
            .replace(/s$/, '');
    }

    function _resolveTableId(source) {
        if (!source) return null;
        var tables = Object.keys(META_TABLES || {});
        var pattern = (source.tableNamePattern || '').toLowerCase();
        var fallback = (source.fallbackTablePattern || '').toLowerCase();
        var patternNorm = _normalizeTableName(source.tableNamePattern || '');
        var fallbackNorm = _normalizeTableName(source.fallbackTablePattern || '');

        // Exact match first
        for (var i = 0; i < tables.length; i++) {
            var name = resolveTableName(tables[i]).toLowerCase();
            if (name === pattern) return tables[i];
        }
        // Normalized exact match for punctuation/plural variants
        if (patternNorm) {
            for (var i2 = 0; i2 < tables.length; i2++) {
                var nameNorm = _normalizeTableName(resolveTableName(tables[i2]));
                if (nameNorm === patternNorm) return tables[i2];
            }
        }
        // Contains match
        for (var j = 0; j < tables.length; j++) {
            var n = resolveTableName(tables[j]).toLowerCase();
            if (n.includes(pattern)) return tables[j];
        }
        // Normalized contains match
        if (patternNorm) {
            for (var j2 = 0; j2 < tables.length; j2++) {
                var nNorm = _normalizeTableName(resolveTableName(tables[j2]));
                if (nNorm.includes(patternNorm)) return tables[j2];
            }
        }
        // Fallback pattern
        if (fallback) {
            for (var k = 0; k < tables.length; k++) {
                var fn = resolveTableName(tables[k]).toLowerCase();
                if (fn.includes(fallback)) return tables[k];
            }
        }
        if (fallbackNorm) {
            for (var k2 = 0; k2 < tables.length; k2++) {
                var fnNorm = _normalizeTableName(resolveTableName(tables[k2]));
                if (fnNorm.includes(fallbackNorm)) return tables[k2];
            }
        }
        return null;
    }

    function _sourceCacheKey(source) {
        if (!source) return '';
        if (source.apiUrl) return 'api:' + source.apiUrl;
        return 'table:' + (source.tableNamePattern || '') + ':' + (source.fallbackTablePattern || '');
    }

    function _normalizeSourceRecords(rawRecords) {
        var rows = Array.isArray(rawRecords) ? rawRecords : [];
        var normalized = [];
        for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            if (!row || typeof row !== 'object') continue;
            var rid = row.id || row.recordId || row._id || ('row_' + i);
            normalized.push({ recordId: String(rid), fields: row });
        }
        return normalized;
    }

    async function _getApiRecords(source) {
        var apiUrl = source && source.apiUrl;
        if (!apiUrl) return [];

        var cacheKey = _sourceCacheKey(source);
        var cached = _apiDataCache[cacheKey];
        if (cached && (Date.now() - cached.lastFetch) < 10000) {
            return cached.records;
        }

        try {
            var response = await fetch(apiUrl, { method: 'GET' });
            if (!response.ok) {
                throw new Error('HTTP ' + response.status);
            }
            var payload = await response.json();
            var records = _normalizeSourceRecords(payload && payload.data ? payload.data : payload);
            _apiDataCache[cacheKey] = { records: records, lastFetch: Date.now() };
            return records;
        } catch (e) {
            console.warn('[Interface] API data fetch error for', apiUrl, ':', e.message);
            return [];
        }
    }

    async function _getSourceRecords(source) {
        if (!source) return [];
        if (source.apiUrl) {
            return _getApiRecords(source);
        }
        var tableId = _resolveTableId(source);
        return tableId ? _getTableRecords(tableId) : [];
    }

    // ============ Data Fetching ============

    async function _getTableRecords(tableId) {
        if (!tableId) return [];
        var cached = _tableDataCache[tableId];
        if (cached && (Date.now() - cached.lastFetch) < 10000) {
            return cached.records;
        }
        var records = [];
        try {
            // Use the same data pipeline as the Database View:
            // getRecordIdsForTable merges IN_MEMORY_DATA + IndexedDB,
            // getRecordsByIds serves from LRU cache / IN_MEMORY_DATA / IDB
            // with proper decryption handling for all storage modes.
            var recordIds = await getRecordIdsForTable(tableId);
            if (recordIds.length > 0) {
                var rawRecords = await getRecordsByIds(tableId, recordIds);
                for (var i = 0; i < rawRecords.length; i++) {
                    var rec = rawRecords[i];
                    var rid = rec.recordId || rec.id;
                    var recFields = rec.fields;
                    if (typeof recFields === 'string') {
                        try { recFields = JSON.parse(recFields); } catch (e) { continue; }
                    }
                    if (recFields && typeof recFields === 'object') {
                        records.push({ recordId: rid, fields: recFields });
                    }
                }
            }
        } catch (e) {
            console.warn('[Interface] Data fetch error for table', tableId, ':', e.message);
        }

        // Ensure META_FIELDS has proper field metadata for this table.
        // The DB screen reloads META_FIELDS from IDB on every table navigation,
        // but the Interface relies on whatever was populated during hydration.
        // If META_FIELDS was deleted (by DB screen navigation) or only has
        // placeholder entries (fieldName === fieldId), reload from IDB.
        var fieldMeta = (typeof META_FIELDS !== 'undefined' && META_FIELDS[tableId]) ? META_FIELDS[tableId] : null;
        if ((!fieldMeta || Object.keys(fieldMeta).length === 0) && typeof db !== 'undefined' && db && typeof getFieldsForTable === 'function') {
            try {
                var idbFields = await getFieldsForTable(tableId);
                if (idbFields && idbFields.length > 0) {
                    if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
                    idbFields.forEach(function(f) {
                        META_FIELDS[tableId][f.fieldId] = f;
                    });
                    fieldMeta = META_FIELDS[tableId];
                }
            } catch (e) {
                console.warn('[Interface] Failed to reload field metadata from IDB:', e.message);
            }
        }

        // Compute formula fields for interface records before translating IDs.
        // Stored records often omit formula values because they are computed at render-time.
        if (fieldMeta && records.length) {
            var recordMap = {};
            for (var rix = 0; rix < records.length; rix++) {
                var ifaceRecord = records[rix] || {};
                var ifaceRecordId = ifaceRecord.recordId;
                if (!ifaceRecordId) continue;
                recordMap[ifaceRecordId] = ifaceRecord.fields || {};
            }
            if (Object.keys(recordMap).length) {
                _applyFormulaColumns(tableId, fieldMeta, recordMap);
            }
        }

        // Translate field IDs to human-readable field names using META_FIELDS.
        // IN_MEMORY_DATA stores fields keyed by field IDs (e.g. "fldAbc123"),
        // but the interface schema references fields by name (e.g. "Client Name").
        if (fieldMeta) {
            records = records.map(function(r) {
                var rawFields = r.fields || {};
                var translated = {};
                Object.keys(rawFields).forEach(function(key) {
                    var meta = fieldMeta[key];
                    var name = (meta && meta.fieldName) ? meta.fieldName : key;
                    var value = rawFields[key];
                    // Preserve both field-id and field-name keys so interface
                    // blocks, formulas, and filters behave like Airtable where
                    // computed values are addressable by canonical field ID.
                    translated[key] = value;
                    if (name !== key) translated[name] = value;
                });
                return { recordId: r.recordId, fields: translated };
            });
        }

        _tableDataCache[tableId] = { records: records, lastFetch: Date.now() };
        // Clear the linked-record label cache when data refreshes so stale
        // display names don't persist across syncs.
        _recordLabelCache = {};
        return records;
    }

    // Pre-warm client data: start loading the client table before the schema
    // is fully resolved, so the data is already cached when renderPage runs.
    async function _preWarmClientData() {
        try {
            var tables = Object.keys(typeof META_TABLES !== 'undefined' ? META_TABLES : {});
            for (var i = 0; i < tables.length; i++) {
                var name = resolveTableName(tables[i]).toLowerCase();
                if (name.includes('client info') || name.includes('client')) {
                    await _getTableRecords(tables[i]);
                    return;
                }
            }
        } catch (e) {
            console.warn('[Interface] Pre-warm failed:', e.message);
        }
    }

    // ============ Data Processing (SEG operations) ============

    // Pre-built search text cache for InterfaceApp records.
    // Maps "tableId:recordId" -> lowercased searchable text.
    var _ifaceSearchTextCache = {};

    function _getIfaceSearchText(record) {
        var tableId = record.tableId || '';
        var recordId = record.recordId || record.id || '';
        var ck = tableId + ':' + recordId;
        if (_ifaceSearchTextCache[ck] !== undefined) return _ifaceSearchTextCache[ck];

        var parts = [recordId];
        var fields = record.fields || {};
        for (var k in fields) {
            if (!Object.prototype.hasOwnProperty.call(fields, k)) continue;
            parts.push(k);
            var text = collectSearchableText(fields[k]);
            if (text) parts.push(text);
        }
        var searchText = parts.join(' ').toLowerCase();
        _ifaceSearchTextCache[ck] = searchText;
        return searchText;
    }

    function _applySegment(records, segment, blockSearchQuery, activeFilters) {
        if (!records || !records.length) return records;
        var result = records.slice();

        // Apply search filter using pre-built search text cache.
        // Tokenized "AND" search  each token must appear in the record's text.
        var searchTokens = normalizeSearchTokens(blockSearchQuery);
        if (searchTokens.length) {
            result = result.filter(function(r) {
                var haystack = _getIfaceSearchText(r);
                for (var i = 0; i < searchTokens.length; i++) {
                    if (haystack.indexOf(searchTokens[i]) === -1) return false;
                }
                return true;
            });
        }

        // Apply active dropdown filters (field-specific)
        if (activeFilters) {
            var filterKeys = Object.keys(activeFilters);
            for (var fi = 0; fi < filterKeys.length; fi++) {
                var af = activeFilters[filterKeys[fi]];
                if (!af || !af.field || !af.value) continue;
                var afField = af.field;
                var afValue = String(af.value).toLowerCase();
                result = result.filter(function(r) {
                    var val = _findFieldValue(r.fields || {}, afField);
                    if (val == null) return false;
                    var sv = Array.isArray(val) ? val.join(', ') : String(val);
                    return sv.toLowerCase().includes(afValue);
                });
            }
        }

        // Apply segment filter
        if (segment && segment.filter) {
            var f = segment.filter;
            result = result.filter(function(r) {
                var val = _findFieldValue(r.fields || {}, f.field);
                if (f.op === 'isToday') {
                    if (!val) return false;
                    var d = new Date(val);
                    var now = new Date();
                    return d.getFullYear() === now.getFullYear() &&
                           d.getMonth() === now.getMonth() &&
                           d.getDate() === now.getDate();
                }
                if (f.op === 'isFutureOrToday') {
                    if (!val) return false;
                    var d2 = new Date(val);
                    var today = new Date();
                    today.setHours(0, 0, 0, 0);
                    return d2 >= today;
                }
                if (f.op === 'eq') return String(val) === String(f.value);
                if (f.op === 'contains') return val && String(val).toLowerCase().includes(String(f.value).toLowerCase());
                return true;
            });
        }

        // Apply sort
        if (segment && segment.sort) {
            var sf = segment.sort.field;
            var dir = segment.sort.dir === 'desc' ? -1 : 1;
            result.sort(function(a, b) {
                var av = _findFieldValue(a.fields || {}, sf);
                var bv = _findFieldValue(b.fields || {}, sf);
                if (av == null && bv == null) return 0;
                if (av == null) return 1;
                if (bv == null) return -1;
                if (typeof av === 'string' && typeof bv === 'string') return av.localeCompare(bv) * dir;
                return (av < bv ? -1 : av > bv ? 1 : 0) * dir;
            });
        }

        // Apply limit
        if (segment && segment.limit) {
            result = result.slice(0, segment.limit);
        }

        return result;
    }

    // ============ Rendering ============

    function _esc(s) {
        if (s == null) return '';
        return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function _formatCaseNoteDescriptionHtml(value) {
        if (value == null || value === '') return _esc('No description field found on this note.');
        var normalized = String(value).replace(/<br\s*\/?\s*>/gi, '\n');
        return _esc(normalized).replace(/\r?\n/g, '<br>');
    }

    function _formatFieldValue(val, fieldType) {
        // For computed field types (formula, rollup, lookup, etc.), delegate
        // to the same formatCell() used by the DB screen so rendering is
        // identical between the two views.
        if (fieldType && typeof isComputedFieldType === 'function' && isComputedFieldType(fieldType)) {
            return (typeof formatCell === 'function') ? formatCell(val, fieldType) : _esc(String(val != null ? val : ''));
        }
        if (val == null) return '<span style="color:var(--text-disabled)">\u2013</span>';
        if (Array.isArray(val)) {
            var resolved = val.map(function(v) {
                if (typeof v === 'string' && /^rec[A-Za-z0-9]{10,}$/.test(v)) {
                    return _resolveRecordIdToLabel(v);
                }
                if (typeof v === 'object' && v !== null) {
                    return v.name || v.label || v.filename || v.email || v.id || null;
                }
                return v;
            }).filter(function(v) { return v != null; });
            if (!resolved.length && val.length) return '<span style="color:var(--text-muted)">linked</span>';
            return _esc(resolved.join(', '));
        }
        if (typeof val === 'object') {
            if (val.label) return _esc(val.label);
            if (val.name) return _esc(val.name);
            if (val.filename) return _esc(val.filename);
            if (val.email) return _esc(val.email);
            return _esc(JSON.stringify(val));
        }
        // Resolve record IDs to display name
        if (typeof val === 'string' && /^rec[A-Za-z0-9]{10,}$/.test(val)) {
            var label = _resolveRecordIdToLabel(val);
            if (label) return _esc(label);
            return '<span style="color:var(--text-muted)">linked</span>';
        }
        // Try to detect date strings and format them
        if (typeof val === 'string' && /^\d{4}-\d{2}-\d{2}/.test(val)) {
            try {
                var d = new Date(val);
                if (!isNaN(d.getTime())) {
                    var formatted = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    if (val.includes('T')) {
                        formatted += ' \u00B7 ' + d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                    }
                    return _esc(formatted);
                }
            } catch (e) {}
        }
        return _esc(String(val));
    }


    function _normalizePageRoles(page) {
        if (!page) return ['all'];
        if (!Array.isArray(page.visibleToRoles) || !page.visibleToRoles.length) {
            page.visibleToRoles = ['all'];
        }
        page.visibleToRoles = page.visibleToRoles
            .map(function(role) { return String(role || '').trim().toLowerCase(); })
            .filter(function(role) { return role; });
        if (!page.visibleToRoles.length) page.visibleToRoles = ['all'];
        if (page.visibleToRoles.includes('all')) page.visibleToRoles = ['all'];
        return page.visibleToRoles;
    }

    function _isPageVisibleToCurrentUser(page) {
        if (_currentUserRole === 'admin') return true;
        var roles = _normalizePageRoles(page);
        if (roles.includes('all')) return true;
        return roles.includes(String(_currentUserRole || '').toLowerCase());
    }

    function _getVisiblePages() {
        if (!_schema || !_schema.pages) return [];
        return _schema.pages.filter(function(page) {
            return _isPageVisibleToCurrentUser(page);
        });
    }

    function _rolesLabel(roles) {
        if (!roles || !roles.length || roles.includes('all')) return 'All';
        return roles.map(function(r) { return r.charAt(0).toUpperCase() + r.slice(1); }).join(', ');
    }

    function _rolePickerPrompt(existingRoles) {
        var current = (existingRoles || ['all']).join(',');
        var raw = prompt('Visible to roles (comma-separated: all, admin, staff, client):', current);
        if (raw === null) return null;
        var roles = raw.split(',').map(function(v) { return v.trim().toLowerCase(); }).filter(Boolean);
        var allowed = { all: true, admin: true, staff: true, client: true };
        roles = roles.filter(function(r) { return allowed[r]; });
        if (!roles.length || roles.includes('all')) return ['all'];
        return Array.from(new Set(roles));
    }

    function _renderPageTabs() {
        var tabs = document.getElementById('iface-page-tabs');
        if (!tabs || !_schema) return;
        var html = '';
        var visiblePages = _getVisiblePages();
        visiblePages.forEach(function(page) {
            if (page.id === 'home') return; // Skip redundant home page tab
            var active = page.id === _activePage ? ' active' : '';
            html += '<span class="iface-page-tab-wrap">';
            html += '<button class="iface-page-tab' + active + '" data-page="' + _esc(page.id) +
                '" onclick="InterfaceApp.switchPage(\'' + _esc(page.id) + '\')">' +
                _esc(page.label) + '</button>';
            // Show permissions controls only in edit mode
            if (_editMode && _currentUserRole === 'admin') {
                var roles = _normalizePageRoles(page);
                var roleLabel = _rolesLabel(roles);
                html += '<button class="iface-page-access-btn is-admin" title="Edit page access" onclick="InterfaceApp.editPagePermissions(\'' + _esc(page.id) + '\')"></button>';
                html += '<span class="iface-page-access-pill" title="Visible to">' + _esc(roleLabel) + '</span>';
            }
            html += '</span>';
        });
        // Admin: add page button
        var adminClass = _currentUserRole === 'admin' ? ' is-admin' : '';
        html += '<button class="iface-add-page-btn' + adminClass + '" onclick="InterfaceApp.addPage()" title="Add page">+</button>';
        tabs.innerHTML = html;
    }

    function _renderQuickLinks(block) {
        var html = '<div class="iface-quick-links">';
        (block.items || []).forEach(function(item) {
            var onclick = '';
            if (item.page) onclick = 'InterfaceApp.switchPage(\'' + _esc(item.page) + '\')';
            else if (item.action === 'new-event') onclick = 'InterfaceApp._showToast(\'New event form coming soon\')';
            else if (item.action === 'new-note') onclick = 'CaseNotesAPI.openModal()';
            html += '<div class="iface-quick-link" onclick="' + onclick + '">' +
                '<div class="iface-quick-link-icon">' + (item.icon || '?') + '</div>' +
                '<span>' + _esc(item.label) + '</span></div>';
        });
        html += '</div>';
        return html;
    }

    function _renderCardList(block, records) {
        var display = block.display || {};
        var html = '<div class="iface-block" data-block-id="' + _esc(block.id) + '">';
        html += '<div class="iface-block-drag-handle">Drag</div>';
        html += '<div class="iface-block-header">';
        html += '<span class="iface-block-title">' + _esc(block.label || 'List') + '</span>';
        html += '<div style="display:flex;gap:8px;align-items:center;">';
        html += '<input type="text" class="iface-block-search" placeholder="Search..." value="' + _esc(_blockSearchState[block.id] || '') + '" data-search-block="' + _esc(block.id) + '" oninput="InterfaceApp.onBlockSearch(\'' + _esc(block.id) + '\', this.value)">';
        html += '<div class="iface-block-actions">';
        html += '<button class="iface-block-action-btn danger" onclick="InterfaceApp.removeBlock(\'' + _esc(block.id) + '\')">Remove</button>';
        html += '</div></div></div>';
        html += '<div class="iface-block-body"><div class="iface-card-list">';
        if (!records || !records.length) {
            html += '<div class="iface-empty">No records found</div>';
        } else {
            records.forEach(function(r) {
                var f = r.fields || {};
                var title = _findFieldValue(f, display.titleField) || r.recordId;
                var subtitle = _findFieldValue(f, display.subtitleField) || '';
                var meta = display.metaField ? _findFieldValue(f, display.metaField) : '';
                html += '<div class="iface-card" data-record-id="' + _esc(r.recordId) + '">';
                html += '<div class="iface-card-icon">' + (display.icon || '\uD83D\uDCCB') + '</div>';
                html += '<div class="iface-card-content">';
                html += '<div class="iface-card-title">' + _formatFieldValue(title) + '</div>';
                if (subtitle) html += '<div class="iface-card-subtitle">' + _formatFieldValue(subtitle) + '</div>';
                if (meta) html += '<div class="iface-card-meta">' + _formatFieldValue(meta) + '</div>';
                html += '</div></div>';
            });
        }
        html += '</div></div></div>';
        return html;
    }

    function _renderTimeline(block, records) {
        var display = block.display || {};
        var html = '<div class="iface-block" data-block-id="' + _esc(block.id) + '">';
        html += '<div class="iface-block-drag-handle">Drag</div>';
        html += '<div class="iface-block-header">';
        html += '<span class="iface-block-title">' + _esc(block.label || 'Timeline') + '</span>';
        html += '<div style="display:flex;gap:8px;align-items:center;">';
        html += '<input type="text" class="iface-block-search" placeholder="Search..." value="' + _esc(_blockSearchState[block.id] || '') + '" data-search-block="' + _esc(block.id) + '" oninput="InterfaceApp.onBlockSearch(\'' + _esc(block.id) + '\', this.value)">';
        html += '<div class="iface-block-actions">';
        html += '<button class="iface-block-action-btn danger" onclick="InterfaceApp.removeBlock(\'' + _esc(block.id) + '\')">Remove</button>';
        html += '</div></div></div>';
        html += '<div class="iface-block-body"><div class="iface-timeline">';
        if (!records || !records.length) {
            html += '<div class="iface-empty">No events scheduled</div>';
        } else {
            records.forEach(function(r) {
                var f = r.fields || {};
                var title = _findFieldValue(f, display.titleField) || 'Event';
                var timeVal = _findFieldValue(f, display.timeField);
                var timeStr = '';
                if (timeVal) {
                    try {
                        var d = new Date(timeVal);
                        if (!isNaN(d.getTime())) timeStr = d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                    } catch (e) { timeStr = String(timeVal); }
                }
                html += '<div class="iface-timeline-item">';
                html += '<div class="iface-timeline-time">' + _esc(timeStr || '--:--') + '</div>';
                html += '<div class="iface-timeline-content">';
                html += '<div class="iface-timeline-title">' + _formatFieldValue(title) + '</div>';
                if (display.detailFields) {
                    var details = display.detailFields.map(function(df) {
                        var v = _findFieldValue(f, df);
                        return v ? _esc(df) + ': ' + _formatFieldValue(v) : null;
                    }).filter(Boolean);
                    if (details.length) {
                        html += '<div class="iface-timeline-detail">' + details.join(' &middot; ') + '</div>';
                    }
                }
                html += '</div></div>';
            });
        }
        html += '</div></div></div>';
        return html;
    }

    // ============ Revamped Block Renderers ============

    function _getUserDisplayName() {
        var session = typeof _loadSynapseSession === 'function' ? _loadSynapseSession() : null;
        var userId = session ? session.userId : '';
        if (typeof _cachedUserProfile !== 'undefined' && _cachedUserProfile && _cachedUserProfile.displayName) {
            return _cachedUserProfile.displayName;
        }
        var name = userId ? userId.replace(/@([^:]+):.*/, '$1') : 'User';
        return name.charAt(0).toUpperCase() + name.slice(1);
    }

    function _getUserInitials() {
        var name = _getUserDisplayName();
        var parts = name.split(/\s+/);
        if (parts.length >= 2) return (parts[0][0] + parts[1][0]).toUpperCase();
        return name.substring(0, 2).toUpperCase();
    }

    function _getTimeGreeting() {
        var h = new Date().getHours();
        if (h < 12) return 'Good morning';
        if (h < 17) return 'Good afternoon';
        return 'Good evening';
    }

    function _renderWelcomeGreeting(block) {
        var name = _getUserDisplayName();
        var tableCount = Object.keys(typeof META_TABLES !== 'undefined' ? META_TABLES : {}).length;
        var subtitle = (block.display && block.display.subtitle) || '';
        subtitle = subtitle.replace('{tableCount}', tableCount);
        if (!subtitle) subtitle = tableCount + ' tables synced';

        var html = '<div class="iface-welcome-greeting">';
        html += '<h1>' + _getTimeGreeting() + ', <span>' + _esc(name) + '</span></h1>';
        html += '<p>' + _esc(subtitle) + '</p>';
        html += '</div>';
        return html;
    }

    function _renderActionCards(block) {
        var items = block.items || [];
        var icons = {
            database: '<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>',
            interface: '<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/></svg>',
            settings: '<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>'
        };
        var html = '<div class="iface-action-cards">';
        items.forEach(function(item) {
            var onclick = '';
            if (item.action && item.action.indexOf('switchApp:') === 0) {
                onclick = 'switchApp(\'' + _esc(item.action.split(':')[1]) + '\')';
            } else if (item.action && item.action.indexOf('page:') === 0) {
                onclick = 'InterfaceApp.switchPage(\'' + _esc(item.action.split(':')[1]) + '\')';
            }
            html += '<div class="iface-action-card" onclick="' + onclick + '">';
            html += '<div class="acard-icon ' + _esc(item.color || 'blue') + '">' + (icons[item.icon] || '') + '</div>';
            html += '<h3>' + _esc(item.label) + '</h3>';
            html += '<p>' + _esc(item.desc) + '</p>';
            html += '<span class="acard-arrow">Open \u2192</span>';
            html += '</div>';
        });
        html += '</div>';
        return html;
    }

    function _renderStatsRow() {
        var tableCount = Object.keys(typeof META_TABLES !== 'undefined' ? META_TABLES : {}).length;
        var roomCount = 'N/A';
        var userCount = '--';
        try {
            if (typeof _settingsMembers !== 'undefined' && _settingsMembers && _settingsMembers.length > 0) {
                userCount = _settingsMembers.length;
            }
        } catch (e) {}

        var html = '<div class="iface-stats-row">';
        html += '<div class="iface-stat-cell" onclick="switchApp(\'database\')"><div class="stat-num">' + tableCount + '</div><div class="stat-label">Tables</div></div>';
        html += '<div class="iface-stat-cell"><div class="stat-num">' + roomCount + '</div><div class="stat-label">Rooms</div></div>';
        html += '<div class="iface-stat-cell"><div class="stat-num">' + userCount + '</div><div class="stat-label">Users</div></div>';
        html += '<div class="iface-stat-cell"><div class="stat-num green">99.9%</div><div class="stat-label">Uptime</div></div>';
        html += '</div>';
        return html;
    }

    function _getInitials(name) {
        if (!name) return '??';
        var parts = String(name).trim().split(/\s+/);
        if (parts.length >= 2) return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
        return name.substring(0, 2).toUpperCase();
    }

    function _formatRelativeTime(dateVal) {
        if (!dateVal) return '';
        var d;
        try { d = new Date(dateVal); } catch (e) { return ''; }
        if (isNaN(d.getTime())) return '';
        var now = new Date();
        var diffMs = d.getTime() - now.getTime();
        var diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));
        var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        var eventDay = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        if (eventDay.getTime() === today.getTime()) return 'today';
        if (diffDays === 1) return 'tomorrow';
        if (diffDays > 1 && diffDays <= 30) return 'in ' + diffDays + ' days';
        if (diffDays > 30) {
            var months = Math.round(diffDays / 30);
            return 'in ' + months + ' month' + (months > 1 ? 's' : '');
        }
        if (diffDays < 0) return Math.abs(diffDays) + ' days ago';
        return '';
    }

    function _formatStatusBadge(status) {
        if (!status) return '';
        var s = String(status).toLowerCase();
        if (s.includes('active') || s.includes('open')) return '<span class="iface-badge iface-badge-green">Active</span>';
        if (s.includes('pending') || s.includes('review')) return '<span class="iface-badge iface-badge-amber">Pending</span>';
        if (s.includes('closed') || s.includes('complete')) return '<span class="iface-badge iface-badge-gray">Closed</span>';
        if (s.includes('overdue') || s.includes('miss')) return '<span class="iface-badge iface-badge-red">Overdue</span>';
        return '<span class="iface-badge iface-badge-outline">' + _esc(status) + '</span>';
    }

    function _renderRecentList(block, records) {
        var display = block.display || {};
        var html = '<div class="iface-recent-section">';
        html += '<h2>' + _esc(block.label || 'Recent');
        if (block.countLabel) html += ' <span class="count">' + _esc(block.countLabel) + '</span>';
        html += '</h2>';
        html += '<div class="iface-recent-list">';

        if (!records || !records.length) {
            html += '<div class="iface-recent-item"><div class="iface-recent-item-left"><div class="iface-ri-info"><p>No records found</p></div></div></div>';
        } else {
            records.forEach(function(r) {
                var f = r.fields || {};
                var title = _findFieldValue(f, display.titleField) || '';
                var initials = _getInitials(Array.isArray(title) ? title[0] : title);
                var subtitle = '';
                if (display.subtitleField) {
                    subtitle = _findFieldValue(f, display.subtitleField) || '';
                } else if (display.subtitleFields) {
                    var parts = display.subtitleFields.map(function(sf) {
                        var v = _findFieldValue(f, sf);
                        return v ? String(Array.isArray(v) ? v.join(', ') : v) : '';
                    }).filter(Boolean);
                    subtitle = parts.join(' \u00B7 ');
                }
                if (display.detailFields) {
                    var details = display.detailFields.map(function(df) {
                        var v = _findFieldValue(f, df);
                        return v ? String(Array.isArray(v) ? v.join(', ') : v) : '';
                    }).filter(Boolean);
                    if (details.length && subtitle) subtitle += ' \u00B7 ' + details.join(' \u00B7 ');
                    else if (details.length) subtitle = details.join(' \u00B7 ');
                }

                html += '<div class="iface-recent-item">';
                html += '<div class="iface-recent-item-left">';
                html += '<div class="iface-ri-avatar">' + _esc(initials) + '</div>';
                html += '<div class="iface-ri-info">';
                html += '<h4>' + _formatFieldValue(Array.isArray(title) ? title[0] : title) + '</h4>';
                if (subtitle) html += '<p>' + _esc(String(subtitle).substring(0, 80)) + '</p>';
                html += '</div></div>';
                html += '<div class="iface-recent-item-right">';

                // Show status badge or time badge
                if (display.statusField) {
                    var statusVal = _findFieldValue(f, display.statusField);
                    if (statusVal) html += _formatStatusBadge(Array.isArray(statusVal) ? statusVal[0] : statusVal);
                }
                if (display.timeField) {
                    var timeVal = _findFieldValue(f, display.timeField);
                    if (timeVal) {
                        try {
                            var td = new Date(timeVal);
                            if (!isNaN(td.getTime())) {
                                html += '<span class="iface-badge iface-badge-amber">' +
                                    td.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) + '</span>';
                            }
                        } catch (e) {}
                    }
                }
                html += '</div></div>';
            });
        }
        html += '</div></div>';
        return html;
    }

    function _renderActivityLog() {
        var html = '<div class="iface-activity-log">';
        html += '<h2>Recent Activity</h2>';

        // Pull activity items from data layer events if available
        var items = [];
        try {
            if (typeof _activityLog !== 'undefined' && _activityLog && _activityLog.length) {
                items = _activityLog.slice(0, 5);
            }
        } catch (e) {}

        if (!items.length) {
            // Default activity items
            var name = _getUserDisplayName();
            var tableCount = Object.keys(typeof META_TABLES !== 'undefined' ? META_TABLES : {}).length;
            items = [
                { dot: 'green', text: '<strong>' + _esc(name) + '</strong> signed in', time: 'just now' },
                { dot: 'green', text: '<strong>' + _esc(name) + '</strong> synced ' + tableCount + ' tables', time: 'just now' },
                { dot: 'blue', text: 'System health check passed', time: '3 min ago' }
            ];
        }

        items.forEach(function(item) {
            html += '<div class="iface-log-item">';
            html += '<span class="iface-log-dot ' + (item.dot || 'blue') + '"></span>';
            html += '<span>' + (item.text || '') + '</span>';
            html += '<span class="iface-log-time">' + _esc(item.time || '') + '</span>';
            html += '</div>';
        });

        html += '</div>';
        return html;
    }

    // ============ Linked Record Resolution ============

    // Resolve a single record ID to its display name by searching all cached
    // table data (current-state DB).  Falls back to the global
    // getDisplayNameFieldId/META helpers when available.
    var _recordLabelCache = {};

    function _resolveRecordIdToLabel(recordId) {
        if (!recordId) return null;
        if (_recordLabelCache[recordId]) return _recordLabelCache[recordId];

        // Search IN_MEMORY_DATA first (fastest, covers all tables)
        if (window.IN_MEMORY_DATA) {
            var tables = Object.keys(window.IN_MEMORY_DATA);
            for (var t = 0; t < tables.length; t++) {
                var tableId = tables[t];
                var tableData = window.IN_MEMORY_DATA[tableId];
                if (!tableData || !tableData[recordId]) continue;

                var fields = tableData[recordId];
                var label = _pickDisplayLabel(tableId, recordId, fields);
                if (label) {
                    _recordLabelCache[recordId] = label;
                    return label;
                }
            }
        }

        // Fallback: search the Interface data cache
        var cachedTables = Object.keys(_tableDataCache);
        for (var c = 0; c < cachedTables.length; c++) {
            var cached = _tableDataCache[cachedTables[c]];
            if (!cached || !cached.records) continue;
            for (var r = 0; r < cached.records.length; r++) {
                var rec = cached.records[r];
                if (rec.recordId === recordId) {
                    var lbl = _pickDisplayLabel(cachedTables[c], recordId, rec.fields);
                    if (lbl) {
                        _recordLabelCache[recordId] = lbl;
                        return lbl;
                    }
                }
            }
        }

        return null;
    }

    function _pickDisplayLabel(tableId, recordId, fields) {
        if (!fields || typeof fields !== 'object') return null;

        // 1. Use the designated displayNameFieldId if set
        if (typeof getDisplayNameFieldId === 'function') {
            var dnfId = getDisplayNameFieldId(tableId);
            if (dnfId) {
                var val = fields[dnfId];
                if (!val && typeof META_FIELDS !== 'undefined' && META_FIELDS[tableId] && META_FIELDS[tableId][dnfId]) {
                    val = fields[META_FIELDS[tableId][dnfId].fieldName];
                }
                if (val != null && val !== '') return String(val);
            }
        }

        // 2. Heuristic: common display-name field names
        var candidates = ['Full Name Client', 'Client Name', 'Display Name', 'Name', 'Title', 'Event Title',
                          'Matter', 'Case Note', 'Activity', 'Subject', 'Label',
                          'display name', 'name', 'title', 'label'];
        for (var i = 0; i < candidates.length; i++) {
            var v = fields[candidates[i]];
            if (v != null && v !== '' && typeof v !== 'object') return String(v);
        }

        // 3. First non-ID string field
        var keys = Object.keys(fields);
        for (var k = 0; k < keys.length; k++) {
            var fv = fields[keys[k]];
            if (typeof fv === 'string' && fv.length > 0 && fv.length < 120 && !/^(rec|fld|tbl|viw)[A-Za-z0-9]{8,}$/.test(fv)) {
                return fv;
            }
        }

        return null;
    }

    // ============ Revamped Data Table Renderer ============

    function _formatFieldValueRevamped(val, colField, fieldType) {
        // For computed field types (formula, rollup, lookup, etc.), delegate
        // to the same formatCell() used by the DB screen so rendering is
        // identical between the two views.
        if (fieldType && typeof isComputedFieldType === 'function' && isComputedFieldType(fieldType)) {
            return (typeof formatCell === 'function') ? formatCell(val, fieldType) : _esc(String(val != null ? val : ''));
        }
        if (val == null || val === '') return '<span class="cell-empty">\u2013</span>';
        if (Array.isArray(val)) {
            var resolved = val.map(function(v) {
                if (typeof v === 'string' && /^rec[A-Za-z0-9]{10,}$/.test(v)) {
                    var label = _resolveRecordIdToLabel(v);
                    return label || null;
                }
                if (typeof v === 'object' && v !== null) {
                    return v.name || v.label || v.filename || v.email || v.id || null;
                }
                return v;
            }).filter(function(v) { return v != null; });
            if (!resolved.length) return '<span class="cell-empty">\u2013</span>';
            return '<span class="cell-array">' + resolved.map(function(item) {
                return '<span class="tag">' + _esc(String(item)) + '</span>';
            }).join('') + '</span>';
        }
        if (typeof val === 'object') {
            if (val.label) return _esc(val.label);
            if (val.name) return _esc(val.name);
            if (val.filename) return _esc(val.filename);
            if (val.email) return _esc(val.email);
            return _esc(JSON.stringify(val));
        }
        // Resolve single record IDs to display name
        if (typeof val === 'string' && /^rec[A-Za-z0-9]{10,}$/.test(val)) {
            var resolved = _resolveRecordIdToLabel(val);
            if (resolved) return _esc(resolved);
            return '<span class="cell-empty">\u2013</span>';
        }
        // Format dates
        if (typeof val === 'string' && /^\d{4}-\d{2}-\d{2}/.test(val)) {
            try {
                var d = new Date(val);
                if (!isNaN(d.getTime())) {
                    var formatted = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    if (val.includes('T')) {
                        formatted += ' \u00B7 ' + d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                    }
                    var relative = _formatRelativeTime(val);
                    if (relative) {
                        return '<div class="date-primary">' + _esc(formatted) + '</div>' +
                               '<div class="date-relative">' + _esc(relative) + '</div>';
                    }
                    return _esc(formatted);
                }
            } catch (e) {}
        }
        return _esc(String(val));
    }

    function _formatFileStatus(val) {
        if (!val) return '<span class="cell-empty">\u2013</span>';
        var s = String(Array.isArray(val) ? val[0] || '' : val).toLowerCase();
        var dotClass = 'slate';
        var label = Array.isArray(val) ? val[0] || '' : String(val);
        if (s.includes('active') || s.includes('open')) dotClass = 'green';
        else if (s.includes('pending') || s.includes('review')) dotClass = 'amber';
        else if (s.includes('overdue') || s.includes('miss')) dotClass = 'red';
        else if (s.includes('closed') || s.includes('complete') || s.includes('denied')) dotClass = 'slate';
        return '<span class="status-dot ' + dotClass + '"></span>' + _esc(label);
    }

    function _renderTableSettingsPanel(block, columns, tableId) {
        var html = '<div class="iface-table-settings-panel">';
        html += '<h4>Table Settings</h4>';

        // Sort settings
        html += '<div class="iface-table-settings-section">';
        html += '<label>Default Sort</label>';
        html += '<div class="iface-settings-row">';
        var curSort = (block.segment && block.segment.sort) || {};
        html += '<select id="iface-sort-field-' + _esc(block.id) + '">';
        columns.forEach(function(col) {
            var sel = (curSort.field === col.field) ? ' selected' : '';
            html += '<option value="' + _esc(col.field) + '"' + sel + '>' + _esc(col.label || col.field) + '</option>';
        });
        html += '</select>';
        html += '<select id="iface-sort-dir-' + _esc(block.id) + '">';
        html += '<option value="desc"' + (curSort.dir === 'desc' ? ' selected' : '') + '>Newest first</option>';
        html += '<option value="asc"' + (curSort.dir === 'asc' ? ' selected' : '') + '>Oldest first</option>';
        html += '</select>';
        html += '</div></div>';

        // Page size
        html += '<div class="iface-table-settings-section">';
        html += '<label>Rows per page</label>';
        html += '<div class="iface-settings-row">';
        var curPageSize = (block.segment && block.segment.pageSize) || 50;
        html += '<select id="iface-pagesize-' + _esc(block.id) + '">';
        [25, 50, 100, 200].forEach(function(sz) {
            html += '<option value="' + sz + '"' + (curPageSize === sz ? ' selected' : '') + '>' + sz + '</option>';
        });
        html += '</select>';
        html += '</div></div>';

        // Column ordering
        html += '<div class="iface-table-settings-section">';
        html += '<label>Columns (drag to reorder)</label>';
        html += '<ul class="iface-col-list">';
        columns.forEach(function(col, idx) {
            html += '<li data-col-idx="' + idx + '">';
            html += '<span>' + _esc(col.label || col.field) + '</span>';
            html += '<div class="col-move-btns">';
            if (idx > 0) {
                html += '<button class="col-move-btn" onclick="InterfaceApp.moveColumn(\'' + _esc(block.id) + '\', ' + idx + ', -1)" title="Move up">\u2191</button>';
            }
            if (idx < columns.length - 1) {
                html += '<button class="col-move-btn" onclick="InterfaceApp.moveColumn(\'' + _esc(block.id) + '\', ' + idx + ', 1)" title="Move down">\u2193</button>';
            }
            html += '</div>';
            html += '<button class="iface-col-remove-btn" onclick="InterfaceApp.removeColumn(\'' + _esc(block.id) + '\', ' + idx + ')" title="Remove column">\u2715</button>';
            html += '</li>';
        });
        html += '</ul>';

        // Add column
        var allFields = _getAvailableFields(tableId, columns);
        if (allFields.length) {
            html += '<div class="iface-add-col-row">';
            html += '<select id="iface-add-col-' + _esc(block.id) + '">';
            html += '<option value="">Add a column...</option>';
            allFields.forEach(function(f) {
                html += '<option value="' + _esc(f.id || f.name) + '">' + _esc(f.name) + '</option>';
            });
            html += '</select>';
            html += '<button class="iface-add-col-btn" onclick="InterfaceApp.addColumn(\'' + _esc(block.id) + '\')">Add</button>';
            html += '</div>';
        }

        html += '</div>';

        // Save button
        html += '<div style="text-align:right;margin-top:8px;">';
        html += '<button class="iface-settings-save-btn" onclick="InterfaceApp.saveTableSettings(\'' + _esc(block.id) + '\')">Save Settings</button>';
        html += '</div>';

        html += '</div>';
        return html;
    }

    function _getAvailableFields(tableId, currentColumns) {
        if (!tableId || typeof META_FIELDS === 'undefined' || !META_FIELDS[tableId]) return [];
        var existing = {};
        (currentColumns || []).forEach(function(col) {
            existing[(col.field || '').toLowerCase()] = true;
        });
        var fields = META_FIELDS[tableId];
        var available = [];
        Object.keys(fields).forEach(function(fid) {
            var meta = fields[fid];
            var name = meta.fieldName || fid;
            if (!existing[name.toLowerCase()] && !existing[fid.toLowerCase()]) {
                available.push({ id: fid, name: name });
            }
        });
        available.sort(function(a, b) { return a.name.localeCompare(b.name); });
        return available;
    }

    function _renderDataTableRevamped(block, records, pageState, allRecords, tableId) {
        var columns = _getMirroredColumnsFromView(tableId, block) || block.columns || [];
        var filters = block.filters || [];
        var ps = pageState || { page: 0, pageSize: block.segment && block.segment.pageSize || 50 };

        // Build field-name-to-fieldType lookup so cell formatters can
        // delegate to formatCell() for computed/formula fields, matching
        // the DB screen rendering exactly.
        var _fieldTypeByName = {};
        var _tblMeta = (typeof META_FIELDS !== 'undefined' && META_FIELDS && META_FIELDS[tableId]) ? META_FIELDS[tableId] : {};
        Object.keys(_tblMeta).forEach(function(fid) {
            var m = _tblMeta[fid];
            if (m) {
                if (m.fieldName) _fieldTypeByName[m.fieldName] = m.fieldType;
                _fieldTypeByName[fid] = m.fieldType;
            }
        });
        var total = records.length;
        var start = ps.page * ps.pageSize;
        var pageRecords = records.slice(start, start + ps.pageSize);

        var html = '<div class="iface-page-content full-width">';

        // Breadcrumb
        html += '<div class="iface-breadcrumb">';
        html += '<a onclick="switchApp(\'home\')">Home</a>';
        html += '<span class="sep">\u203A</span>';
        html += '<span>' + _esc(block.label || 'Table') + '</span>';
        html += '</div>';

        // Header with title and actions
        html += '<div class="iface-clients-header">';
        var allCount = Array.isArray(allRecords) ? allRecords.length : total;
        var countLabel = total === allCount ? (total + ' records') : (total + ' of ' + allCount + ' records');
        html += '<h2>' + _esc(block.label || 'Table') + ' <span class="muted">\u00B7 ' + countLabel + '</span></h2>';
        html += '<div class="iface-clients-header-actions">';
        html += '<input type="text" class="iface-block-search" placeholder="Search..." style="width:200px;margin-right:4px;" value="' + _esc(_blockSearchState[block.id] || '') + '" data-search-block="' + _esc(block.id) + '" oninput="InterfaceApp.onBlockSearch(\'' + _esc(block.id) + '\', this.value)">';
        if (_currentUserRole === 'admin') {
            html += '<button class="iface-table-settings-btn" onclick="InterfaceApp.toggleTableSettings(\'' + _esc(block.id) + '\')">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12.22 2h-.44a2 2 0 00-2 2v.18a2 2 0 01-1 1.73l-.43.25a2 2 0 01-2 0l-.15-.08a2 2 0 00-2.73.73l-.22.38a2 2 0 00.73 2.73l.15.1a2 2 0 011 1.72v.51a2 2 0 01-1 1.74l-.15.09a2 2 0 00-.73 2.73l.22.38a2 2 0 002.73.73l.15-.08a2 2 0 012 0l.43.25a2 2 0 011 1.73V20a2 2 0 002 2h.44a2 2 0 002-2v-.18a2 2 0 011-1.73l.43-.25a2 2 0 012 0l.15.08a2 2 0 002.73-.73l.22-.39a2 2 0 00-.73-2.73l-.15-.08a2 2 0 01-1-1.74v-.5a2 2 0 011-1.74l.15-.09a2 2 0 00.73-2.73l-.22-.38a2 2 0 00-2.73-.73l-.15.08a2 2 0 01-2 0l-.43-.25a2 2 0 01-1-1.73V4a2 2 0 00-2-2z"/><circle cx="12" cy="12" r="3"/></svg>';
            html += ' Settings</button>';
        }
        html += '<button class="iface-btn-secondary">';
        html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
        html += ' Export</button>';
        html += '</div></div>';

        // Admin table settings panel (toggle visibility)
        if (_currentUserRole === 'admin' && _tableSettingsOpen[block.id]) {
            html += _renderTableSettingsPanel(block, columns, tableId);
        }

        // Filter pills
        if (filters.length) {
            html += '<div class="iface-filter-bar">';
            filters.forEach(function(flt) {
                var activeVal = (block._activeFilters && block._activeFilters[flt.id]) ? block._activeFilters[flt.id].value : '';
                var isActive = !!activeVal;
                html += '<span class="iface-filter-pill' + (isActive ? ' active' : '') + '" onclick="InterfaceApp._showFilterDropdown(\'' + _esc(block.id) + '\', \'' + _esc(flt.id) + '\', this)">';
                html += '<span class="pill-label">' + _esc(flt.label) + '</span>';
                html += '<span class="pill-value">' + _esc(isActive ? activeVal : 'All') + '</span>';
                if (isActive) {
                    html += ' <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" onclick="event.stopPropagation();InterfaceApp.onFilterChange(\'' + _esc(block.id) + '\', \'' + _esc(flt.id) + '\', \'\')"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
                } else {
                    html += ' <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>';
                }
                html += '</span>';

                // Hidden select for filter value picking
                html += '<select class="iface-filter-dropdown" data-filter-id="' + _esc(flt.id) + '" style="display:none;position:absolute;" onchange="InterfaceApp.onFilterChange(\'' + _esc(block.id) + '\', \'' + _esc(flt.id) + '\', this.value);this.style.display=\'none\';">';
                html += '<option value="">All ' + _esc(flt.label) + '</option>';
                var vals = {};
                (allRecords || records).forEach(function(r) {
                    var v = _findFieldValue(r.fields || {}, flt.field);
                    if (v != null && v !== '') {
                        var sv = Array.isArray(v) ? v.join(', ') : String(v);
                        vals[sv] = true;
                    }
                });
                Object.keys(vals).sort().forEach(function(v) {
                    var sel = (v === activeVal) ? ' selected' : '';
                    html += '<option value="' + _esc(v) + '"' + sel + '>' + _esc(v) + '</option>';
                });
                html += '</select>';
            });

            // Clear filters button
            var hasActiveFilters = filters.some(function(flt) {
                return block._activeFilters && block._activeFilters[flt.id];
            });
            if (hasActiveFilters) {
                html += '<button class="iface-filter-clear" onclick="InterfaceApp._clearAllFilters(\'' + _esc(block.id) + '\')">Clear filters</button>';
            }
            html += '</div>';
        }

        // Table wrapper
        html += '<div style="background:var(--bg-secondary);border:1px solid var(--border-primary);border-radius:var(--radius-xl);overflow:hidden;">';
        html += '<div class="iface-table-wrapper"><table class="iface-table-revamp">';
        // Temporarily hidden until the relationship graph experience is improved.
        var includeRelationshipAction = false;
        html += '<thead><tr>';
        columns.forEach(function(col) {
            var sortIndicator = '';
            if (block.segment && block.segment.sort && block.segment.sort.field === col.field) {
                sortIndicator = block.segment.sort.dir === 'asc' ? ' \u2191' : ' \u2193';
            }
            var colId = (col.label || col.field).toLowerCase().replace(/[^a-z0-9]+/g, '-');
            var w = col.width ? ' style="min-width:' + col.width + 'px;max-width:' + (col.width + 80) + 'px"' : '';
            html += '<th' + w + ' data-col="' + _esc(colId) + '" onclick="InterfaceApp.onColumnSort(\'' + _esc(block.id) + '\', \'' + _esc(col.field) + '\')">' + _esc(col.label || col.field) + sortIndicator + '</th>';
        });
        if (includeRelationshipAction) {
            html += '<th style="width:180px;">Client Relationship Graph</th>';
        }
        html += '</tr></thead><tbody>';

        if (!pageRecords.length) {
            var emptyColspan = columns.length + (includeRelationshipAction ? 1 : 0);
            html += '<tr><td colspan="' + emptyColspan + '" style="text-align:center;color:var(--text-muted);padding:40px;">No records found</td></tr>';
        } else {
            pageRecords.forEach(function(r) {
                var isClientTable = block.id === 'clients-table';
                var rowClick = isClientTable
                    ? ' onclick="InterfaceApp.openClientProfilePage(\'' + _esc(r.recordId) + '\', event)" style="cursor:pointer;"'
                    : '';
                html += '<tr data-record-id="' + _esc(r.recordId) + '"' + rowClick + '>';
                columns.forEach(function(col) {
                    var val = _findFieldValue(r.fields || {}, col.field);
                    var label = (col.label || col.field || '').toLowerCase();
                    var colId = (col.label || col.field).toLowerCase().replace(/[^a-z0-9]+/g, '-');
                    var colFieldType = _fieldTypeByName[col.field] || null;
                    // Special formatting based on column type
                    if (label.includes('client name') || label === 'name') {
                        html += '<td data-col="' + _esc(colId) + '"><span class="client-name">' + _formatFieldValueRevamped(val, col.field, colFieldType) + '</span></td>';
                    } else if (label.includes('file status') || label.includes('status')) {
                        html += '<td data-col="' + _esc(colId) + '">' + _formatFileStatus(val) + '</td>';
                    } else {
                        html += '<td data-col="' + _esc(colId) + '">' + _formatFieldValueRevamped(val, col.field, colFieldType) + '</td>';
                    }
                });
                if (includeRelationshipAction) {
                    html += '<td><button class="iface-page-btn" onclick="InterfaceApp.openClientRelationshipGraph(\'' + _esc(r.recordId) + '\')">View graph</button></td>';
                }
                html += '</tr>';
            });
        }
        html += '</tbody></table></div>';

        // Pagination
        var totalPages = Math.ceil(total / ps.pageSize);
        if (totalPages > 1) {
            html += '<div class="iface-pagination">';
            html += '<span>Showing ' + (start + 1) + '\u2013' + Math.min(start + ps.pageSize, total) + ' of ' + total + '</span>';
            html += '<div class="iface-pagination-btns">';
            html += '<button class="iface-page-btn" onclick="InterfaceApp.onPageChange(\'' + _esc(block.id) + '\', ' + (ps.page - 1) + ')"' + (ps.page <= 0 ? ' disabled' : '') + '>\u00AB Prev</button>';
            html += '<button class="iface-page-btn" onclick="InterfaceApp.onPageChange(\'' + _esc(block.id) + '\', ' + (ps.page + 1) + ')"' + (ps.page >= totalPages - 1 ? ' disabled' : '') + '>Next \u00BB</button>';
            html += '</div></div>';
        }

        html += '</div></div>';
        return html;
    }

    // ============ Events Agenda Renderer ============

    function _groupEventsByDay(records, timeField) {
        var groups = {};
        var today = new Date();
        today.setHours(0, 0, 0, 0);

        records.forEach(function(r) {
            var val = _findFieldValue(r.fields || {}, timeField);
            if (!val) return;
            var d;
            try { d = new Date(val); } catch (e) { return; }
            if (isNaN(d.getTime())) return;
            var dayKey = d.toISOString().split('T')[0];
            if (!groups[dayKey]) groups[dayKey] = { date: new Date(d.getFullYear(), d.getMonth(), d.getDate()), events: [] };
            groups[dayKey].events.push(r);
        });

        return Object.keys(groups).sort().map(function(key) {
            var g = groups[key];
            g.isToday = g.date.getTime() === today.getTime();
            return g;
        });
    }

    function _getAgendaBarColor(index) {
        var colors = ['blue', 'green', 'amber', 'red'];
        return colors[index % colors.length];
    }

    function _renderEventsAgenda(block, records) {
        var display = block.display || {};
        var timeField = display.timeField || 'Hearing Date/Time';
        var calConfig = block.calendarConfig || {};

        // Build attorney list from records for sidebar
        var attorneySet = {};
        var attorneyFields = display.attorneyFields || ['ICH Attny', 'MCH Attny'];
        records.forEach(function(r) {
            var f = r.fields || {};
            attorneyFields.forEach(function(af) {
                var v = _findFieldValue(f, af);
                if (v) {
                    var names = Array.isArray(v) ? v : [v];
                    names.forEach(function(n) {
                        if (n && typeof n === 'string' && !/^rec[A-Za-z0-9]{10,}$/.test(n)) {
                            attorneySet[n] = true;
                        }
                    });
                }
            });
        });
        var attorneys = Object.keys(attorneySet).sort();

        // Group events by day
        var dayGroups = _groupEventsByDay(records, timeField);
        var todayStr = new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }).toUpperCase();

        var html = '<div class="iface-page-content full-width">';

        // Breadcrumb
        html += '<div class="iface-breadcrumb">';
        html += '<a onclick="switchApp(\'home\')">Home</a>';
        html += '<span class="sep">\u203A</span>';
        html += '<span>Events</span>';
        html += '</div>';

        html += '<div class="iface-events-layout">';

        //  Sidebar 
        html += '<div class="iface-events-sidebar">';
        html += '<input type="text" class="iface-events-sidebar-search" placeholder="Search attorneys..." oninput="InterfaceApp._filterEventsSidebar(this.value)">';

        // Active attorneys
        html += '<div class="iface-sidebar-group-title">Attorneys <span style="font-weight:500;color:var(--text-muted)">' + attorneys.length + '</span></div>';
        attorneys.forEach(function(name) {
            html += '<div class="iface-attorney-row active" data-attorney="' + _esc(name) + '" onclick="InterfaceApp._toggleAttorneyFilter(this)">';
            html += '<div class="iface-attorney-check checked"></div>';
            html += '<span class="iface-attorney-name-side">' + _esc(name) + '</span>';
            html += '</div>';
        });

        // Google Calendar link
        html += '<div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border-primary);">';
        html += '<button class="iface-btn-secondary" style="width:100%;justify-content:center;" onclick="InterfaceApp._showGoogleCalendar()">Open Google Calendar</button>';
        html += '</div>';

        html += '</div>';

        //  Main area 
        html += '<div class="iface-events-main">';

        // Calendar header
        var dateDisplay = new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
        html += '<div class="iface-cal-header">';
        html += '<div class="iface-cal-header-left">';
        html += '<button class="iface-cal-nav-btn">\u2039</button>';
        html += '<span class="iface-cal-month">' + _esc(dateDisplay) + '</span>';
        html += '<button class="iface-cal-nav-btn">\u203A</button>';
        html += '<button class="iface-cal-nav-btn" style="font-size:11px;width:auto;padding:0 10px;font-weight:500;">Today</button>';
        html += '</div>';
        html += '<div class="iface-cal-header-right">';
        html += '<button class="iface-view-btn active">Agenda</button>';
        html += '<button class="iface-view-btn" onclick="InterfaceApp._showGoogleCalendar()">Calendar</button>';
        html += '</div></div>';

        // Event type filters
        html += '<div class="iface-cal-filters">';
        html += '<button class="iface-cal-filter-btn active">All Events</button>';
        html += '<button class="iface-cal-filter-btn">Hearings</button>';
        html += '<button class="iface-cal-filter-btn">Interviews</button>';
        html += '<button class="iface-cal-filter-btn">Client Appts</button>';
        html += '<button class="iface-cal-filter-btn">Deadlines</button>';
        html += '</div>';

        // Agenda list
        html += '<div class="iface-agenda-list">';

        if (!dayGroups.length) {
            html += '<div style="padding:40px 20px;text-align:center;color:var(--text-muted);font-size:13px;">No upcoming events found</div>';
        } else {
            dayGroups.forEach(function(group) {
                var dayLabel = group.date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }).toUpperCase();
                html += '<div class="iface-agenda-day' + (group.isToday ? ' today' : '') + '">';
                html += (group.isToday ? 'TODAY \u2014 ' : '') + dayLabel;
                html += '</div>';

                group.events.forEach(function(r, idx) {
                    var f = r.fields || {};
                    var title = _findFieldValue(f, display.titleField) || 'Event';
                    var clientName = _findFieldValue(f, display.clientField || 'Full Name Client') || _findFieldValue(f, 'Client Name') || '';
                    var timeVal = _findFieldValue(f, timeField);
                    var timeStr = '';
                    if (timeVal) {
                        try {
                            var td = new Date(timeVal);
                            if (!isNaN(td.getTime())) timeStr = td.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                        } catch (e) {}
                    }
                    var barColor = _getAgendaBarColor(idx);

                    // Build detail text
                    var detailParts = [];
                    (display.detailFields || []).forEach(function(df) {
                        var v = _findFieldValue(f, df);
                        if (v && !/^rec[A-Za-z0-9]{10,}$/.test(String(v))) {
                            detailParts.push(Array.isArray(v) ? v.join(', ') : String(v));
                        }
                    });
                    var detailText = detailParts.join(' \u00B7 ');

                    // Build attorney badges
                    var attyBadges = [];
                    attorneyFields.forEach(function(af) {
                        var v = _findFieldValue(f, af);
                        if (v) {
                            var names = Array.isArray(v) ? v : [v];
                            names.forEach(function(n) {
                                if (n && !/^rec[A-Za-z0-9]{10,}$/.test(String(n))) {
                                    attyBadges.push(n);
                                }
                            });
                        }
                    });

                    html += '<div class="iface-agenda-item">';
                    html += '<span class="iface-agenda-time">' + _esc(timeStr || '--:--') + '</span>';
                    html += '<div class="iface-agenda-bar ' + barColor + '"></div>';
                    html += '<div class="iface-agenda-content">';
                    var displayTitle = (clientName ? (Array.isArray(clientName) ? clientName[0] : clientName) + ' \u2014 ' : '') +
                        (Array.isArray(title) ? title[0] : title);
                    html += '<h4>' + _esc(displayTitle) + '</h4>';
                    if (detailText) html += '<p>' + _esc(detailText) + '</p>';
                    if (attyBadges.length) {
                        html += '<div class="agenda-tags">';
                        attyBadges.forEach(function(n) {
                            html += '<span class="iface-badge iface-badge-blue">' + _esc(n) + '</span>';
                        });
                        html += '</div>';
                    }
                    html += '</div></div>';
                });
            });
        }

        html += '</div></div></div></div>';
        return html;
    }

    // Helper: show filter dropdown on pill click
    function _showFilterDropdown(blockId, filterId, pillEl) {
        var sel = pillEl.parentElement.querySelector('select[data-filter-id="' + filterId + '"]');
        if (sel) {
            sel.style.display = sel.style.display === 'none' ? 'block' : 'none';
            sel.focus();
            sel.size = Math.min(Object.keys(sel.options).length, 10);
        }
    }

    function _clearAllFilters(blockId) {
        if (!_schema || !_activePage) return;
        var page = _schema.pages.find(function(p) { return p.id === _activePage; });
        if (!page) return;
        var block = page.blocks.find(function(b) { return b.id === blockId; });
        if (!block) return;
        block._activeFilters = {};
        _tablePaginationState[blockId] = { page: 0, pageSize: (block.segment && block.segment.pageSize) || 50 };
        renderPage(_activePage);
    }

    function _filterEventsSidebar(query) {
        var q = (query || '').toLowerCase();
        document.querySelectorAll('.iface-attorney-row').forEach(function(row) {
            var name = (row.querySelector('.iface-attorney-name-side') || {}).textContent || '';
            row.style.display = (!q || name.toLowerCase().includes(q)) ? '' : 'none';
        });
    }

    function _toggleAttorneyFilter(rowEl) {
        var check = rowEl.querySelector('.iface-attorney-check');
        if (check) {
            check.classList.toggle('checked');
            rowEl.classList.toggle('active');
        }
    }

    function _showGoogleCalendar() {
        // Switch to google calendar tab if events page has tab-container
        // For now, toggle to google calendar view
        if (_schema && _activePage === 'events') {
            var page = _schema.pages.find(function(p) { return p.id === 'events'; });
            if (page) {
                var gcalBlock = page.blocks.find(function(b) { return b.type === 'google-calendar'; });
                if (gcalBlock) {
                    gcalBlock._hidden = false;
                    var agendaBlock = page.blocks.find(function(b) { return b.type === 'events-agenda'; });
                    if (agendaBlock) agendaBlock._hidden = true;
                    renderPage('events');
                    return;
                }
            }
        }
        _showToast('Google Calendar view not available');
    }

    function _getMirroredColumnsFromView(tableId, block) {
        if (!tableId || !block || !block.mirrorViewFields || typeof getVisibleFieldsForView !== 'function') return null;

        var viewId = block.mirrorViewId || '_default';
        var visibleFieldIds = getVisibleFieldsForView(tableId, viewId) || [];
        var tableFields = (typeof META_FIELDS !== 'undefined' && META_FIELDS && META_FIELDS[tableId]) ? META_FIELDS[tableId] : {};
        if (!visibleFieldIds.length || !tableFields) return null;

        var existingCols = block.columns || [];
        var existingByField = {};
        existingCols.forEach(function(col) {
            if (col && col.field) existingByField[col.field] = col;
        });

        var mirroredColumns = visibleFieldIds.map(function(fieldId) {
            var fieldMeta = tableFields[fieldId] || {};
            var fieldName = fieldMeta.fieldName || fieldId;
            var existing = existingByField[fieldName] || existingByField[fieldId];
            return {
                field: fieldName,
                label: (existing && existing.label) || fieldName,
                width: (existing && existing.width) || 160
            };
        });

        // Keep curated block columns first when available.
        // This prevents interface tables from ballooning into every visible field
        // while still honoring view visibility.
        if (existingCols.length) {
            var mirroredFieldSet = new Set();
            mirroredColumns.forEach(function(col) {
                mirroredFieldSet.add(col.field);
            });

            var curatedVisibleColumns = existingCols
                .filter(function(col) {
                    return col && col.field && mirroredFieldSet.has(col.field);
                })
                .map(function(col) {
                    return {
                        field: col.field,
                        label: col.label || col.field,
                        width: col.width || 160
                    };
                });

            if (curatedVisibleColumns.length) return curatedVisibleColumns;
        }

        return mirroredColumns;
    }

    function _renderDataTable(block, records, pageState, allRecords, tableId) {
        var columns = _getMirroredColumnsFromView(tableId, block) || block.columns || [];
        var filters = block.filters || [];
        var ps = pageState || { page: 0, pageSize: block.segment && block.segment.pageSize || 50 };
        var total = records.length;
        var start = ps.page * ps.pageSize;
        var pageRecords = records.slice(start, start + ps.pageSize);

        // Build field-name-to-fieldType lookup so cell formatters can
        // delegate to formatCell() for computed/formula fields, matching
        // the DB screen rendering exactly.
        var _fieldTypeByName = {};
        var _tblMeta = (typeof META_FIELDS !== 'undefined' && META_FIELDS && META_FIELDS[tableId]) ? META_FIELDS[tableId] : {};
        Object.keys(_tblMeta).forEach(function(fid) {
            var m = _tblMeta[fid];
            if (m) {
                if (m.fieldName) _fieldTypeByName[m.fieldName] = m.fieldType;
                _fieldTypeByName[fid] = m.fieldType;
            }
        });

        var html = '<div class="iface-block iface-data-table-block" data-block-id="' + _esc(block.id) + '">';
        html += '<div class="iface-block-drag-handle">Drag</div>';
        html += '<div class="iface-block-header">';
        html += '<span class="iface-block-title">' + _esc(block.label || 'Table') + ' <span style="font-weight:400;color:var(--text-muted);font-size:12px;">(' + total + ' records)</span></span>';
        html += '<div style="display:flex;gap:8px;align-items:center;">';
        html += '<input type="text" class="iface-block-search" placeholder="Search..." value="' + _esc(_blockSearchState[block.id] || '') + '" data-search-block="' + _esc(block.id) + '" oninput="InterfaceApp.onBlockSearch(\'' + _esc(block.id) + '\', this.value)">';
        html += '<div class="iface-block-actions">';
        html += '<button class="iface-block-action-btn danger" onclick="InterfaceApp.removeBlock(\'' + _esc(block.id) + '\')">Remove</button>';
        html += '</div></div></div>';

        // Filters
        if (filters.length) {
            html += '<div class="iface-filters">';
            filters.forEach(function(flt) {
                var activeVal = (block._activeFilters && block._activeFilters[flt.id]) ? block._activeFilters[flt.id].value : '';
                html += '<select class="iface-filter-dropdown" data-filter-id="' + _esc(flt.id) + '" onchange="InterfaceApp.onFilterChange(\'' + _esc(block.id) + '\', \'' + _esc(flt.id) + '\', this.value)">';
                html += '<option value="">' + _esc(flt.label) + '</option>';
                // Build unique values from ALL records (use allRecords to avoid narrowing options)
                var vals = {};
                (allRecords || records).forEach(function(r) {
                    var v = _findFieldValue(r.fields || {}, flt.field);
                    if (v != null && v !== '') {
                        var sv = Array.isArray(v) ? v.join(', ') : String(v);
                        vals[sv] = true;
                    }
                });
                Object.keys(vals).sort().forEach(function(v) {
                    var sel = (v === activeVal) ? ' selected' : '';
                    html += '<option value="' + _esc(v) + '"' + sel + '>' + _esc(v) + '</option>';
                });
                html += '</select>';
            });
            html += '</div>';
        }

        // Table
        html += '<div class="iface-block-body"><div class="iface-table-wrapper"><table class="iface-table">';
        html += '<thead><tr>';
        columns.forEach(function(col) {
            var w = col.width ? ' style="width:' + col.width + 'px"' : '';
            var colId = (col.label || col.field).toLowerCase().replace(/[^a-z0-9]+/g, '-');
            html += '<th' + w + ' data-col="' + _esc(colId) + '" onclick="InterfaceApp.onColumnSort(\'' + _esc(block.id) + '\', \'' + _esc(col.field) + '\')">' + _esc(col.label || col.field) + '</th>';
        });
        html += '</tr></thead><tbody>';
        if (!pageRecords.length) {
            html += '<tr><td colspan="' + columns.length + '" style="text-align:center;color:var(--text-muted);padding:30px;">No records</td></tr>';
        } else {
            pageRecords.forEach(function(r) {
                html += '<tr data-record-id="' + _esc(r.recordId) + '">';
                columns.forEach(function(col) {
                    var val = _findFieldValue(r.fields || {}, col.field);
                    var colId = (col.label || col.field).toLowerCase().replace(/[^a-z0-9]+/g, '-');
                    var colFieldType = _fieldTypeByName[col.field] || null;
                    html += '<td data-col="' + _esc(colId) + '">' + _formatFieldValue(val, colFieldType) + '</td>';
                });
                html += '</tr>';
            });
        }
        html += '</tbody></table></div>';

        // Pagination
        var totalPages = Math.ceil(total / ps.pageSize);
        if (totalPages > 1) {
            html += '<div class="iface-pagination">';
            html += '<span>Showing ' + (start + 1) + '-' + Math.min(start + ps.pageSize, total) + ' of ' + total + '</span>';
            html += '<div class="iface-pagination-btns">';
            html += '<button class="iface-page-btn" onclick="InterfaceApp.onPageChange(\'' + _esc(block.id) + '\', ' + (ps.page - 1) + ')"' + (ps.page <= 0 ? ' disabled' : '') + '>&laquo; Prev</button>';
            html += '<button class="iface-page-btn" onclick="InterfaceApp.onPageChange(\'' + _esc(block.id) + '\', ' + (ps.page + 1) + ')"' + (ps.page >= totalPages - 1 ? ' disabled' : '') + '>Next &raquo;</button>';
            html += '</div></div>';
        }

        html += '</div></div>';
        return html;
    }


    function _getCaseNotesWidgetState(blockId) {
        if (!_caseNotesWidgetState[blockId]) {
            _caseNotesWidgetState[blockId] = {
                filters: {
                    client_pp_id: '',
                    matter_id: '',
                    type: '',
                    search: '',
                    dateFrom: '',
                    dateTo: '',
                    per_page: '20'
                },
                page: 1,
                items: [],
                total: 0,
                per_page: 20,
                count: 0,
                status: 'Ready.',
                error: '',
                lastQueryKey: ''
            };
        }
        return _caseNotesWidgetState[blockId];
    }

    function _toCaseNotesTimestamp(dateValue, isEndOfDay) {
        if (!dateValue) return '';
        var d = new Date(dateValue + 'T00:00:00');
        if (isEndOfDay) d.setHours(23, 59, 59, 999);
        return isNaN(d.getTime()) ? '' : d.toISOString();
    }

    function _buildCaseNotesWidgetParams(state) {
        var params = new URLSearchParams();
        var filters = state.filters || {};
        if (filters.client_pp_id) params.set('client_pp_id', String(filters.client_pp_id).trim());
        if (filters.matter_id) params.set('matter_id', String(filters.matter_id).trim());
        if (filters.type) params.set('type', String(filters.type).trim());
        var dateFrom = _toCaseNotesTimestamp(filters.dateFrom, false);
        var dateTo = _toCaseNotesTimestamp(filters.dateTo, true);
        if (dateFrom) params.set('date_from', dateFrom);
        if (dateTo) params.set('date_to', dateTo);
        params.set('page', String(Math.max(1, state.page || 1)));
        params.set('per_page', String(filters.per_page || '20'));
        return params;
    }

    function _normalizeCaseNotesResponse(json, fallbackPerPage) {
        if (Array.isArray(json)) {
            return { items: json, total: json.length, page: 1, per_page: fallbackPerPage };
        }
        var items = json && (json.items || json.data || json.records || json.result || json.results) || [];
        var total = json && (json.totalItems || json.total_items || json.total || json.count);
        var page = json && (json.page || json.currentPage || json.current_page);
        var perPage = json && (json.perPage || json.per_page || json.limit);
        return {
            items: Array.isArray(items) ? items : [],
            total: Number(total != null ? total : (Array.isArray(items) ? items.length : 0)),
            page: Number(page || 1),
            per_page: Number(perPage || fallbackPerPage || 20)
        };
    }

    function _pickCaseNoteValue(note, keys) {
        if (!note || typeof note !== 'object') return '';
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (note[key] != null && String(note[key]).trim() !== '') {
                return String(note[key]);
            }
        }
        return '';
    }

    function _caseNotesSearch(items, query) {
        var q = String(query || '').toLowerCase().trim();
        if (!q) return items;
        return items.filter(function(note) {
            var desc = _pickCaseNoteValue(note, ['Description', 'description', 'note', 'body', 'details']).toLowerCase();
            return desc.indexOf(q) !== -1;
        });
    }

    async function _buildCaseNotesClientIndex() {
        var source = { op: 'DES', tableNamePattern: 'client info', fallbackTablePattern: 'client' };
        var records = await _getSourceRecords(source);
        var byJoinKey = {};
        var byClientPpId = {};
        var byRecordId = {};

        function _addJoinKey(map, key, payload) {
            var normalized = String(key || '').trim().toLowerCase();
            if (!normalized) return;
            map[normalized] = payload;
        }

        records.forEach(function(record) {
            var fields = record.fields || {};
            var recordId = String(record.recordId || '');
            var displayName = _findFieldValue(fields, 'display name') || _findFieldValue(fields, 'Display Name') || _findFieldValue(fields, 'name') || recordId;
            var payload = {
                recordId: recordId,
                displayName: String(displayName || recordId || 'Unknown client')
            };

            _addJoinKey(byRecordId, recordId, payload);
            _addJoinKey(byJoinKey, fields.airtableId, payload);
            _addJoinKey(byJoinKey, fields.Airtable_ID, payload);
            _addJoinKey(byJoinKey, fields.airtable_id, payload);
            _addJoinKey(byJoinKey, recordId, payload);

            var clientPpId = String(fields.Client_PP_ID || fields.client_pp_id || fields.pp_client_id || '').trim();
            if (clientPpId) {
                byClientPpId[clientPpId.toLowerCase()] = payload;
            }
        });
        return { byJoinKey: byJoinKey, byClientPpId: byClientPpId, byRecordId: byRecordId };
    }

    function _resolveCaseNoteClientInfo(note, clientIndex) {
        var contactName = _pickCaseNoteValue(note, ['Contact', 'contact']);
        var joinKey = _pickCaseNoteValue(note, ['join', 'Join', 'client_airtable_id', 'Softr_Link_to_clients', 'airtableId', 'clientId', 'client_id', 'Client Record ID']);
        var resolved = null;
        if (joinKey) {
            resolved = clientIndex.byJoinKey[String(joinKey).toLowerCase()] || clientIndex.byRecordId[String(joinKey).toLowerCase()] || null;
        }

        if (!resolved) {
            var clientPpId = _pickCaseNoteValue(note, ['Client_PP_ID', 'client_pp_id']);
            if (clientPpId) {
                resolved = clientIndex.byClientPpId[String(clientPpId).toLowerCase()] || null;
            }
        }

        var displayName = contactName || (resolved ? resolved.displayName : '');

        return {
            joinKey: joinKey,
            recordId: resolved ? resolved.recordId : '',
            displayName: displayName
        };
    }

    function _buildCaseNoteRecordId(note, indexHint) {
        var directId = _pickCaseNoteValue(note, ['id', 'recordId', 'record_id', 'note_id', 'uuid']);
        if (directId) return directId;
        var client = _pickCaseNoteValue(note, ['client_airtable_id', 'Softr_Link_to_clients', 'Client_PP_ID', 'client_pp_id']) || 'unknown-client';
        var date = _pickCaseNoteValue(note, ['Date', 'date', 'created_at', 'updated_at', 'Modified']) || 'unknown-date';
        var text = _pickCaseNoteValue(note, ['Description', 'description', 'note', 'body', 'details']) || '';
        var compact = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').slice(0, 40) || ('row-' + String(indexHint || 0));
        return ['casenote', client, date, compact].join(':');
    }

    async function _mirrorCaseNotesToLocalDb(items) {
        var tableId = _resolveTableId({ tableNamePattern: 'case notes', fallbackTablePattern: 'note' });
        if (!tableId || !Array.isArray(items) || !items.length || typeof saveDataRecord !== 'function') return 0;

        var persisted = 0;
        if (window.IN_MEMORY_DATA && !window.IN_MEMORY_DATA[tableId]) window.IN_MEMORY_DATA[tableId] = {};

        for (var i = 0; i < items.length; i++) {
            var note = items[i];
            if (!note || typeof note !== 'object') continue;
            var rid = _buildCaseNoteRecordId(note, i);
            var fields = Object.assign({}, note);
            try {
                await saveDataRecord({ tableId: tableId, recordId: rid, fields: fields });
                if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
                    window.IN_MEMORY_DATA[tableId][rid] = fields;
                }
                persisted++;
            } catch (e) {
                // non-fatal: this is a best-effort mirror from the widget endpoint
            }
        }
        return persisted;
    }

    async function _fetchCaseNotesWidgetData(block, state) {
        var endpoint = block.endpoint || CASE_NOTES_WIDGET_ENDPOINT;
        var params = _buildCaseNotesWidgetParams(state);
        var queryKey = params.toString();
        if (state.lastQueryKey === queryKey && state.items.length) return;

        var url = endpoint + '?' + queryKey;
        var res = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' } });
        if (!res.ok) {
            var errText = await res.text().catch(function() { return ''; });
            throw new Error('Request failed (' + res.status + ' ' + res.statusText + ')' + (errText ? ': ' + errText : ''));
        }

        var json = await res.json();
        var normalized = _normalizeCaseNotesResponse(json, Number(state.filters.per_page || 20));
        var mirroredCount = await _mirrorCaseNotesToLocalDb(normalized.items);
        var filteredItems = _caseNotesSearch(normalized.items, state.filters.search);

        state.items = filteredItems;
        state.total = normalized.total;
        state.per_page = normalized.per_page;
        state.count = filteredItems.length;
        state.page = normalized.page || state.page;
        state.lastQueryKey = queryKey;
        state.status = 'Loaded ' + filteredItems.length + ' notes (page ' + state.page + '). Mirrored ' + mirroredCount + ' to DB table.';
        state.error = '';
    }

    function _readCaseNotesWidgetForm(blockId) {
        var ids = ['client_pp_id', 'matter_id', 'type', 'search', 'dateFrom', 'dateTo', 'per_page'];
        var current = _getCaseNotesWidgetState(blockId).filters || {};
        var next = {};
        ids.forEach(function(key) {
            var input = document.getElementById('cnw-' + blockId + '-' + key);
            next[key] = input ? String(input.value || '').trim() : String(current[key] || '');
        });
        if (!next.per_page) next.per_page = String(current.per_page || '20');
        return next;
    }

    async function _renderCaseNotesWidget(block) {
        var state = _getCaseNotesWidgetState(block.id);
        if (!state.lastQueryKey) {
            try {
                await _fetchCaseNotesWidgetData(block, state);
            } catch (err) {
                state.error = err && err.message ? err.message : 'Failed to load case notes.';
                state.status = 'Error.';
            }
        }

        var clientIndex = await _buildCaseNotesClientIndex();

        // Group notes by client for inbox-style display
        var clientGroups = {};
        var clientOrder = [];
        state.items.forEach(function(note) {
            var clientInfo = _resolveCaseNoteClientInfo(note, clientIndex);
            var key = clientInfo.recordId || clientInfo.joinKey || 'unlinked';
            if (!clientGroups[key]) {
                clientGroups[key] = {
                    displayName: clientInfo.displayName || 'Unknown client',
                    joinKey: clientInfo.joinKey || '',
                    recordId: clientInfo.recordId || '',
                    notes: []
                };
                clientOrder.push(key);
            }
            var date = _pickCaseNoteValue(note, ['Date', 'date', 'created_at', 'updated_at', 'Modified']);
            var description = _pickCaseNoteValue(note, ['Description', 'description', 'note', 'body', 'details']);
            var category = _pickCaseNoteValue(note, ['Type', 'type', 'Activity', 'activity']) || 'Case Note';
            clientGroups[key].notes.push({
                date: date || '',
                description: description || '',
                category: category
            });
        });

        // Sort notes within each group chronologically (oldest first, scroll up for older)
        clientOrder.forEach(function(key) {
            clientGroups[key].notes.sort(function(a, b) {
                var da = a.date ? new Date(a.date).getTime() : 0;
                var db = b.date ? new Date(b.date).getTime() : 0;
                return da - db;
            });
        });

        var totalPages = state.total && state.per_page ? Math.ceil(Number(state.total) / Math.max(Number(state.per_page), 1)) : 0;
        var firstClientKey = clientOrder[0] || '';

        var html = '<div class="iface-block" data-block-id="' + _esc(block.id) + '" style="margin:0 24px 16px;">';
        html += '<div class="iface-block-header">';
        html += '<span class="iface-block-title">' + _esc(block.label || 'Case Notes Inbox') + '</span>';
        html += '<div style="display:flex;gap:6px;align-items:center;">';
        html += '<button class="iface-quick-action secondary" style="font-size:11px;padding:5px 10px;" onclick="InterfaceApp.caseNotesWidgetAction(\'' + _esc(block.id) + '\', \'load\')">Refresh</button>';
        html += '<button class="iface-quick-action secondary" style="font-size:11px;padding:5px 10px;" onclick="InterfaceApp.caseNotesWidgetAction(\'' + _esc(block.id) + '\', \'prev\')"' + (state.page <= 1 ? ' disabled' : '') + '>\u2190</button>';
        html += '<span style="font-size:11px;color:var(--iface-text-muted);">' + _esc(String(state.page || 1)) + (totalPages ? '/' + totalPages : '') + '</span>';
        html += '<button class="iface-quick-action secondary" style="font-size:11px;padding:5px 10px;" onclick="InterfaceApp.caseNotesWidgetAction(\'' + _esc(block.id) + '\', \'next\')"' + (totalPages && state.page >= totalPages ? ' disabled' : '') + '>\u2192</button>';
        html += '</div></div>';

        if (state.error) html += '<div class="iface-case-notes-error" style="padding:8px 16px;">' + _esc(state.error) + '</div>';

        // Inbox layout: client list on left, messages on right
        html += '<div class="iface-inbox">';

        // Left panel: client list
        html += '<div class="iface-inbox-list">';
        html += '<div class="iface-inbox-list-header">';
        html += 'Clients <span class="inbox-count">' + clientOrder.length + '</span>';
        html += '</div>';

        if (!clientOrder.length) {
            html += '<div style="padding:16px;font-size:13px;color:var(--iface-text-muted);">No case notes found.</div>';
        } else {
            clientOrder.forEach(function(key, idx) {
                var group = clientGroups[key];
                var lastNote = group.notes[group.notes.length - 1];
                var previewText = lastNote ? lastNote.description.substring(0, 60) : '';
                var activeClass = (idx === 0) ? ' active' : '';
                html += '<div class="iface-inbox-item' + activeClass + '" data-inbox-client="' + _esc(key) + '" onclick="InterfaceApp._selectInboxClient(\'' + _esc(block.id) + '\', \'' + _esc(key) + '\')">';
                html += '<div class="iface-inbox-item-name">' + _esc(group.displayName) + '</div>';
                html += '<div class="iface-inbox-item-preview">' + _esc(previewText) + (previewText.length >= 60 ? '...' : '') + '</div>';
                html += '<div class="iface-inbox-item-time">' + _esc(group.notes.length + ' note' + (group.notes.length !== 1 ? 's' : '')) + (lastNote && lastNote.date ? ' \u00B7 ' + _esc(lastNote.date) : '') + '</div>';
                html += '</div>';
            });
        }
        html += '</div>';

        // Right panel: chronological messages for selected client
        html += '<div class="iface-inbox-detail">';
        if (firstClientKey && clientGroups[firstClientKey]) {
            var firstGroup = clientGroups[firstClientKey];
            html += '<div class="iface-inbox-detail-header">';
            html += '<h3>' + _esc(firstGroup.displayName) + '</h3>';
            html += '<div class="inbox-meta">';
            if (firstGroup.joinKey) html += _esc(firstGroup.joinKey) + ' \u00B7 ';
            html += firstGroup.notes.length + ' note' + (firstGroup.notes.length !== 1 ? 's' : '');
            if (firstGroup.recordId) {
                html += ' \u00B7 <a href="client-profile.html?clientId=' + encodeURIComponent(firstGroup.recordId) + '" target="_blank" rel="noopener" style="color:var(--iface-accent);text-decoration:none;font-weight:500;">Open profile \u2192</a>';
            }
            html += '</div></div>';
            html += '<div class="iface-inbox-messages">';
            // Chronological order (oldest first = scroll up for older)
            firstGroup.notes.forEach(function(note) {
                html += '<div class="iface-inbox-msg">';
                html += '<div class="iface-inbox-msg-header">';
                html += '<span class="iface-inbox-msg-author">' + _esc(note.category) + '</span>';
                html += '<span class="iface-inbox-msg-time">' + _esc(note.date) + '</span>';
                html += '</div>';
                html += '<div class="iface-inbox-msg-body">' + _formatCaseNoteDescriptionHtml(note.description) + '</div>';
                html += '<div class="iface-inbox-msg-tags"><span class="iface-inbox-msg-tag">' + _esc(note.category) + '</span></div>';
                html += '</div>';
            });
            html += '</div>';
        } else {
            html += '<div style="display:flex;align-items:center;justify-content:center;flex:1;color:var(--iface-text-muted);font-size:13px;">Select a client to view notes</div>';
        }
        html += '</div>';
        html += '</div>'; // .iface-inbox

        html += '</div>';
        return html;
    }


    function _renderTabContainer(block, allBlocksMap) {
        var tabs = block.tabs || [];
        var html = '<div class="iface-block" data-block-id="' + _esc(block.id) + '" style="margin:0 24px 16px;">';
        html += '<div class="iface-block-drag-handle">Drag</div>';
        html += '<div class="iface-tab-bar">';
        tabs.forEach(function(tab, i) {
            var active = i === 0 ? ' active' : '';
            html += '<button class="iface-tab-btn' + active + '" data-tab="' + _esc(tab.id) + '" onclick="InterfaceApp.switchTab(\'' + _esc(block.id) + '\', \'' + _esc(tab.id) + '\')">' + _esc(tab.label) + '</button>';
        });
        html += '</div>';
        tabs.forEach(function(tab, i) {
            var active = i === 0 ? ' active' : '';
            html += '<div class="iface-tab-panel' + active + '" data-tab-panel="' + _esc(tab.id) + '">';
            var childBlock = allBlocksMap[tab.blockId];
            if (childBlock) {
                html += '<div data-child-block="' + _esc(tab.blockId) + '"></div>';
            } else {
                html += '<div class="iface-empty">Tab content loading...</div>';
            }
            html += '</div>';
        });
        html += '</div>';
        return html;
    }


    function _normGraphToken(value) {
        return String(value || '')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, ' ')
            .trim();
    }

    function _pickClientNameField(fields) {
        if (!fields) return null;
        var keys = Object.keys(fields);
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i].toLowerCase();
            if (k === 'client name' || k === 'name' || k.includes('client name')) return keys[i];
        }
        return keys.length ? keys[0] : null;
    }

    function _clientGraphValueText(value) {
        if (value == null) return '';
        if (Array.isArray(value)) {
            return value.map(_clientGraphValueText).filter(Boolean).join(', ');
        }
        if (typeof value === 'object') {
            var preferred = ['name', 'label', 'title', 'id', 'value'];
            for (var i = 0; i < preferred.length; i++) {
                var key = preferred[i];
                if (Object.prototype.hasOwnProperty.call(value, key)) {
                    var picked = _clientGraphValueText(value[key]);
                    if (picked) return picked;
                }
            }
            var values = Object.keys(value).map(function(k) { return _clientGraphValueText(value[k]); }).filter(Boolean);
            return values.slice(0, 2).join(', ');
        }
        return String(value).trim();
    }

    function _collectClientIdsFromValue(value, clientIdSet, out) {
        if (!value) return;
        if (Array.isArray(value)) {
            value.forEach(function(item) { _collectClientIdsFromValue(item, clientIdSet, out); });
            return;
        }
        if (typeof value === 'object') {
            Object.keys(value).forEach(function(key) {
                _collectClientIdsFromValue(value[key], clientIdSet, out);
            });
            return;
        }
        if (typeof value === 'string' && clientIdSet.has(value)) out.add(value);
    }

    function _pickRelationshipLabel(fields) {
        var keys = Object.keys(fields || {});
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var norm = _normGraphToken(key);
            if (norm.includes('relationship') || norm === 'relation' || norm.includes('type')) {
                var text = _clientGraphValueText(fields[key]);
                if (text) return text;
            }
        }
        return 'Related';
    }

    function _buildRelationshipAdjacency(clientEntries, relationshipRecords) {
        var adjacency = new Map();
        var clientIdSet = new Set(clientEntries.map(function(entry) { return entry.id; }));
        (relationshipRecords || []).forEach(function(rec) {
            var fields = (rec && rec.fields) || {};
            var found = new Set();
            Object.keys(fields).forEach(function(fieldKey) {
                _collectClientIdsFromValue(fields[fieldKey], clientIdSet, found);
            });
            var ids = Array.from(found);
            if (ids.length < 2) return;
            var relationLabel = _pickRelationshipLabel(fields);
            for (var i = 0; i < ids.length; i++) {
                for (var j = i + 1; j < ids.length; j++) {
                    var a = ids[i];
                    var b = ids[j];
                    if (!adjacency.has(a)) adjacency.set(a, new Map());
                    if (!adjacency.has(b)) adjacency.set(b, new Map());
                    if (!adjacency.get(a).has(b)) adjacency.get(a).set(b, { weight: 0, labels: [] });
                    if (!adjacency.get(b).has(a)) adjacency.get(b).set(a, { weight: 0, labels: [] });
                    var edgeAB = adjacency.get(a).get(b);
                    var edgeBA = adjacency.get(b).get(a);
                    edgeAB.weight += 1;
                    edgeBA.weight += 1;
                    edgeAB.labels.push(relationLabel);
                    edgeBA.labels.push(relationLabel);
                }
            }
        });
        return adjacency;
    }

    function _buildClientRelationshipGraph(records, selectedRecordId, relationshipRecords) {
        var all = Array.isArray(records) ? records : [];
        var entries = [];
        for (var i = 0; i < all.length; i++) {
            var rec = all[i] || {};
            var fields = rec.fields || {};
            var nameField = _pickClientNameField(fields);
            var clientName = nameField ? _findFieldValue(fields, nameField) : null;
            var displayName = Array.isArray(clientName) ? clientName[0] : clientName;
            displayName = String(displayName || rec.recordId || '').trim();
            if (!displayName) continue;
            entries.push({ id: rec.recordId || ('client-' + i), name: displayName, fields: fields });
        }

        var nodes = [];
        var links = [];
        var options = entries.map(function(e) { return { id: e.id, label: e.name }; });
        if (!entries.length) {
            return { nodes: nodes, links: links, selectedId: null, selectedName: '', options: options };
        }

        var anchor = entries.find(function(e) { return e.id === selectedRecordId; }) || entries[0];
        var selectedId = anchor.id;
        var selectedName = anchor.name;
        var centerNodeId = 'n-' + anchor.id;
        nodes.push({ id: centerNodeId, label: anchor.name, role: 'center', x: 0, y: 0 });

        var tableFieldWeights = {
            'ich atty': 3,
            'mch attny options': 3,
            'case manager': 3,
            'country': 2,
            'file case status': 2,
            'a#': 4
        };

        var satellites = entries.filter(function(e) { return e.id !== anchor.id; });
        var adjacency = _buildRelationshipAdjacency(entries, relationshipRecords);
        var adjacent = adjacency.get(anchor.id);
        if (adjacent && adjacent.size) {
            var relRanked = Array.from(adjacent.entries()).map(function(pair) {
                var otherId = pair[0];
                var info = pair[1];
                var other = entries.find(function(e) { return e.id === otherId; });
                return {
                    other: other,
                    similarity: info.weight,
                    reasons: [Array.from(new Set(info.labels)).slice(0, 2).join(', ')]
                };
            }).filter(function(item) { return item.other; });
            relRanked.sort(function(a, b) { return b.similarity - a.similarity; });
            var relVisible = relRanked.slice(0, 14);
            for (var r = 0; r < relVisible.length; r++) {
                var relItem = relVisible[r];
                var relAngle = (Math.PI * 2 * r) / Math.max(1, relVisible.length);
                var relBand = Math.floor(r / 5);
                var relRadius = 165 + (relBand * 42);
                var relX = Math.cos(relAngle) * relRadius;
                var relY = Math.sin(relAngle) * relRadius;
                var relNodeId = 'n-' + relItem.other.id;
                nodes.push({
                    id: relNodeId,
                    label: relItem.other.name,
                    role: 'linked',
                    x: relX,
                    y: relY,
                    weight: relItem.similarity,
                    meta: relItem.reasons[0]
                });
                links.push({ from: centerNodeId, to: relNodeId, weight: relItem.similarity });
            }
            return { nodes: nodes, links: links, selectedId: selectedId, selectedName: selectedName, options: options };
        }
        var ranked = [];
        for (var j = 0; j < satellites.length; j++) {
            var other = satellites[j];
            var similarity = 0;
            var reasons = [];
            var keys = Object.keys(other.fields || {});
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var keyNorm = _normGraphToken(key);
                if (!keyNorm) continue;
                var av = _findFieldValue(anchor.fields, key);
                var bv = other.fields[key];
                if (av == null || bv == null || av === '' || bv === '') continue;
                var avText = _clientGraphValueText(av);
                var bvText = _clientGraphValueText(bv);
                var aNorm = _normGraphToken(avText);
                var bNorm = _normGraphToken(bvText);
                if (!aNorm || !bNorm) continue;
                if (aNorm === bNorm) {
                    var weight = 1;
                    Object.keys(tableFieldWeights).forEach(function(name) {
                        if (keyNorm.indexOf(name) !== -1) weight = Math.max(weight, tableFieldWeights[name]);
                    });
                    similarity += weight;
                    reasons.push(key + ': ' + bvText);
                }
            }
            if (similarity <= 0) continue;
            ranked.push({ other: other, similarity: similarity, reasons: reasons });
        }

        ranked.sort(function(a, b) { return b.similarity - a.similarity; });
        var maxNodes = 14;
        var visible = ranked.slice(0, maxNodes);
        for (var n = 0; n < visible.length; n++) {
            var item = visible[n];
            var angle = (Math.PI * 2 * n) / Math.max(1, visible.length);
            var rankBand = Math.floor(n / 5);
            var radius = 165 + (rankBand * 42);
            var x = Math.cos(angle) * radius;
            var y = Math.sin(angle) * radius;
            var nodeId = 'n-' + item.other.id;
            nodes.push({
                id: nodeId,
                label: item.other.name,
                role: 'linked',
                x: x,
                y: y,
                weight: item.similarity,
                meta: item.reasons.slice(0, 1).join('  ')
            });
            links.push({ from: centerNodeId, to: nodeId, weight: item.similarity });
        }

        return { nodes: nodes, links: links, selectedId: selectedId, selectedName: selectedName, options: options };
    }

    function _renderClientRelationshipGraph(block, records, relationshipRecords) {
        var graph = _buildClientRelationshipGraph(records || [], block._selectedClientRecordId, relationshipRecords || []);
        var blockId = _esc(block.id || 'client-graph');
        var canvasId = 'iface-client-graph-canvas-' + blockId;
        var summary = graph.links.length
            ? ('Showing ' + graph.links.length + ' linked clients for ' + graph.selectedName + '.')
            : 'No shared relationships were detected for this client.';

        var html = '';
        html += '<div class="iface-client-graph-block" data-client-graph-block="' + blockId + '">';
        html += '<div class="iface-block-header"><h3>' + _esc(block.label || 'Client Relationship Graph') + '</h3></div>';
        html += '<div class="iface-client-graph-toolbar">';
        html += '<label>Client</label>';
        html += '<select class="iface-client-graph-select" onchange="InterfaceApp.onClientGraphClientChange(\'' + blockId + '\', this.value)">';
        if (!graph.options.length) {
            html += '<option value="">No clients available</option>';
        } else {
            for (var i = 0; i < graph.options.length; i++) {
                var opt = graph.options[i];
                html += '<option value="' + _esc(opt.id) + '"' + (opt.id === graph.selectedId ? ' selected' : '') + '>' + _esc(opt.label) + '</option>';
            }
        }
        html += '</select>';
        html += '</div>';
        html += '<div class="iface-client-graph-summary" id="' + _esc(canvasId) + '-summary">' + _esc(summary) + '</div>';
        html += '<div class="iface-client-graph-canvas-wrap">';
        html += '<canvas class="iface-client-graph-canvas" id="' + _esc(canvasId) + '"></canvas>';
        html += '</div>';
        html += '</div>';

        setTimeout(function() { _drawClientRelationshipCanvas(blockId, graph); }, 0);
        return html;
    }

    function _drawClientRelationshipCanvas(blockId, graph) {
        var canvas = document.getElementById('iface-client-graph-canvas-' + blockId);
        if (!canvas || !canvas.getContext) return;
        var rect = canvas.getBoundingClientRect();
        var dpr = window.devicePixelRatio || 1;
        var width = Math.max(640, Math.floor(rect.width || 1200));
        var height = Math.max(360, Math.floor(rect.height || 500));
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        var ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);

        var cx = width / 2;
        var cy = height / 2;

        var nodeById = {};
        (graph.nodes || []).forEach(function(n) { nodeById[n.id] = n; });

        (graph.links || []).forEach(function(link) {
            var from = nodeById[link.from];
            var to = nodeById[link.to];
            if (!from || !to) return;
            ctx.beginPath();
            ctx.moveTo(cx + from.x, cy + from.y);
            ctx.lineTo(cx + to.x, cy + to.y);
            var alpha = Math.min(0.75, 0.2 + ((link.weight || 1) * 0.08));
            ctx.strokeStyle = 'rgba(59, 130, 246, ' + alpha + ')';
            ctx.lineWidth = Math.min(5, 1 + (link.weight || 1));
            ctx.stroke();
        });

        (graph.nodes || []).forEach(function(node) {
            var isCenter = node.role === 'center';
            var r = isCenter ? 19 : Math.min(14, 8 + Math.max(0, (node.weight || 1) * 0.6));
            var x = cx + (node.x || 0);
            var y = cy + (node.y || 0);
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = isCenter ? '#22c55e' : '#3b82f6';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(15,23,42,0.45)';
            ctx.stroke();

            var label = String(node.label || '').slice(0, 28);
            var angle = Math.atan2((node.y || 0), (node.x || 0));
            var labelRadius = isCenter ? 0 : (r + 22);
            var lx = isCenter ? x : x + Math.cos(angle) * labelRadius;
            var ly = isCenter ? (y - 30) : y + Math.sin(angle) * labelRadius;
            var align = isCenter ? 'center' : (Math.cos(angle) >= 0 ? 'left' : 'right');
            ctx.font = (isCenter ? '600 13px' : '500 12px') + ' IBM Plex Sans, sans-serif';
            ctx.textAlign = align;
            var textWidth = ctx.measureText(label).width;
            var padX = 8;
            var boxX = align === 'center' ? lx - (textWidth / 2) - padX : (align === 'left' ? lx - padX : lx - textWidth - padX);
            var boxY = ly - 11;
            var boxW = textWidth + (padX * 2);
            var boxH = 18;
            ctx.fillStyle = 'rgba(15,23,42,0.86)';
            ctx.beginPath();
            ctx.roundRect(boxX, boxY, boxW, boxH, 8);
            ctx.fill();
            ctx.fillStyle = 'rgba(226,232,240,0.98)';
            ctx.fillText(label, lx, ly + 3);
            if (node.meta) {
                ctx.font = '11px IBM Plex Sans, sans-serif';
                ctx.fillStyle = 'rgba(148,163,184,0.95)';
                ctx.textAlign = align;
                var metaText = String(node.meta).slice(0, 42);
                ctx.fillText(metaText, lx, ly + 19);
            }
        });

        if (!graph.nodes || !graph.nodes.length) {
            ctx.font = '500 14px IBM Plex Sans, sans-serif';
            ctx.fillStyle = 'rgba(148,163,184,0.95)';
            ctx.textAlign = 'center';
            ctx.fillText('No client relationship data found.', cx, cy);
        }
    }

    function onClientGraphClientChange(blockId, selectedRecordId) {
        if (!_schema || !_activePage) return;
        var page = _schema.pages.find(function(p) { return p.id === _activePage; });
        if (!page) return;
        var block = page.blocks.find(function(b) { return b.id === blockId; });
        if (!block) return;
        block._selectedClientRecordId = selectedRecordId || '';
        renderPage(_activePage);
        if (_urlStateBootstrapped) persistUrlState();
    }

    function openClientRelationshipGraph(recordId) {
        if (!recordId || !_schema) return;
        var page = _schema.pages.find(function(p) { return p.id === 'client-relationships'; });
        if (!page || !Array.isArray(page.blocks)) {
            _showToast('Client Relationship Graph page is not available.');
            return;
        }
        var graphBlock = page.blocks.find(function(b) { return b.type === 'client-relationship-graph'; });
        if (!graphBlock) {
            _showToast('Client Relationship Graph block is not configured.');
            return;
        }
        graphBlock._selectedClientRecordId = recordId;
        switchPage('client-relationships');
        if (_urlStateBootstrapped) persistUrlState();
    }


    // ============ Google Calendar Block ============

    // Scoped state per block instance (keyed by block.id)
    var _gcalState = {};

    function _renderGoogleCalendar(block) {
        var bid = _esc(block.id);
        var html = '';
        html += '<div class="gcal-container" data-gcal-block="' + bid + '">';

        // Sidebar
        html += '<div class="gcal-sidebar">';
        html += '<h4>Visible Calendars</h4>';
        html += '<p class="gcal-sidebar-note">Drag to reorder. Double-click to hide.</p>';
        html += '<div class="gcal-active-bar" id="gcal-active-' + bid + '"></div>';
        html += '<div class="gcal-bulk-buttons">';
        html += '<button data-gcal-action="add-attorneys" data-gcal-bid="' + bid + '">Add Attorneys</button>';
        html += '<button data-gcal-action="add-all" data-gcal-bid="' + bid + '">Add All</button>';
        html += '<button data-gcal-action="clear-all" data-gcal-bid="' + bid + '">Clear All</button>';
        html += '</div>';
        html += '<h4 style="margin-top:16px">Calendar Roster</h4>';
        html += '<input class="gcal-sidebar-search" id="gcal-search-' + bid + '" type="text" placeholder="Search calendars...">';
        html += '<div class="gcal-chip-pool" id="gcal-pool-' + bid + '"></div>';
        html += '</div>';

        // Main section
        html += '<div class="gcal-main">';
        html += '<div class="gcal-date-picker">';
        html += '<label for="gcal-start-' + bid + '">Start:</label>';
        html += '<input type="date" id="gcal-start-' + bid + '">';
        html += '<button data-gcal-action="today" data-gcal-bid="' + bid + '">Today</button>';
        html += '</div>';
        html += '<div class="gcal-controls">';
        html += '<button data-gcal-action="toggle-sidebar" data-gcal-bid="' + bid + '">Hide Sidebar</button>';
        html += '<button data-gcal-action="toggle-view" data-gcal-bid="' + bid + '">Side-by-Side</button>';
        html += '<button data-gcal-action="toggle-mode" data-gcal-bid="' + bid + '">Switch View</button>';
        html += '</div>';
        html += '<div class="gcal-iframes" id="gcal-iframes-' + bid + '"></div>';
        html += '</div>';

        html += '</div>';
        return html;
    }

    function _gcalInit(block) {
        var bid = block.id;
        var cfg = block.config || {};
        var tz = cfg.timezone || 'America/New_York';
        var staticGroups = cfg.staticGroups || [];
        var fallbackRoster = cfg.fallbackRoster || [];
        var cacheKey = cfg.cacheKey || 'rklUserRoster';
        var webhookUrl = cfg.webhookUrl || '';

        // Color maps
        var emojiHex = {'\u26AA':'#ffffff','\uD83D\uDFE2':'#43a047','\uD83D\uDD35':'#1e88e5','\uD83D\uDFE3':'#9c27b0','\uD83D\uDFE1':'#ffd600','\uD83D\uDD34':'#e53935','\uD83D\uDFE0':'#fb8c00','\u26AB':'#000000','\uD83D\uDFE4':'#964B00'};
        var groupHex = { hear: '#8c24ff', event: '#4285f4' };
        var isLight = function(hex) { var m = hex.match(/\w\w/g); if (!m) return true; var r = parseInt(m[0],16), g = parseInt(m[1],16), b = parseInt(m[2],16); return (r*0.299+g*0.587+b*0.114)>186; };

        var state = _gcalState[bid] = {
            allCalendars: [],
            attorneyColors: {},
            viewMode: localStorage.getItem('gcal-mode-' + bid) || 'WEEK',
            sideView: JSON.parse(localStorage.getItem('gcal-side-' + bid) || 'false')
        };

        function chipColor(cal) {
            var clr = state.attorneyColors[(cal.id || '').toLowerCase()];
            if (clr) return emojiHex[clr] || '#6c757d';
            if (cal.grp) return groupHex[cal.grp] || '#6c757d';
            return '#6c757d';
        }

        function digestRows(rows) {
            var cals = [], colors = {};
            (rows || []).forEach(function(row) {
                var email = (row.Email || '').trim().toLowerCase();
                if (!email) return;
                var display = (row.Name || '').trim() || email;
                var emoji;
                if (row.Colors && emojiHex[row.Colors.trim()]) { emoji = row.Colors.trim(); }
                else { var first = Array.from(display)[0]; if (emojiHex[first]) emoji = first; }
                if (emoji) colors[email] = emoji;
                display = display.replace(emoji || '', '').trim() || email;
                cals.push({ id: email, name: display });
            });
            return { cals: cals, colors: colors };
        }

        // DOM references
        var activeBar = document.getElementById('gcal-active-' + bid);
        var chipPool = document.getElementById('gcal-pool-' + bid);
        var iframesBox = document.getElementById('gcal-iframes-' + bid);
        var startInput = document.getElementById('gcal-start-' + bid);
        var searchInput = document.getElementById('gcal-search-' + bid);
        if (!activeBar || !chipPool || !iframesBox) return;

        function filterRosterChips() {
            if (!chipPool) return;
            var query = ((searchInput && searchInput.value) || '').toLowerCase().trim();
            chipPool.querySelectorAll('.gcal-chip').forEach(function(ch) {
                var matches = !query || (ch.textContent || '').toLowerCase().includes(query);
                ch.style.display = matches ? '' : 'none';
            });
        }

        if (searchInput) {
            searchInput.addEventListener('input', filterRosterChips);
        }

        function createChip(cal) {
            var el = document.createElement('div');
            el.className = 'gcal-chip';
            el.textContent = cal.name;
            el.draggable = true;
            el.dataset.id = cal.id;
            paintChip(el, cal);
            el.ondragstart = function(e) { e.dataTransfer.setData('text/plain', ''); el.classList.add('dragging'); };
            el.ondragend = function() { el.classList.remove('dragging'); };
            el.ondblclick = function() { toggleChip(el); };
            return el;
        }

        function paintChip(el, cal) {
            var bg = chipColor(cal);
            el.style.backgroundColor = bg;
            el.style.color = isLight(bg) ? '#000' : '#fff';
            if (bg === '#ffffff') el.style.border = '1px solid #ccc';
        }

        function toggleChip(chip) {
            var target = (chip.parentElement === activeBar) ? chipPool : activeBar;
            target.appendChild(chip);
            persistSel();
            updateIframes();
        }

        function persistSel() {
            var ids = [];
            activeBar.querySelectorAll('.gcal-chip').forEach(function(c) { ids.push(c.dataset.id); });
            localStorage.setItem('gcal-sel-' + bid, JSON.stringify(ids));
        }

        function loadSel() {
            try { var raw = localStorage.getItem('gcal-sel-' + bid); return raw ? JSON.parse(raw) : null; } catch(e) { return null; }
        }

        // Drag-and-drop
        [activeBar, chipPool].forEach(function(zone) {
            zone.addEventListener('dragover', function(e) { e.preventDefault(); });
            zone.addEventListener('drop', function(e) {
                e.preventDefault();
                var drag = document.querySelector('.gcal-chip.dragging');
                if (drag) zone.appendChild(drag);
                persistSel();
                updateIframes();
            });
        });

        // Calendar iframe rendering
        var fmtDate = function(s) { return s.replace(/-/g, ''); };
        var colorParam = function(id) {
            var cal = state.allCalendars.find(function(c) { return c.id === id; });
            return '%23' + chipColor(cal || { id: id }).slice(1);
        };

        function iframeWrap(src) {
            var wrap = document.createElement('div');
            wrap.className = 'gcal-iframe-wrapper';
            wrap.innerHTML = '<div class="gcal-spinner-overlay"><div class="gcal-spinner"></div></div>';
            var iframe = document.createElement('iframe');
            iframe.className = 'gcal-calendar-iframe';
            iframe.loading = 'lazy';
            iframe.src = src;
            iframe.onload = function() {
                var spinner = wrap.querySelector('.gcal-spinner-overlay');
                if (spinner) spinner.remove();
            };
            wrap.appendChild(iframe);
            return wrap;
        }

        function updateIframes() {
            iframesBox.innerHTML = '';
            var selected = [];
            activeBar.querySelectorAll('.gcal-chip').forEach(function(c) { selected.push(c.dataset.id); });
            var mode = state.viewMode;
            var side = state.sideView;
            iframesBox.style.flexDirection = side ? 'row' : 'column';

            var start = startInput ? startInput.value : '';
            var end = '';
            if (start) {
                var s = new Date(start);
                var e = new Date(start);
                e.setDate(s.getDate() + 4);
                end = fmtDate(e.toISOString().slice(0, 10));
            }

            if (!side) {
                var url = 'https://calendar.google.com/calendar/embed?ctz=' + encodeURIComponent(tz) + '&mode=' + mode + '&showPrint=0';
                selected.forEach(function(id) {
                    url += '&src=' + encodeURIComponent(id) + '&color=' + colorParam(id);
                });
                if (start && end) url += '&dates=' + fmtDate(start) + '/' + end;
                iframesBox.appendChild(iframeWrap(url));
            } else {
                selected.forEach(function(id) {
                    var url = 'https://calendar.google.com/calendar/embed?src=' + encodeURIComponent(id) + '&mode=' + mode + '&ctz=' + encodeURIComponent(tz) + '&color=' + colorParam(id);
                    if (start && end) url += '&dates=' + fmtDate(start) + '/' + end;
                    var wrap = document.createElement('div');
                    wrap.className = 'gcal-person-wrapper';
                    var calObj = state.allCalendars.find(function(c) { return c.id === id; });
                    wrap.innerHTML = '<h4>' + _esc((calObj || { name: id }).name) + '</h4>';
                    wrap.appendChild(iframeWrap(url));
                    iframesBox.appendChild(wrap);
                });
            }
        }

        // Wire control buttons
        var gcalContainer = document.querySelector('[data-gcal-block="' + bid + '"]');
        if (gcalContainer) {
            gcalContainer.querySelectorAll('[data-gcal-action]').forEach(function(btn) {
                var action = btn.getAttribute('data-gcal-action');
                btn.addEventListener('click', function() {
                    if (action === 'add-attorneys') {
                        chipPool.querySelectorAll('.gcal-chip').forEach(function(ch) {
                            if (state.attorneyColors[ch.dataset.id]) activeBar.appendChild(ch);
                        });
                        persistSel(); updateIframes();
            filterRosterChips();
                    } else if (action === 'add-all') {
                        chipPool.querySelectorAll('.gcal-chip').forEach(function(ch) { activeBar.appendChild(ch); });
                        persistSel(); updateIframes();
                    } else if (action === 'clear-all') {
                        activeBar.querySelectorAll('.gcal-chip').forEach(function(ch) { chipPool.appendChild(ch); });
                        persistSel(); updateIframes();
                    } else if (action === 'toggle-sidebar') {
                        var sidebar = gcalContainer.querySelector('.gcal-sidebar');
                        var main = gcalContainer.querySelector('.gcal-main');
                        if (sidebar.style.display === 'none') {
                            sidebar.style.display = '';
                            main.style.width = '75%';
                            btn.textContent = 'Hide Sidebar';
                        } else {
                            sidebar.style.display = 'none';
                            main.style.width = '100%';
                            btn.textContent = 'Show Sidebar';
                        }
                    } else if (action === 'toggle-view') {
                        state.sideView = !state.sideView;
                        localStorage.setItem('gcal-side-' + bid, JSON.stringify(state.sideView));
                        btn.textContent = state.sideView ? 'Composite View' : 'Side-by-Side';
                        updateIframes();
                    } else if (action === 'toggle-mode') {
                        var seq = ['AGENDA', 'WEEK', 'MONTH'];
                        var cur = state.viewMode;
                        state.viewMode = seq[(seq.indexOf(cur) + 1) % seq.length];
                        localStorage.setItem('gcal-mode-' + bid, state.viewMode);
                        updateIframes();
                    } else if (action === 'today') {
                        if (startInput) {
                            startInput.value = new Date().toISOString().split('T')[0];
                            updateIframes();
                        }
                    }
                });
            });
        }
        if (startInput) { startInput.onchange = function() { updateIframes(); }; }

        // Remote sync
        function syncRemote() {
            if (!webhookUrl) return;
            fetch(webhookUrl).then(function(resp) {
                if (!resp.ok) throw new Error(resp.statusText);
                return resp.json();
            }).then(function(data) {
                localStorage.setItem(cacheKey, JSON.stringify(data));
                reconcile(data);
            }).catch(function(err) { console.error('[GCal] Remote sync failed', err); });
        }

        function reconcile(rows) {
            var result = digestRows(rows);
            var remoteCals = result.cals;
            var remoteColors = result.colors;
            var remoteIds = new Set(remoteCals.map(function(c) { return c.id; }));

            state.allCalendars = state.allCalendars.filter(function(c) { return c.grp || remoteIds.has(c.id); });
            gcalContainer.querySelectorAll('.gcal-chip').forEach(function(el) {
                if (!remoteIds.has(el.dataset.id) && !staticGroups.find(function(g) { return g.id === el.dataset.id; })) el.remove();
            });
            remoteCals.forEach(function(c) {
                if (!state.allCalendars.find(function(x) { return x.id === c.id; })) {
                    state.allCalendars.push(c);
                    chipPool.appendChild(createChip(c));
                }
            });
            state.attorneyColors = remoteColors;
            gcalContainer.querySelectorAll('.gcal-chip').forEach(function(ch) {
                var cal = state.allCalendars.find(function(c) { return c.id === ch.dataset.id; });
                paintChip(ch, cal || {});
            });
            persistSel(); updateIframes();
        }

        // Boot: load from cache or fallback, build chips, sync remote
        var cachedJson = null;
        try { cachedJson = JSON.parse(localStorage.getItem(cacheKey) || 'null'); } catch(e) { cachedJson = null; }

        var initial;
        if (cachedJson) { initial = digestRows(cachedJson); }
        else { initial = digestRows(fallbackRoster); }
        state.allCalendars = initial.cals.slice();
        state.attorneyColors = initial.colors;

        // Add static groups
        staticGroups.forEach(function(g) { state.allCalendars.push(g); });

        // Build chips
        var defaultSel = new Set(Object.keys(state.attorneyColors));
        var storedSel = loadSel();
        var sel = (storedSel && storedSel.length) ? new Set(storedSel) : defaultSel;
        state.allCalendars.forEach(function(c) {
            var chip = createChip(c);
            if (sel.has(c.id)) { activeBar.appendChild(chip); }
            else { chipPool.appendChild(chip); }
        });

        updateIframes();
        filterRosterChips();
        syncRemote();
    }

    // Helper: find a field value by name, using fuzzy matching
    function _findFieldValue(fields, fieldName) {
        if (!fields || !fieldName) return null;
        // Exact match
        if (fields[fieldName] !== undefined) return fields[fieldName];
        // Case-insensitive match
        var lower = fieldName.toLowerCase();
        var keys = Object.keys(fields);
        for (var i = 0; i < keys.length; i++) {
            if (keys[i].toLowerCase() === lower) return fields[keys[i]];
        }
        // Partial match
        for (var j = 0; j < keys.length; j++) {
            if (keys[j].toLowerCase().includes(lower)) return fields[keys[j]];
        }
        return null;
    }

    // ============ Page Rendering ============

    async function renderPage(pageId) {
        _activePage = pageId;
        var container = document.getElementById('iface-page-container');
        if (!container || !_schema) return;

        var visiblePages = _getVisiblePages();
        if (!visiblePages.length) {
            _renderPageTabs();
            container.innerHTML = '<div class="iface-empty">No interface pages are available for your role.</div>';
            return;
        }

        var requestedPage = _schema.pages.find(function(p) { return p.id === pageId; });
        if (!requestedPage || !_isPageVisibleToCurrentUser(requestedPage)) {
            _activePage = visiblePages[0].id;
        }

        _renderPageTabs();

        var page = _schema.pages.find(function(p) { return p.id === _activePage; });
        if (!page) {
            container.innerHTML = '<div class="iface-empty">Page not found</div>';
            return;
        }

        container.innerHTML = '<div class="iface-page active" data-page-id="' + _esc(page.id) + '"><div class="iface-empty"><div class="iface-skeleton" style="width:60%;height:20px;margin:20px auto;"></div><div class="iface-skeleton" style="width:40%;height:14px;margin:8px auto;"></div></div></div>';

        // Build block map for tab containers
        var allBlocks = _flattenBlocks(page.blocks);
        var allBlocksMap = {};
        allBlocks.forEach(function(b) { allBlocksMap[b.id] = b; });

        // Pre-fetch all needed tables
        var fetchWork = {};
        allBlocks.forEach(function(b) {
            if (b.source) {
                var key = _sourceCacheKey(b.source);
                if (key) fetchWork[key] = b.source;
            }
        });
        var fetchPromises = Object.keys(fetchWork).map(function(key) {
            return _getSourceRecords(fetchWork[key]);
        });
        await Promise.all(fetchPromises);

        // Render blocks
        // Blocks referenced by containers/tabs should render only inside their parent
        // and not again as top-level siblings.
        var nestedBlockIds = {};
        page.blocks.forEach(function(b) {
            (b.children || []).forEach(function(cid) { nestedBlockIds[cid] = true; });
            (b.tabs || []).forEach(function(tab) {
                if (tab && tab.blockId) nestedBlockIds[tab.blockId] = true;
            });
        });
        var rootBlocks = page.blocks.filter(function(b) { return !nestedBlockIds[b.id]; });

        var editClass = _editMode ? ' iface-editing' : '';
        // Determine if page content needs the page-content wrapper (home page) or is full-width (clients, events)
        var isHomePage = page.id === 'home';
        var html = '<div class="iface-page active' + editClass + '" data-page-id="' + _esc(page.id) + '">';

        if (isHomePage) {
            html += '<div class="iface-page-content">';
        }

        for (var i = 0; i < rootBlocks.length; i++) {
            var block = rootBlocks[i];
            html += await _renderBlock(block, allBlocksMap);
        }

        if (isHomePage) {
            html += '</div>';
        }

        html += '</div>';
        container.innerHTML = html;

        // Update topbar nav highlighting
        _updateTopbarNav(page.id);

        // Update avatar initials
        var avatarEl = document.getElementById('iface-avatar');
        if (avatarEl) avatarEl.textContent = _getUserInitials();

        // Render child blocks inside tab containers
        var tabContainers = container.querySelectorAll('[data-child-block]');
        for (var t = 0; t < tabContainers.length; t++) {
            var childEl = tabContainers[t];
            var childBlockId = childEl.getAttribute('data-child-block');
            var childBlock = allBlocksMap[childBlockId];
            if (childBlock) {
                childEl.innerHTML = await _renderBlock(childBlock, allBlocksMap);
            }
        }

        // Initialize Google Calendar blocks (need live DOM)
        allBlocks.forEach(function(b) {
            if (b.type === 'google-calendar' && !b._hidden) {
                _gcalInit(b);
            }
        });
    }

    function _updateTopbarNav(pageId) {
        // No-op: redundant interface topbar nav has been removed
    }

    async function _renderBlock(block, allBlocksMap) {
        if (block._hidden) return '';
        var html = '';
        var tableId, records, searchQ, pageState;

        switch (block.type) {
            case 'welcome-greeting':
                html = _renderWelcomeGreeting(block);
                break;

            case 'action-cards':
                html = _renderActionCards(block);
                break;

            case 'stats-row':
                html = _renderStatsRow();
                break;

            case 'home-columns':
                html = '<div class="iface-home-columns">';
                if (block.children) {
                    for (var hc = 0; hc < block.children.length; hc++) {
                        var hChildBlock = allBlocksMap[block.children[hc]];
                        if (hChildBlock) html += await _renderBlock(hChildBlock, allBlocksMap);
                    }
                }
                html += '</div>';
                break;

            case 'recent-list':
                records = await _getSourceRecords(block.source);
                searchQ = _blockSearchState[block.id] || '';
                records = _applySegment(records, block.segment, searchQ, block._activeFilters);
                html = _renderRecentList(block, records);
                break;

            case 'activity-log':
                html = _renderActivityLog();
                break;

            case 'events-agenda':
                records = await _getSourceRecords(block.source);
                searchQ = _blockSearchState[block.id] || '';
                records = _applySegment(records, block.segment, searchQ, block._activeFilters);
                html = _renderEventsAgenda(block, records);
                break;

            case 'quick-links':
                html = _renderQuickLinks(block);
                break;

            case 'columns':
                html = '<div class="iface-columns">';
                if (block.children) {
                    for (var c = 0; c < block.children.length; c++) {
                        var childBlock = allBlocksMap[block.children[c]];
                        if (childBlock) html += await _renderBlock(childBlock, allBlocksMap);
                    }
                }
                html += '</div>';
                break;

            case 'card-list':
                records = await _getSourceRecords(block.source);
                searchQ = _blockSearchState[block.id] || '';
                records = _applySegment(records, block.segment, searchQ, block._activeFilters);
                html = _renderCardList(block, records);
                break;

            case 'timeline':
                records = await _getSourceRecords(block.source);
                searchQ = _blockSearchState[block.id] || '';
                records = _applySegment(records, block.segment, searchQ, block._activeFilters);
                html = _renderTimeline(block, records);
                break;

            case 'data-table':
                var allTableRecords = await _getSourceRecords(block.source);
                searchQ = _blockSearchState[block.id] || '';
                records = _applySegment(allTableRecords, block.segment, searchQ, block._activeFilters);
                pageState = _tablePaginationState[block.id] || { page: 0, pageSize: (block.segment && block.segment.pageSize) || 50 };
                tableId = _resolveTableId(block.source);
                html = _renderDataTableRevamped(block, records, pageState, allTableRecords, tableId);
                break;

            case 'case-notes-widget':
                html = await _renderCaseNotesWidget(block);
                break;

            case 'tab-container':
                html = _renderTabContainer(block, allBlocksMap);
                break;

            case 'google-calendar':
                html = _renderGoogleCalendar(block);
                break;

            case 'client-relationship-graph':
                // Temporarily hidden until the relationship graph experience is fixed.
                html = '';
                break;

            default:
                html = '<div class="iface-block"><div class="iface-block-body"><div class="iface-empty">Unknown block type: ' + _esc(block.type) + '</div></div></div>';
        }
        return html;
    }

    function _flattenBlocks(blocks) {
        var result = [];
        var seenIds = {};
        function addBlock(b) {
            if (!b || seenIds[b.id]) return;
            seenIds[b.id] = true;
            result.push(b);
        }

        (blocks || []).forEach(function(b) {
            addBlock(b);
            if (b.children) {
                var page = _schema.pages.find(function(p) {
                    return p.blocks.some(function(pb) { return pb.id === b.id; });
                });
                if (page) {
                    b.children.forEach(function(cid) {
                        var cb = page.blocks.find(function(pb) { return pb.id === cid; });
                        addBlock(cb);
                    });
                }
            }
            if (b.tabs) {
                var page2 = _schema.pages.find(function(p) {
                    return p.blocks.some(function(pb) { return pb.id === b.id; });
                });
                if (page2) {
                    b.tabs.forEach(function(tab) {
                        var tb = page2.blocks.find(function(pb) { return pb.id === tab.blockId; });
                        addBlock(tb);
                    });
                }
            }
        });
        return result;
    }

    // ============ User Interactions ============

    function switchPage(pageId) {
        if (!_schema) return;
        // Redirect 'home' to the first real content page
        if (pageId === 'home') {
            var realPages = _getVisiblePages().filter(function(p) { return p.id !== 'home'; });
            pageId = realPages.length ? realPages[0].id : pageId;
        }
        var page = _schema.pages.find(function(p) { return p.id === pageId; });
        if (page && !_isPageVisibleToCurrentUser(page)) {
            _showToast('You do not have access to that page.');
            return;
        }
        _blockSearchState = {};
        _tablePaginationState = {};
        renderPage(pageId);
        if (_urlStateBootstrapped) persistUrlState();
    }

    function switchTab(blockId, tabId) {
        var block = document.querySelector('[data-block-id="' + blockId + '"]');
        if (!block) return;
        block.querySelectorAll('.iface-tab-btn').forEach(function(btn) {
            btn.classList.toggle('active', btn.getAttribute('data-tab') === tabId);
        });
        block.querySelectorAll('.iface-tab-panel').forEach(function(panel) {
            panel.classList.toggle('active', panel.getAttribute('data-tab-panel') === tabId);
        });
    }

    function onBlockSearch(blockId, query) {
        _blockSearchState[blockId] = query;
        // Preserve pageSize when resetting page to 0  without pageSize,
        // records.slice(NaN, NaN) returns [] and nothing renders.
        var existing = _tablePaginationState[blockId] || {};
        _tablePaginationState[blockId] = { page: 0, pageSize: existing.pageSize || 50 };
        // Debounce re-render  250ms avoids mid-typing DOM thrash while staying responsive
        clearTimeout(onBlockSearch._timer);
        onBlockSearch._timer = setTimeout(async function() {
            await renderPage(_activePage);
            if (_urlStateBootstrapped) persistUrlState();
            // Restore focus to the search input that was replaced by renderPage
            var el = document.querySelector('.iface-block-search[data-search-block="' + blockId + '"]');
            if (el) { el.focus(); el.selectionStart = el.selectionEnd = el.value.length; }
        }, 250);
    }

    function onGlobalSearch(query) {
        _globalSearchQuery = query;
        // Apply as search to all blocks
        if (_schema && _activePage) {
            var page = _schema.pages.find(function(p) { return p.id === _activePage; });
            if (page) {
                page.blocks.forEach(function(b) {
                    _blockSearchState[b.id] = query;
                    var existing = _tablePaginationState[b.id] || {};
                    _tablePaginationState[b.id] = { page: 0, pageSize: existing.pageSize || 50 };
                });
            }
        }
        clearTimeout(onGlobalSearch._timer);
        onGlobalSearch._timer = setTimeout(async function() {
            await renderPage(_activePage);
            if (_urlStateBootstrapped) persistUrlState();
            // Restore focus to global search input after DOM replacement
            var el = document.getElementById('iface-global-search');
            if (el) { el.focus(); el.selectionStart = el.selectionEnd = el.value.length; }
        }, 250);
    }

    function onFilterChange(blockId, filterId, value) {
        // Find the block and apply filter to segment
        if (!_schema || !_activePage) return;
        var page = _schema.pages.find(function(p) { return p.id === _activePage; });
        if (!page) return;
        var block = page.blocks.find(function(b) { return b.id === blockId; });
        if (!block || !block.filters) return;
        var filterDef = block.filters.find(function(f) { return f.id === filterId; });
        if (!filterDef) return;

        // Store active filter in block (applied via _applySegment)
        if (!block._activeFilters) block._activeFilters = {};
        if (value) {
            block._activeFilters[filterId] = { field: filterDef.field, op: 'contains', value: value };
        } else {
            delete block._activeFilters[filterId];
        }

        // Reset pagination when filter changes
        _tablePaginationState[blockId] = { page: 0, pageSize: (block.segment && block.segment.pageSize) || 50 };
        renderPage(_activePage);
        if (_urlStateBootstrapped) persistUrlState();
    }

    function onColumnSort(blockId, fieldName) {
        if (!_schema || !_activePage) return;
        var page = _schema.pages.find(function(p) { return p.id === _activePage; });
        if (!page) return;
        var block = page.blocks.find(function(b) { return b.id === blockId; });
        if (!block || !block.segment) return;
        var currentSort = block.segment.sort || {};
        if (currentSort.field === fieldName) {
            block.segment.sort = { field: fieldName, dir: currentSort.dir === 'asc' ? 'desc' : 'asc' };
        } else {
            block.segment.sort = { field: fieldName, dir: 'asc' };
        }
        _tablePaginationState[blockId] = { page: 0, pageSize: block.segment.pageSize || 50 };
        renderPage(_activePage);
        if (_urlStateBootstrapped) persistUrlState();
        // Persist sort preference to room data so all users see the same default
        if (_currentUserRole === 'admin') {
            saveSchema();
        }
    }

    function onPageChange(blockId, newPage) {
        if (newPage < 0) return;
        var ps = _tablePaginationState[blockId] || { page: 0, pageSize: 50 };
        ps.page = newPage;
        _tablePaginationState[blockId] = ps;
        renderPage(_activePage);
        if (_urlStateBootstrapped) persistUrlState();
    }

    async function caseNotesWidgetAction(blockId, action) {
        var state = _getCaseNotesWidgetState(blockId);
        if (action === 'load') {
            state.filters = _readCaseNotesWidgetForm(blockId);
            state.page = 1;
            state.lastQueryKey = '';
            state.status = 'Loading...';
        } else if (action === 'prev') {
            state.page = Math.max(1, Number(state.page || 1) - 1);
            state.lastQueryKey = '';
            state.status = 'Loading...';
        } else if (action === 'next') {
            state.page = Number(state.page || 1) + 1;
            state.lastQueryKey = '';
            state.status = 'Loading...';
        } else if (action === 'reset') {
            _caseNotesWidgetState[blockId] = null;
            _getCaseNotesWidgetState(blockId);
        } else if (action === 'copy') {
            state.filters = _readCaseNotesWidgetForm(blockId);
            var url = CASE_NOTES_WIDGET_ENDPOINT + '?' + _buildCaseNotesWidgetParams(state).toString();
            try {
                await navigator.clipboard.writeText(url);
                _showToast('Copied query URL to clipboard.');
            } catch (e) {
                _showToast('Clipboard unavailable.');
            }
        }
        renderPage(_activePage);
    }

    async function openClientFromCaseNote(buttonEl) {
        if (!buttonEl) return;
        var recordId = buttonEl.getAttribute('data-client-record-id');
        if (!recordId) return;
        var clientsTableId = (typeof CaseNotesAPI !== 'undefined' && CaseNotesAPI.getClientsTableId)
            ? CaseNotesAPI.getClientsTableId()
            : _resolveTableId({ tableNamePattern: 'client info', fallbackTablePattern: 'client' });
        if (!clientsTableId) {
            _showToast('Clients table is not available in this workspace.');
            return;
        }
        switchPage('clients');
        try {
            await renderPage('clients');
        } catch (e) {
            // best effort
        }
        setTimeout(function() {
            openRecordProfile(clientsTableId, recordId);
        }, 120);
    }

    // Check if a field value (string, array, or nested object) overlaps with an ID set.
    function _fieldValueOverlaps(value, idSet) {
        if (value == null || value === '') return false;
        if (typeof value === 'string') return idSet.has(value.trim());
        if (Array.isArray(value)) {
            for (var vi = 0; vi < value.length; vi++) {
                if (_fieldValueOverlaps(value[vi], idSet)) return true;
            }
            return false;
        }
        if (typeof value === 'object') {
            if (typeof value.id === 'string' && idSet.has(value.id.trim())) return true;
            if (typeof value.recordId === 'string' && idSet.has(value.recordId.trim())) return true;
            return false;
        }
        return false;
    }

    // Filter rows from a source table to only those linked to a specific client,
    // walking the edge path backwards from the client table to the source table.
    function _filterRowsByEdgePath(sourceRows, path, clientRecordId, allTableRows) {
        if (!path || !path.length || !sourceRows.length) return sourceRows;

        // Start from client and walk backwards through intermediate tables
        var targetIds = new Set();
        targetIds.add(clientRecordId);

        for (var i = path.length - 1; i >= 1; i--) {
            var edge = path[i];
            var intermediateRows = allTableRows[edge.fromTableId];
            if (!intermediateRows || !intermediateRows.length) return sourceRows; // can't resolve, include all
            var nextTargetIds = new Set();
            for (var r = 0; r < intermediateRows.length; r++) {
                var fields = intermediateRows[r].fields || {};
                // Check both field ID and field name keys
                var val = fields[edge.fieldId];
                if (val === undefined) val = fields[edge.fieldName];
                if (_fieldValueOverlaps(val, targetIds)) {
                    var rid = intermediateRows[r].recordId;
                    if (rid) nextTargetIds.add(rid);
                }
            }
            if (!nextTargetIds.size) return [];
            targetIds = nextTargetIds;
        }

        // Final step: filter source rows using the first edge's field
        var firstEdge = path[0];
        var filtered = [];
        for (var j = 0; j < sourceRows.length; j++) {
            var fields = sourceRows[j].fields || {};
            var val = fields[firstEdge.fieldId];
            if (val === undefined) val = fields[firstEdge.fieldName];
            if (_fieldValueOverlaps(val, targetIds)) {
                filtered.push(sourceRows[j]);
            }
        }
        // Safety fallback: if filtering produced nothing, include all rows
        // (edge metadata may be stale; client-profile.html will re-filter)
        return filtered.length > 0 ? filtered : sourceRows;
    }

    async function _buildClientProfileContext(recordId) {
        // Use actual Airtable table names (lowercased)  includes display tables
        // plus lookup tables needed to resolve linked record IDs to names.
        var REQUIRED_TABLES = {
            // Primary profile tables
            'client info': true,
            'case master view': true,
            'applications': true,
            'update tracker': true,
            'global eads': true,
            'events': true,
            'imported table 4': true,
            'support comments': true,
            'relationships': true,
            'deadlines 2.0': true,
            // Lookup / resolution tables
            'users': true,
            'locations': true,
            'status': true,
            'event type': true,
            'hearing type': true,
            'activity dictionary': true,
            'activity sub types': true,
            'custodian': true,
            'abandoning parent': true,
            'sij engagement interviews': true,
            'foia request': true,
            'office locations': true,
            'templates': true,
            'placeholder fields': true
        };

        // Lookup tables are small reference data used for record ID resolution 
        // always include all their records in the snapshot.
        var LOOKUP_TABLES = {
            'users': true, 'locations': true, 'status': true, 'event type': true,
            'hearing type': true, 'activity dictionary': true, 'activity sub types': true,
            'custodian': true, 'abandoning parent': true, 'office locations': true,
            'templates': true, 'placeholder fields': true, 'sij engagement interviews': true,
            'foia request': true
        };

        var data = {};
        var tableIdToName = {};
        var tableIds = Object.keys(META_TABLES || {}).filter(function(tableId) {
            var tableName = resolveTableName(tableId).trim().toLowerCase();
            if (REQUIRED_TABLES[tableName]) {
                tableIdToName[tableId] = resolveTableName(tableId);
                return true;
            }
            return false;
        });

        //  Phase 1: Fetch all tables in parallel batches 
        // Previously sequential (~100ms  25 tables = ~2.5s).
        // Now batched 6-wide (~100ms  ceil(25/6) batches  ~500ms).
        var BATCH_SIZE = 6;
        var allTableRows = {}; // tableId -> rows
        for (var b = 0; b < tableIds.length; b += BATCH_SIZE) {
            var batch = tableIds.slice(b, b + BATCH_SIZE);
            await Promise.all(batch.map(function(tid) {
                return _getTableRecords(tid).then(function(rows) {
                    allTableRows[tid] = rows;
                });
            }));
        }

        //  Phase 2: Use edges graph to pre-filter data tables 
        // Instead of sending ALL records from every table in the snapshot,
        // use the edges (link graph) to include only records related to
        // this specific client. Lookup tables are kept in full since they're
        // small reference data needed for ID  display-name resolution.
        var clientTableId = null;
        for (var ci = 0; ci < tableIds.length; ci++) {
            if ((tableIdToName[tableIds[ci]] || '').toLowerCase() === 'client info') {
                clientTableId = tableIds[ci];
                break;
            }
        }

        var edges = [];
        var tablePathMap = {};
        try { edges = await getAllEdges(); } catch (e) { /* edges unavailable, skip filtering */ }
        if (clientTableId && edges.length) {
            tablePathMap = computeLinkedRecordTableMap(edges, clientTableId);
        }

        // Build tableIdMap so client-profile.html can resolve tableId  tableName
        var tableIdMap = {};
        for (var ti = 0; ti < tableIds.length; ti++) {
            var tableId = tableIds[ti];
            var tableName = tableIdToName[tableId] || tableId;
            var rows = allTableRows[tableId] || [];
            var tNameLower = tableName.toLowerCase();
            tableIdMap[tableId] = tableName;

            if (tNameLower === 'client info' || LOOKUP_TABLES[tNameLower]) {
                // Client info and lookup tables: include all records
                data[tableName] = rows;
                continue;
            }

            // Data tables: filter to client-related records via edge path
            var pathInfo = tablePathMap[tableId];
            if (pathInfo && pathInfo.path && pathInfo.path.length > 0) {
                var filtered = _filterRowsByEdgePath(rows, pathInfo.path, recordId, allTableRows);
                data[tableName] = filtered;
            } else {
                // No edge path discovered  include all (safe fallback)
                data[tableName] = rows;
            }
        }

        return {
            version: 1,
            capturedAt: Date.now(),
            clientId: recordId,
            data: data,
            tableIdMap: tableIdMap
        };
    }

    async function openClientProfilePage(recordId, event) {
        if (!recordId) return;
        if (event && event.target && event.target.closest('button, a, input, select, textarea')) {
            return;
        }

        try {
            var snapshot = await _buildClientProfileContext(recordId);
            sessionStorage.setItem('amino.clientProfile.context.v1', JSON.stringify(snapshot));
        } catch (e) {
            console.warn('[Interface] Failed to persist client profile context:', e.message);
        }

        try {
            _saveRecentProfileRecord({
                recordId: recordId,
                tableId: (_resolveTableByPattern('client info') || _resolveTableByPattern('client') || {}).id || '',
                title: recordId,
                subtitle: 'Recent client'
            });
        } catch (e) {}

        var targetUrl = 'client-profile.html?clientId=' + encodeURIComponent(recordId);
        window.location.href = targetUrl;
    }

    // Navigate to a page tab (used by quick-action buttons)
    function navigatePage(pageId) {
        if (!pageId) return;
        switchPage(pageId);
    }

    // Inbox: switch active client in the case notes inbox
    function _selectInboxClient(blockId, clientKey) {
        var blockEl = document.querySelector('[data-block-id="' + blockId + '"]');
        if (!blockEl) return;

        // Update active state in the list
        var items = blockEl.querySelectorAll('.iface-inbox-item');
        items.forEach(function(item) {
            item.classList.toggle('active', item.getAttribute('data-inbox-client') === clientKey);
        });

        // Re-render the detail panel with the selected client's notes
        var state = _getCaseNotesWidgetState(blockId);
        _buildCaseNotesClientIndex().then(function(clientIndex) {
            var clientGroups = {};
            state.items.forEach(function(note) {
                var clientInfo = _resolveCaseNoteClientInfo(note, clientIndex);
                var key = clientInfo.recordId || clientInfo.joinKey || 'unlinked';
                if (!clientGroups[key]) {
                    clientGroups[key] = {
                        displayName: clientInfo.displayName || 'Unknown client',
                        joinKey: clientInfo.joinKey || '',
                        recordId: clientInfo.recordId || '',
                        notes: []
                    };
                }
                var date = _pickCaseNoteValue(note, ['Date', 'date', 'created_at', 'updated_at', 'Modified']);
                var description = _pickCaseNoteValue(note, ['Description', 'description', 'note', 'body', 'details']);
                var category = _pickCaseNoteValue(note, ['Type', 'type', 'Activity', 'activity']) || 'Case Note';
                clientGroups[key].notes.push({ date: date || '', description: description || '', category: category });
            });

            var group = clientGroups[clientKey];
            if (!group) return;

            // Sort chronologically (oldest first)
            group.notes.sort(function(a, b) {
                var da = a.date ? new Date(a.date).getTime() : 0;
                var db = b.date ? new Date(b.date).getTime() : 0;
                return da - db;
            });

            var detailEl = blockEl.querySelector('.iface-inbox-detail');
            if (!detailEl) return;

            var html = '<div class="iface-inbox-detail-header">';
            html += '<h3>' + _esc(group.displayName) + '</h3>';
            html += '<div class="inbox-meta">';
            if (group.joinKey) html += _esc(group.joinKey) + ' \u00B7 ';
            html += group.notes.length + ' note' + (group.notes.length !== 1 ? 's' : '');
            if (group.recordId) {
                html += ' \u00B7 <a href="client-profile.html?clientId=' + encodeURIComponent(group.recordId) + '" target="_blank" rel="noopener" style="color:var(--iface-accent);text-decoration:none;font-weight:500;">Open profile \u2192</a>';
            }
            html += '</div></div>';
            html += '<div class="iface-inbox-messages">';
            group.notes.forEach(function(note) {
                html += '<div class="iface-inbox-msg">';
                html += '<div class="iface-inbox-msg-header">';
                html += '<span class="iface-inbox-msg-author">' + _esc(note.category) + '</span>';
                html += '<span class="iface-inbox-msg-time">' + _esc(note.date) + '</span>';
                html += '</div>';
                html += '<div class="iface-inbox-msg-body">' + _formatCaseNoteDescriptionHtml(note.description) + '</div>';
                html += '<div class="iface-inbox-msg-tags"><span class="iface-inbox-msg-tag">' + _esc(note.category) + '</span></div>';
                html += '</div>';
            });
            html += '</div>';
            detailEl.innerHTML = html;

            // Scroll to bottom (newest messages at bottom)
            var messagesEl = detailEl.querySelector('.iface-inbox-messages');
            if (messagesEl) messagesEl.scrollTop = messagesEl.scrollHeight;
        });
    }

    // ============ Admin: Table Settings ============

    function toggleTableSettings(blockId) {
        if (_currentUserRole !== 'admin') return;
        _tableSettingsOpen[blockId] = !_tableSettingsOpen[blockId];
        renderPage(_activePage);
    }

    function moveColumn(blockId, colIdx, direction) {
        if (_currentUserRole !== 'admin') return;
        var block = _findBlockById(blockId);
        if (!block || !block.columns) return;
        var newIdx = colIdx + direction;
        if (newIdx < 0 || newIdx >= block.columns.length) return;
        var temp = block.columns[colIdx];
        block.columns[colIdx] = block.columns[newIdx];
        block.columns[newIdx] = temp;
        renderPage(_activePage);
    }

    function removeColumn(blockId, colIdx) {
        if (_currentUserRole !== 'admin') return;
        var block = _findBlockById(blockId);
        if (!block || !block.columns) return;
        block.columns.splice(colIdx, 1);
        renderPage(_activePage);
    }

    function addColumn(blockId) {
        if (_currentUserRole !== 'admin') return;
        var sel = document.getElementById('iface-add-col-' + blockId);
        if (!sel || !sel.value) return;
        var block = _findBlockById(blockId);
        if (!block) return;
        if (!block.columns) block.columns = [];
        var fieldId = sel.value;
        // Resolve field name from META_FIELDS
        var fieldName = fieldId;
        var tableId = _resolveTableId(block.source);
        if (tableId && typeof META_FIELDS !== 'undefined' && META_FIELDS[tableId] && META_FIELDS[tableId][fieldId]) {
            fieldName = META_FIELDS[tableId][fieldId].fieldName || fieldId;
        }
        block.columns.push({ field: fieldName, label: fieldName, width: 160 });
        renderPage(_activePage);
    }

    async function saveTableSettings(blockId) {
        if (_currentUserRole !== 'admin') return;
        var block = _findBlockById(blockId);
        if (!block) return;

        // Read sort settings from the panel
        var sortFieldEl = document.getElementById('iface-sort-field-' + blockId);
        var sortDirEl = document.getElementById('iface-sort-dir-' + blockId);
        var pageSizeEl = document.getElementById('iface-pagesize-' + blockId);

        if (!block.segment) block.segment = { op: 'SEG' };
        if (sortFieldEl && sortFieldEl.value) {
            block.segment.sort = { field: sortFieldEl.value, dir: (sortDirEl && sortDirEl.value) || 'desc' };
        }
        if (pageSizeEl) {
            block.segment.pageSize = parseInt(pageSizeEl.value, 10) || 50;
        }

        await saveSchema();
        _tableSettingsOpen[blockId] = false;
        _tablePaginationState[blockId] = { page: 0, pageSize: block.segment.pageSize || 50 };
        renderPage(_activePage);
        _showToast('Table settings saved');
    }

    function _findBlockById(blockId) {
        if (!_schema || !_schema.pages) return null;
        for (var i = 0; i < _schema.pages.length; i++) {
            var blocks = _schema.pages[i].blocks || [];
            for (var j = 0; j < blocks.length; j++) {
                if (blocks[j].id === blockId) return blocks[j];
            }
        }
        return null;
    }

    // ============ Admin: Edit Mode ============

    function toggleEditMode() {
        if (_currentUserRole !== 'admin') return;
        _editMode = !_editMode;
        var btn = document.getElementById('iface-edit-toggle');
        if (btn) btn.classList.toggle('active', _editMode);
        renderPage(_activePage);
    }

    async function removeBlock(blockId) {
        if (_currentUserRole !== 'admin' || !_editMode) return;
        if (!confirm('Remove this block from the page?')) return;
        var page = _schema.pages.find(function(p) { return p.id === _activePage; });
        if (!page) return;
        page.blocks = page.blocks.filter(function(b) { return b.id !== blockId; });
        // Also remove from any column children
        page.blocks.forEach(function(b) {
            if (b.children) b.children = b.children.filter(function(c) { return c !== blockId; });
            if (b.tabs) b.tabs = b.tabs.filter(function(t) { return t.blockId !== blockId; });
        });
        await saveSchema();
        renderPage(_activePage);
    }

    async function addPage() {
        if (_currentUserRole !== 'admin') return;
        var name = prompt('New page name:');
        if (!name) return;
        var baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '') || 'page';
        var id = baseId;
        var counter = 2;
        while ((_schema.pages || []).some(function(p) { return p.id === id; })) {
            id = baseId + '-' + counter;
            counter += 1;
        }
        var roles = _rolePickerPrompt(['all']);
        if (roles === null) return;
        _schema.pages.push({
            id: id,
            label: name,
            icon: 'page',
            visibleToRoles: roles,
            blocks: []
        });
        await saveSchema();
        switchPage(id);
    }

    async function editPagePermissions(pageId) {
        if (_currentUserRole !== 'admin' || !_schema) return;
        var page = _schema.pages.find(function(p) { return p.id === pageId; });
        if (!page) return;
        var roles = _normalizePageRoles(page);
        var nextRoles = _rolePickerPrompt(roles);
        if (nextRoles === null) return;
        page.visibleToRoles = nextRoles;
        await saveSchema();
        renderPage(_activePage);
    }

    // ============ Toast ============

    function _showToast(msg) {
        var toast = document.createElement('div');
        toast.style.cssText = 'position:fixed;bottom:20px;right:20px;background:var(--bg-elevated);color:var(--text-primary);border:1px solid var(--border-primary);border-radius:var(--radius-md);padding:10px 16px;font-size:13px;z-index:9999;box-shadow:var(--shadow-md);';
        toast.textContent = msg;
        document.body.appendChild(toast);
        setTimeout(function() { toast.remove(); }, 3000);
    }

    // ============ Initialization ============

    async function init() {
        if (_initialized) return;
        _initialized = true;
        var t0 = performance.now();

        // Load schema and pre-warm the most common table data in parallel.
        // The schema load finds/creates the interface room and reads configuration.
        // Meanwhile, we can start loading the client table data since it's almost
        // always the first page users see.
        var preWarmPromise = _preWarmClientData();
        await loadSchema();
        console.log('[Interface] Schema loaded in', Math.round(performance.now() - t0), 'ms');

        var visiblePages = _getVisiblePages().filter(function(p) { return p.id !== 'home'; });
        _activePage = visiblePages.length ? visiblePages[0].id : null;

        // Set admin visibility
        var editBtn = document.getElementById('iface-edit-toggle');
        if (editBtn) {
            editBtn.classList.toggle('is-admin', _currentUserRole === 'admin');
        }

        // Set avatar initials
        var avatarEl = document.getElementById('iface-avatar');
        if (avatarEl) avatarEl.textContent = _getUserInitials();

        // Wait for pre-warm to complete before rendering (data will be cached)
        try { await preWarmPromise; } catch (e) {}

        if (_activePage) {
            await renderPage(_activePage);
        }
        console.log('[Interface] First render in', Math.round(performance.now() - t0), 'ms');

        // Listen for data updates  clear both Interface table-data cache
        // and the shared record LRU cache so re-renders fetch fresh data
        // through the same pipeline the Database View uses.
        window.addEventListener('amino:record-update', function() {
            _tableDataCache = {};
            _ifaceSearchTextCache = {};
            clearRecordCache();
            if (_currentApp === 'interface' && _activePage) {
                clearTimeout(init._refreshTimer);
                init._refreshTimer = setTimeout(function() { renderPage(_activePage); }, 1000);
            }
        });
        window.addEventListener('amino:record-updated', function() {
            _tableDataCache = {};
            _ifaceSearchTextCache = {};
            clearRecordCache();
            if (_currentApp === 'interface' && _activePage) {
                clearTimeout(init._refreshTimer);
                init._refreshTimer = setTimeout(function() { renderPage(_activePage); }, 400);
            }
        });
        window.addEventListener('amino:sync', function() {
            _tableDataCache = {};
            _ifaceSearchTextCache = {};
            clearRecordCache();
            if (_currentApp === 'interface' && _activePage) {
                clearTimeout(init._refreshTimer);
                init._refreshTimer = setTimeout(function() { renderPage(_activePage); }, 1000);
            }
        });

        console.log('[Interface] Initialized with', _schema.pages.length, 'pages');
    }

    function setUrlState(state) {
        if (!state) return;
        if (state.page) _activePage = state.page;
        if (typeof state.search === 'string' && state.search) {
            _globalSearchQuery = state.search;
            _blockSearchState = _blockSearchState || {};
            if (_schema && _activePage) {
                var page = _schema.pages.find(function(p) { return p.id === _activePage; });
                if (page) {
                    page.blocks.forEach(function(b) { _blockSearchState[b.id] = state.search; });
                }
            }
        }
    }

    function getUrlState() {
        return { page: _activePage || '', search: _globalSearchQuery || '' };
    }

    // ============ Public API ============

    return {
        init: init,
        loadSchema: loadSchema,
        saveSchema: saveSchema,
        renderPage: renderPage,
        switchPage: switchPage,
        switchTab: switchTab,
        onBlockSearch: onBlockSearch,
        onGlobalSearch: onGlobalSearch,
        onFilterChange: onFilterChange,
        onColumnSort: onColumnSort,
        onPageChange: onPageChange,
        caseNotesWidgetAction: caseNotesWidgetAction,
        openClientFromCaseNote: openClientFromCaseNote,
        openClientProfilePage: openClientProfilePage,
        navigatePage: navigatePage,
        _selectInboxClient: _selectInboxClient,
        onClientGraphClientChange: onClientGraphClientChange,
        openClientRelationshipGraph: openClientRelationshipGraph,
        setUrlState: setUrlState,
        getUrlState: getUrlState,
        toggleEditMode: toggleEditMode,
        toggleTableSettings: toggleTableSettings,
        moveColumn: moveColumn,
        removeColumn: removeColumn,
        addColumn: addColumn,
        saveTableSettings: saveTableSettings,
        removeBlock: removeBlock,
        addPage: addPage,
        editPagePermissions: editPagePermissions,
        _showToast: _showToast,
        _showFilterDropdown: _showFilterDropdown,
        _clearAllFilters: _clearAllFilters,
        _filterEventsSidebar: _filterEventsSidebar,
        _toggleAttorneyFilter: _toggleAttorneyFilter,
        _showGoogleCalendar: _showGoogleCalendar,
        getInterfaceRoomId: function() { return _findOrCreateInterfaceRoom(); },
        get schema() { return _schema; },
        get activePage() { return _activePage; },
        get editMode() { return _editMode; }
    };
})();

// ============ App Navigation & Settings ============

var _currentApp = 'home'; // 'home' | 'database' | 'interface' | 'settings'
var _currentUserRole = 'unknown';
var _settingsOrgSpaceId = null;
var _settingsMembers = []; // Cached member list for settings
var _settingsRooms = []; // Cached room list (tables with matrix_room_id)
var _settingsPermissionGroups = { groups: [], assignments: {} }; // Shared room permission structures
var _urlStateBootstrapped = false;

function canAccessDatabaseApp() {
    var role = String(_currentUserRole || '').toLowerCase();
    return role === 'admin' || role === 'staff';
}

function applyAppNavPermissions() {
    var dbBtn = document.getElementById('app-nav-database');
    if (!dbBtn) return;
    var allowed = canAccessDatabaseApp();
    dbBtn.style.display = allowed ? '' : 'none';
    dbBtn.setAttribute('aria-hidden', allowed ? 'false' : 'true');
}

function _setUrlParam(params, key, value) {
    if (value == null || value === '') params.delete(key);
    else params.set(key, String(value));
}

function _encodeUrlJson(value) {
    try { return encodeURIComponent(JSON.stringify(value)); } catch (e) { return ''; }
}

function _decodeUrlJson(raw, fallback) {
    if (!raw) return fallback;
    try { return JSON.parse(decodeURIComponent(raw)); } catch (e) { return fallback; }
}

function persistUrlState() {
    if (typeof window === 'undefined' || !window.history || !window.location) return;
    var params = new URLSearchParams(window.location.search || '');
    _setUrlParam(params, 'app', _currentApp || 'home');

    if (_currentApp === 'database') {
        _setUrlParam(params, 'table', currentTable || '');
        _setUrlParam(params, 'view', currentView || '');
        _setUrlParam(params, 'search', currentSearchQuery || '');
        _setUrlParam(params, 'page', currentPage || 0);
        _setUrlParam(params, 'filters', currentFilters && hasFilterConditions(currentFilters) ? _encodeUrlJson(currentFilters) : '');
    } else {
        params.delete('table');
        params.delete('view');
        params.delete('search');
        params.delete('page');
        params.delete('filters');
    }

    if (_currentApp === 'interface') {
        var ifaceState = (typeof InterfaceApp !== 'undefined' && InterfaceApp.getUrlState)
            ? InterfaceApp.getUrlState()
            : null;
        _setUrlParam(params, 'ifacePage', ifaceState && ifaceState.page ? ifaceState.page : '');
        _setUrlParam(params, 'ifaceSearch', ifaceState && ifaceState.search ? ifaceState.search : '');
    } else {
        params.delete('ifacePage');
        params.delete('ifaceSearch');
    }

    var next = window.location.pathname + (params.toString() ? '?' + params.toString() : '') + window.location.hash;
    window.history.replaceState(null, '', next);
}

function getUrlState() {
    var params = new URLSearchParams(window.location.search || '');
    return {
        app: params.get('app') || '',
        table: params.get('table') || '',
        view: params.get('view') || '',
        search: params.get('search') || '',
        page: parseInt(params.get('page') || '0', 10) || 0,
        filters: _decodeUrlJson(params.get('filters'), []),
        ifacePage: params.get('ifacePage') || '',
        ifaceSearch: params.get('ifaceSearch') || ''
    };
}

function switchApp(appName) {
    if (appName === 'database' && !canAccessDatabaseApp()) {
        appName = 'interface';
    }

    _currentApp = appName;

    // Update nav button states
    document.querySelectorAll('.app-nav-btn').forEach(function(btn) {
        btn.classList.remove('active');
    });
    var activeBtn = document.getElementById('app-nav-' + appName);
    if (activeBtn) activeBtn.classList.add('active');

    // Toggle sub-app visibility
    var homeApp = document.getElementById('home-app');
    var dbApp = document.getElementById('database-app');
    var ifApp = document.getElementById('interface-app');
    var fmApp = document.getElementById('forms-app');
    var stApp = document.getElementById('settings-app');

    homeApp.classList.remove('visible');
    dbApp.style.display = 'none';
    ifApp.classList.remove('visible');
    if (fmApp) fmApp.classList.remove('visible');
    stApp.classList.remove('visible');

    if (appName === 'home') {
        homeApp.classList.add('visible');
        populateHomePage();
    } else if (appName === 'database') {
        dbApp.style.display = 'flex';
    } else if (appName === 'interface') {
        ifApp.classList.add('visible');
        InterfaceApp.init();
    } else if (appName === 'forms') {
        if (fmApp) fmApp.classList.add('visible');
        FormsApp.init();
    } else if (appName === 'settings') {
        stApp.classList.add('visible');
        loadSettingsData();
    }

    if (_urlStateBootstrapped) persistUrlState();
}

// ============ Home Page Data Population ============

// Cache for the current user's Matrix profile (display name, email)
var _cachedUserProfile = null;

function openHomeStat(kind) {
    if (kind === 'tables' || kind === 'records') {
        switchApp('database');
        return;
    }

    if (kind === 'case-notes') {
        var caseNotesTableId = (typeof CaseNotesAPI !== 'undefined' && CaseNotesAPI.getCaseNotesTableId)
            ? CaseNotesAPI.getCaseNotesTableId()
            : null;

        if (!caseNotesTableId) {
            showToast('warning', 'Case Notes table not found');
            return;
        }

        switchApp('database');
        setTimeout(function() {
            showTable(caseNotesTableId).catch(function(err) {
                console.warn('[Home] Could not open Case Notes table:', err);
                showToast('error', 'Could not open Case Notes');
            });
        }, 0);
        return;
    }

    if (kind === 'data-source') {
        if (MatrixClient.isLoggedIn()) {
            showToast('success', 'Connected to Matrix (Live)');
        } else {
            showSynapseLoginScreen();
        }
    }
}

function populateHomePage() {
    // Display name / avatar  use cached profile if available, fall back to userId localpart
    var session = _loadSynapseSession();
    var userId = session ? session.userId : '';
    var displayName = '';
    if (_cachedUserProfile && _cachedUserProfile.displayName) {
        displayName = _cachedUserProfile.displayName;
    } else {
        displayName = userId ? userId.replace(/@([^:]+):.*/, '$1') : 'User';
        displayName = displayName.charAt(0).toUpperCase() + displayName.slice(1);
    }

    var initials = displayName.substring(0, 2).toUpperCase();
    var avatarEl = document.getElementById('home-avatar');
    if (avatarEl) avatarEl.textContent = initials;

    // Sync quick stats for the route chooser home
    var tableCountEl = document.getElementById('home-table-count');
    var recordCountEl = document.getElementById('home-record-count');
    var caseNotesCountEl = document.getElementById('home-casenotes-count');
    var syncStatusEl = document.getElementById('home-sync-status');

    var tableIds = Object.keys(META_TABLES || {});
    if (tableCountEl) tableCountEl.textContent = String(tableIds.length);

    var totalRecords = 0;
    for (var i = 0; i < tableIds.length; i++) {
        var tid = tableIds[i];
        if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tid]) {
            totalRecords += Object.keys(window.IN_MEMORY_DATA[tid]).length;
        }
    }
    if (recordCountEl) recordCountEl.textContent = totalRecords.toLocaleString();

    var caseNotesTableId = null;
    for (var j = 0; j < tableIds.length; j++) {
        var table = META_TABLES[tableIds[j]];
        var name = table && table.tableName ? String(table.tableName).toLowerCase() : '';
        if (name === 'casenotes' || name === 'case notes' || name === 'case note') {
            caseNotesTableId = tableIds[j];
            break;
        }
    }
    var caseNotesCount = 0;
    if (caseNotesTableId && window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[caseNotesTableId]) {
        caseNotesCount = Object.keys(window.IN_MEMORY_DATA[caseNotesTableId]).length;
    }
    if (caseNotesCountEl) caseNotesCountEl.textContent = caseNotesCount.toLocaleString();

    // Count form-type views across all tables
    var formsCountEl = document.getElementById('home-forms-count');
    if (formsCountEl) {
        var formsCount = 0;
        var allTableIds = Object.keys(META_VIEWS || {});
        for (var fi = 0; fi < allTableIds.length; fi++) {
            var views = META_VIEWS[allTableIds[fi]] || {};
            var vids = Object.keys(views);
            for (var fj = 0; fj < vids.length; fj++) {
                if (views[vids[fj]] && views[vids[fj]].viewType === 'form') formsCount++;
            }
        }
        formsCountEl.textContent = String(formsCount);
    }

    if (syncStatusEl) {
        if (_isOnlineOnlyMode()) {
            syncStatusEl.textContent = 'Online';
        } else {
            syncStatusEl.textContent = MatrixClient.isLoggedIn() ? 'Live' : 'Local';
        }
    }

    // Async: fetch real display name from Matrix profile if not cached
    if (!_cachedUserProfile && userId && MatrixClient.isLoggedIn()) {
        MatrixClient.getProfile(userId).then(function(profile) {
            if (profile && profile.displayname) {
                _cachedUserProfile = { userId: userId, displayName: profile.displayname, email: '' };
                refreshDisplayName(profile.displayname);
                var av = document.getElementById('home-avatar');
                if (av) av.textContent = profile.displayname.substring(0, 2).toUpperCase();
            }
            return MatrixClient.getAccountData('law.firm.user.email');
        }).then(function(emailData) {
            if (emailData && emailData.email && _cachedUserProfile) {
                _cachedUserProfile.email = emailData.email;
            }
        }).catch(function(e) {
            console.warn('[Home] Could not fetch profile:', e);
        });
    }
}


function _timeAgo(ts) {
    var diff = Date.now() - ts;
    if (diff < 60000) return 'just now';
    if (diff < 3600000) return Math.floor(diff / 60000) + ' min ago';
    if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
    return Math.floor(diff / 86400000) + 'd ago';
}

function populateHomeActivity() {
    // Home page now uses the three-column dashboard layout.
    // Activity feed has been replaced by case notes, communications, and calendar panels.
}

function showAppNav() {
    document.getElementById('app-nav').classList.add('visible');
    document.getElementById('file-header').classList.add('visible');
}

function hideAppNav() {
    document.getElementById('app-nav').classList.remove('visible');
    document.getElementById('file-header').classList.remove('visible');
}

function updateAppNavUser() {
    var session = _loadSynapseSession();
    var username = '';
    if (_cachedUserProfile && _cachedUserProfile.displayName) {
        username = _cachedUserProfile.displayName;
    } else {
        username = session ? session.userId : '';
    }
    document.getElementById('app-nav-username').textContent = username;
    var roleEl = document.getElementById('app-nav-role');
    roleEl.textContent = _currentUserRole;
    roleEl.className = 'app-nav-user-role';
    if (_currentUserRole === 'admin') roleEl.classList.add('admin');
    else if (_currentUserRole === 'staff') roleEl.classList.add('staff');
    var fhRole = document.getElementById('file-header-role');
    if (fhRole) fhRole.textContent = _currentUserRole || 'admin';
    applyAppNavPermissions();
}

async function detectAndStoreUserRole() {
    try {
        if (!MatrixClient.isLoggedIn()) return;

        // Hardcoded admin users always get admin role, even before org space is found
        if (MatrixClient.isHardcodedAdmin()) {
            _currentUserRole = 'admin';
        }

        var orgSpaceId = await MatrixClient.findOrgSpace();
        if (orgSpaceId) {
            _settingsOrgSpaceId = orgSpaceId;
            _currentUserRole = await MatrixClient.detectUserRole(orgSpaceId);
        }
    } catch (e) {
        console.warn('[AppNav] Could not detect user role:', e);
    }
    updateAppNavUser();
}

async function appNavLogout() {
    if (!confirm('Sign out of Amino?')) return;
    hideAppNav();
    // Encrypt plaintext records before clearing the key  the encrypted
    // IndexedDB data is retained on device (AES-GCM-256, unreadable without
    // the user's password) so the next login can skip re-hydration.
    await AminoData.logout(false); // Encrypts data-layer records, keeps data for offline access
    if (_deferEncryptionUI && encryptionKey && db) {
        try { await encryptAllUIRecords(); } catch (e) { console.error('[appNavLogout] encrypt failed:', e); }
    }
    _deferEncryptionUI = false;
    clearSessionKey();
    encryptionKey = null;
    encryptionEnabled = false;
    _isOfflineSession = false;
    hideOfflineModeBanner();
    synapseLogout();
    location.reload();
}

// ============ Settings: Tab Switching ============

function switchSettingsTab(tab) {
    document.querySelectorAll('.settings-tab').forEach(function(t) { t.classList.remove('active'); });
    document.getElementById('settings-tab-' + tab).classList.add('active');

    document.getElementById('settings-panel-roles').style.display = tab === 'roles' ? 'block' : 'none';
    document.getElementById('settings-panel-rooms').style.display = tab === 'rooms' ? 'block' : 'none';
    document.getElementById('settings-panel-relationships').style.display = tab === 'relationships' ? 'block' : 'none';
    document.getElementById('settings-panel-preferences').style.display = tab === 'preferences' ? 'block' : 'none';

    if (tab === 'preferences') {
        initPreferencesTab();
    }
    if (tab === 'relationships') {
        initRelationshipsTab();
    }
}

// ============ Settings: Preferences Tab ============

function initPreferencesTab() {
    var cb = document.getElementById('pref-offline-sync-toasts');
    if (cb) {
        cb.checked = UserPreferences.get('showOfflineSyncToasts') !== false;
    }
    var confirmInlineEditCb = document.getElementById('pref-confirm-inline-cell-edit');
    if (confirmInlineEditCb) {
        confirmInlineEditCb.checked = UserPreferences.get('confirmInlineCellEdit') !== false;
    }
    _initOnlineOnlyModeUI();
    loadUserProfile();
}

async function loadUserProfile() {
    var loadingEl = document.getElementById('profile-loading');
    var formEl = document.getElementById('profile-form');
    var nameInput = document.getElementById('profile-display-name');
    var emailInput = document.getElementById('profile-email');
    var userIdEl = document.getElementById('profile-user-id');

    if (!loadingEl || !formEl) return;

    // Show cached data immediately if available
    if (_cachedUserProfile) {
        nameInput.value = _cachedUserProfile.displayName || '';
        emailInput.value = _cachedUserProfile.email || '';
        userIdEl.textContent = _cachedUserProfile.userId || '';
        loadingEl.style.display = 'none';
        formEl.style.display = 'block';
    }

    try {
        var userId = MatrixClient.getUserId();
        if (!userId) {
            loadingEl.textContent = 'Not logged in.';
            return;
        }

        // Fetch profile, 3pids, and account-data email in parallel
        var profilePromise = MatrixClient.getProfile(userId);
        var threepidPromise = MatrixClient.get3pids();
        var emailDataPromise = MatrixClient.getAccountData('law.firm.user.email');
        var results = await Promise.all([profilePromise, threepidPromise, emailDataPromise]);
        var profile = results[0];
        var threepidData = results[1];
        var emailAccountData = results[2];

        var displayName = (profile && profile.displayname) || '';
        var email = '';
        // Prefer 3pid email (server-verified), fall back to account data
        if (threepidData && threepidData.threepids) {
            for (var i = 0; i < threepidData.threepids.length; i++) {
                if (threepidData.threepids[i].medium === 'email') {
                    email = threepidData.threepids[i].address;
                    break;
                }
            }
        }
        if (!email && emailAccountData && emailAccountData.email) {
            email = emailAccountData.email;
        }

        _cachedUserProfile = { userId: userId, displayName: displayName, email: email };

        nameInput.value = displayName;
        emailInput.value = email;
        userIdEl.textContent = userId;
        loadingEl.style.display = 'none';
        formEl.style.display = 'block';
    } catch (e) {
        console.error('[Settings] Failed to load profile:', e);
        loadingEl.textContent = 'Failed to load profile.';
    }
}

async function saveUserProfile() {
    var nameInput = document.getElementById('profile-display-name');
    var emailInput = document.getElementById('profile-email');
    var statusEl = document.getElementById('profile-status');
    var saveBtn = document.getElementById('profile-save-btn');

    var newName = nameInput.value.trim();
    var newEmail = emailInput.value.trim();

    saveBtn.disabled = true;
    statusEl.style.color = 'var(--text-muted)';
    statusEl.textContent = 'Saving...';

    try {
        // Update display name if changed
        var oldName = _cachedUserProfile ? _cachedUserProfile.displayName : '';
        if (newName !== oldName) {
            await MatrixClient.setDisplayName(newName);
        }

        // Persist email into both account data and Synapse user 3pid list so
        // Matrix email password reset can discover the address.
        var oldEmail = _cachedUserProfile ? _cachedUserProfile.email : '';
        if (newEmail !== oldEmail) {
            await MatrixClient.setAccountData('law.firm.user.email', { email: newEmail });
            await syncUserEmailThreepid(newEmail);
        }

        // Update cache
        _cachedUserProfile = {
            userId: MatrixClient.getUserId(),
            displayName: newName,
            email: newEmail
        };

        // Refresh display name across the app
        refreshDisplayName(newName);

        statusEl.style.color = 'var(--success-500)';
        statusEl.textContent = 'Profile saved.';
        setTimeout(function() { statusEl.textContent = ''; }, 3000);
    } catch (e) {
        console.error('[Settings] Failed to save profile:', e);
        statusEl.style.color = 'var(--error-500)';
        statusEl.textContent = 'Failed to save: ' + e.message;
    } finally {
        saveBtn.disabled = false;
    }
}

async function syncUserEmailThreepid(email) {
    var session = _loadSynapseSession();
    if (!session || !session.userId || !session.accessToken) {
        throw new Error('Not logged in.');
    }

    var userPath = SYNAPSE_HOMESERVER_URL + '/_synapse/admin/v2/users/' + encodeURIComponent(session.userId);
    var headers = {
        'Authorization': 'Bearer ' + session.accessToken,
        'Content-Type': 'application/json'
    };

    // Read current threepids so we only replace the email entry and keep others.
    var readRes = await fetch(userPath, {
        method: 'GET',
        headers: headers
    });

    if (!readRes.ok) {
        if (readRes.status === 403) {
            throw new Error('Your account does not have permission to sync email to Matrix password-reset records.');
        }
        var readErr = await readRes.json().catch(function() { return {}; });
        throw new Error(readErr.error || 'Failed to load current Matrix email bindings (HTTP ' + readRes.status + ')');
    }

    var userData = await readRes.json();
    var threepids = Array.isArray(userData.threepids) ? userData.threepids.slice() : [];

    // Remove any existing email entries and add the newly requested one.
    threepids = threepids.filter(function(item) {
        return item && item.medium !== 'email';
    });

    if (email) {
        threepids.push({
            medium: 'email',
            address: email
        });
    }

    var writeRes = await fetch(userPath, {
        method: 'PUT',
        headers: headers,
        body: JSON.stringify({ threepids: threepids })
    });

    if (!writeRes.ok) {
        if (writeRes.status === 403) {
            throw new Error('Your account does not have permission to sync email to Matrix password-reset records.');
        }
        var writeErr = await writeRes.json().catch(function() { return {}; });
        throw new Error(writeErr.error || 'Failed to save Matrix password-reset email (HTTP ' + writeRes.status + ')');
    }
}

// Update display name in the home page and sidebar
function refreshDisplayName(displayName) {
    if (!displayName) return;
    var homeNameEl = document.getElementById('home-display-name');
    if (homeNameEl) homeNameEl.textContent = displayName;

    var homeAvatarEl = document.getElementById('home-avatar');
    if (homeAvatarEl) {
        var initials = displayName.substring(0, 2).toUpperCase();
        homeAvatarEl.textContent = initials;
    }

    var navUsernameEl = document.getElementById('app-nav-username');
    if (navUsernameEl) navUsernameEl.textContent = displayName;
}

function toggleOfflineSyncToasts(enabled) {
    UserPreferences.set('showOfflineSyncToasts', enabled);
}

function toggleConfirmInlineCellEdit(enabled) {
    UserPreferences.set('confirmInlineCellEdit', enabled);
}

function toggleOnlineOnlyMode(enabled) {
    // Persist via localStorage and update the AminoData layer
    localStorage.setItem('amino_online_only_mode', enabled ? 'true' : 'false');
    if (typeof AminoData !== 'undefined' && AminoData.setOnlineOnlyMode) {
        AminoData.setOnlineOnlyMode(enabled);
    }

    // Update the UI banner
    var banner = document.getElementById('online-only-active-banner');
    if (banner) banner.style.display = enabled ? 'block' : 'none';

    // Update the Data Source indicator on the home screen
    _updateDataSourceIndicator();

    if (enabled) {
        showToast('info', 'Online-only mode enabled. Data will not be stored locally.');
        // Clear existing IndexedDB data records so nothing lingers
        if (db) {
            try {
                var tx = db.transaction('data', 'readwrite');
                tx.objectStore('data').clear();
                console.log('[Settings] Cleared IndexedDB data store (online-only mode)');
            } catch (e) {
                console.warn('[Settings] Could not clear IDB data store:', e);
            }
        }
    } else {
        showToast('info', 'Online-only mode disabled. Data will be stored locally for offline access.');
    }
}

function _initOnlineOnlyModeUI() {
    var checkbox = document.getElementById('pref-online-only-mode');
    var banner = document.getElementById('online-only-active-banner');
    var isEnabled = _isOnlineOnlyMode();
    if (checkbox) checkbox.checked = isEnabled;
    if (banner) banner.style.display = isEnabled ? 'block' : 'none';
}

function _updateDataSourceIndicator() {
    var el = document.getElementById('home-sync-status');
    if (!el) return;
    if (_isOnlineOnlyMode()) {
        el.textContent = 'Online';
        el.title = 'Online-only mode: data fetched from server, not stored locally';
    }
}

// ============ Settings: Table Relationships ============

var _relConfig = {}; // edgeId -> { label, cardinality, isPrimary, displayFields[] }
var _relConfigLoaded = false;
var _relExpandedEdgeId = null; // which row is expanded for editing

async function _loadRelConfig() {
    if (_relConfigLoaded) return _relConfig;
    try {
        var roomId = await InterfaceApp.getInterfaceRoomId();
        if (roomId) {
            var state = await MatrixClient.getStateEvent(roomId, 'law.firm.interface', 'relationships');
            if (state && state.edges) {
                _relConfig = state.edges;
            }
        }
    } catch (e) {
        // No saved config yet, use empty defaults
        console.log('[Relationships] No saved config, starting fresh');
    }
    _relConfigLoaded = true;
    return _relConfig;
}

async function _saveRelConfig() {
    try {
        var roomId = await InterfaceApp.getInterfaceRoomId();
        if (!roomId) { console.warn('[Relationships] Cannot save: no interface room'); return; }
        await MatrixClient.sendStateEvent(roomId, 'law.firm.interface', 'relationships', {
            edges: _relConfig,
            lastModified: new Date().toISOString(),
            modifiedBy: MatrixClient.getUserId() || 'unknown'
        });
        console.log('[Relationships] Config saved');
        showSettingsToast('success', 'Relationship configuration saved.');
    } catch (e) {
        console.error('[Relationships] Save failed:', e);
        showSettingsToast('error', 'Failed to save relationship configuration.');
    }
}

function _getRelConfig(edgeId) {
    return _relConfig[edgeId] || {};
}

function _setRelConfig(edgeId, key, value) {
    if (!_relConfig[edgeId]) _relConfig[edgeId] = {};
    _relConfig[edgeId][key] = value;
}

function _resolveTableName(tableId) {
    var table = META_TABLES[tableId];
    if (table && table.tableName) return table.tableName;
    return tableId;
}

function _inferCardinality(edge) {
    // If prefersSingle is set on the edge, it's a one-to-X relationship
    // If there's an inverse field, both sides have link fields (many-to-many by default)
    if (edge.prefersSingle) {
        return edge.inverseFieldId ? 'one-to-many' : 'one-to-one';
    }
    return edge.inverseFieldId ? 'many-to-many' : 'one-to-many';
}

async function initRelationshipsTab() {
    var loadingEl = document.getElementById('rel-table-loading');
    var contentEl = document.getElementById('rel-table-content');
    var emptyEl = document.getElementById('rel-table-empty');
    var graphEmptyEl = document.getElementById('rel-graph-empty');

    if (loadingEl) loadingEl.style.display = 'flex';
    if (contentEl) contentEl.style.display = 'none';
    if (emptyEl) emptyEl.style.display = 'none';

    try {
        await _loadRelConfig();
        var edges = await getAllEdges();
        if (!edges || edges.length === 0) {
            // Try rebuilding edges if cache is empty
            await rebuildEdges();
            edges = await getAllEdges();
        }

        if (!edges || edges.length === 0) {
            if (loadingEl) loadingEl.style.display = 'none';
            if (emptyEl) emptyEl.style.display = 'block';
            if (graphEmptyEl) graphEmptyEl.style.display = 'flex';
            _renderRelStats([], {});
            return;
        }

        if (loadingEl) loadingEl.style.display = 'none';
        if (contentEl) contentEl.style.display = 'block';
        if (graphEmptyEl) graphEmptyEl.style.display = 'none';

        _renderRelStats(edges, _relConfig);
        _renderRelTable(edges, _relConfig);
        _renderRelGraph(edges, _relConfig);
        _renderRelLegend(edges);
    } catch (e) {
        console.error('[Relationships] Init failed:', e);
        if (loadingEl) loadingEl.style.display = 'none';
        if (emptyEl) {
            emptyEl.style.display = 'block';
            emptyEl.textContent = 'Failed to load relationships: ' + (e.message || e);
        }
    }
}

function _renderRelStats(edges, config) {
    var statsEl = document.getElementById('rel-graph-stats');
    if (!statsEl) return;

    // Count unique tables involved in edges
    var tableSet = {};
    for (var i = 0; i < edges.length; i++) {
        tableSet[edges[i].fromTableId] = true;
        tableSet[edges[i].toTableId] = true;
    }
    var tableCount = Object.keys(tableSet).length;

    // Count primary edges
    var primaryCount = 0;
    for (var j = 0; j < edges.length; j++) {
        var cfg = config[edges[j].edgeId] || {};
        if (cfg.isPrimary) primaryCount++;
    }

    statsEl.innerHTML =
        '<div class="settings-rel-stat"><div class="settings-rel-stat-value">' + tableCount + '</div><div class="settings-rel-stat-label">Connected Tables</div></div>' +
        '<div class="settings-rel-stat"><div class="settings-rel-stat-value">' + edges.length + '</div><div class="settings-rel-stat-label">Relationships</div></div>' +
        '<div class="settings-rel-stat"><div class="settings-rel-stat-value">' + primaryCount + '</div><div class="settings-rel-stat-label">Primary Nav Paths</div></div>';
}

function _renderRelTable(edges, config) {
    var tbody = document.getElementById('rel-table-tbody');
    if (!tbody) return;

    var html = '';
    for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var cfg = config[edge.edgeId] || {};
        var fromName = _resolveTableName(edge.fromTableId);
        var toName = _resolveTableName(edge.toTableId);
        var cardinality = cfg.cardinality || _inferCardinality(edge);
        var label = cfg.label || '';
        var isPrimary = !!cfg.isPrimary;
        var cardClass = cardinality.replace(/\s+/g, '-');

        var eid = _escSettingsHtml(edge.edgeId);

        html += '<tr data-edge-id="' + eid + '">';
        // Primary star
        html += '<td style="text-align: center;"><span class="settings-rel-primary-star ' + (isPrimary ? '' : 'inactive') + '" onclick="toggleRelPrimary(\'' + eid + '\')" title="' + (isPrimary ? 'Primary navigation path' : 'Click to mark as primary') + '">' + (isPrimary ? '\u2605' : '\u2606') + '</span></td>';
        // From table
        html += '<td class="rel-table-name">' + _escSettingsHtml(fromName) + '</td>';
        // Arrow
        html += '<td class="settings-rel-arrow">\u2192</td>';
        // To table
        html += '<td class="rel-table-name">' + _escSettingsHtml(toName) + '</td>';
        // Link field
        html += '<td class="rel-field-name">' + _escSettingsHtml(edge.fieldName || edge.fieldId) + '</td>';
        // Cardinality
        html += '<td><span class="rel-cardinality-badge ' + cardClass + '">' + _escSettingsHtml(cardinality) + '</span></td>';
        // Label
        html += '<td style="color: ' + (label ? 'var(--text-primary)' : 'var(--text-muted)') + '; font-size: 12px;">' + (label ? _escSettingsHtml(label) : 'No label') + '</td>';
        // Edit
        html += '<td><button class="settings-rel-edit-btn" onclick="toggleRelEdit(\'' + eid + '\')">Edit</button></td>';
        html += '</tr>';

        // Detail row (hidden by default)
        if (_relExpandedEdgeId === edge.edgeId) {
            html += _renderRelDetailRow(edge, cfg);
        }
    }
    tbody.innerHTML = html;
}

function _renderRelDetailRow(edge, cfg) {
    var cardinality = cfg.cardinality || _inferCardinality(edge);
    var label = cfg.label || '';
    var displayFields = (cfg.displayFields || []).join(', ');
    var eid = _escSettingsHtml(edge.edgeId);

    var html = '<tr class="settings-rel-detail-row" data-detail-for="' + eid + '">';
    html += '<td colspan="8">';
    html += '<div class="settings-rel-detail-form">';
    // Label
    html += '<div><label>Relationship Label</label>';
    html += '<input type="text" id="rel-edit-label-' + eid + '" value="' + _escSettingsHtml(label) + '" placeholder="e.g. Client Cases, Case Documents...">';
    html += '</div>';
    // Cardinality
    html += '<div><label>Cardinality</label>';
    html += '<select id="rel-edit-cardinality-' + eid + '">';
    html += '<option value="one-to-one"' + (cardinality === 'one-to-one' ? ' selected' : '') + '>One-to-One</option>';
    html += '<option value="one-to-many"' + (cardinality === 'one-to-many' ? ' selected' : '') + '>One-to-Many</option>';
    html += '<option value="many-to-many"' + (cardinality === 'many-to-many' ? ' selected' : '') + '>Many-to-Many</option>';
    html += '</select>';
    html += '</div>';
    // Display fields (comma-separated field names to show when traversing this link)
    html += '<div style="grid-column: 1 / -1;"><label>Display Fields (comma-separated field names shown when following this link)</label>';
    html += '<input type="text" id="rel-edit-display-' + eid + '" value="' + _escSettingsHtml(displayFields) + '" placeholder="e.g. Name, Status, Date Filed">';
    html += '</div>';
    // Actions
    html += '<div class="settings-rel-detail-actions">';
    html += '<button class="settings-action-btn primary" onclick="saveRelEdit(\'' + eid + '\')">Save</button>';
    html += '<button class="settings-action-btn" onclick="toggleRelEdit(null)">Cancel</button>';
    html += '</div>';
    html += '</div>';
    html += '</td>';
    html += '</tr>';
    return html;
}

function _escSettingsHtml(s) {
    if (s == null) return '';
    return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

function toggleRelPrimary(edgeId) {
    var current = _getRelConfig(edgeId);
    _setRelConfig(edgeId, 'isPrimary', !current.isPrimary);
    _saveRelConfig();
    initRelationshipsTab();
}

function toggleRelEdit(edgeId) {
    _relExpandedEdgeId = (_relExpandedEdgeId === edgeId) ? null : edgeId;
    // Re-render just the table to show/hide the detail row
    getAllEdges().then(function(edges) {
        _renderRelTable(edges, _relConfig);
    });
}

function saveRelEdit(edgeId) {
    var labelInput = document.getElementById('rel-edit-label-' + edgeId);
    var cardInput = document.getElementById('rel-edit-cardinality-' + edgeId);
    var displayInput = document.getElementById('rel-edit-display-' + edgeId);

    if (labelInput) _setRelConfig(edgeId, 'label', labelInput.value.trim());
    if (cardInput) _setRelConfig(edgeId, 'cardinality', cardInput.value);
    if (displayInput) {
        var fields = displayInput.value.split(',').map(function(s) { return s.trim(); }).filter(Boolean);
        _setRelConfig(edgeId, 'displayFields', fields);
    }

    _relExpandedEdgeId = null;
    _saveRelConfig();
    initRelationshipsTab();
}

function _renderRelLegend(edges) {
    var legendEl = document.getElementById('rel-graph-legend');
    if (!legendEl) return;

    // Collect unique table IDs and assign colors
    var colorMap = _buildRelColorMap(edges);
    var html = '';
    var tableIds = Object.keys(colorMap);
    for (var i = 0; i < tableIds.length; i++) {
        var tid = tableIds[i];
        var name = _resolveTableName(tid);
        html += '<div class="settings-rel-legend-item">';
        html += '<span class="settings-rel-legend-swatch" style="background: ' + colorMap[tid] + ';"></span>';
        html += '<span>' + _escSettingsHtml(name) + '</span>';
        html += '</div>';
    }
    legendEl.innerHTML = html;
}

var _REL_GRAPH_COLORS = [
    '#3b82f6', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6',
    '#06b6d4', '#ec4899', '#14b8a6', '#f97316', '#6366f1',
    '#84cc16', '#e879f9', '#0ea5e9', '#a3e635', '#fb923c'
];

function _buildRelColorMap(edges) {
    var tableSet = {};
    for (var i = 0; i < edges.length; i++) {
        tableSet[edges[i].fromTableId] = true;
        tableSet[edges[i].toTableId] = true;
    }
    var ids = Object.keys(tableSet).sort();
    var map = {};
    for (var j = 0; j < ids.length; j++) {
        map[ids[j]] = _REL_GRAPH_COLORS[j % _REL_GRAPH_COLORS.length];
    }
    return map;
}

function _renderRelGraph(edges, config) {
    var canvas = document.getElementById('rel-graph-canvas');
    if (!canvas || !canvas.getContext) return;

    var container = canvas.parentElement;
    var rect = container.getBoundingClientRect();
    var dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';

    var ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, rect.width, rect.height);

    if (!edges || edges.length === 0) return;

    var colorMap = _buildRelColorMap(edges);

    // Collect unique table nodes and compute positions using force-directed-like layout
    var tableSet = {};
    for (var i = 0; i < edges.length; i++) {
        tableSet[edges[i].fromTableId] = true;
        tableSet[edges[i].toTableId] = true;
    }
    var tableIds = Object.keys(tableSet).sort();
    var nodeCount = tableIds.length;

    // Position nodes in an elliptical layout centered in the canvas
    var cx = rect.width / 2;
    var cy = rect.height / 2;
    var radiusX = Math.min(rect.width * 0.38, 280);
    var radiusY = Math.min(rect.height * 0.35, 160);
    var nodePositions = {};

    if (nodeCount === 1) {
        nodePositions[tableIds[0]] = { x: cx, y: cy };
    } else if (nodeCount === 2) {
        nodePositions[tableIds[0]] = { x: cx - radiusX * 0.6, y: cy };
        nodePositions[tableIds[1]] = { x: cx + radiusX * 0.6, y: cy };
    } else {
        for (var n = 0; n < nodeCount; n++) {
            var angle = (Math.PI * 2 * n) / nodeCount - Math.PI / 2;
            nodePositions[tableIds[n]] = {
                x: cx + Math.cos(angle) * radiusX,
                y: cy + Math.sin(angle) * radiusY
            };
        }
    }

    // Draw edges
    for (var e = 0; e < edges.length; e++) {
        var edge = edges[e];
        var from = nodePositions[edge.fromTableId];
        var to = nodePositions[edge.toTableId];
        if (!from || !to) continue;

        var cfg = config[edge.edgeId] || {};
        var isPrimary = !!cfg.isPrimary;

        ctx.beginPath();
        ctx.moveTo(from.x, from.y);

        // Use a quadratic curve for parallel edges between same table pairs
        var midX = (from.x + to.x) / 2;
        var midY = (from.y + to.y) / 2;
        var dx = to.x - from.x;
        var dy = to.y - from.y;
        var len = Math.sqrt(dx * dx + dy * dy) || 1;
        // Offset perpendicular to the edge for a slight curve
        var offsetScale = 20;
        var perpX = -dy / len * offsetScale;
        var perpY = dx / len * offsetScale;

        ctx.quadraticCurveTo(midX + perpX, midY + perpY, to.x, to.y);

        ctx.strokeStyle = isPrimary ? '#f59e0b' : 'rgba(148, 163, 184, 0.35)';
        ctx.lineWidth = isPrimary ? 2.5 : 1.5;
        if (isPrimary) {
            ctx.setLineDash([]);
        } else {
            ctx.setLineDash([4, 3]);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw arrowhead
        var arrowLen = 8;
        // Compute tangent at endpoint of quadratic curve
        var t = 0.95;
        var tangentX = 2 * (1 - t) * (midX + perpX - from.x) + 2 * t * (to.x - midX - perpX);
        var tangentY = 2 * (1 - t) * (midY + perpY - from.y) + 2 * t * (to.y - midY - perpY);
        var tLen = Math.sqrt(tangentX * tangentX + tangentY * tangentY) || 1;
        tangentX /= tLen;
        tangentY /= tLen;

        var arrowX = to.x - tangentX * 22;
        var arrowY = to.y - tangentY * 22;
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX - tangentX * arrowLen + tangentY * arrowLen * 0.5, arrowY - tangentY * arrowLen - tangentX * arrowLen * 0.5);
        ctx.lineTo(arrowX - tangentX * arrowLen - tangentY * arrowLen * 0.5, arrowY - tangentY * arrowLen + tangentX * arrowLen * 0.5);
        ctx.closePath();
        ctx.fillStyle = isPrimary ? '#f59e0b' : 'rgba(148, 163, 184, 0.5)';
        ctx.fill();

        // Edge label (field name)
        var labelX = midX + perpX * 0.6;
        var labelY = midY + perpY * 0.6 - 4;
        var edgeLabel = cfg.label || edge.fieldName || '';
        if (edgeLabel) {
            ctx.font = '10px ' + getComputedStyle(document.documentElement).getPropertyValue('--font-sans').trim();
            ctx.fillStyle = isPrimary ? '#f59e0b' : 'rgba(148, 163, 184, 0.7)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(edgeLabel, labelX, labelY);
        }
    }

    // Draw table nodes
    var nodeRadius = 20;
    for (var nd = 0; nd < tableIds.length; nd++) {
        var tid = tableIds[nd];
        var pos = nodePositions[tid];
        var color = colorMap[tid];
        var tableName = _resolveTableName(tid);

        // Node circle
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.2;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Table initial in circle
        var initial = tableName.substring(0, 2).toUpperCase();
        ctx.font = 'bold 12px ' + getComputedStyle(document.documentElement).getPropertyValue('--font-sans').trim();
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(initial, pos.x, pos.y);

        // Table name below node
        ctx.font = '11px ' + getComputedStyle(document.documentElement).getPropertyValue('--font-sans').trim();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim() || '#f1f5f9';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        // Truncate long names
        var displayName = tableName.length > 18 ? tableName.substring(0, 16) + '\u2026' : tableName;
        ctx.fillText(displayName, pos.x, pos.y + nodeRadius + 6);
    }
}

// ============ Settings: Toast ============

function showSettingsToast(type, message) {
    var toast = document.getElementById('settings-toast');
    toast.className = 'settings-toast ' + type;
    toast.textContent = message;
    setTimeout(function() {
        toast.className = 'settings-toast';
        toast.textContent = '';
    }, 5000);
}

// ============ Settings: Load Data ============

var _settingsLoaded = false;

async function loadSettingsData() {
    if (_settingsLoaded) return;

    // Table Relationships tab: admin-only visibility
    var relTab = document.getElementById('settings-tab-relationships');
    if (relTab) relTab.style.display = (_currentUserRole === 'admin') ? '' : 'none';

    if (_currentUserRole !== 'admin') {
        document.getElementById('settings-users-loading').style.display = 'none';
        document.getElementById('settings-users-empty').style.display = 'block';
        document.getElementById('settings-users-empty').textContent = 'You need admin privileges to manage settings.';
        document.getElementById('settings-invite-section').style.display = 'none';
        return;
    }

    // Show invite section for admins
    document.getElementById('settings-invite-section').style.display = 'block';

    await loadSettingsUsers();
    await loadSettingsRoomList();
    await loadPermissionGroups();
    await loadPermissionsMatrix();
    _settingsLoaded = true;
}

// ============ Settings: Users & Roles ============

async function loadSettingsUsers() {
    var loadingEl = document.getElementById('settings-users-loading');
    var contentEl = document.getElementById('settings-users-content');
    var emptyEl = document.getElementById('settings-users-empty');

    loadingEl.style.display = 'flex';
    contentEl.style.display = 'none';
    emptyEl.style.display = 'none';

    try {
        if (!_settingsOrgSpaceId) {
            _settingsOrgSpaceId = await MatrixClient.findOrgSpace();
        }
        if (!_settingsOrgSpaceId) {
            loadingEl.style.display = 'none';
            emptyEl.style.display = 'block';
            return;
        }

        // Get members of the org space
        var members = await MatrixClient.getRoomMembers(_settingsOrgSpaceId, { memberships: ['join', 'invite'] });

        // Also include users that are in any table room but not yet joined to the org
        // space (for example, users provisioned externally or force-joined to data rooms).
        if (!_settingsRooms.length) await loadSettingsRoomList();
        var memberMap = {};
        members.forEach(function(member) {
            memberMap[member.userId] = member;
        });
        for (var roomIndex = 0; roomIndex < _settingsRooms.length; roomIndex++) {
            var room = _settingsRooms[roomIndex];
            try {
                var roomMembers = await MatrixClient.getRoomMembers(room.roomId);
                roomMembers.forEach(function(member) {
                    if (!memberMap[member.userId]) {
                        memberMap[member.userId] = member;
                    }
                });
            } catch (roomMemberError) {
                console.warn('[Settings] Could not load members for room', room.roomId, roomMemberError);
            }
        }
        members = Object.keys(memberMap).map(function(userId) {
            return memberMap[userId];
        });

        // Get power levels of the org space
        var powerLevels = await MatrixClient.getRoomPowerLevels(_settingsOrgSpaceId);

        _settingsMembers = members.map(function(m) {
            var level = (powerLevels.users && powerLevels.users[m.userId]) || powerLevels.users_default || 0;
            var role = 'default';
            if (level >= 100) role = 'admin';
            else if (level >= 50) role = 'staff';
            else if (level >= 10) role = 'client';
            return {
                userId: m.userId,
                displayName: m.displayName,
                powerLevel: level,
                role: role
            };
        });

        // Sort: admins first, then staff, then others
        _settingsMembers.sort(function(a, b) { return b.powerLevel - a.powerLevel; });

        renderSettingsUsers();

        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
    } catch (e) {
        console.error('[Settings] Failed to load users:', e);
        loadingEl.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Failed to load members: ' + e.message;
    }
}

function renderSettingsUsers() {
    var tbody = document.getElementById('settings-users-tbody');
    var session = _loadSynapseSession();
    var myUserId = session ? session.userId : '';

    tbody.innerHTML = _settingsMembers.map(function(m) {
        var isSelf = m.userId === myUserId;
        var roleClass = m.role;
        return '<tr>' +
            '<td class="user-id">' + escapeHtml(m.userId) + '</td>' +
            '<td>' + escapeHtml(m.displayName) + '</td>' +
            '<td><span class="role-badge ' + roleClass + '">' + m.role + '</span></td>' +
            '<td>' +
                (isSelf
                    ? '<span style="font-size: 12px; color: var(--text-muted);">You</span>'
                    : '<select class="settings-role-select" onchange="changeUserRole(\'' + escapeHtml(m.userId).replace(/'/g, "\\'") + '\', this.value)">' +
                        '<option value="admin"' + (m.role === 'admin' ? ' selected' : '') + '>Admin (100)</option>' +
                        '<option value="staff"' + (m.role === 'staff' ? ' selected' : '') + '>Staff (50)</option>' +
                        '<option value="client"' + (m.role === 'client' ? ' selected' : '') + '>Client (10)</option>' +
                        '<option value="default"' + (m.role === 'default' ? ' selected' : '') + '>Default (0)</option>' +
                    '</select>'
                ) +
            '</td>' +
            '<td style="white-space: nowrap;">' +
                (isSelf ? '' :
                    '<button class="settings-action-btn danger" style="margin-right:4px;" onclick="revokeAllRoomAccessForUser(\'' + escapeHtml(m.userId).replace(/'/g, "\\'") + '\')" title="Remove from all data rooms but keep in org">Revoke Rooms</button>' +
                    '<button class="settings-action-btn danger" onclick="kickUserFromOrg(\'' + escapeHtml(m.userId).replace(/'/g, "\\'") + '\')" title="Remove from organization and all rooms">Remove</button>'
                ) +
            '</td>' +
        '</tr>';
    }).join('');

    // Also update the room access user dropdown
    populateRoomUserSelect();
}

async function changeUserRole(userId, newRole) {
    var levelMap = { admin: 100, staff: 50, client: 10, default: 0 };
    var level = levelMap[newRole];
    if (level === undefined) return;

    try {
        // 1. Set power level in org space
        await MatrixClient.setUserPowerLevel(_settingsOrgSpaceId, userId, level);

        // 2. Also update power levels in all table rooms the user is in
        await updateUserRoleInAllRooms(userId, level);

        // Update local cache
        _settingsMembers.forEach(function(m) {
            if (m.userId === userId) {
                m.powerLevel = level;
                m.role = newRole;
            }
        });
        renderSettingsUsers();

        showSettingsToast('success', 'Role updated to ' + newRole + ' for ' + userId);
    } catch (e) {
        console.error('[Settings] Failed to change role:', e);
        showSettingsToast('error', 'Failed to update role: ' + e.message);
        // Reload to reflect actual state
        _settingsLoaded = false;
        loadSettingsData();
    }
}

async function updateUserRoleInAllRooms(userId, level) {
    // Get all table rooms and update the user's power level in each
    if (!_settingsRooms.length) await loadSettingsRoomList();

    var session = _loadSynapseSession();
    if (!session || !session.accessToken) return;

    for (var i = 0; i < _settingsRooms.length; i++) {
        var room = _settingsRooms[i];
        try {
            await MatrixClient.setUserPowerLevel(room.roomId, userId, level);
        } catch (e) {
            // User may not be in this room  that's fine, skip
            console.warn('[Settings] Could not set power level in room ' + room.name + ':', e.message);
        }
    }
}

async function kickUserFromOrg(userId) {
    if (!confirm('Remove ' + userId + ' from the organization? They will lose access to all rooms.')) return;

    try {
        // Kick from org space
        await MatrixClient.kickUser(_settingsOrgSpaceId, userId, 'Removed by admin');

        // Kick from all table rooms
        for (var i = 0; i < _settingsRooms.length; i++) {
            try {
                await MatrixClient.kickUser(_settingsRooms[i].roomId, userId, 'Removed by admin');
            } catch (e) {
                // May not be in room
            }
        }

        // Remove from local cache
        _settingsMembers = _settingsMembers.filter(function(m) { return m.userId !== userId; });
        renderSettingsUsers();

        showSettingsToast('success', 'Removed ' + userId + ' from organization');
    } catch (e) {
        console.error('[Settings] Failed to kick user:', e);
        showSettingsToast('error', 'Failed to remove user: ' + e.message);
    }
}

// ============ Settings: Invite User ============

// Internal email domains  users with these domains are auto-selected for all rooms
var INTERNAL_EMAIL_DOMAINS = ['rklacy.com', 'aminoimmigration.com', 'asiloymas.com'];

function _isInternalEmail(email) {
    if (!email) return false;
    var domain = email.toLowerCase().split('@')[1];
    return domain && INTERNAL_EMAIL_DOMAINS.indexOf(domain) !== -1;
}

// ---- Room Assignment Modal ----

var _roomAssignUserId = null;   // userId being assigned rooms
var _roomAssignRoleLevel = 0;   // power level for the user

function openRoomAssignModal(userId, email, roleLevel) {
    _roomAssignUserId = userId;
    _roomAssignRoleLevel = roleLevel;

    var modal = document.getElementById('room-assign-modal');
    var badge = document.getElementById('room-assign-user-badge');
    var listEl = document.getElementById('room-assign-list');
    var noteEl = document.getElementById('room-assign-internal-note');
    var statusEl = document.getElementById('room-assign-status');
    var confirmBtn = document.getElementById('room-assign-confirm-btn');

    badge.textContent = userId;
    statusEl.textContent = '';
    statusEl.classList.remove('visible');
    confirmBtn.disabled = false;
    confirmBtn.textContent = 'Grant Access';

    var isInternal = _isInternalEmail(email);
    if (isInternal) {
        noteEl.classList.add('visible');
    } else {
        noteEl.classList.remove('visible');
    }

    // Build room list from _settingsRooms (already loaded during settings init)
    if (!_settingsRooms || _settingsRooms.length === 0) {
        listEl.innerHTML = '<div style="padding: 24px; text-align: center; color: var(--text-muted); font-size: 13px;">No data rooms found. You can assign rooms later from the Room Access tab.</div>';
    } else {
        listEl.innerHTML = _settingsRooms.map(function(r, i) {
            var checkedAttr = isInternal ? ' checked' : '';
            return '<div class="room-assign-item">' +
                '<input type="checkbox" id="room-assign-cb-' + i + '" data-room-id="' + escapeHtml(r.roomId) + '"' + checkedAttr + ' onchange="updateRoomAssignCount()">' +
                '<label for="room-assign-cb-' + i + '">' + escapeHtml(r.name) + '</label>' +
            '</div>';
        }).join('');
    }

    updateRoomAssignCount();
    modal.classList.add('open');
}

function closeRoomAssignModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('room-assign-modal').classList.remove('open');
    _roomAssignUserId = null;
}

function updateRoomAssignCount() {
    var checkboxes = document.querySelectorAll('#room-assign-list input[type="checkbox"]');
    var checked = 0;
    checkboxes.forEach(function(cb) { if (cb.checked) checked++; });
    document.getElementById('room-assign-count').textContent = checked + ' of ' + checkboxes.length + ' selected';
}

function roomAssignSelectAll() {
    document.querySelectorAll('#room-assign-list input[type="checkbox"]').forEach(function(cb) { cb.checked = true; });
    updateRoomAssignCount();
}

function roomAssignDeselectAll() {
    document.querySelectorAll('#room-assign-list input[type="checkbox"]').forEach(function(cb) { cb.checked = false; });
    updateRoomAssignCount();
}

async function confirmRoomAssignment() {
    if (!_roomAssignUserId) return;

    var confirmBtn = document.getElementById('room-assign-confirm-btn');
    var statusEl = document.getElementById('room-assign-status');
    confirmBtn.disabled = true;
    confirmBtn.textContent = 'Granting...';
    statusEl.classList.add('visible');

    var checkboxes = document.querySelectorAll('#room-assign-list input[type="checkbox"]:checked');
    var selectedRoomIds = [];
    checkboxes.forEach(function(cb) { selectedRoomIds.push(cb.getAttribute('data-room-id')); });

    if (selectedRoomIds.length === 0) {
        statusEl.textContent = 'No rooms selected.';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'Grant Access';
        return;
    }

    var session = _loadSynapseSession();
    if (!session || !session.accessToken) {
        statusEl.textContent = 'Not logged in.';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'Grant Access';
        return;
    }

    var joined = 0;
    var failed = 0;

    for (var i = 0; i < selectedRoomIds.length; i++) {
        var roomId = selectedRoomIds[i];
        statusEl.textContent = 'Joining room ' + (i + 1) + ' of ' + selectedRoomIds.length + '...';

        try {
            // Try Synapse admin force-join first
            var encodedRoomId = encodeURIComponent(roomId);
            var res = await fetch(
                SYNAPSE_HOMESERVER_URL + '/_synapse/admin/v1/join/' + encodedRoomId,
                {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + session.accessToken,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ user_id: _roomAssignUserId })
                }
            );

            if (!res.ok) {
                // Fallback to invite
                var errData = await res.json().catch(function() { return {}; });
                if (res.status === 403 || (errData.errcode && errData.errcode === 'M_FORBIDDEN')) {
                    await MatrixClient.inviteUser(roomId, _roomAssignUserId);
                    joined++;
                    continue;
                }
                throw new Error(errData.error || 'HTTP ' + res.status);
            }

            // Set power level in the room
            try {
                await MatrixClient.setUserPowerLevel(roomId, _roomAssignUserId, _roomAssignRoleLevel);
            } catch (plErr) {
                console.warn('[RoomAssign] Could not set power level in room:', plErr.message);
            }

            joined++;
        } catch (e) {
            console.error('[RoomAssign] Failed to join room ' + roomId + ':', e);
            failed++;
        }
    }

    if (failed === 0) {
        statusEl.textContent = 'Granted access to ' + joined + ' room' + (joined !== 1 ? 's' : '') + '.';
        statusEl.style.color = 'var(--success-500)';
        showSettingsToast('success', _roomAssignUserId + ' added to ' + joined + ' room' + (joined !== 1 ? 's' : ''));
    } else {
        statusEl.textContent = 'Joined ' + joined + ', failed ' + failed + ' room(s).';
        statusEl.style.color = 'var(--warning-500)';
        showSettingsToast('info', 'Joined ' + joined + ' rooms, ' + failed + ' failed for ' + _roomAssignUserId);
    }

    confirmBtn.textContent = 'Done';
    // Auto-close after a short delay
    setTimeout(function() {
        closeRoomAssignModal();
        statusEl.style.color = '';
    }, 1500);
}

async function inviteNewUser() {
    var username = document.getElementById('invite-username').value.trim();
    var displayName = document.getElementById('invite-display-name').value.trim();
    var email = document.getElementById('invite-email').value.trim();
    var role = document.getElementById('invite-role').value;
    var statusEl = document.getElementById('invite-status');
    var btn = document.getElementById('invite-submit-btn');

    if (!username) {
        statusEl.textContent = 'Username is required.';
        statusEl.style.color = 'var(--danger-500)';
        return;
    }
    if (!email) {
        statusEl.textContent = 'Email is required.';
        statusEl.style.color = 'var(--danger-500)';
        return;
    }

    // Basic email validation
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        statusEl.textContent = 'Please enter a valid email address.';
        statusEl.style.color = 'var(--danger-500)';
        return;
    }

    // Clean username: remove @ prefix and :domain suffix if given
    username = username.replace(/^@/, '').split(':')[0].toLowerCase();

    var session = _loadSynapseSession();
    if (!session || !session.accessToken) {
        statusEl.textContent = 'Not logged in.';
        statusEl.style.color = 'var(--danger-500)';
        return;
    }

    // Derive the server domain from current user's ID
    var domain = session.userId.split(':')[1];
    var fullUserId = '@' + username + ':' + domain;

    btn.disabled = true;
    btn.textContent = 'Creating...';
    statusEl.textContent = '';

    try {
        // Generate a temporary password the user must change
        var tempPassword = _generateTempPassword();

        // 1. Create user via Synapse Admin API
        var encodedUserId = encodeURIComponent(fullUserId);
        var createBody = {
            password: tempPassword,
            displayname: displayName || username,
            threepids: [{
                medium: 'email',
                address: email
            }],
            admin: false,
            deactivated: false
        };

        var createRes = await fetch(
            SYNAPSE_HOMESERVER_URL + '/_synapse/admin/v2/users/' + encodedUserId,
            {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer ' + session.accessToken,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(createBody)
            }
        );

        if (!createRes.ok) {
            var errData = await createRes.json().catch(function() { return {}; });
            throw new Error(errData.error || 'Failed to create user (HTTP ' + createRes.status + ')');
        }

        // 2. Invite user to the organization space
        if (_settingsOrgSpaceId) {
            try {
                await MatrixClient.inviteUser(_settingsOrgSpaceId, fullUserId);
            } catch (inviteErr) {
                // If already in space, that's fine
                if (inviteErr.errcode !== 'M_FORBIDDEN') {
                    console.warn('[Settings] Could not invite to org space:', inviteErr.message);
                }
            }

            // 3. Set the user's power level based on selected role
            var levelMap = { admin: 100, staff: 50, client: 10, default: 0 };
            var level = levelMap[role] || 0;
            try {
                await MatrixClient.setUserPowerLevel(_settingsOrgSpaceId, fullUserId, level);
            } catch (plErr) {
                console.warn('[Settings] Could not set power level:', plErr.message);
            }
        }

        // Clear form
        document.getElementById('invite-username').value = '';
        document.getElementById('invite-display-name').value = '';
        document.getElementById('invite-email').value = '';

        statusEl.innerHTML = 'User <strong>' + escapeHtml(fullUserId) + '</strong> created.<br>Temporary password: <code style="background:var(--bg-tertiary);padding:2px 6px;border-radius:3px;user-select:all;">' + escapeHtml(tempPassword) + '</code><br><span style="color:var(--text-muted);">Share these credentials with the user. They should change their password after first login.</span>';
        statusEl.style.color = 'var(--success-500)';

        showSettingsToast('success', 'User ' + fullUserId + ' created and invited to organization.');

        // Reload member list
        _settingsLoaded = false;
        await loadSettingsData();

        // Open room assignment modal so admin can grant data room access
        var levelMap2 = { admin: 100, staff: 50, client: 10, default: 0 };
        openRoomAssignModal(fullUserId, email, levelMap2[role] || 0);

    } catch (e) {
        console.error('[Settings] Failed to invite user:', e);
        statusEl.textContent = 'Failed: ' + e.message;
        statusEl.style.color = 'var(--danger-500)';
        showSettingsToast('error', 'Failed to create user: ' + e.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Invite User';
    }
}

function _generateTempPassword() {
    var chars = 'abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    var password = '';
    var array = new Uint8Array(16);
    crypto.getRandomValues(array);
    for (var i = 0; i < 16; i++) {
        password += chars[array[i] % chars.length];
    }
    return password;
}


async function loadPermissionsMatrix() {
    var loadingEl = document.getElementById('settings-permissions-matrix-loading');
    var contentEl = document.getElementById('settings-permissions-matrix-content');
    if (!loadingEl || !contentEl) return;

    loadingEl.style.display = 'flex';
    contentEl.style.display = 'none';

    try {
        if (!_settingsRooms.length) await loadSettingsRoomList();

        var roomMembersByRoomId = {};
        for (var i = 0; i < _settingsRooms.length; i++) {
            var room = _settingsRooms[i];
            try {
                var members = await MatrixClient.getRoomMembers(room.roomId);
                roomMembersByRoomId[room.roomId] = members.map(function(m) { return m.userId; });
            } catch (e) {
                roomMembersByRoomId[room.roomId] = [];
            }
        }

        renderPermissionsMatrix(roomMembersByRoomId);
        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
    } catch (e) {
        console.error('[Settings] Failed to load permissions matrix:', e);
        loadingEl.style.display = 'none';
    }
}

// Cache for the last permissions matrix data so we can re-render without re-fetching
var _permissionsMatrixData = null;

function renderPermissionsMatrix(roomMembersByRoomId) {
    _permissionsMatrixData = roomMembersByRoomId;
    var head = document.getElementById('settings-permissions-matrix-head');
    var body = document.getElementById('settings-permissions-matrix-body');
    if (!head || !body) return;

    var session = _loadSynapseSession();
    var myUserId = session ? session.userId : '';

    var roomHeaders = _settingsRooms.map(function(room) {
        return '<th>' + escapeHtml(room.name) + '</th>';
    }).join('');

    head.innerHTML = '<tr><th>User</th><th>Role</th><th>Group</th>' + roomHeaders + '<th></th></tr>';

    body.innerHTML = _settingsMembers.map(function(member) {
        var isSelf = member.userId === myUserId;
        var groupName = getPermissionGroupNameForUser(member.userId) || '--';
        var escapedUserId = escapeHtml(member.userId).replace(/'/g, "\\'");
        var cells = _settingsRooms.map(function(room) {
            var users = roomMembersByRoomId[room.roomId] || [];
            var hasAccess = users.indexOf(member.userId) !== -1;
            var escapedRoomId = escapeHtml(room.roomId).replace(/'/g, "\\'");
            if (isSelf) {
                return '<td style="text-align:center;">' + (hasAccess ? '&#10003;' : '') + '</td>';
            }
            return '<td style="text-align:center;">' +
                '<input type="checkbox"' + (hasAccess ? ' checked' : '') +
                ' onchange="toggleMatrixRoomAccess(\'' + escapedUserId + '\', \'' + escapedRoomId + '\', this.checked, this)"' +
                ' title="' + (hasAccess ? 'Revoke' : 'Grant') + ' access">' +
            '</td>';
        }).join('');
        var revokeBtn = isSelf ? '' :
            '<button class="settings-action-btn danger" style="white-space:nowrap;font-size:11px;padding:3px 8px;" ' +
            'onclick="revokeAllRoomAccessForUser(\'' + escapedUserId + '\')" title="Remove from all data rooms">Revoke All</button>';
        return '<tr>' +
            '<td class="user-id">' + escapeHtml(member.userId) + '</td>' +
            '<td><span class="role-badge ' + member.role + '">' + member.role + '</span></td>' +
            '<td>' + escapeHtml(groupName) + '</td>' +
            cells +
            '<td>' + revokeBtn + '</td>' +
        '</tr>';
    }).join('');
}

async function toggleMatrixRoomAccess(userId, roomId, grant, checkbox) {
    checkbox.disabled = true;
    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) throw new Error('Not logged in');

        if (grant) {
            var encodedRoomId = encodeURIComponent(roomId);
            var res = await fetch(
                SYNAPSE_HOMESERVER_URL + '/_synapse/admin/v1/join/' + encodedRoomId,
                {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + session.accessToken,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ user_id: userId })
                }
            );
            if (!res.ok) {
                var errData = await res.json().catch(function() { return {}; });
                if (res.status === 403 || (errData.errcode && errData.errcode === 'M_FORBIDDEN')) {
                    await MatrixClient.inviteUser(roomId, userId);
                    showSettingsToast('info', 'Invited ' + userId + ' to room (they must accept).');
                    checkbox.disabled = false;
                    return;
                }
                throw new Error(errData.error || 'Admin join failed (' + res.status + ')');
            }
            showSettingsToast('success', 'Joined ' + userId + ' to room');
        } else {
            await MatrixClient.kickUser(roomId, userId, 'Access revoked by admin');
            showSettingsToast('success', 'Removed ' + userId + ' from room');
        }
    } catch (e) {
        console.error('[Settings] toggleMatrixRoomAccess failed:', e);
        checkbox.checked = !grant;
        showSettingsToast('error', 'Failed: ' + e.message);
    }
    checkbox.disabled = false;
}

async function revokeAllRoomAccessForUser(userId) {
    if (!confirm('Remove ' + userId + ' from ALL data rooms? They will remain in the organization but lose access to all table data.')) return;

    try {
        if (!_settingsRooms.length) await loadSettingsRoomList();

        var removed = 0;
        var failed = 0;
        for (var i = 0; i < _settingsRooms.length; i++) {
            var room = _settingsRooms[i];
            try {
                var members = await MatrixClient.getRoomMembers(room.roomId);
                var isMember = members.some(function(m) { return m.userId === userId; });
                if (isMember) {
                    await MatrixClient.kickUser(room.roomId, userId, 'All room access revoked by admin');
                    removed++;
                }
            } catch (e) {
                console.warn('[Settings] revokeAllRoomAccessForUser room failed:', room.roomId, e);
                failed++;
            }
        }

        showSettingsToast('success', 'Removed ' + userId + ' from ' + removed + ' room' + (removed !== 1 ? 's' : '') + (failed > 0 ? ' (' + failed + ' failed)' : ''));
        await loadPermissionsMatrix();
    } catch (e) {
        console.error('[Settings] revokeAllRoomAccessForUser failed:', e);
        showSettingsToast('error', 'Failed to revoke room access: ' + e.message);
    }
}

function getPermissionGroupNameForUser(userId) {
    var groupId = _settingsPermissionGroups.assignments[userId];
    if (!groupId) return '';
    var group = (_settingsPermissionGroups.groups || []).find(function(g) { return g.id === groupId; });
    return group ? group.name : '';
}

async function loadPermissionGroups() {
    if (!_settingsOrgSpaceId) return;
    try {
        var evt = await MatrixClient.getStateEvent(_settingsOrgSpaceId, 'law.firm.permission.groups', '');
        _settingsPermissionGroups = {
            groups: (evt && evt.groups) || [],
            assignments: (evt && evt.assignments) || {}
        };
    } catch (e) {
        _settingsPermissionGroups = { groups: [], assignments: {} };
    }
    renderPermissionGroups();
}

async function savePermissionGroups() {
    if (!_settingsOrgSpaceId) throw new Error('No organization space found');
    await MatrixClient.sendStateEvent(_settingsOrgSpaceId, 'law.firm.permission.groups', '', _settingsPermissionGroups);
}

function renderPermissionGroups() {
    var groupSelect = document.getElementById('settings-room-group-select');
    if (!groupSelect) return;

    var currentVal = groupSelect.value;
    groupSelect.innerHTML = '<option value="">-- No group --</option>';
    (_settingsPermissionGroups.groups || []).forEach(function(group) {
        var opt = document.createElement('option');
        opt.value = group.id;
        opt.textContent = group.name + ' (' + (group.roomIds || []).length + ' rooms)';
        groupSelect.appendChild(opt);
    });
    if (currentVal) groupSelect.value = currentVal;
}

async function createPermissionGroupFromSelectedUser() {
    var userId = document.getElementById('settings-room-user-select').value;
    if (!userId) {
        showSettingsToast('error', 'Select a user first.');
        return;
    }

    try {
        if (!_settingsRooms.length) await loadSettingsRoomList();
        var roomIds = [];
        for (var i = 0; i < _settingsRooms.length; i++) {
            var room = _settingsRooms[i];
            try {
                var members = await MatrixClient.getRoomMembers(room.roomId);
                if (members.some(function(m) { return m.userId === userId; })) roomIds.push(room.roomId);
            } catch (e) {}
        }

        var groupName = prompt('Group name?', 'Group for ' + userId);
        if (!groupName) return;

        var group = { id: 'grp_' + Date.now(), name: groupName, roomIds: roomIds };
        _settingsPermissionGroups.groups.push(group);
        await savePermissionGroups();
        renderPermissionGroups();
        showSettingsToast('success', 'Permission group created.');
        await loadPermissionsMatrix();
    } catch (e) {
        showSettingsToast('error', 'Failed to create group: ' + e.message);
    }
}

async function assignSelectedUserToPermissionGroup() {
    var userId = document.getElementById('settings-room-user-select').value;
    var groupId = document.getElementById('settings-room-group-select').value;
    if (!userId) {
        showSettingsToast('error', 'Select a user first.');
        return;
    }

    if (groupId) _settingsPermissionGroups.assignments[userId] = groupId;
    else delete _settingsPermissionGroups.assignments[userId];

    try {
        await savePermissionGroups();
        showSettingsToast('success', groupId ? 'Group assigned.' : 'Group cleared.');
        await loadPermissionsMatrix();
    } catch (e) {
        showSettingsToast('error', 'Failed to save group assignment: ' + e.message);
    }
}

async function applySelectedGroupPermissions() {
    var userId = document.getElementById('settings-room-user-select').value;
    var groupId = document.getElementById('settings-room-group-select').value;
    if (!userId || !groupId) {
        showSettingsToast('error', 'Select both a user and a group.');
        return;
    }

    var group = (_settingsPermissionGroups.groups || []).find(function(g) { return g.id === groupId; });
    if (!group) {
        showSettingsToast('error', 'Group not found.');
        return;
    }

    try {
        if (!_settingsRooms.length) await loadSettingsRoomList();
        var roomSet = {};
        (group.roomIds || []).forEach(function(rid) { roomSet[rid] = true; });

        for (var i = 0; i < _settingsRooms.length; i++) {
            var room = _settingsRooms[i];
            var shouldHaveAccess = !!roomSet[room.roomId];
            try {
                var members = await MatrixClient.getRoomMembers(room.roomId);
                var hasAccess = members.some(function(m) { return m.userId === userId; });
                if (shouldHaveAccess && !hasAccess) {
                    await MatrixClient.inviteUser(room.roomId, userId);
                }
                if (!shouldHaveAccess && hasAccess) {
                    await MatrixClient.kickUser(room.roomId, userId, 'Removed by permission group application');
                }
            } catch (e) {
                console.warn('[Settings] applySelectedGroupPermissions room failed:', room.roomId, e);
            }
        }

        showSettingsToast('success', 'Applied group permissions to ' + userId + '.');
        await loadRoomAccessForUser();
        await loadPermissionsMatrix();
    } catch (e) {
        showSettingsToast('error', 'Failed to apply group: ' + e.message);
    }
}

// ============ Settings: Room Access ============

async function loadSettingsRoomList() {
    try {
        var tablesData = await webhookFetch('/amino-tables');
        _settingsRooms = (tablesData.tables || [])
            .filter(function(t) { return !!t.matrix_room_id; })
            .map(function(t) {
                return {
                    roomId: t.matrix_room_id,
                    name: t.table_name || t.table_id,
                    tableId: t.table_id
                };
            });
    } catch (e) {
        console.warn('[Settings] Failed to load rooms:', e);
        _settingsRooms = [];
    }
}

function populateRoomUserSelect() {
    var select = document.getElementById('settings-room-user-select');
    var currentVal = select.value;
    // Keep the first option
    select.innerHTML = '<option value="">-- Choose a user --</option>';
    _settingsMembers.forEach(function(m) {
        var opt = document.createElement('option');
        opt.value = m.userId;
        opt.textContent = m.displayName + ' (' + m.userId + ')';
        select.appendChild(opt);
    });
    if (currentVal) select.value = currentVal;
}

async function loadRoomAccessForUser() {
    var userId = document.getElementById('settings-room-user-select').value;
    var groupSelect = document.getElementById('settings-room-group-select');
    if (groupSelect) {
        groupSelect.value = (_settingsPermissionGroups.assignments && _settingsPermissionGroups.assignments[userId]) || '';
    }
    var loadingEl = document.getElementById('settings-rooms-loading');
    var contentEl = document.getElementById('settings-rooms-content');
    var emptyEl = document.getElementById('settings-rooms-empty');

    if (!userId) {
        contentEl.style.display = 'none';
        loadingEl.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Select a user to manage their room access.';
        return;
    }

    loadingEl.style.display = 'flex';
    contentEl.style.display = 'none';
    emptyEl.style.display = 'none';

    try {
        if (!_settingsRooms.length) await loadSettingsRoomList();

        // Check membership for selected user in each room
        var roomAccess = [];
        for (var i = 0; i < _settingsRooms.length; i++) {
            var room = _settingsRooms[i];
            var isMember = false;
            try {
                var members = await MatrixClient.getRoomMembers(room.roomId);
                isMember = members.some(function(m) { return m.userId === userId; });
            } catch (e) {
                // Can't check  assume not member
            }
            roomAccess.push({
                roomId: room.roomId,
                name: room.name,
                tableId: room.tableId,
                isMember: isMember
            });
        }

        renderRoomAccessTable(userId, roomAccess);

        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
    } catch (e) {
        console.error('[Settings] Failed to load room access:', e);
        loadingEl.style.display = 'none';
        emptyEl.style.display = 'block';
        emptyEl.textContent = 'Failed to load room access: ' + e.message;
    }
}

function renderRoomAccessTable(userId, roomAccess) {
    var tbody = document.getElementById('settings-rooms-tbody');
    tbody.innerHTML = roomAccess.map(function(r) {
        var checkedAttr = r.isMember ? ' checked' : '';
        return '<tr>' +
            '<td><span class="room-name">' + escapeHtml(r.name) + '</span>' +
                '<span class="room-id">' + escapeHtml(r.roomId) + '</span></td>' +
            '<td style="text-align: center;">' +
                '<input type="checkbox" class="settings-access-checkbox"' + checkedAttr +
                ' onchange="toggleRoomAccess(\'' + escapeHtml(userId).replace(/'/g, "\\'") + '\', \'' +
                escapeHtml(r.roomId).replace(/'/g, "\\'") + '\', this.checked, this)">' +
            '</td>' +
            '<td><span id="room-status-' + r.roomId.replace(/[^a-zA-Z0-9]/g, '_') + '" style="font-size: 12px; color: var(--text-muted);">' +
                (r.isMember ? 'Joined' : 'Not joined') + '</span></td>' +
        '</tr>';
    }).join('');
}

async function toggleRoomAccess(userId, roomId, grant, checkbox) {
    var statusSpan = document.getElementById('room-status-' + roomId.replace(/[^a-zA-Z0-9]/g, '_'));
    checkbox.disabled = true;

    try {
        var session = _loadSynapseSession();
        if (!session || !session.accessToken) throw new Error('Not logged in');

        if (grant) {
            // Use Synapse Admin API to force-join user to room
            statusSpan.textContent = 'Joining...';
            statusSpan.style.color = 'var(--primary-400)';

            var encodedRoomId = encodeURIComponent(roomId);
            var res = await fetch(
                SYNAPSE_HOMESERVER_URL + '/_synapse/admin/v1/join/' + encodedRoomId,
                {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + session.accessToken,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ user_id: userId })
                }
            );

            if (!res.ok) {
                // Fallback: try inviting via standard Matrix API, then the user must accept
                var errData = await res.json().catch(function() { return {}; });
                if (res.status === 403 || (errData.errcode && errData.errcode === 'M_FORBIDDEN')) {
                    // Not a server admin  fall back to invite
                    await MatrixClient.inviteUser(roomId, userId);
                    statusSpan.textContent = 'Invited';
                    statusSpan.style.color = 'var(--warning-500)';
                    showSettingsToast('info', 'Invited ' + userId + ' to room (they must accept). Server admin required for force-join.');
                    checkbox.disabled = false;
                    return;
                }
                throw new Error(errData.error || 'Admin join failed (' + res.status + ')');
            }

            statusSpan.textContent = 'Joined';
            statusSpan.style.color = 'var(--success-500)';
            showSettingsToast('success', 'Joined ' + userId + ' to room');
        } else {
            // Kick user from room
            statusSpan.textContent = 'Removing...';
            statusSpan.style.color = 'var(--danger-500)';

            await MatrixClient.kickUser(roomId, userId, 'Access revoked by admin');

            statusSpan.textContent = 'Not joined';
            statusSpan.style.color = 'var(--text-muted)';
            showSettingsToast('success', 'Removed ' + userId + ' from room');
        }
    } catch (e) {
        console.error('[Settings] toggleRoomAccess failed:', e);
        // Revert checkbox
        checkbox.checked = !grant;
        statusSpan.textContent = grant ? 'Failed' : 'Joined';
        statusSpan.style.color = 'var(--danger-500)';
        showSettingsToast('error', 'Failed: ' + e.message);
    }

    checkbox.disabled = false;
    try { await loadPermissionsMatrix(); } catch (e) {}
}

async function revokeAllRoomsForSelectedUser() {
    var userId = document.getElementById('settings-room-user-select').value;
    if (!userId) {
        showSettingsToast('error', 'Select a user first.');
        return;
    }
    if (!confirm('Remove ' + userId + ' from ALL data rooms? They will remain in the organization but lose access to all table data.')) return;

    try {
        if (!_settingsRooms.length) await loadSettingsRoomList();

        var removed = 0;
        var failed = 0;
        for (var i = 0; i < _settingsRooms.length; i++) {
            var room = _settingsRooms[i];
            try {
                var members = await MatrixClient.getRoomMembers(room.roomId);
                var isMember = members.some(function(m) { return m.userId === userId; });
                if (isMember) {
                    await MatrixClient.kickUser(room.roomId, userId, 'All room access revoked by admin');
                    removed++;
                }
            } catch (e) {
                console.warn('[Settings] revokeAllRoomsForSelectedUser room failed:', room.roomId, e);
                failed++;
            }
        }

        showSettingsToast('success', 'Removed ' + userId + ' from ' + removed + ' room' + (removed !== 1 ? 's' : '') + (failed > 0 ? ' (' + failed + ' failed)' : ''));
        await loadRoomAccessForUser();
        try { await loadPermissionsMatrix(); } catch (e) {}
    } catch (e) {
        console.error('[Settings] revokeAllRoomsForSelectedUser failed:', e);
        showSettingsToast('error', 'Failed to revoke room access: ' + e.message);
    }
}

// ============ Initialize Workspaces on Load ============

// Extend init to load workspaces and update Matrix status
var originalInit = init;
init = async function() {
    await originalInit();
    await loadWorkspaces();
    renderWorkspaceTabs();
    updateMatrixStatus();

    // Show app nav bar and detect role
    showAppNav();
    await detectAndStoreUserRole();

    var state = getUrlState();
    _urlStateBootstrapped = true;

    if (state.table && META_TABLES[state.table]) {
        switchApp('database');
        await showTable(state.table);
        if (state.view) await selectView(state.view);
        if (state.filters) {
            currentFilters = normalizeFilterGroup(state.filters);
            updateFilterCount();
        }
        if (typeof state.search === 'string') {
            currentSearchQuery = state.search;
            var si = document.getElementById('view-search-input');
            if (si) si.value = state.search;
        }
        if (typeof state.page === 'number' && state.page >= 0) currentPage = state.page;
        await renderTable();
    } else if (state.app === 'interface') {
        switchApp('interface');
        InterfaceApp.setUrlState({ page: state.ifacePage || 'clients', search: state.ifaceSearch });
        if (InterfaceApp.activePage) await InterfaceApp.renderPage(InterfaceApp.activePage);
    } else if (state.app === 'settings') {
        switchApp('settings');
    } else if (state.app === 'forms') {
        switchApp('forms');
    } else if (state.app === 'database') {
        switchApp('database');
    } else {
        switchApp('interface');
        InterfaceApp.setUrlState({ page: 'clients', search: '' });
        if (InterfaceApp.activePage) await InterfaceApp.renderPage(InterfaceApp.activePage);
    }

    persistUrlState();
};

// Keyboard handler for modals (Escape to close)
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        var commandPalette = document.getElementById('command-palette-overlay');
        if (commandPalette && !commandPalette.classList.contains('hidden')) {
            closeCommandPalette();
            return;
        }
        // Close room publish modal if open
        var pubModal = document.getElementById('room-publish-modal');
        if (pubModal && !pubModal.classList.contains('hidden')) {
            closeRoomPublishModal();
            return;
        }
        // Synapse login is mandatory  do not dismiss with Escape
        var synapseScreen = document.getElementById('synapse-login-screen');
        if (synapseScreen && !synapseScreen.classList.contains('hidden')) {
            return;
        }
        // Close room manager if open
        var rmPanel = document.getElementById('room-manager');
        if (rmPanel && !rmPanel.classList.contains('hidden')) {
            hideRoomManager();
            return;
        }
        // Close connect API modal if open
        var connectModal = document.getElementById('connect-api-modal');
        if (connectModal && connectModal.style.display !== 'none') {
            hideConnectApiModal();
            return;
        }
        // Close forms create modal if open
        var formsModal = document.getElementById('forms-create-modal');
        if (formsModal && formsModal.classList.contains('open')) {
            FormsApp.closeCreateModal();
            return;
        }
        // Close create view modal if open
        var modal = document.getElementById('create-view-modal');
        if (modal && modal.classList.contains('open')) {
            closeCreateViewModal();
        }
    }
});

// Keyboard handler for unlock screen
document.getElementById('unlock-password').onkeydown = (e) => { if (e.key === 'Enter') unlockWithPassword(); };
document.getElementById('setup-password').onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('setup-password-confirm').focus(); };
document.getElementById('setup-password-confirm').onkeydown = (e) => { if (e.key === 'Enter') setupEncryptionWithPassword(); };

// Handle AminoData auth expiry  stop polling, prompt re-login
window.addEventListener('amino:auth-expired', async function() {
    console.warn('[AminoData] Access token expired  stopping data layer polling');
    await AminoData.logout(false);
    // The main Synapse session may still be valid; only force re-login
    // if the Matrix session is also expired
});

// ============ Encrypt-on-Logout: Safety Handlers (UI Database) ============
// Best-effort encryption when the page is being discarded without a
// clean logout. Mirrors the same pattern used in data-layer.js for the
// amino-data-layer database, but operates on the UI's 'amino' IndexedDB.
var _encryptUIOnUnloadRunning = false;

function _tryEncryptUIOnUnload() {
    if (!_deferEncryptionUI || !encryptionKey || !db || _encryptUIOnUnloadRunning) return;
    _encryptUIOnUnloadRunning = true;
    encryptAllUIRecords()
        .catch(function(err) {
            console.error('[Amino] Encrypt-on-unload (UI) failed:', err);
        })
        .finally(function() {
            _encryptUIOnUnloadRunning = false;
        });
}

document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'hidden' && _deferEncryptionUI) {
        _tryEncryptUIOnUnload();
    }
});

window.addEventListener('beforeunload', function() {
    _tryEncryptUIOnUnload();
});

// Initialize: Synapse login is the gate  everything derives from it
(async function() {
    // OPTIMIZATION 3: Start opening IndexedDB immediately, in parallel with
    // session verification and crypto key import. openDB() has no dependency
    // on auth state  it just opens the database connection. By starting it
    // here, the IDB open runs concurrently with network/crypto operations
    // and is usually already resolved by the time init() needs it.
    window._earlyDbPromise = openDB().catch(function(err) {
        console.warn('[Startup] Early DB open failed (will retry in init):', err);
        return null;
    });

    // Helper: Check if cached encrypted data exists in IndexedDB for offline access
    async function _hasCachedDataForOffline() {
        try {
            var config = getEncryptionConfig();
            if (!config || !config.verificationToken || config.type !== 'synapse') return false;
            var hasHydration = !!localStorage.getItem('amino_hydration_complete');
            if (!hasHydration) return false;
            // Verify IndexedDB has actual data
            var testDb = window._earlyDbPromise ? await window._earlyDbPromise : null;
            if (!testDb) {
                testDb = await openDB().catch(function() { return null; });
            }
            if (!testDb) return false;
            // Quick check: does the tables store have entries?
            var tx = testDb.transaction('tables', 'readonly');
            var count = await new Promise(function(resolve) {
                var req = tx.objectStore('tables').count();
                req.onsuccess = function() { resolve(req.result); };
                req.onerror = function() { resolve(0); };
            });
            return count > 0;
        } catch (e) {
            return false;
        }
    }

    // Check for existing valid Synapse session
    var session = _loadSynapseSession();
    if (session && session.accessToken) {
        // OPTIMIZATION 1: Skip blocking network verification on refresh.
        // If we have a session key in sessionStorage (survives refresh), optimistically
        // trust the cached session and verify in the background. This removes 100-2000ms
        // of network latency from the critical startup path.
        var hasSessionKey = !!sessionStorage.getItem('amino_session_key');
        var valid;
        var networkError = false;
        if (hasSessionKey) {
            // Optimistically assume valid  verify in background after init
            valid = true;
            // Set up MatrixClient immediately
            MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
            // Background verification: if session is actually expired, log out gracefully
            verifySynapseSession().then(function(actuallyValid) {
                if (!actuallyValid) {
                    console.warn('[Startup] Background session verification failed  session expired');
                    _clearSynapseSession();
                    clearSessionKey();
                    showSynapseLoginScreen();
                    showSynapseError('Session expired. Please sign in again.');
                }
            }).catch(function() {
                // Network error during background check  stay logged in (offline-friendly)
            });
        } else {
            // No session key (first login or key cleared)  must verify synchronously
            try {
                valid = await verifySynapseSession();
            } catch (verifyErr) {
                // Network error during verification  check for offline access
                valid = false;
                networkError = true;
            }
            if (valid) {
                MatrixClient.setSession(SYNAPSE_HOMESERVER_URL, session.accessToken, session.userId, session.deviceId);
            }
        }
        if (valid) {
            // Try to restore encryption from session key
            var sessionKey = await loadSessionKey();
            var config = getEncryptionConfig();
            if (sessionKey && config && config.verificationToken && config.type === 'synapse') {
                try {
                    await decryptData(config.verificationToken, sessionKey);
                    encryptionKey = sessionKey;
                    encryptionEnabled = true;
                    _deferEncryptionUI = true;

                    // Session + encryption restored  show loading overlay, then hide login and init app.
                    // The loading overlay (z-index 200) covers the login screen (z-index 105)
                    // so the user sees a seamless transition instead of a blank screen gap.
                    showLoadingOverlay();
                    setLoadingOverlayMode('local-memory');
                    hideSynapseLoginScreen();
                    try {
                        await init();
                    } catch (initErr) {
                        console.error('[Startup] Init failed after session restore:', initErr);
                        hideLoadingOverlay();
                        showSynapseError('Initialization failed: ' + initErr.message);
                        showSynapseLoginScreen();
                    }
                    return;
                } catch (e) {
                    // Session key invalid, need re-login to re-derive
                    clearSessionKey();
                }
            }
            // Session valid but no encryption key  need password to re-derive.
            // If we're offline, offer offline unlock instead of the online login form.
            if (!navigator.onLine || !hasSessionKey) {
                var hasCachedForRekey = await _hasCachedDataForOffline();
                if (hasCachedForRekey) {
                    console.log('[Startup] Session exists but no encryption key  showing offline unlock for password re-derivation');
                    showOfflineUnlockScreen();
                    return;
                }
            }
            // Fall through to show Synapse login
        } else {
            // Session verification failed  check if we can offer offline access
            if (session.userId) {
                var hasCachedData = await _hasCachedDataForOffline();
                if (hasCachedData) {
                    // We have cached encrypted data + verification token  offer offline login
                    console.log('[Startup] Network unavailable but cached data exists  showing offline unlock');
                    showOfflineUnlockScreen();
                    return;
                }
            }
            // No cached data or no session  clear and show normal login
            if (!networkError) {
                _clearSynapseSession();
            }
        }
    } else if (!session || !session.accessToken) {
        // No session token at all, but check if we have a userId and cached data
        // (happens after logout that kept encrypted data for offline re-login)
        if (session && session.userId) {
            var hasCachedData = await _hasCachedDataForOffline();
            if (hasCachedData && !navigator.onLine) {
                console.log('[Startup] No access token but cached data available offline  showing offline unlock');
                showOfflineUnlockScreen();
                return;
            }
        }
    }

    // No valid session or need re-authentication  login screen is already visible
})();
    </script>

    <script>
if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
        navigator.serviceWorker.register('./sw.js').catch(function(err) {
            console.warn('[ServiceWorker] Registration failed:', err && err.message ? err.message : err);
        });
    });
}
    </script>
    <script type="module" src="src/formulas/bridge.js"></script>
</body>
</html>
