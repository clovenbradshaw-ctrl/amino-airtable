<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DB Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f5f5f5; color: #333; display: flex; height: 100vh; }

        /* Sidebar scrollbar styling */
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-track { background: transparent; }
        .sidebar::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.15); border-radius: 3px; }
        .sidebar::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.25); }

        /* Sidebar - Light mode style */
        .sidebar { width: 288px; background: #ffffff; border-right: 1px solid #e5e7eb; overflow-y: auto; flex-shrink: 0; font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .sidebar-header { padding: 16px; border-bottom: 1px solid #e5e7eb; }
        .sidebar-header-top { display: flex; align-items: center; gap: 10px; margin-bottom: 14px; }
        .sidebar-logo { width: 28px; height: 28px; border-radius: 8px; background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%); display: flex; align-items: center; justify-content: center; }
        .sidebar-logo svg { width: 14px; height: 14px; color: #fff; }
        .sidebar-header h2 { color: #1f2937; font-size: 15px; font-weight: 600; letter-spacing: -0.01em; }

        /* Sidebar Search */
        .sidebar-search { position: relative; }
        .sidebar-search-icon { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #9ca3af; pointer-events: none; }
        .sidebar-search-icon svg { width: 14px; height: 14px; }
        .sidebar-search input {
            width: 100%;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 9px 44px 9px 36px;
            font-size: 13px;
            color: #1f2937;
            transition: all 0.15s;
        }
        .sidebar-search input::placeholder { color: #9ca3af; }
        .sidebar-search input:focus {
            outline: none;
            border-color: rgba(59, 130, 246, 0.5);
            background: #ffffff;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15);
        }
        .sidebar-search-shortcut {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #9ca3af;
            background: #e5e7eb;
            padding: 3px 6px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            font-family: system-ui, sans-serif;
        }

        /* Section Headers */
        .sidebar-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #6b7280;
            cursor: pointer;
            transition: color 0.15s;
            user-select: none;
        }
        .sidebar-section-header:hover { color: #374151; }
        .sidebar-section-header:active { color: #1f2937; background: #f3f4f6; transition: background-color 0.05s, color 0.05s; border-radius: 4px; }
        .sidebar-section-header svg { width: 12px; height: 12px; transition: transform 0.2s; }
        .sidebar-section-header.collapsed svg { transform: rotate(-90deg); }
        .sidebar-section-header .section-icon { opacity: 0.8; }
        .sidebar-section-header .section-count { margin-left: auto; font-weight: 400; color: #9ca3af; }

        /* Sidebar Divider */
        .sidebar-divider { height: 1px; background: #e5e7eb; margin: 8px 16px; }

        /* Table Items - Light mode */
        .sidebar div.table-item {
            padding: 9px 12px;
            margin: 2px 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #4b5563;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.15s;
            position: relative;
        }
        .sidebar div.table-item:hover { background: #f3f4f6; color: #1f2937; }
        .sidebar div.table-item:active { background: #e5e7eb; color: #1f2937; transition: background-color 0.05s, color 0.05s; }
        .sidebar div.table-item.active { background: #e5e7eb; color: #1f2937; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .sidebar div.table-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 20px;
            border-radius: 0 2px 2px 0;
        }
        .sidebar div.table-item .table-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .sidebar div.table-item .count { font-size: 11px; color: #9ca3af; font-variant-numeric: tabular-nums; }
        .sidebar div.table-item.active .count { color: #6b7280; }
        .sidebar div.table-item:hover .count { color: #6b7280; }

        /* Table Type Icons */
        .table-icon {
            width: 20px;
            height: 20px;
            border-radius: 5px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .table-icon svg { width: 12px; height: 12px; }
        .table-icon.type-events { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .table-icon.type-operational { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
        .table-icon.type-collection { background: rgba(139, 92, 246, 0.2); color: #8b5cf6; }
        .table-icon.type-reference { background: rgba(16, 185, 129, 0.2); color: #10b981; }
        .table-icon.type-dev { background: rgba(107, 114, 128, 0.2); color: #9ca3af; }

        /* Count Bar Visualization */
        .count-bar-wrapper { display: flex; align-items: center; gap: 6px; min-width: 54px; justify-content: flex-end; }
        .count-bar { height: 4px; border-radius: 2px; transition: all 0.15s; opacity: 0.6; }
        .count-value { font-size: 11px; font-variant-numeric: tabular-nums; min-width: 28px; text-align: right; }

        /* Pin Button */
        .pin-btn {
            padding: 4px;
            border-radius: 4px;
            background: transparent;
            border: none;
            cursor: pointer;
            opacity: 0;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .pin-btn svg { width: 12px; height: 12px; color: #9ca3af; }
        .pin-btn:hover svg { color: #f59e0b; }
        .pin-btn.pinned { opacity: 1; }
        .pin-btn.pinned svg { color: #f59e0b; fill: #f59e0b; }
        .sidebar div.table-item:hover .pin-btn { opacity: 1; }

        /* Table item with expandable views */
        .sidebar div.table-item .expand-arrow {
            font-size: 10px;
            color: #9ca3af;
            transition: transform 0.2s;
            padding: 4px;
        }
        .sidebar div.table-item.expanded .expand-arrow { transform: rotate(90deg); }
        .sidebar div.table-item:hover .expand-arrow { color: #6b7280; }

        /* Table views list (expandable) */
        .table-views-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.25s ease-out;
            background: #f9fafb;
            margin: 0 8px;
            border-radius: 0 0 8px 8px;
        }
        .table-views-list.expanded {
            max-height: 500px;
        }
        .table-view-item {
            padding: 7px 12px 7px 40px;
            cursor: pointer;
            font-size: 12px;
            color: #6b7280;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.15s;
            margin: 1px 4px;
            border-radius: 6px;
        }
        .table-view-item:hover {
            background: #e5e7eb;
            color: #1f2937;
        }
        .table-view-item:active {
            background: #d1d5db;
            color: #1f2937;
            transition: background-color 0.05s, color 0.05s;
        }
        .table-view-item.active {
            background: rgba(59, 130, 246, 0.15);
            color: #1d4ed8;
        }
        .table-view-item.active:active {
            background: rgba(59, 130, 246, 0.25);
        }
        .table-view-item .view-icon {
            font-size: 12px;
            width: 16px;
            text-align: center;
            color: #9ca3af;
        }
        .table-view-item:hover .view-icon,
        .table-view-item.active .view-icon {
            color: inherit;
        }
        .table-view-item .view-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .table-view-item .view-name-input {
            flex: 1;
            background: #ffffff;
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 4px;
            color: #1f2937;
            font-size: 12px;
            padding: 3px 8px;
            outline: none;
            min-width: 0;
        }
        .table-view-item .view-name-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .table-view-default {
            color: #9ca3af;
            font-style: italic;
        }

        /* Main content - Airtable light style */
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: #fff; }

        /* Toolbar */
        .toolbar { padding: 12px 20px; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; background: #fff; }
        .toolbar h1 { font-size: 18px; font-weight: 600; color: #333; flex: 1; }
        .btn { padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; color: #333; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 4px; }
        .btn:hover { background: #e8e8e8; }
        .btn-primary { background: #2d6cdf; border-color: #2d6cdf; color: #fff; }
        .btn-primary:hover { background: #2560c9; }

        /* Status bar */
        .status-bar { padding: 8px 20px; background: #fafafa; border-bottom: 1px solid #e0e0e0; font-size: 12px; color: #666; display: flex; align-items: center; gap: 12px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.synced { background: #20c933; }
        .status-dot.loading { background: #fcb400; }

        /* Sync toggle switch */
        .sync-toggle-wrapper { display: flex; align-items: center; gap: 6px; margin-left: 8px; padding-left: 12px; border-left: 1px solid #ddd; }
        .sync-toggle-label { font-size: 11px; color: #666; white-space: nowrap; }
        .sync-toggle { position: relative; width: 32px; height: 18px; background: #ccc; border-radius: 9px; cursor: pointer; transition: background 0.2s; }
        .sync-toggle.active { background: #20c933; }
        .sync-toggle-knob { position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: left 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .sync-toggle.active .sync-toggle-knob { left: 16px; }

        /* Sync Status Feed */
        .sync-feed-btn { background: none; border: none; padding: 2px 6px; cursor: pointer; font-size: 11px; color: #666; border-radius: 3px; margin-left: 4px; }
        .sync-feed-btn:hover { background: #e8e8e8; color: #333; }
        .sync-feed-btn.has-activity { color: #2d6cdf; }
        .sync-feed-panel { position: fixed; bottom: 60px; right: 20px; width: 420px; max-height: 300px; background: #1a1a2e; border-radius: 8px; box-shadow: 0 4px 24px rgba(0,0,0,0.3); z-index: 1000; display: none; flex-direction: column; font-family: "SF Mono", Monaco, "Cascadia Code", monospace; }
        .sync-feed-panel.visible { display: flex; }
        .sync-feed-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid #333; color: #fff; font-size: 12px; font-weight: 500; }
        .sync-feed-header-left { display: flex; align-items: center; gap: 8px; }
        .sync-feed-status-dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
        .sync-feed-status-dot.active { background: #20c933; animation: pulse 2s infinite; }
        .sync-feed-status-dot.error { background: #ff4757; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .sync-feed-close { background: none; border: none; color: #666; cursor: pointer; font-size: 16px; padding: 0 4px; }
        .sync-feed-close:hover { color: #fff; }
        .sync-feed-body { flex: 1; overflow-y: auto; padding: 8px 0; max-height: 240px; }
        .sync-feed-line { padding: 2px 12px; font-size: 11px; line-height: 1.6; color: #a0a0a0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .sync-feed-line.info { color: #7ec8e3; }
        .sync-feed-line.success { color: #20c933; }
        .sync-feed-line.error { color: #ff4757; }
        .sync-feed-line.warn { color: #fcb400; }
        .sync-feed-line .timestamp { color: #555; margin-right: 8px; }
        .sync-feed-line .prefix { color: #888; }
        .sync-feed-empty { padding: 20px; text-align: center; color: #555; font-size: 11px; }
        .sync-feed-footer { padding: 8px 12px; border-top: 1px solid #333; display: flex; align-items: center; justify-content: space-between; font-size: 10px; color: #555; }
        .sync-feed-footer button { background: #333; border: none; color: #888; font-size: 10px; padding: 4px 8px; border-radius: 3px; cursor: pointer; }
        .sync-feed-footer button:hover { background: #444; color: #fff; }

        /* Table container */
        .table-container { flex: 1; overflow: auto; }

        /* Airtable-style table */
        table { min-width: 100%; border-collapse: collapse; font-size: 13px; }
        th { background: #f5f5f5; border-bottom: 2px solid #ddd; padding: 8px 12px; text-align: left; font-weight: 500; color: #333; position: sticky; top: 0; z-index: 10; white-space: nowrap; }
        th:first-child { width: 120px; color: #666; }
        td { border-bottom: 1px solid #eee; padding: 8px 12px; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: top; }
        tr:hover td { background: #f8f9fa; }
        tr.selected td { background: #e8f0fe; }

        /* Cell content styling */
        .cell-empty { color: #ccc; }
        .cell-array { color: #333; }
        .cell-array .tag { display: inline-block; background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; font-size: 12px; }
        .cell-link { color: #2d6cdf; text-decoration: none; }
        .cell-link:hover { text-decoration: underline; }
        .cell-number { font-family: "SF Mono", Monaco, monospace; }
        .cell-bool { padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; }
        .cell-bool.true { background: #d4edda; color: #155724; }
        .cell-bool.false { background: #f8d7da; color: #721c24; }

        /* Pagination */
        .pagination { padding: 12px 20px; border-top: 1px solid #e0e0e0; background: #fafafa; display: flex; align-items: center; gap: 12px; font-size: 13px; }
        .pagination button { padding: 6px 12px; background: #fff; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; }
        .pagination button:hover:not(:disabled) { background: #f5f5f5; }
        .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
        .pagination .page-info { color: #666; }

        /* Auth screen */
        #auth-screen { position: fixed; inset: 0; background: #1d1f25; display: flex; align-items: center; justify-content: center; z-index: 100; }
        #auth-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .auth-box { background: #fff; border-radius: 8px; padding: 32px; width: 360px; box-shadow: 0 4px 24px rgba(0,0,0,0.3); }
        .auth-box h2 { font-size: 20px; margin-bottom: 8px; color: #333; }
        .auth-box p { font-size: 13px; color: #666; margin-bottom: 24px; }
        .auth-box input { width: 100%; padding: 10px 12px; background: #fff; border: 1px solid #ddd; border-radius: 6px; color: #333; font-size: 14px; margin-bottom: 12px; }
        .auth-box input:focus { outline: none; border-color: #2d6cdf; box-shadow: 0 0 0 3px rgba(45,108,223,0.1); }
        .auth-box button { width: 100%; padding: 10px; background: #2d6cdf; border: none; border-radius: 6px; color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; }
        .auth-box button:hover { background: #2560c9; }
        .auth-box button:disabled { background: #ccc; cursor: not-allowed; }
        .auth-box button.secondary { background: #f5f5f5; color: #333; }
        .auth-box button.secondary:hover { background: #e8e8e8; }
        .auth-error { color: #dc3545; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: #f8d7da; border-radius: 4px; display: none; }
        .auth-info { color: #666; font-size: 12px; margin-top: 16px; text-align: center; }
        .hidden { display: none !important; }

        /* Encryption unlock screen */
        #unlock-screen { position: fixed; inset: 0; background: #1d1f25; display: flex; align-items: center; justify-content: center; z-index: 110; }
        #unlock-screen.fading-out { opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .unlock-box { background: #fff; border-radius: 12px; padding: 32px; width: 400px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); }
        .unlock-box h2 { font-size: 22px; margin-bottom: 8px; color: #333; display: flex; align-items: center; gap: 10px; }
        .unlock-box h2 .lock-icon { font-size: 24px; }
        .unlock-box .subtitle { font-size: 13px; color: #666; margin-bottom: 24px; }
        .unlock-box input { width: 100%; padding: 12px 14px; background: #fff; border: 1px solid #ddd; border-radius: 6px; color: #333; font-size: 14px; margin-bottom: 12px; }
        .unlock-box input:focus { outline: none; border-color: #2d6cdf; box-shadow: 0 0 0 3px rgba(45,108,223,0.15); }
        .unlock-box button { width: 100%; padding: 12px; background: #2d6cdf; border: none; border-radius: 6px; color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500; transition: background 0.15s; }
        .unlock-box button:hover { background: #2560c9; }
        .unlock-box button:disabled { background: #ccc; cursor: not-allowed; }
        .unlock-box button.secondary { background: #f5f5f5; color: #333; border: 1px solid #ddd; }
        .unlock-box button.secondary:hover { background: #e8e8e8; }
        .unlock-box button.passkey-btn { background: #1a1a2e; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .unlock-box button.passkey-btn:hover { background: #16162a; }
        .unlock-box button.passkey-btn .passkey-icon { font-size: 18px; }
        .unlock-error { color: #dc3545; font-size: 13px; margin-bottom: 12px; padding: 10px 12px; background: #f8d7da; border-radius: 6px; display: none; }
        .unlock-divider { display: flex; align-items: center; gap: 12px; margin: 16px 0; color: #999; font-size: 12px; }
        .unlock-divider::before, .unlock-divider::after { content: ''; flex: 1; height: 1px; background: #e0e0e0; }
        .unlock-info { color: #666; font-size: 12px; margin-top: 16px; text-align: center; line-height: 1.5; }
        .unlock-info a { color: #2d6cdf; text-decoration: none; }
        .unlock-info a:hover { text-decoration: underline; }
        .setup-section { margin-bottom: 20px; }
        .setup-section label { display: block; font-size: 13px; color: #555; margin-bottom: 6px; font-weight: 500; }
        .password-strength { height: 4px; background: #e0e0e0; border-radius: 2px; margin-top: -8px; margin-bottom: 12px; overflow: hidden; }
        .password-strength-fill { height: 100%; transition: width 0.2s, background 0.2s; width: 0%; }
        .password-strength-fill.weak { background: #dc3545; width: 33%; }
        .password-strength-fill.medium { background: #fcb400; width: 66%; }
        .password-strength-fill.strong { background: #20c933; width: 100%; }
        .security-note { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-bottom: 16px; font-size: 12px; color: #555; line-height: 1.5; }
        .security-note strong { color: #333; }

        /* Empty state */
        .empty-state { padding: 60px 20px; text-align: center; color: #666; }
        .empty-state h3 { font-size: 16px; margin-bottom: 8px; color: #333; }

        /* Loading states */
        .loading-state { padding: 60px 20px; text-align: center; color: #666; animation: fadeIn 0.15s ease-out; }
        .loading-state h3 { font-size: 16px; margin-bottom: 8px; color: #333; }
        .loading-spinner { display: inline-block; width: 24px; height: 24px; border: 3px solid #e0e0e0; border-top-color: #2d6cdf; border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Smooth content transitions for view switching */
        .table-container > * { animation: fadeIn 0.15s ease-out; }

        /* Skeleton loading for table */
        .skeleton-row td { background: linear-gradient(90deg, #f0f0f0 25%, #e8e8e8 50%, #f0f0f0 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .skeleton-cell { height: 16px; background: #e0e0e0; border-radius: 4px; }

        /* Progress bar */
        .progress-bar { height: 3px; background: #e0e0e0; border-radius: 2px; overflow: hidden; margin-top: 4px; }
        .progress-fill { height: 100%; background: #2d6cdf; transition: width 0.3s ease; }

        /* Table loading indicator */
        .table-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .table-container { position: relative; }

        /* Airtable-style View Controls Bar */
        .view-controls-bar { display: flex; align-items: center; gap: 4px; padding: 8px 20px; background: #fff; border-bottom: 1px solid #e0e0e0; }
        .view-control-wrapper { position: relative; }
        .view-control-btn { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: transparent; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; color: #555; transition: all 0.15s; }
        .view-control-btn:hover { background: #f0f0f0; color: #333; }
        .view-control-btn.active { background: #e8f0fe; color: #2d6cdf; }
        .view-control-btn svg { flex-shrink: 0; }
        .control-count { background: #2d6cdf; color: #fff; font-size: 10px; font-weight: 600; padding: 1px 5px; border-radius: 8px; min-width: 16px; text-align: center; }
        .view-controls-spacer { flex: 1; }

        /* View Search */
        .view-search-wrapper { position: relative; display: flex; align-items: center; }
        .view-search-wrapper .search-icon { position: absolute; left: 10px; color: #999; pointer-events: none; }
        .view-search-input { padding: 6px 10px 6px 32px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; width: 180px; transition: all 0.15s; }
        .view-search-input:focus { outline: none; border-color: #2d6cdf; box-shadow: 0 0 0 2px rgba(45,108,223,0.1); width: 220px; }
        .view-search-input::placeholder { color: #aaa; }

        /* View Control Dropdowns */
        .view-control-dropdown { position: absolute; top: 100%; left: 0; margin-top: 4px; background: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); z-index: 100; min-width: 280px; display: none; }
        .view-control-dropdown.open { display: block; }
        .dropdown-section { padding: 0; }
        .dropdown-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #eee; background: #fafafa; border-radius: 8px 8px 0 0; }
        .dropdown-header span { font-size: 13px; font-weight: 600; color: #333; }
        .dropdown-action-btn { background: transparent; border: none; color: #2d6cdf; font-size: 12px; cursor: pointer; padding: 4px 8px; border-radius: 4px; }
        .dropdown-action-btn:hover { background: #e8f0fe; }

        /* Filter Dropdown */
        .filter-list { padding: 12px 16px; max-height: 300px; overflow-y: auto; }
        .empty-filters, .empty-sorts { color: #999; font-size: 13px; text-align: center; padding: 20px 0; }
        .filter-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid #f0f0f0; }
        .filter-row:last-child { border-bottom: none; }
        .filter-row select, .filter-row input { padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
        .filter-row select { min-width: 100px; }
        .filter-row input { flex: 1; min-width: 80px; }
        .filter-remove-btn { background: transparent; border: none; color: #999; cursor: pointer; padding: 4px; border-radius: 4px; }
        .filter-remove-btn:hover { background: #fee2e2; color: #dc2626; }

        /* Sort Dropdown */
        .sort-list { padding: 12px 16px; max-height: 300px; overflow-y: auto; }
        .sort-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid #f0f0f0; }
        .sort-row:last-child { border-bottom: none; }
        .sort-row select { padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; flex: 1; }
        .sort-direction-btns { display: flex; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; }
        .sort-direction-btn { padding: 6px 10px; background: #fff; border: none; cursor: pointer; font-size: 11px; color: #666; }
        .sort-direction-btn.active { background: #2d6cdf; color: #fff; }
        .sort-direction-btn:first-child { border-right: 1px solid #ddd; }
        .sort-remove-btn { background: transparent; border: none; color: #999; cursor: pointer; padding: 4px; border-radius: 4px; }
        .sort-remove-btn:hover { background: #fee2e2; color: #dc2626; }

        /* Group Dropdown */
        .group-options, .color-options { padding: 8px 0; max-height: 400px; overflow-y: auto; }
        .group-option, .color-option { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; font-size: 13px; transition: background 0.1s; }
        .group-option:hover, .color-option:hover { background: #f5f5f5; }
        .group-option .check-mark, .color-option .check-mark { color: #2d6cdf; font-size: 14px; width: 16px; visibility: hidden; }
        .group-option.selected .check-mark, .color-option.selected .check-mark, .group-option.none-selected .check-mark, .color-option.none-selected .check-mark { visibility: visible; }

        /* Dropdown Search */
        .dropdown-search-wrapper { padding: 8px 12px; border-bottom: 1px solid #eee; }
        .dropdown-search-input { width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; box-sizing: border-box; }
        .dropdown-search-input:focus { outline: none; border-color: #2d6cdf; box-shadow: 0 0 0 2px rgba(45,108,223,0.1); }
        .dropdown-search-input::placeholder { color: #aaa; }

        /* Grouped Table View */
        .group-header-row td {
            background: #f8f9fa;
            font-weight: 600;
            padding: 10px 12px !important;
            border-top: 1px solid #e0e0e0;
            cursor: pointer;
            user-select: none;
        }
        .group-header-row:hover td { background: #f0f1f3; }
        .group-header-row .group-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #333;
        }
        .group-header-row .group-toggle svg {
            width: 16px;
            height: 16px;
            transition: transform 0.2s;
            color: #666;
        }
        .group-header-row.collapsed .group-toggle svg { transform: rotate(-90deg); }
        .group-header-row .group-name { font-size: 13px; }
        .group-header-row .group-count {
            font-size: 12px;
            color: #666;
            font-weight: 400;
            margin-left: 8px;
        }
        .group-row.hidden { display: none; }

        /* Row Height Dropdown */
        .row-height-option { display: flex; align-items: center; gap: 10px; padding: 10px 16px; cursor: pointer; font-size: 13px; transition: background 0.1s; }
        .row-height-option:hover { background: #f5f5f5; }
        .row-height-option.selected { background: #e8f0fe; color: #2d6cdf; }
        .row-height-option svg { color: #666; }
        .row-height-option.selected svg { color: #2d6cdf; }

        /* Row height variations */
        table.row-height-short td { padding: 4px 12px; }
        table.row-height-medium td { padding: 8px 12px; }
        table.row-height-tall td { padding: 14px 12px; }
        table.row-height-extra-tall td { padding: 20px 12px; white-space: normal; }

        /* Field History Modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
        .modal-overlay.open { opacity: 1; visibility: visible; }
        .modal { background: #fff; border-radius: 12px; width: 90%; max-width: 700px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,0.3); transform: translateY(20px); transition: transform 0.2s; }
        .modal-overlay.open .modal { transform: translateY(0); }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; }
        .modal-header h2 { font-size: 18px; font-weight: 600; color: #333; flex: 1; margin: 0; }
        .modal-header .record-id { font-size: 12px; color: #999; font-family: "SF Mono", Monaco, monospace; }
        .modal-close { width: 32px; height: 32px; border: none; background: #f5f5f5; border-radius: 6px; cursor: pointer; font-size: 18px; color: #666; display: flex; align-items: center; justify-content: center; }
        .modal-close:hover { background: #e8e8e8; color: #333; }
        .modal-body { flex: 1; overflow-y: auto; padding: 0; }
        .modal-empty { padding: 60px 20px; text-align: center; color: #666; }
        .modal-empty h3 { font-size: 16px; color: #333; margin-bottom: 8px; }

        /* History Timeline */
        .history-timeline { padding: 16px 0; }
        .history-item { padding: 16px 24px; border-bottom: 1px solid #f0f0f0; transition: background 0.15s; }
        .history-item:hover { background: #fafafa; }
        .history-item:last-child { border-bottom: none; }
        .history-item-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
        .history-field-name { font-weight: 600; color: #333; font-size: 14px; }
        .history-change-type { font-size: 11px; font-weight: 500; padding: 3px 8px; border-radius: 4px; text-transform: uppercase; letter-spacing: 0.3px; }
        .history-change-type.created { background: #d1fae5; color: #059669; }
        .history-change-type.updated { background: #dbeafe; color: #1d4ed8; }
        .history-change-type.deleted { background: #fee2e2; color: #dc2626; }
        .history-timestamp { font-size: 12px; color: #999; margin-left: auto; }
        .history-event-id { font-size: 11px; color: #ccc; font-family: "SF Mono", Monaco, monospace; }
        .history-values { display: flex; gap: 12px; align-items: flex-start; flex-wrap: wrap; }
        .history-value-box { flex: 1; min-width: 200px; padding: 10px 12px; border-radius: 6px; font-size: 13px; }
        .history-value-box.old { background: #fef2f2; border: 1px solid #fecaca; }
        .history-value-box.new { background: #f0fdf4; border: 1px solid #bbf7d0; }
        .history-value-box.null { background: #f5f5f5; border: 1px solid #e0e0e0; color: #999; font-style: italic; }
        .history-value-label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #999; margin-bottom: 4px; }
        .history-value-content { word-break: break-word; color: #333; }
        .history-arrow { color: #999; font-size: 16px; flex-shrink: 0; align-self: center; }

        /* History Button in Table */
        .history-btn { padding: 4px 8px; background: transparent; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 11px; color: #666; display: inline-flex; align-items: center; gap: 4px; transition: all 0.15s; }
        .history-btn:hover { background: #f5f5f5; border-color: #2d6cdf; color: #2d6cdf; }
        .history-btn svg { width: 12px; height: 12px; }

        /* Field filter in modal */
        .modal-toolbar { padding: 12px 24px; background: #fafafa; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; }
        .modal-toolbar select { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; background: #fff; }
        .modal-toolbar .history-count { font-size: 12px; color: #666; margin-left: auto; }

        /* View Selector in Data Toolbar */
        .view-selector { position: relative; display: flex; align-items: center; gap: 8px; }
        .view-selector-btn { padding: 6px 12px; background: #fff; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 8px; min-width: 140px; transition: border-color 0.15s; }
        .view-selector-btn:hover { border-color: #2d6cdf; }
        .view-selector-btn .view-icon { font-size: 14px; }
        .view-selector-btn .view-name { flex: 1; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .view-selector-btn .dropdown-arrow { font-size: 10px; color: #666; }
        .view-selector-dropdown { position: absolute; top: 100%; left: 0; margin-top: 4px; min-width: 200px; background: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); z-index: 100; max-height: 300px; overflow-y: auto; display: none; }
        .view-selector-dropdown.open { display: block; }
        .view-selector-dropdown-header { padding: 10px 12px; font-size: 11px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #eee; background: #fafafa; }
        .view-selector-option { padding: 10px 12px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 10px; transition: background 0.1s; }
        .view-selector-option:hover { background: #f5f5f5; }
        .view-selector-option.active { background: #e8f0fe; color: #2d6cdf; }
        .view-selector-option .view-type-icon { width: 20px; text-align: center; }
        .view-selector-option .view-option-name { flex: 1; }
        .view-selector-option .view-check { color: #2d6cdf; font-size: 14px; }

        /* Fields Button & Dropdown */
        .fields-btn { padding: 6px 12px; background: #fff; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 6px; transition: all 0.15s; }
        .fields-btn:hover { border-color: #2d6cdf; background: #f8faff; }
        .fields-btn .fields-icon { font-size: 14px; }
        .fields-btn .fields-count { background: #e8f0fe; color: #2d6cdf; padding: 2px 6px; border-radius: 10px; font-size: 11px; font-weight: 600; }
        .fields-dropdown { position: absolute; top: 100%; right: 0; margin-top: 4px; width: 280px; background: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); z-index: 100; display: none; }
        .fields-dropdown.open { display: block; }
        .fields-dropdown-header { padding: 12px 16px; border-bottom: 1px solid #eee; display: flex; align-items: center; justify-content: space-between; }
        .fields-dropdown-header h3 { font-size: 14px; font-weight: 600; color: #333; margin: 0; }
        .fields-dropdown-actions { display: flex; gap: 8px; }
        .fields-dropdown-actions button { padding: 4px 8px; font-size: 11px; background: transparent; border: none; color: #2d6cdf; cursor: pointer; border-radius: 4px; }
        .fields-dropdown-actions button:hover { background: #e8f0fe; }
        .fields-dropdown-list { max-height: 350px; overflow-y: auto; padding: 8px 0; }
        .fields-dropdown-item { padding: 8px 16px; display: flex; align-items: center; gap: 10px; cursor: pointer; transition: background 0.1s; user-select: none; }
        .fields-dropdown-item:hover { background: #f5f5f5; }
        .fields-dropdown-item.dragging { background: #e8f0fe; opacity: 0.8; }
        .fields-dropdown-item .field-drag-handle { cursor: grab; color: #ccc; font-size: 12px; padding: 2px; }
        .fields-dropdown-item .field-drag-handle:hover { color: #999; }
        .fields-dropdown-item .field-checkbox { width: 18px; height: 18px; border: 2px solid #ddd; border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: all 0.15s; flex-shrink: 0; }
        .fields-dropdown-item .field-checkbox.checked { background: #2d6cdf; border-color: #2d6cdf; color: #fff; }
        .fields-dropdown-item .field-checkbox .check-icon { font-size: 12px; display: none; }
        .fields-dropdown-item .field-checkbox.checked .check-icon { display: block; }
        .fields-dropdown-item .field-info { flex: 1; min-width: 0; }
        .fields-dropdown-item .field-name { font-size: 13px; color: #333; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .fields-dropdown-item .field-type { font-size: 11px; color: #999; }
        .fields-dropdown-item .field-move-btns { display: flex; flex-direction: column; gap: 2px; opacity: 0; transition: opacity 0.15s; }
        .fields-dropdown-item:hover .field-move-btns { opacity: 1; }
        .fields-dropdown-item .field-move-btn { width: 18px; height: 14px; border: none; background: #f0f0f0; border-radius: 3px; cursor: pointer; font-size: 10px; color: #666; display: flex; align-items: center; justify-content: center; }
        .fields-dropdown-item .field-move-btn:hover { background: #e0e0e0; color: #333; }
        .fields-dropdown-footer { padding: 10px 16px; border-top: 1px solid #eee; background: #fafafa; font-size: 11px; color: #999; }

        /* View-specific toolbar wrapper */
        .toolbar-views { display: flex; align-items: center; gap: 8px; position: relative; }

        /* Initial Loading Overlay */
        #loading-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #1d1f25 0%, #2d3748 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #loading-overlay.fading-out {
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }
        .loading-content {
            text-align: center;
            max-width: 400px;
            padding: 40px;
        }
        .loading-logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 24px;
            position: relative;
        }
        .loading-logo-inner {
            width: 100%;
            height: 100%;
            border-radius: 20px;
            background: linear-gradient(135deg, #2d6cdf 0%, #7c3aed 100%);
            animation: pulse-glow 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            color: white;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(45, 108, 223, 0.4); transform: scale(1); }
            50% { box-shadow: 0 0 40px rgba(124, 58, 237, 0.6); transform: scale(1.05); }
        }
        .loading-title {
            font-size: 24px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        .loading-subtitle {
            font-size: 14px;
            color: #a0aec0;
            margin-bottom: 32px;
            line-height: 1.5;
        }
        .loading-progress-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 24px;
        }
        .loading-progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 16px;
            position: relative;
        }
        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2d6cdf, #7c3aed, #2d6cdf);
            background-size: 200% 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
            animation: shimmer-progress 1.5s linear infinite;
        }
        @keyframes shimmer-progress {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        .loading-status {
            font-size: 13px;
            color: #e2e8f0;
            margin-bottom: 4px;
        }
        .loading-detail {
            font-size: 12px;
            color: #718096;
            font-family: "SF Mono", Monaco, monospace;
        }
        .loading-time-estimate {
            font-size: 11px;
            color: #a0aec0;
            margin-top: 8px;
            min-height: 16px;
        }
        .loading-progress-activity {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            border-radius: 3px;
        }
        .loading-progress-activity::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
            animation: activity-sweep 1.2s ease-in-out infinite;
        }
        @keyframes activity-sweep {
            0% { left: -50%; }
            100% { left: 100%; }
        }
        .loading-facts {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 24px;
        }
        .loading-fact {
            text-align: center;
        }
        .loading-fact-value {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            line-height: 1;
        }
        .loading-fact-label {
            font-size: 11px;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }
        .loading-note {
            font-size: 12px;
            color: #4a5568;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 16px;
            border-radius: 8px;
            border-left: 3px solid #2d6cdf;
        }
        .loading-note strong {
            color: #a0aec0;
        }
        .loading-skip-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .loading-skip-text {
            font-size: 12px;
            color: #718096;
            margin-bottom: 12px;
        }
        .loading-skip-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #a0aec0;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .loading-skip-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            color: #fff;
        }
        .loading-skip-btn:active {
            transform: scale(0.98);
        }
        /* Floating particles animation */
        .loading-particles {
            position: absolute;
            inset: 0;
            overflow: hidden;
            pointer-events: none;
        }
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(45, 108, 223, 0.3);
            border-radius: 50%;
            animation: float-up 8s ease-in-out infinite;
        }
        .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
        .particle:nth-child(2) { left: 20%; animation-delay: 1s; }
        .particle:nth-child(3) { left: 30%; animation-delay: 2s; }
        .particle:nth-child(4) { left: 40%; animation-delay: 3s; }
        .particle:nth-child(5) { left: 50%; animation-delay: 4s; }
        .particle:nth-child(6) { left: 60%; animation-delay: 5s; }
        .particle:nth-child(7) { left: 70%; animation-delay: 6s; }
        .particle:nth-child(8) { left: 80%; animation-delay: 7s; }
        .particle:nth-child(9) { left: 90%; animation-delay: 0.5s; }
        .particle:nth-child(10) { left: 15%; animation-delay: 2.5s; }
        @keyframes float-up {
            0%, 100% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 1; transform: translateY(90vh) scale(1); }
            90% { opacity: 1; transform: translateY(10vh) scale(1); }
            100% { transform: translateY(0) scale(0); opacity: 0; }
        }

        /* Refresh indicator for incremental syncs */
        .refresh-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #999;
            padding: 2px 8px;
            border-radius: 4px;
            transition: all 0.3s;
        }
        .refresh-indicator.syncing {
            color: #2d6cdf;
            background: rgba(45, 108, 223, 0.1);
        }
        .refresh-indicator .refresh-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #999;
            transition: all 0.3s;
        }
        .refresh-indicator.syncing .refresh-dot {
            background: #2d6cdf;
            animation: pulse-dot 1s ease-in-out infinite;
        }
        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
        }

        /* View Save Indicator */
        .view-save-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #999;
            padding: 4px 10px;
            border-radius: 4px;
            transition: all 0.3s;
            margin-left: 8px;
        }
        .view-save-indicator.dirty {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }
        .view-save-indicator.saving {
            color: #2d6cdf;
            background: rgba(45, 108, 223, 0.1);
        }
        .view-save-indicator.saved {
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }
        .view-save-indicator .save-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }
        .view-save-indicator.saving .save-dot {
            animation: pulse-dot 1s ease-in-out infinite;
        }
        .view-save-btn {
            padding: 4px 10px;
            background: #2d6cdf;
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 4px;
            transition: all 0.15s;
        }
        .view-save-btn:hover {
            background: #2560c9;
        }
        .view-save-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* View Folders in Sidebar */
        .table-view-folder {
            padding: 6px 16px 6px 36px;
            cursor: pointer;
            font-size: 12px;
            color: #8a8a8a;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.15s;
            user-select: none;
        }
        .table-view-folder:hover {
            background: #2d2f36;
            color: #fff;
        }
        .table-view-folder .folder-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }
        .table-view-folder.expanded .folder-icon {
            transform: rotate(90deg);
        }
        .table-view-folder .folder-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .table-view-folder .folder-actions {
            display: none;
            gap: 4px;
        }
        .table-view-folder:hover .folder-actions {
            display: flex;
        }
        .table-view-folder .folder-action-btn {
            background: transparent;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 2px 4px;
            font-size: 10px;
            border-radius: 3px;
        }
        .table-view-folder .folder-action-btn:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }
        .folder-views-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.25s ease-out;
        }
        .folder-views-list.expanded {
            max-height: 500px;
        }
        .folder-views-list .table-view-item {
            padding-left: 52px;
        }
        .table-view-add-btn {
            padding: 6px 16px 6px 44px;
            cursor: pointer;
            font-size: 12px;
            color: #555;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.15s;
        }
        .table-view-add-btn:hover {
            background: #2d2f36;
            color: #2d6cdf;
        }
        .table-view-add-btn .add-icon {
            font-size: 14px;
            color: #2d6cdf;
        }

        /* Folder Input */
        .folder-name-input {
            background: #2d2f36;
            border: 1px solid #2d6cdf;
            color: #fff;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            width: 120px;
        }
        .folder-name-input:focus {
            outline: none;
            border-color: #5b9aff;
        }

        /* Context Menu for Views */
        .view-context-menu {
            position: fixed;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 160px;
            padding: 4px 0;
            display: none;
        }
        .view-context-menu.open {
            display: block;
        }
        .view-context-menu-item {
            padding: 8px 16px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .view-context-menu-item:hover {
            background: #f5f5f5;
        }
        .view-context-menu-item.danger {
            color: #dc2626;
        }
        .view-context-menu-item.danger:hover {
            background: #fee2e2;
        }
        .view-context-menu-separator {
            height: 1px;
            background: #eee;
            margin: 4px 0;
        }

        /* Column Drag Styles */
        th.dragging {
            opacity: 0.5;
            background: #e8f0fe !important;
        }
        th.drag-over {
            border-left: 3px solid #2d6cdf;
        }
        th {
            cursor: grab;
        }
        th:active {
            cursor: grabbing;
        }
        th:first-child {
            cursor: default;
        }

        /* Schema View - Card Layout */
        .schema-view-container {
            padding: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            overflow-y: auto;
        }
        .schema-card {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            width: 320px;
            max-height: 500px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: box-shadow 0.2s, transform 0.2s;
            display: flex;
            flex-direction: column;
        }
        .schema-card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }
        .schema-card-header {
            padding: 16px;
            background: linear-gradient(135deg, #f8f9fa 0%, #fff 100%);
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .schema-card-id {
            font-family: "SF Mono", Monaco, monospace;
            font-size: 11px;
            color: #666;
            background: #f0f0f0;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .schema-card-actions {
            display: flex;
            gap: 8px;
        }
        .schema-card-body {
            padding: 0;
            overflow-y: auto;
            flex: 1;
        }
        .schema-field-row {
            padding: 12px 16px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .schema-field-row:last-child {
            border-bottom: none;
        }
        .schema-field-name {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .schema-field-value {
            font-size: 13px;
            color: #333;
            word-break: break-word;
        }
        .schema-field-value.empty {
            color: #ccc;
            font-style: italic;
        }

        /* Create View Modal */
        .create-view-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }
        .create-view-modal.open {
            opacity: 1;
            visibility: visible;
        }
        .create-view-modal-content {
            background: #fff;
            border-radius: 12px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            transform: translateY(20px);
            transition: transform 0.2s;
        }
        .create-view-modal.open .create-view-modal-content {
            transform: translateY(0);
        }
        .create-view-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e0e0e0;
        }
        .create-view-modal-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin: 0 0 4px 0;
        }
        .create-view-modal-header p {
            font-size: 13px;
            color: #666;
            margin: 0;
        }
        .create-view-modal-body {
            padding: 24px;
        }
        .create-view-field {
            margin-bottom: 16px;
        }
        .create-view-field label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #333;
            margin-bottom: 6px;
        }
        .create-view-field input,
        .create-view-field select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        .create-view-field input:focus,
        .create-view-field select:focus {
            outline: none;
            border-color: #2d6cdf;
            box-shadow: 0 0 0 3px rgba(45,108,223,0.1);
        }
        .create-view-modal-footer {
            padding: 16px 24px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            background: #fafafa;
            border-radius: 0 0 12px 12px;
        }
        .create-view-modal-footer button {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        .create-view-modal-footer .btn-cancel {
            background: #fff;
            border: 1px solid #ddd;
            color: #666;
        }
        .create-view-modal-footer .btn-cancel:hover {
            background: #f5f5f5;
        }
        .create-view-modal-footer .btn-create {
            background: #2d6cdf;
            border: 1px solid #2d6cdf;
            color: #fff;
        }
        .create-view-modal-footer .btn-create:hover {
            background: #2560c9;
        }

        /* View Tags */
        .view-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }
        .view-tag {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            background: #e8f0fe;
            color: #2d6cdf;
        }
        .view-tag.workspace {
            background: #fef3c7;
            color: #92400e;
        }
        .table-view-item .view-tags {
            padding-left: 24px;
        }

        /* Workspace Tabs */
        .workspace-tabs {
            display: flex;
            gap: 4px;
            padding: 8px 16px;
            background: #16181d;
            border-bottom: 1px solid #2d2f36;
        }
        .workspace-tab {
            padding: 6px 12px;
            font-size: 12px;
            color: #8a8a8a;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .workspace-tab:hover {
            background: #2d2f36;
            color: #fff;
        }
        .workspace-tab.active {
            background: #2d6cdf;
            color: #fff;
        }
        .workspace-tab .workspace-count {
            margin-left: 6px;
            font-size: 10px;
            background: rgba(255,255,255,0.2);
            padding: 2px 5px;
            border-radius: 8px;
        }
        .workspace-add-btn {
            padding: 6px 8px;
            font-size: 12px;
            color: #666;
            cursor: pointer;
        }
        .workspace-add-btn:hover {
            color: #2d6cdf;
        }

        /* Nested Views Indentation */
        .table-view-item.nested-level-1 { padding-left: 60px; }
        .table-view-item.nested-level-2 { padding-left: 76px; }
        .table-view-item.nested-level-3 { padding-left: 92px; }
        .view-nest-indicator {
            font-size: 10px;
            color: #666;
            margin-right: 4px;
        }

        /* View Type Indicator in Sidebar */
        .view-type-badge {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            background: #2d2f36;
            color: #888;
            margin-left: auto;
        }
        .view-type-badge.schema { background: #7c3aed; color: #fff; }
        .view-type-badge.grid { background: #2d6cdf; color: #fff; }

        /* Events View Styles - Events section header is now handled by sidebar-section-header */
        .events-section-header {
            padding: 12px 16px 8px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #6b7280;
            border-bottom: 1px solid #e5e7eb;
        }
        .sidebar div.table-item.events-item {
            margin: 2px 8px;
            border-radius: 8px;
            background: transparent;
            border: none;
        }
        .sidebar div.table-item.events-item .table-icon {
            background: rgba(245, 158, 11, 0.15);
            border-radius: 5px;
        }
        .sidebar div.table-item.events-item .table-icon svg { color: #d97706; }
        .sidebar div.table-item.events-item:hover {
            background: #f3f4f6;
        }
        .sidebar div.table-item.events-item:active {
            background: rgba(139, 92, 246, 0.15);
            transition: background-color 0.05s;
        }
        .sidebar div.table-item.events-item.active {
            background: rgba(139, 92, 246, 0.15);
        }
        .sidebar div.table-item.events-item.active::before {
            background: #8b5cf6;
        }

        /* Sync Status sidebar item */
        .sidebar div.table-item.sync-status-item {
            margin: 2px 8px;
            border-radius: 8px;
            background: transparent;
            border: none;
        }
        .sidebar div.table-item.sync-status-item .table-icon {
            background: rgba(16, 185, 129, 0.15);
            border-radius: 5px;
        }
        .sidebar div.table-item.sync-status-item .table-icon svg { color: #10b981; }
        .sidebar div.table-item.sync-status-item:hover {
            background: #f3f4f6;
        }
        .sidebar div.table-item.sync-status-item:active {
            background: rgba(16, 185, 129, 0.15);
            transition: background-color 0.05s;
        }
        .sidebar div.table-item.sync-status-item.active {
            background: rgba(16, 185, 129, 0.15);
        }
        .sidebar div.table-item.sync-status-item.active::before {
            background: #10b981;
        }

        /* Sync Status View */
        .sync-status-view { padding: 24px; max-width: 1200px; }
        .sync-status-header { display: flex; align-items: center; gap: 12px; margin-bottom: 24px; }
        .sync-status-header h2 { font-size: 18px; font-weight: 600; color: #1f2937; }
        .sync-status-header .sync-status-badge {
            font-size: 11px; font-weight: 600; padding: 3px 10px; border-radius: 12px;
        }
        .sync-status-badge.synced { background: #d1fae5; color: #065f46; }
        .sync-status-badge.syncing { background: #fef3c7; color: #92400e; }
        .sync-status-badge.error { background: #fee2e2; color: #991b1b; }

        .sync-status-cards {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; margin-bottom: 24px;
        }
        .sync-status-card {
            background: #fff; border: 1px solid #e5e7eb; border-radius: 10px; padding: 18px;
        }
        .sync-status-card .card-label { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #6b7280; margin-bottom: 6px; }
        .sync-status-card .card-value { font-size: 22px; font-weight: 600; color: #1f2937; }
        .sync-status-card .card-sub { font-size: 12px; color: #9ca3af; margin-top: 4px; }

        .sync-status-section { margin-bottom: 24px; }
        .sync-status-section h3 { font-size: 14px; font-weight: 600; color: #374151; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .sync-status-section h3 .section-dot { width: 8px; height: 8px; border-radius: 50%; }
        .sync-status-section h3 .section-dot.green { background: #10b981; }
        .sync-status-section h3 .section-dot.amber { background: #f59e0b; }
        .sync-status-section h3 .section-dot.red { background: #ef4444; }

        .sync-history-table { width: 100%; border-collapse: collapse; font-size: 13px; background: #fff; border: 1px solid #e5e7eb; border-radius: 10px; overflow: hidden; }
        .sync-history-table th { background: #f9fafb; border-bottom: 1px solid #e5e7eb; padding: 10px 14px; text-align: left; font-weight: 600; color: #374151; font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; }
        .sync-history-table td { border-bottom: 1px solid #f3f4f6; padding: 10px 14px; color: #4b5563; }
        .sync-history-table tr:last-child td { border-bottom: none; }
        .sync-history-table tr:hover td { background: #f9fafb; }
        .sync-history-table .sync-type-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: 4px; text-transform: uppercase; }
        .sync-history-table .sync-type-badge.incremental { background: #dbeafe; color: #1d4ed8; }
        .sync-history-table .sync-type-badge.full { background: #ede9fe; color: #6d28d9; }
        .sync-history-table .sync-type-badge.snapshot { background: #d1fae5; color: #065f46; }
        .sync-history-table .sync-type-badge.error { background: #fee2e2; color: #991b1b; }
        .sync-result-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: 4px; }
        .sync-result-badge.success { background: #d1fae5; color: #065f46; }
        .sync-result-badge.error { background: #fee2e2; color: #991b1b; }
        .sync-result-badge.no-change { background: #f3f4f6; color: #6b7280; }

        .sync-poll-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .sync-poll-controls .btn-poll {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 8px 16px; border-radius: 8px; border: 1px solid #e5e7eb;
            background: #fff; font-size: 13px; font-weight: 500; color: #374151;
            cursor: pointer; transition: all 0.15s;
        }
        .sync-poll-controls .btn-poll:hover { background: #f9fafb; border-color: #d1d5db; }
        .sync-poll-controls .btn-poll.primary { background: #10b981; color: #fff; border-color: #10b981; }
        .sync-poll-controls .btn-poll.primary:hover { background: #059669; }
        .sync-poll-controls .btn-poll:disabled { opacity: 0.5; cursor: not-allowed; }

        .snapshot-export-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }

        .sync-activity-log {
            background: #1a1a2e; border-radius: 10px; padding: 16px; max-height: 300px; overflow-y: auto;
            font-family: "SF Mono", Monaco, Consolas, monospace; font-size: 12px; line-height: 1.6;
        }
        .sync-activity-log .log-line { color: #8b92a8; }
        .sync-activity-log .log-line .timestamp { color: #5a6178; margin-right: 8px; }
        .sync-activity-log .log-line.info .message { color: #60a5fa; }
        .sync-activity-log .log-line.success .message { color: #34d399; }
        .sync-activity-log .log-line.error .message { color: #f87171; }
        .sync-activity-log .log-line.warn .message { color: #fbbf24; }
        .sync-activity-log .log-empty { color: #5a6178; text-align: center; padding: 20px; }

        /* Events Table */
        .events-table { min-width: 100%; border-collapse: collapse; font-size: 13px; }
        .events-table th { background: #f5f5f5; border-bottom: 2px solid #ddd; padding: 10px 12px; text-align: left; font-weight: 500; color: #333; position: sticky; top: 0; z-index: 10; white-space: nowrap; }
        .events-table td { border-bottom: 1px solid #eee; padding: 10px 12px; vertical-align: top; }
        .events-table tr:hover td { background: #f8f9fa; }
        .events-table .event-id { font-family: "SF Mono", Monaco, monospace; font-size: 12px; color: #666; }
        .events-table .event-timestamp { font-size: 12px; color: #666; white-space: nowrap; }
        .events-table .event-set { font-family: "SF Mono", Monaco, monospace; font-size: 11px; color: #2d6cdf; background: #e8f0fe; padding: 2px 6px; border-radius: 4px; display: inline-block; max-width: 150px; overflow: hidden; text-overflow: ellipsis; }
        .events-table .event-record-id { font-family: "SF Mono", Monaco, monospace; font-size: 11px; color: #059669; background: #d1fae5; padding: 2px 6px; border-radius: 4px; display: inline-block; }
        .events-table .event-type-badge { font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 4px; }
        .events-table .event-type-badge.data { background: #dbeafe; color: #1d4ed8; }
        .events-table .event-type-badge.INS { background: #d1fae5; color: #065f46; }
        .events-table .event-type-badge.ALT { background: #fef3c7; color: #92400e; }
        .events-table .event-type-badge.NUL { background: #fee2e2; color: #991b1b; }
        .events-table .event-type-badge.SYN { background: #dbeafe; color: #1d4ed8; }
        .events-table .event-type-badge.table { background: #fef3c7; color: #92400e; }
        .events-table .event-type-badge.field { background: #ede9fe; color: #6d28d9; }
        .events-table .event-type-badge.view { background: #fce7f3; color: #be185d; }
        .events-table .event-type-badge.viewconfig { background: #f3e8ff; color: #7c3aed; }
        .events-table .event-type-badge.current { background: #d1fae5; color: #065f46; }
        .events-table .field-op-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 4px; margin-right: 4px; }
        .events-table .field-op-badge.INS { background: #d1fae5; color: #065f46; }
        .events-table .field-op-badge.ALT { background: #fef3c7; color: #92400e; }
        .events-table .field-op-badge.NUL { background: #fee2e2; color: #991b1b; }
        .events-table .field-op-badge.SYN { background: #dbeafe; color: #1d4ed8; }
        .events-table .field-op-badge .field-count { font-weight: 400; opacity: 0.8; }
        .events-table .event-details { white-space: nowrap; }
        .events-table .current-state-row { background: #f0fdf4; }
        .events-table .event-id.current-state { color: #9ca3af; }

        /* New Event Indicator */
        .events-table tr.new-event td { background: linear-gradient(90deg, #ecfdf5 0%, #fff 100%); }
        .events-table tr.new-event:hover td { background: linear-gradient(90deg, #d1fae5 0%, #f8f9fa 100%); }
        .new-event-badge { display: inline-flex; align-items: center; gap: 4px; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 4px; background: #10b981; color: #fff; text-transform: uppercase; letter-spacing: 0.5px; margin-left: 6px; animation: pulse-new 2s ease-in-out infinite; }
        @keyframes pulse-new { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .new-events-divider { position: relative; padding: 8px 0; }
        .new-events-divider td { background: #f0fdf4 !important; border-bottom: 2px solid #10b981; text-align: center; padding: 8px 12px; }
        .new-events-divider-text { display: inline-flex; align-items: center; gap: 8px; color: #059669; font-size: 11px; font-weight: 600; }
        .new-events-divider-text::before, .new-events-divider-text::after { content: ''; display: inline-block; width: 40px; height: 1px; background: #10b981; }

        /* Payload Preview */
        .payload-preview-container { max-width: 400px; }
        .payload-preview { font-family: "SF Mono", Monaco, monospace; font-size: 11px; color: #555; background: #f8f9fa; padding: 6px 10px; border-radius: 4px; max-height: 60px; overflow: hidden; cursor: pointer; position: relative; transition: all 0.2s; border: 1px solid #e5e7eb; }
        .payload-preview:hover { background: #f0f4f8; border-color: #cbd5e1; }
        .payload-preview.expanded { max-height: none; white-space: pre-wrap; word-break: break-all; }
        .payload-expand-btn { position: absolute; bottom: 4px; right: 4px; font-size: 10px; color: #2d6cdf; background: #fff; padding: 2px 6px; border-radius: 3px; border: 1px solid #e5e7eb; cursor: pointer; }
        .payload-preview.expanded .payload-expand-btn { position: static; display: block; margin-top: 8px; }

        /* JSON Syntax Highlighting */
        .json-key { color: #7c3aed; }
        .json-string { color: #059669; }
        .json-number { color: #2563eb; }
        .json-boolean { color: #dc2626; }
        .json-null { color: #6b7280; font-style: italic; }

        /* Payload Fields Display */
        .payload-fields { }
        .payload-op-group { margin-bottom: 6px; }
        .payload-op-group:last-child { margin-bottom: 0; }
        .payload-op-label { display: inline-block; font-size: 9px; font-weight: 600; padding: 1px 5px; border-radius: 3px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        .payload-op-label.INS { background: #dcfce7; color: #166534; }
        .payload-op-label.ALT { background: #fef3c7; color: #92400e; }
        .payload-op-label.NUL { background: #fee2e2; color: #991b1b; }
        .payload-field-row { display: flex; gap: 8px; padding: 2px 0; border-bottom: 1px solid #f0f0f0; }
        .payload-field-row:last-child { border-bottom: none; }
        .payload-field-name { color: #6366f1; font-weight: 500; min-width: 80px; flex-shrink: 0; }
        .payload-field-value { color: #374151; word-break: break-word; }
        .payload-field-value.string { color: #059669; }
        .payload-field-value.number { color: #2563eb; }
        .payload-field-value.boolean { color: #dc2626; }
        .payload-field-value.null { color: #9ca3af; font-style: italic; }
        .payload-field-value.array { color: #7c3aed; }
        .payload-field-value.object { color: #0891b2; }
        .payload-raw-toggle { font-size: 10px; color: #6b7280; cursor: pointer; margin-top: 6px; }
        .payload-raw-toggle:hover { color: #2d6cdf; text-decoration: underline; }

        /* Event Actions */
        .event-actions { display: flex; gap: 6px; }
        .event-action-btn { padding: 4px 8px; background: #fff; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 11px; color: #666; display: inline-flex; align-items: center; gap: 4px; transition: all 0.15s; white-space: nowrap; }
        .event-action-btn:hover { background: #f5f5f5; border-color: #2d6cdf; color: #2d6cdf; }
        .event-action-btn.primary { background: #2d6cdf; border-color: #2d6cdf; color: #fff; }
        .event-action-btn.primary:hover { background: #2560c9; }

        /* Infinite Scroll Loading */
        .events-load-more { display: flex; align-items: center; justify-content: center; padding: 20px; gap: 10px; color: #666; font-size: 13px; }
        .events-load-more .loading-spinner-small { width: 20px; height: 20px; border: 2px solid #e5e7eb; border-top-color: #2d6cdf; border-radius: 50%; animation: spin 0.8s linear infinite; }
        .events-end-message { text-align: center; padding: 20px; color: #9ca3af; font-size: 12px; border-top: 1px solid #eee; }

        /* Point in Time Modal */
        .pit-modal { max-width: 900px; width: 95%; }
        .pit-modal-header { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .pit-modal-header .pit-info { flex: 1; }
        .pit-modal-header .pit-event-badge { font-size: 11px; background: #fef3c7; color: #92400e; padding: 4px 8px; border-radius: 4px; font-family: "SF Mono", Monaco, monospace; }
        .pit-modal-header .pit-timestamp { font-size: 12px; color: #666; }

        /* Historical data notice styling */
        .historical-notice {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #fef3c7;
            border: 1px solid #fcd34d;
            border-radius: 6px;
            padding: 10px 14px;
            margin: 0 24px 12px 24px;
            font-size: 12px;
            color: #92400e;
        }
        .historical-notice svg {
            flex-shrink: 0;
        }
        .historical-notice-text {
            line-height: 1.4;
        }
        .historical-notice-text strong {
            font-weight: 600;
        }
        .history-modal .historical-notice {
            margin: 12px 16px;
        }

        .pit-record-card { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; margin: 16px 24px; overflow: hidden; }
        .pit-record-header { background: #f8f9fa; padding: 12px 16px; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; gap: 12px; }
        .pit-record-header .pit-table-name { font-weight: 600; color: #333; }
        .pit-record-header .pit-record-id { font-family: "SF Mono", Monaco, monospace; font-size: 11px; color: #666; }
        .pit-record-header .pit-go-to-table { margin-left: auto; }
        .pit-record-fields { padding: 16px; }
        .pit-field-row { display: flex; padding: 8px 0; border-bottom: 1px solid #f0f0f0; }
        .pit-field-row:last-child { border-bottom: none; }
        .pit-field-name { width: 180px; flex-shrink: 0; font-weight: 500; color: #333; font-size: 13px; }
        .pit-field-value { flex: 1; font-size: 13px; color: #555; word-break: break-word; }
        .pit-empty-state { padding: 40px 20px; text-align: center; color: #666; }

        /* Events View Controls */
        .events-controls { padding: 12px 20px; background: #fff; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .events-filter-group { display: flex; align-items: center; gap: 8px; }
        .events-filter-group label { font-size: 12px; color: #666; font-weight: 500; }
        .events-filter-group select, .events-filter-group input { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
        .events-filter-group input { width: 150px; }
        .events-stats { margin-left: auto; font-size: 12px; color: #666; }
        .events-actions { display: flex; gap: 8px; margin-left: 12px; }
        .events-actions .btn { padding: 5px 10px; font-size: 11px; }
        .events-actions .btn svg { width: 14px; height: 14px; }
        .import-status { position: fixed; bottom: 20px; right: 20px; background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 16px 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 280px; }
        .import-status.success { border-color: #10b981; }
        .import-status.error { border-color: #ef4444; }
        .import-status-title { font-weight: 600; font-size: 14px; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
        .import-status-title.success { color: #059669; }
        .import-status-title.error { color: #dc2626; }
        .import-status-details { font-size: 12px; color: #666; }
        .import-progress { margin-top: 8px; height: 4px; background: #e5e7eb; border-radius: 2px; overflow: hidden; }
        .import-progress-bar { height: 100%; background: #2d6cdf; transition: width 0.3s; }

        /* Record Profile Slide-out Panel */
        .record-profile-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }
        .record-profile-overlay.open {
            opacity: 1;
            visibility: visible;
        }
        .record-profile-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 600px;
            max-width: 90vw;
            background: #fff;
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
            transform: translateX(100%);
            transition: transform 0.25s ease-out;
            display: flex;
            flex-direction: column;
            z-index: 1001;
        }
        .record-profile-overlay.open .record-profile-panel {
            transform: translateX(0);
        }
        .profile-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 12px;
            background: #fafafa;
        }
        .profile-header h2 {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .profile-header .profile-view-name {
            flex: 1;
            font-size: 11px;
            color: #666;
            background: #e8f4fd;
            border: 1px solid #b8d9f0;
            padding: 3px 8px;
            border-radius: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .profile-header .profile-view-name:empty {
            display: none;
        }
        .profile-header .profile-record-id {
            font-size: 11px;
            color: #999;
            font-family: "SF Mono", Monaco, monospace;
        }
        .profile-close {
            width: 32px;
            height: 32px;
            border: none;
            background: #f0f0f0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .profile-close:hover { background: #e0e0e0; color: #333; }
        .profile-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            background: #fff;
            padding: 0 20px;
        }
        .profile-tab {
            padding: 12px 16px;
            font-size: 13px;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            transition: all 0.15s;
        }
        .profile-tab:hover { color: #333; }
        .profile-tab.active {
            color: #2d6cdf;
            border-bottom-color: #2d6cdf;
        }
        .profile-tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
        }
        .profile-tab-content.active {
            display: flex;
            flex-direction: column;
        }
        .profile-sync-history-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
            color: #666;
            flex: 1;
        }
        .profile-sync-history-empty svg {
            width: 48px;
            height: 48px;
            color: #ccc;
            margin-bottom: 16px;
        }
        .profile-sync-history-empty h3 {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin: 0 0 8px 0;
        }
        .profile-sync-history-empty p {
            font-size: 13px;
            color: #666;
            margin: 0;
        }
        .profile-sync-history-list {
            padding: 16px 20px;
        }
        .profile-sync-history-item {
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #fff;
        }
        .profile-sync-history-item:last-child { margin-bottom: 0; }
        .profile-sync-history-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .profile-sync-history-field {
            font-weight: 500;
            color: #333;
            font-size: 13px;
        }
        .profile-sync-history-type {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }
        .profile-sync-history-type.created { background: #dcfce7; color: #166534; }
        .profile-sync-history-type.updated { background: #dbeafe; color: #1e40af; }
        .profile-sync-history-type.deleted { background: #fee2e2; color: #991b1b; }
        .profile-sync-history-time {
            margin-left: auto;
            font-size: 11px;
            color: #999;
        }
        .profile-sync-history-values {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }
        .profile-sync-history-value {
            flex: 1;
            padding: 6px 8px;
            border-radius: 4px;
            word-break: break-word;
        }
        .profile-sync-history-value.old { background: #fee2e2; color: #991b1b; }
        .profile-sync-history-value.new { background: #dcfce7; color: #166534; }
        .profile-sync-history-value-label {
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            margin-bottom: 2px;
            opacity: 0.7;
        }
        .profile-toolbar {
            padding: 10px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            background: #fff;
        }
        .profile-toolbar-label {
            font-size: 12px;
            color: #666;
        }
        .profile-layout-btn {
            padding: 4px 8px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            color: #666;
        }
        .profile-layout-btn:hover { background: #e8e8e8; }
        .profile-layout-btn.active { background: #2d6cdf; border-color: #2d6cdf; color: #fff; }
        .profile-toolbar-spacer { flex: 1; }
        .profile-add-block-btn {
            padding: 4px 10px;
            background: #fff;
            border: 1px dashed #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            color: #666;
        }
        .profile-add-block-btn:hover { border-color: #2d6cdf; color: #2d6cdf; }
        .profile-configure-btn {
            padding: 4px 10px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .profile-configure-btn:hover { border-color: #2d6cdf; color: #2d6cdf; }
        .profile-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }
        .profile-block {
            margin-bottom: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #fff;
        }
        .profile-block-header {
            padding: 8px 12px;
            background: #f8f9fa;
            border-bottom: 1px solid #e5e7eb;
            border-radius: 8px 8px 0 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #666;
        }
        .profile-block-header .block-drag-handle {
            cursor: grab;
            color: #ccc;
        }
        .profile-block-header .block-drag-handle:hover { color: #999; }
        .profile-block-header .block-title { flex: 1; font-weight: 500; color: #333; }
        .profile-block-header .block-cols-select {
            padding: 2px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 11px;
            background: #fff;
        }
        .profile-block-header .block-remove-btn {
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            padding: 2px;
        }
        .profile-block-header .block-remove-btn:hover { color: #dc2626; }
        .profile-block-content {
            padding: 12px;
        }
        .profile-field-grid {
            display: grid;
            gap: 12px;
        }
        .profile-field-grid.cols-1 { grid-template-columns: 1fr; }
        .profile-field-grid.cols-2 { grid-template-columns: 1fr 1fr; }
        .profile-field-grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
        .profile-field-card {
            background: #f8f9fa;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 10px 12px;
            transition: all 0.15s;
        }
        .profile-field-card:hover { border-color: #ccc; }
        .profile-field-card.dragging { opacity: 0.5; border-color: #2d6cdf; }
        .profile-field-card.drag-over { border-color: #2d6cdf; background: #e8f0fe; }
        .profile-field-name {
            font-size: 11px;
            font-weight: 500;
            color: #666;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .profile-field-name .field-drag-handle {
            cursor: grab;
            color: #ccc;
            font-size: 10px;
        }
        .profile-field-name .field-drag-handle:hover { color: #999; }
        .profile-field-value {
            font-size: 13px;
            color: #333;
            word-break: break-word;
        }
        .profile-field-value.empty {
            color: #ccc;
            font-style: italic;
        }
        .profile-nav {
            padding: 12px 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 12px;
            background: #fafafa;
        }
        .profile-nav-btn {
            padding: 6px 12px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .profile-nav-btn:hover:not(:disabled) { border-color: #2d6cdf; color: #2d6cdf; }
        .profile-nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .profile-nav-info {
            flex: 1;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        .profile-nav-history {
            padding: 6px 12px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .profile-nav-history:hover { border-color: #2d6cdf; color: #2d6cdf; }

        /* Profile Configure Mode */
        .profile-body.configure-mode .profile-field-card {
            cursor: move;
            border-style: dashed;
        }
        .profile-body.configure-mode .profile-field-card .field-drag-handle {
            display: inline;
        }
        .profile-body:not(.configure-mode) .profile-field-card .field-drag-handle {
            display: none;
        }
        .profile-body.configure-mode .profile-block-header .block-drag-handle {
            display: inline;
        }
        .profile-body:not(.configure-mode) .profile-block-header .block-drag-handle {
            display: none;
        }
        .profile-body:not(.configure-mode) .profile-block-header .block-cols-select {
            display: none;
        }
        .profile-body:not(.configure-mode) .profile-block-header .block-remove-btn {
            display: none;
        }
        .profile-body:not(.configure-mode) .profile-block-header {
            display: none;
        }
        .profile-body:not(.configure-mode) .profile-block {
            border: none;
            background: transparent;
        }
        .profile-body:not(.configure-mode) .profile-block-content {
            padding: 0;
        }
        .profile-body:not(.configure-mode) .profile-block {
            margin-bottom: 0;
        }

        /* Add Field to Block dropdown */
        .profile-add-field-btn {
            width: 100%;
            padding: 8px;
            background: #fff;
            border: 1px dashed #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            color: #999;
            margin-top: 8px;
        }
        .profile-add-field-btn:hover {
            border-color: #2d6cdf;
            color: #2d6cdf;
        }
        .profile-body:not(.configure-mode) .profile-add-field-btn {
            display: none;
        }
        .profile-field-picker {
            position: fixed;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            z-index: 1100;
            width: 240px;
            max-height: 300px;
            overflow-y: auto;
        }
        .profile-field-picker-header {
            padding: 10px 12px;
            border-bottom: 1px solid #eee;
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }
        .profile-field-picker-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .profile-field-picker-item:hover {
            background: #f5f5f5;
        }
        .profile-field-picker-item .field-type-badge {
            font-size: 10px;
            color: #999;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <!-- Encryption Unlock Screen -->
    <div id="unlock-screen" class="hidden">
        <!-- Setup Mode (first time) -->
        <div id="unlock-setup" class="unlock-box">
            <h2><span class="lock-icon">&#128274;</span> Secure Your Data</h2>
            <p class="subtitle">Set up encryption to protect your locally cached data</p>
            <div id="unlock-setup-error" class="unlock-error"></div>

            <div class="security-note">
                <strong>Why encrypt?</strong> Your API key and cached data will be encrypted before being stored in your browser. If someone gains access to your browser's storage, they won't be able to read your data without your password or passkey.
            </div>

            <div class="setup-section">
                <label for="setup-password">Create a password</label>
                <input type="password" id="setup-password" placeholder="Enter a strong password" autocomplete="new-password" oninput="updatePasswordStrength()">
                <div class="password-strength"><div class="password-strength-fill" id="password-strength-fill"></div></div>
            </div>

            <div class="setup-section">
                <label for="setup-password-confirm">Confirm password</label>
                <input type="password" id="setup-password-confirm" placeholder="Confirm your password" autocomplete="new-password">
            </div>

            <button id="setup-password-btn" onclick="setupEncryptionWithPassword()">Set Up with Password</button>

            <div class="unlock-divider">or</div>

            <button id="setup-passkey-btn" class="passkey-btn" onclick="setupEncryptionWithPasskey()">
                <span class="passkey-icon">&#128273;</span> Set Up with Passkey
            </button>

            <button id="skip-encryption-btn" class="secondary" onclick="skipEncryption()">Skip (Not Recommended)</button>

            <div class="unlock-info">
                Passkeys use your device's biometrics (Face ID, Touch ID, Windows Hello) for secure, passwordless authentication.
            </div>
        </div>

        <!-- Unlock Mode (returning user) -->
        <div id="unlock-prompt" class="unlock-box hidden">
            <h2><span class="lock-icon">&#128274;</span> Unlock Your Data</h2>
            <p class="subtitle">Enter your password or use your passkey to access your encrypted data</p>
            <div id="unlock-prompt-error" class="unlock-error"></div>

            <div id="passkey-unlock-section">
                <button id="passkey-unlock-btn" class="passkey-btn" onclick="unlockWithPasskey()">
                    <span class="passkey-icon">&#128273;</span> Unlock with Passkey
                </button>
                <div class="unlock-divider">or enter your password</div>
            </div>

            <input type="password" id="unlock-password" placeholder="Enter your password" autocomplete="current-password">
            <button id="unlock-password-btn" onclick="unlockWithPassword()">Unlock</button>

            <button id="clear-encrypted-data-btn" class="secondary" onclick="clearEncryptedData()">Clear All Data & Start Fresh</button>

            <div class="unlock-info">
                Forgot your password? You'll need to clear all local data and start fresh. Your data on the server is not affected.
            </div>
        </div>
    </div>

    <div id="auth-screen" class="hidden">
        <div class="auth-box">
            <h2>Amino Viewer</h2>
            <p>Connect to your Amino event stream</p>
            <div id="auth-error" class="auth-error"></div>
            <input type="password" id="api-key-input" placeholder="API Key" autocomplete="off">
            <input type="text" id="set-filter-input" placeholder="Filter by set (optional)" autocomplete="off">
            <button id="auth-submit">Connect</button>
            <button id="auth-clear" class="secondary hidden">Clear Local Data</button>
            <div class="auth-divider" style="display: flex; align-items: center; gap: 12px; margin: 16px 0 12px;">
                <div style="flex: 1; height: 1px; background: #e0e0e0;"></div>
                <span style="font-size: 12px; color: #999;">or</span>
                <div style="flex: 1; height: 1px; background: #e0e0e0;"></div>
            </div>
            <button id="auth-skip-upload" class="secondary" onclick="skipAuthAndUploadCSV()">Skip - Upload CSV Only</button>
            <div id="auth-info" class="auth-info"></div>
        </div>
    </div>

    <!-- Initial Data Loading Overlay -->
    <div id="loading-overlay" class="hidden">
        <div class="loading-particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
        </div>
        <div class="loading-content">
            <div class="loading-logo">
                <div class="loading-logo-inner">A</div>
            </div>
            <h1 class="loading-title">Setting Up Your Workspace</h1>
            <p class="loading-subtitle">We're downloading your data to this device for lightning-fast access.</p>

            <div class="loading-facts">
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-tables">0</div>
                    <div class="loading-fact-label">Tables</div>
                </div>
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-fields">0</div>
                    <div class="loading-fact-label">Fields</div>
                </div>
                <div class="loading-fact">
                    <div class="loading-fact-value" id="loading-records">0</div>
                    <div class="loading-fact-label">Records</div>
                </div>
            </div>

            <div class="loading-progress-container">
                <div class="loading-progress-bar">
                    <div class="loading-progress-fill" id="loading-progress-fill" style="width: 0%"></div>
                    <div class="loading-progress-activity"></div>
                </div>
                <div class="loading-status" id="loading-status">Connecting to server...</div>
                <div class="loading-detail" id="loading-detail">Page 1</div>
                <div class="loading-time-estimate" id="loading-time-estimate"></div>
            </div>

            <div class="loading-note">
                <strong>One-time setup:</strong> This only happens once per device. After this, your data loads instantly from local storage.
            </div>

            <div class="loading-skip-section">
                <div class="loading-skip-text">Have a CSV export? Skip the download and import directly.</div>
                <button class="loading-skip-btn" onclick="skipSetupAndUploadFile()">
                    Skip &amp; Upload CSV File
                </button>
            </div>
        </div>
    </div>

    <!-- Connect API Key Modal -->
    <div id="connect-api-modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; align-items: center; justify-content: center;">
        <div style="background: #fff; border-radius: 8px; padding: 24px; width: 360px; box-shadow: 0 4px 24px rgba(0,0,0,0.3);">
            <h3 style="font-size: 16px; margin-bottom: 6px; color: #333;">Connect API Key</h3>
            <p style="font-size: 13px; color: #666; margin-bottom: 16px;">Add your API key to enable syncing with the server.</p>
            <div id="connect-api-error" style="color: #dc3545; font-size: 13px; margin-bottom: 12px; padding: 8px 12px; background: #f8d7da; border-radius: 4px; display: none;"></div>
            <input type="password" id="connect-api-key-input" placeholder="API Key" autocomplete="off" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <input type="text" id="connect-api-set-filter" placeholder="Filter by set (optional)" autocomplete="off" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 12px; box-sizing: border-box;">
            <button id="connect-api-submit" onclick="submitConnectApi()" style="width: 100%; padding: 10px; background: #2d6cdf; border: none; border-radius: 6px; color: #fff; font-size: 14px; cursor: pointer; margin-bottom: 8px; font-weight: 500;">Connect</button>
            <button onclick="hideConnectApiModal()" style="width: 100%; padding: 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 6px; color: #333; font-size: 14px; cursor: pointer; font-weight: 500;">Cancel</button>
        </div>
    </div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-header-top">
                <div class="sidebar-logo">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <ellipse cx="12" cy="5" rx="9" ry="3"/>
                        <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/>
                        <path d="M3 12c0 1.66 4 3 9 3s9-1.34 9-3"/>
                    </svg>
                </div>
                <h2>Amino Viewer</h2>
            </div>
            <div class="sidebar-search">
                <span class="sidebar-search-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.3-4.3"/>
                    </svg>
                </span>
                <input type="text" id="sidebar-search-input" placeholder="Search tables..." />
                <span class="sidebar-search-shortcut">&#8984;K</span>
            </div>
        </div>
        <div id="table-list"></div>
    </div>

    <div class="main">
        <!-- Data Viewer View -->
        <div id="data-view" style="display: flex; flex-direction: column; height: 100%;">
            <div class="toolbar">
                <h1 id="title">Select a table</h1>

                <!-- View Selector -->
                <div class="toolbar-views">
                    <div class="view-selector" id="view-selector-container">
                        <button class="view-selector-btn" id="view-selector-btn" onclick="toggleViewSelector()">
                            <span class="view-icon" id="current-view-icon">&#9638;</span>
                            <span class="view-name" id="current-view-name">All Fields</span>
                            <span class="dropdown-arrow">&#9662;</span>
                        </button>
                        <div class="view-selector-dropdown" id="view-selector-dropdown">
                            <!-- View options will be rendered here -->
                        </div>
                    </div>

                    <!-- Fields Button -->
                    <button class="fields-btn" id="fields-btn" onclick="toggleFieldsDropdown()">
                        <span class="fields-icon">&#9776;</span>
                        <span>Fields</span>
                        <span class="fields-count" id="fields-visible-count">0</span>
                    </button>
                    <div class="fields-dropdown" id="fields-dropdown">
                        <div class="fields-dropdown-header">
                            <h3>Toggle Fields</h3>
                            <div class="fields-dropdown-actions">
                                <button onclick="showAllFields()">Show All</button>
                                <button onclick="hideAllFields()">Hide All</button>
                            </div>
                        </div>
                        <div class="fields-dropdown-list" id="fields-dropdown-list">
                            <!-- Field items will be rendered here -->
                        </div>
                        <div class="fields-dropdown-footer">
                            Drag to reorder  Click checkbox to toggle
                        </div>
                    </div>
                </div>

                <!-- View Save Indicator -->
                <div class="view-save-indicator" id="view-save-indicator" style="display: none;">
                    <span class="save-dot"></span>
                    <span id="save-indicator-text">Saved</span>
                </div>
                <button class="view-save-btn" id="manual-save-btn" onclick="saveViewToBackendNow()" style="display: none;">Save Now</button>

                <button class="btn" onclick="manualSync()">Sync</button>
                <button class="btn" id="connect-api-btn" onclick="showConnectApiModal()" style="display: none; background: #2d6cdf; color: #fff;">Connect API</button>
                <button class="btn" onclick="logout()">Logout</button>
            </div>

            <!-- Airtable-style View Controls Bar -->
            <div class="view-controls-bar" id="view-controls-bar">
                <!-- Filter Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="filter-btn" onclick="toggleFilterDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M4 8h8M6 12h4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                        <span>Filter</span>
                        <span class="control-count" id="filter-count" style="display: none;">0</span>
                    </button>
                    <div class="view-control-dropdown filter-dropdown" id="filter-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Filter records</span>
                                <button class="dropdown-action-btn" onclick="addFilter()">+ Add filter</button>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="filter-search-input" placeholder="Find a field" oninput="filterFilterDropdown(this.value)">
                            </div>
                            <div class="filter-list" id="filter-list">
                                <div class="empty-filters">No filters applied</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sort Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="sort-btn" onclick="toggleSortDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M4 5l2-2 2 2M6 3v10M12 11l-2 2-2-2M10 13V3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
                        <span>Sort</span>
                        <span class="control-count" id="sort-count" style="display: none;">0</span>
                    </button>
                    <div class="view-control-dropdown sort-dropdown" id="sort-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Sort records</span>
                                <button class="dropdown-action-btn" onclick="addSort()">+ Add sort</button>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="sort-search-input" placeholder="Find a field" oninput="filterSortDropdown(this.value)">
                            </div>
                            <div class="sort-list" id="sort-list">
                                <div class="empty-sorts">No sorts applied</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Group Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="group-btn" onclick="toggleGroupDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="2" y="3" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="3" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="2" y="9" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/><rect x="9" y="9" width="5" height="4" rx="1" stroke="currentColor" stroke-width="1.5"/></svg>
                        <span>Group</span>
                    </button>
                    <div class="view-control-dropdown group-dropdown" id="group-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Group records by</span>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="group-search-input" placeholder="Find a field" oninput="filterGroupDropdown(this.value)">
                            </div>
                            <div class="group-options" id="group-options">
                                <div class="group-option none-selected" onclick="setGroupBy(null)">
                                    <span class="check-mark">&#10003;</span>
                                    <span>None</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Color Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="color-btn" onclick="toggleColorDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="5" stroke="currentColor" stroke-width="1.5"/><path d="M8 3v10M3 8h10" stroke="currentColor" stroke-width="1.5"/></svg>
                        <span>Color</span>
                    </button>
                    <div class="view-control-dropdown color-dropdown" id="color-dropdown">
                        <div class="dropdown-section">
                            <div class="dropdown-header">
                                <span>Color records by</span>
                            </div>
                            <div class="dropdown-search-wrapper">
                                <input type="text" class="dropdown-search-input" id="color-search-input" placeholder="Find a field" oninput="filterColorDropdown(this.value)">
                            </div>
                            <div class="color-options" id="color-options">
                                <div class="color-option none-selected" onclick="setColorBy(null)">
                                    <span class="check-mark">&#10003;</span>
                                    <span>None</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Row Height Button -->
                <div class="view-control-wrapper">
                    <button class="view-control-btn" id="row-height-btn" onclick="toggleRowHeightDropdown()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                        <span>Row height</span>
                    </button>
                    <div class="view-control-dropdown row-height-dropdown" id="row-height-dropdown">
                        <div class="dropdown-section">
                            <div class="row-height-option" onclick="setRowHeight('short')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 6h12M2 10h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Short</span>
                            </div>
                            <div class="row-height-option selected" onclick="setRowHeight('medium')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Medium</span>
                            </div>
                            <div class="row-height-option" onclick="setRowHeight('tall')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 3h12M2 7h12M2 11h12M2 15h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Tall</span>
                            </div>
                            <div class="row-height-option" onclick="setRowHeight('extra-tall')">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M2 2h12M2 5h12M2 8h12M2 11h12M2 14h12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                                <span>Extra tall</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="view-controls-spacer"></div>

                <!-- Search -->
                <div class="view-search-wrapper">
                    <svg class="search-icon" width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="7" cy="7" r="4.5" stroke="currentColor" stroke-width="1.5"/><path d="M10.5 10.5L14 14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
                    <input type="text" class="view-search-input" id="view-search-input" placeholder="Find in view" oninput="handleViewSearch(this.value)">
                </div>
            </div>
            <div class="status-bar">
                <span class="status-dot" id="status-dot"></span>
                <span id="status-text">Ready</span>
                <div class="progress-bar" id="progress-bar" style="display: none; flex: 1; max-width: 200px;">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <span id="status-detail" style="color: #999; font-size: 11px;"></span>
                <div class="sync-toggle-wrapper">
                    <span class="sync-toggle-label">Sync to Snapshot</span>
                    <div class="sync-toggle" id="sync-toggle" onclick="toggleSnapshotSync()">
                        <div class="sync-toggle-knob"></div>
                    </div>
                    <button class="sync-feed-btn" id="sync-feed-btn" onclick="SyncStatusFeed.toggle()" title="View sync activity log">[log]</button>
                </div>
                <span style="flex: 1;"></span>
                <span class="refresh-indicator" id="refresh-indicator">
                    <span class="refresh-dot"></span>
                    <span id="last-refresh-text">Auto-refresh in 60s</span>
                </span>
            </div>
            <div class="table-container" id="table-container">
                <table id="table"></table>
            </div>
            <div class="pagination" id="pagination">
                <button id="prev-btn" onclick="prevPage()">Previous</button>
                <span class="page-info" id="page-info">Page 1</span>
                <button id="next-btn" onclick="nextPage()">Next</button>
            </div>
        </div>
    </div>

    <!-- View Context Menu -->
    <div class="view-context-menu" id="view-context-menu">
        <div class="view-context-menu-item" onclick="moveViewToFolder()">
            <span>&#128193;</span> Move to folder...
        </div>
        <div class="view-context-menu-item" onclick="renameView()">
            <span>&#9998;</span> Rename
        </div>
        <div class="view-context-menu-item" onclick="manageViewTags()">
            <span>&#127991;</span> Manage tags...
        </div>
        <div class="view-context-menu-item" onclick="addViewToWorkspaceMenu()">
            <span>&#11088;</span> Add to workspace...
        </div>
        <div class="view-context-menu-item" onclick="setViewParent()">
            <span>&#128279;</span> Set parent view...
        </div>
        <div class="view-context-menu-separator"></div>
        <div class="view-context-menu-item danger" onclick="deleteView()">
            <span>&#128465;</span> Delete
        </div>
    </div>

    <!-- Table Context Menu -->
    <div class="view-context-menu" id="table-context-menu">
        <div class="view-context-menu-item" onclick="createViewFolderFromContextMenu()">
            <span>&#128193;</span> New folder
        </div>
    </div>

    <!-- Field History Modal -->
    <div class="modal-overlay" id="history-modal-overlay" onclick="closeHistoryModal(event)">
        <div class="modal history-modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 id="history-modal-title">Field History</h2>
                <button class="modal-close" onclick="closeHistoryModal()">&times;</button>
            </div>
            <div class="modal-toolbar">
                <label>Filter by field:</label>
                <select id="history-field-filter" onchange="filterHistoryByField()">
                    <option value="">All Fields</option>
                </select>
                <span class="history-count" id="history-count"></span>
            </div>
            <div class="historical-notice">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M8 4.5V8L10.5 9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="historical-notice-text"><strong>Historical data:</strong> Values shown are what was recorded at the time of each change, not the current state of the record.</span>
            </div>
            <div class="modal-body" id="history-modal-body">
                <!-- History items will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Create View Modal -->
    <div class="create-view-modal" id="create-view-modal" onclick="closeCreateViewModal(event)">
        <div class="create-view-modal-content" onclick="event.stopPropagation()">
            <div class="create-view-modal-header">
                <h2>Create New View</h2>
                <p id="create-view-reason">Customize this view with your own filters and field settings.</p>
            </div>
            <div class="create-view-modal-body">
                <div class="create-view-field">
                    <label for="create-view-name">View Name</label>
                    <input type="text" id="create-view-name" placeholder="Enter view name...">
                </div>
                <div class="create-view-field">
                    <label for="create-view-type">View Type</label>
                    <select id="create-view-type">
                        <option value="grid">Grid View</option>
                        <option value="schema">Schema View (Cards)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-parent">Parent View (for nesting)</label>
                    <select id="create-view-parent">
                        <option value="">(No parent - root level)</option>
                    </select>
                </div>
                <div class="create-view-field">
                    <label for="create-view-tags">Tags (comma-separated)</label>
                    <input type="text" id="create-view-tags" placeholder="e.g., reports, daily, team-a">
                </div>
                <div class="create-view-field">
                    <label for="create-view-workspace">Add to Workspace</label>
                    <select id="create-view-workspace">
                        <option value="">(None)</option>
                    </select>
                </div>
            </div>
            <div class="create-view-modal-footer">
                <button class="btn-cancel" onclick="closeCreateViewModal()">Cancel</button>
                <button class="btn-create" id="create-view-submit" onclick="submitCreateView()">Create View</button>
            </div>
        </div>
    </div>

    <!-- Point in Time Modal -->
    <div class="modal-overlay" id="pit-modal-overlay" onclick="closePitModal(event)">
        <div class="modal pit-modal" onclick="event.stopPropagation()">
            <div class="modal-header pit-modal-header">
                <div class="pit-info">
                    <h2 id="pit-modal-title">Record at Point in Time</h2>
                    <span class="pit-timestamp" id="pit-modal-timestamp"></span>
                </div>
                <span class="pit-event-badge" id="pit-modal-event-badge"></span>
                <button class="modal-close" onclick="closePitModal()">&times;</button>
            </div>
            <div class="historical-notice">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M8 4.5V8L10.5 9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span class="historical-notice-text"><strong>Snapshot:</strong> This shows the record as it existed at this point in time, not its current state. Click "View Current Record" to see the latest data.</span>
            </div>
            <div class="modal-body" id="pit-modal-body">
                <!-- Record state will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Record Profile Slide-out Panel -->
    <div class="record-profile-overlay" id="record-profile-overlay" onclick="closeRecordProfile(event)">
        <div class="record-profile-panel" onclick="event.stopPropagation()">
            <div class="profile-header">
                <h2 id="profile-title">Record</h2>
                <span class="profile-view-name" id="profile-view-name"></span>
                <span class="profile-record-id" id="profile-record-id"></span>
                <button class="profile-close" onclick="closeRecordProfile()">&times;</button>
            </div>
            <div class="profile-tabs">
                <div class="profile-tab active" data-tab="details" onclick="switchProfileTab('details')">Case Details</div>
                <div class="profile-tab" data-tab="sync-history" onclick="switchProfileTab('sync-history')">Sync History</div>
            </div>
            <div class="profile-tab-content active" id="profile-tab-details">
                <div class="profile-toolbar" id="profile-toolbar">
                    <button class="profile-configure-btn" id="profile-configure-btn" onclick="toggleProfileConfigureMode()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                        Configure
                    </button>
                    <div class="profile-toolbar-spacer"></div>
                    <button class="profile-add-block-btn" id="profile-add-block-btn" onclick="addProfileBlock()" style="display: none;">+ Add Block</button>
                </div>
                <div class="profile-body" id="profile-body">
                    <!-- Profile content will be rendered here -->
                </div>
            </div>
            <div class="profile-tab-content" id="profile-tab-sync-history">
                <!-- Sync history content will be rendered here -->
            </div>
            <div class="profile-nav">
                <button class="profile-nav-btn" id="profile-prev-btn" onclick="navigateProfile(-1)">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15,18 9,12 15,6"/></svg>
                    Prev
                </button>
                <span class="profile-nav-info" id="profile-nav-info">1 of 100</span>
                <button class="profile-nav-btn" id="profile-next-btn" onclick="navigateProfile(1)">
                    Next
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9,18 15,12 9,6"/></svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Sync Status Feed Panel -->
    <div class="sync-feed-panel" id="sync-feed-panel">
        <div class="sync-feed-header">
            <div class="sync-feed-header-left">
                <span class="sync-feed-status-dot" id="sync-feed-status-dot"></span>
                <span>Sync Activity</span>
            </div>
            <button class="sync-feed-close" onclick="SyncStatusFeed.hide()">&times;</button>
        </div>
        <div class="sync-feed-body" id="sync-feed-body">
            <div class="sync-feed-empty">No sync activity yet</div>
        </div>
        <div class="sync-feed-footer">
            <span id="sync-feed-stats">Idle</span>
            <button onclick="SyncStatusFeed.clear()">Clear</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@msgpack/msgpack@3.1.2/dist.umd/msgpack.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <script>
var API = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:nrIL-Oi-/aminostream';
var DB_NAME = 'aminostream';
var DB_VERSION = 7;
var PAGE_SIZE = 100;

var API_KEY = null;
var SET_FILTER = null;
var db = null;

// ============ Encryption Configuration ============
var ENCRYPTION_CONFIG_KEY = 'amino_encryption_config';
var ENCRYPTED_CREDENTIALS_KEY = 'amino_encrypted_credentials';
var encryptionKey = null; // CryptoKey object, only kept in memory
var encryptionEnabled = false;
var passkeyCredentialId = null; // For WebAuthn

// ============ Web Crypto API Utilities ============

// Generate a random salt for key derivation
function generateSalt() {
    return crypto.getRandomValues(new Uint8Array(16));
}

// Generate a random IV for AES-GCM encryption
function generateIV() {
    return crypto.getRandomValues(new Uint8Array(12));
}

// Derive an encryption key from a password using PBKDF2
async function deriveKeyFromPassword(password, salt) {
    var encoder = new TextEncoder();
    var passwordKey = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        'PBKDF2',
        false,
        ['deriveBits', 'deriveKey']
    );

    return crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        },
        passwordKey,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
}

// Encrypt data using AES-GCM
async function encryptData(data, key) {
    var encoder = new TextEncoder();
    var iv = generateIV();
    var encodedData = encoder.encode(JSON.stringify(data));

    var encryptedBuffer = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encodedData
    );

    // Combine IV and encrypted data
    var combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encryptedBuffer), iv.length);

    return arrayBufferToBase64(combined);
}

// Decrypt data using AES-GCM
async function decryptData(encryptedBase64, key) {
    var combined = base64ToArrayBuffer(encryptedBase64);
    var iv = combined.slice(0, 12);
    var encryptedData = combined.slice(12);

    var decryptedBuffer = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encryptedData
    );

    var decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decryptedBuffer));
}

// Helper: Convert ArrayBuffer to Base64
function arrayBufferToBase64(buffer) {
    var bytes = new Uint8Array(buffer);
    var binary = '';
    for (var i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

// Helper: Convert Base64 to ArrayBuffer
function base64ToArrayBuffer(base64) {
    var binary = atob(base64);
    var bytes = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

// ============ WebAuthn Passkey Utilities ============

// Check if WebAuthn is supported
function isPasskeySupported() {
    return !!(window.PublicKeyCredential && navigator.credentials);
}

// Create a new passkey for encryption
async function createPasskey() {
    if (!isPasskeySupported()) {
        throw new Error('Passkeys are not supported in this browser');
    }

    // Generate a random challenge
    var challenge = crypto.getRandomValues(new Uint8Array(32));
    var userId = crypto.getRandomValues(new Uint8Array(16));

    var publicKeyOptions = {
        challenge: challenge,
        rp: {
            name: 'Amino Viewer',
            id: window.location.hostname
        },
        user: {
            id: userId,
            name: 'amino-user',
            displayName: 'Amino Viewer User'
        },
        pubKeyCredParams: [
            { alg: -7, type: 'public-key' },   // ES256
            { alg: -257, type: 'public-key' }  // RS256
        ],
        authenticatorSelection: {
            authenticatorAttachment: 'platform',
            userVerification: 'required',
            residentKey: 'required'
        },
        timeout: 60000,
        attestation: 'none',
        extensions: {
            prf: {
                eval: {
                    first: new TextEncoder().encode('amino-encryption-key')
                }
            }
        }
    };

    var credential = await navigator.credentials.create({ publicKey: publicKeyOptions });

    // Check if PRF extension is supported
    var prfSupported = credential.getClientExtensionResults().prf !== undefined;

    return {
        credentialId: arrayBufferToBase64(credential.rawId),
        userId: arrayBufferToBase64(userId),
        prfSupported: prfSupported
    };
}

// Authenticate with an existing passkey
async function authenticateWithPasskey(credentialId) {
    if (!isPasskeySupported()) {
        throw new Error('Passkeys are not supported in this browser');
    }

    var challenge = crypto.getRandomValues(new Uint8Array(32));

    var publicKeyOptions = {
        challenge: challenge,
        allowCredentials: [{
            id: base64ToArrayBuffer(credentialId),
            type: 'public-key'
        }],
        userVerification: 'required',
        timeout: 60000,
        extensions: {
            prf: {
                eval: {
                    first: new TextEncoder().encode('amino-encryption-key')
                }
            }
        }
    };

    var assertion = await navigator.credentials.get({ publicKey: publicKeyOptions });

    // Check if PRF was used
    var prfResult = assertion.getClientExtensionResults().prf;

    return {
        credentialId: arrayBufferToBase64(assertion.rawId),
        prfOutput: prfResult ? arrayBufferToBase64(prfResult.results.first) : null,
        authenticatorData: arrayBufferToBase64(assertion.response.authenticatorData)
    };
}

// Derive encryption key from passkey authentication
async function deriveKeyFromPasskey(prfOutput, salt) {
    if (prfOutput) {
        // PRF is supported - use PRF output directly
        var prfBytes = base64ToArrayBuffer(prfOutput);
        var keyMaterial = await crypto.subtle.importKey(
            'raw',
            prfBytes,
            'HKDF',
            false,
            ['deriveBits', 'deriveKey']
        );

        return crypto.subtle.deriveKey(
            {
                name: 'HKDF',
                salt: salt,
                info: new TextEncoder().encode('amino-aes-key'),
                hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    } else {
        // PRF not supported - fall back to using authenticator data hash
        throw new Error('Your authenticator does not support the PRF extension needed for encryption. Please use a password instead.');
    }
}

// ============ Password Strength Checker ============

function checkPasswordStrength(password) {
    var strength = 0;
    if (password.length >= 8) strength++;
    if (password.length >= 12) strength++;
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
    if (/[0-9]/.test(password)) strength++;
    if (/[^a-zA-Z0-9]/.test(password)) strength++;

    if (strength <= 2) return 'weak';
    if (strength <= 3) return 'medium';
    return 'strong';
}

function updatePasswordStrength() {
    var password = document.getElementById('setup-password').value;
    var strengthFill = document.getElementById('password-strength-fill');
    strengthFill.className = 'password-strength-fill';

    if (password.length > 0) {
        var strength = checkPasswordStrength(password);
        strengthFill.classList.add(strength);
    }
}

// ============ Encryption Setup & Unlock Functions ============

// Check if encryption is already set up
function getEncryptionConfig() {
    var configStr = localStorage.getItem(ENCRYPTION_CONFIG_KEY);
    if (!configStr) return null;
    try {
        return JSON.parse(configStr);
    } catch (e) {
        return null;
    }
}

// Save encryption configuration
function saveEncryptionConfig(config) {
    localStorage.setItem(ENCRYPTION_CONFIG_KEY, JSON.stringify(config));
}

// Session key persistence: store encryption key in sessionStorage to survive refresh
var SESSION_KEY_STORAGE = 'amino_session_key';

async function saveSessionKey(key) {
    try {
        var raw = await crypto.subtle.exportKey('raw', key);
        sessionStorage.setItem(SESSION_KEY_STORAGE, arrayBufferToBase64(raw));
    } catch (e) {
        console.warn('Could not save session key:', e);
    }
}

async function loadSessionKey() {
    var stored = sessionStorage.getItem(SESSION_KEY_STORAGE);
    if (!stored) return null;
    try {
        var raw = base64ToArrayBuffer(stored);
        return await crypto.subtle.importKey(
            'raw',
            raw,
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
    } catch (e) {
        console.warn('Could not restore session key:', e);
        sessionStorage.removeItem(SESSION_KEY_STORAGE);
        return null;
    }
}

function clearSessionKey() {
    sessionStorage.removeItem(SESSION_KEY_STORAGE);
}

// Show the unlock screen (setup or prompt mode)
function showUnlockScreen(mode) {
    var unlockScreen = document.getElementById('unlock-screen');
    var setupBox = document.getElementById('unlock-setup');
    var promptBox = document.getElementById('unlock-prompt');

    unlockScreen.classList.remove('hidden', 'fading-out');

    if (mode === 'setup') {
        setupBox.classList.remove('hidden');
        promptBox.classList.add('hidden');

        // Hide passkey button if not supported
        if (!isPasskeySupported()) {
            document.getElementById('setup-passkey-btn').style.display = 'none';
        }
    } else {
        setupBox.classList.add('hidden');
        promptBox.classList.remove('hidden');

        // Check encryption config for passkey
        var config = getEncryptionConfig();
        var passkeySection = document.getElementById('passkey-unlock-section');
        if (config && config.type === 'passkey' && isPasskeySupported()) {
            passkeySection.style.display = 'block';
            passkeyCredentialId = config.credentialId;
        } else {
            passkeySection.style.display = 'none';
        }
    }
}

// Hide the unlock screen
function hideUnlockScreen() {
    var el = document.getElementById('unlock-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    setTimeout(function() { el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

// Show error on unlock screen
function showUnlockError(mode, message) {
    var errorId = mode === 'setup' ? 'unlock-setup-error' : 'unlock-prompt-error';
    var errorEl = document.getElementById(errorId);
    errorEl.textContent = message;
    errorEl.style.display = 'block';
}

// Hide error on unlock screen
function hideUnlockError(mode) {
    var errorId = mode === 'setup' ? 'unlock-setup-error' : 'unlock-prompt-error';
    document.getElementById(errorId).style.display = 'none';
}

// Set up encryption with password
async function setupEncryptionWithPassword() {
    hideUnlockError('setup');

    var password = document.getElementById('setup-password').value;
    var confirmPassword = document.getElementById('setup-password-confirm').value;

    if (!password) {
        showUnlockError('setup', 'Please enter a password');
        return;
    }

    if (password.length < 8) {
        showUnlockError('setup', 'Password must be at least 8 characters');
        return;
    }

    if (password !== confirmPassword) {
        showUnlockError('setup', 'Passwords do not match');
        return;
    }

    var btn = document.getElementById('setup-password-btn');
    btn.disabled = true;
    btn.textContent = 'Setting up...';

    try {
        var salt = generateSalt();
        encryptionKey = await deriveKeyFromPassword(password, salt);

        // Create verification token
        var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, encryptionKey);

        // Save config
        saveEncryptionConfig({
            type: 'password',
            salt: arrayBufferToBase64(salt),
            verificationToken: verificationToken
        });

        encryptionEnabled = true;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Encryption setup failed:', e);
        showUnlockError('setup', 'Failed to set up encryption: ' + e.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Set Up with Password';
    }
}

// Set up encryption with passkey
async function setupEncryptionWithPasskey() {
    hideUnlockError('setup');

    if (!isPasskeySupported()) {
        showUnlockError('setup', 'Passkeys are not supported in this browser');
        return;
    }

    var btn = document.getElementById('setup-passkey-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Setting up...';

    try {
        var passkeyResult = await createPasskey();

        if (!passkeyResult.prfSupported) {
            showUnlockError('setup', 'Your device does not support the encryption features needed for passkey-based encryption. Please use a password instead.');
            return;
        }

        // Authenticate immediately to get PRF output
        var authResult = await authenticateWithPasskey(passkeyResult.credentialId);

        if (!authResult.prfOutput) {
            showUnlockError('setup', 'Failed to get encryption key from passkey. Please use a password instead.');
            return;
        }

        var salt = generateSalt();
        encryptionKey = await deriveKeyFromPasskey(authResult.prfOutput, salt);

        // Create verification token
        var verificationToken = await encryptData({ verify: 'amino-encryption-check' }, encryptionKey);

        // Save config
        saveEncryptionConfig({
            type: 'passkey',
            credentialId: passkeyResult.credentialId,
            salt: arrayBufferToBase64(salt),
            verificationToken: verificationToken
        });

        encryptionEnabled = true;
        passkeyCredentialId = passkeyResult.credentialId;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Passkey setup failed:', e);
        if (e.name === 'NotAllowedError') {
            showUnlockError('setup', 'Passkey setup was cancelled. Please try again.');
        } else {
            showUnlockError('setup', 'Failed to set up passkey: ' + e.message);
        }
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Set Up with Passkey';
    }
}

// Skip encryption (not recommended)
function skipEncryption() {
    if (!confirm('Are you sure? Your API key and cached data will be stored unencrypted, which means anyone with access to your browser could read them.')) {
        return;
    }

    saveEncryptionConfig({ type: 'none' });
    encryptionEnabled = false;
    encryptionKey = null;
    hideUnlockScreen();
    initAuthScreen();
}

// Unlock with password
async function unlockWithPassword() {
    hideUnlockError('prompt');

    var password = document.getElementById('unlock-password').value;
    if (!password) {
        showUnlockError('prompt', 'Please enter your password');
        return;
    }

    var btn = document.getElementById('unlock-password-btn');
    btn.disabled = true;
    btn.textContent = 'Unlocking...';

    try {
        var config = getEncryptionConfig();
        if (!config || !config.salt) {
            throw new Error('Invalid encryption configuration');
        }

        var salt = base64ToArrayBuffer(config.salt);
        encryptionKey = await deriveKeyFromPassword(password, salt);

        // Verify the key
        try {
            await decryptData(config.verificationToken, encryptionKey);
        } catch (e) {
            throw new Error('Incorrect password');
        }

        encryptionEnabled = true;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        document.getElementById('unlock-password').value = '';
        initAuthScreen();
    } catch (e) {
        console.error('Unlock failed:', e);
        showUnlockError('prompt', e.message || 'Failed to unlock');
        encryptionKey = null;
    } finally {
        btn.disabled = false;
        btn.textContent = 'Unlock';
    }
}

// Unlock with passkey
async function unlockWithPasskey() {
    hideUnlockError('prompt');

    var btn = document.getElementById('passkey-unlock-btn');
    btn.disabled = true;
    btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Unlocking...';

    try {
        var config = getEncryptionConfig();
        if (!config || config.type !== 'passkey') {
            throw new Error('Passkey not configured');
        }

        var authResult = await authenticateWithPasskey(config.credentialId);

        if (!authResult.prfOutput) {
            throw new Error('Failed to get encryption key from passkey');
        }

        var salt = base64ToArrayBuffer(config.salt);
        encryptionKey = await deriveKeyFromPasskey(authResult.prfOutput, salt);

        // Verify the key
        try {
            await decryptData(config.verificationToken, encryptionKey);
        } catch (e) {
            throw new Error('Passkey authentication failed');
        }

        encryptionEnabled = true;
        passkeyCredentialId = config.credentialId;
        await saveSessionKey(encryptionKey);
        hideUnlockScreen();
        initAuthScreen();
    } catch (e) {
        console.error('Passkey unlock failed:', e);
        if (e.name === 'NotAllowedError') {
            showUnlockError('prompt', 'Passkey authentication was cancelled. Please try again.');
        } else {
            showUnlockError('prompt', e.message || 'Failed to unlock with passkey');
        }
        encryptionKey = null;
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span class="passkey-icon">&#128273;</span> Unlock with Passkey';
    }
}

// Clear all encrypted data and start fresh
async function clearEncryptedData() {
    if (!confirm('This will delete ALL local data including your cached database. Your data on the server is not affected. Continue?')) {
        return;
    }

    try {
        // Clear localStorage encryption config and credentials
        localStorage.removeItem(ENCRYPTION_CONFIG_KEY);
        localStorage.removeItem(ENCRYPTED_CREDENTIALS_KEY);
        localStorage.removeItem('amino_api_key');
        localStorage.removeItem('amino_set_filter');

        // Clear IndexedDB
        await new Promise((resolve, reject) => {
            var req = indexedDB.deleteDatabase(DB_NAME);
            req.onsuccess = resolve;
            req.onerror = () => reject(req.error);
        });

        encryptionKey = null;
        encryptionEnabled = false;
        passkeyCredentialId = null;

        // Show setup screen
        showUnlockScreen('setup');
    } catch (e) {
        console.error('Failed to clear data:', e);
        alert('Failed to clear data: ' + e.message);
    }
}

// ============ Encrypted Credentials Storage ============

// Save API credentials (encrypted if encryption is enabled)
async function saveEncryptedCredentials(apiKey, setFilter) {
    var credentials = { apiKey: apiKey, setFilter: setFilter };

    if (encryptionEnabled && encryptionKey) {
        var encrypted = await encryptData(credentials, encryptionKey);
        localStorage.setItem(ENCRYPTED_CREDENTIALS_KEY, encrypted);
        // Remove plaintext credentials
        localStorage.removeItem('amino_api_key');
        localStorage.removeItem('amino_set_filter');
    } else {
        // Store as plaintext (no encryption)
        localStorage.setItem('amino_api_key', apiKey);
        if (setFilter) {
            localStorage.setItem('amino_set_filter', setFilter);
        } else {
            localStorage.removeItem('amino_set_filter');
        }
    }
}

// Load API credentials (decrypt if necessary)
async function loadEncryptedCredentials() {
    if (encryptionEnabled && encryptionKey) {
        var encrypted = localStorage.getItem(ENCRYPTED_CREDENTIALS_KEY);
        if (encrypted) {
            try {
                return await decryptData(encrypted, encryptionKey);
            } catch (e) {
                console.error('Failed to decrypt credentials:', e);
                return null;
            }
        }
    } else {
        var apiKey = localStorage.getItem('amino_api_key');
        if (apiKey) {
            return {
                apiKey: apiKey,
                setFilter: localStorage.getItem('amino_set_filter')
            };
        }
    }
    return null;
}

// Clear saved credentials
function clearEncryptedCredentials() {
    localStorage.removeItem(ENCRYPTED_CREDENTIALS_KEY);
    localStorage.removeItem('amino_api_key');
    localStorage.removeItem('amino_set_filter');
}

// ============ Encrypted IndexedDB Wrapper ============

// Encrypt data before storing in IndexedDB
async function encryptForStorage(data) {
    if (encryptionEnabled && encryptionKey) {
        return {
            _encrypted: true,
            data: await encryptData(data, encryptionKey)
        };
    }
    return data;
}

// Decrypt data after retrieving from IndexedDB
async function decryptFromStorage(data) {
    if (data && data._encrypted && encryptionEnabled && encryptionKey) {
        return await decryptData(data.data, encryptionKey);
    }
    return data;
}

// ============ Encryption Init Flow ============

// Initialize encryption system - called before anything else
async function initEncryption() {
    var config = getEncryptionConfig();

    if (!config) {
        // First time user - show setup screen
        showUnlockScreen('setup');
        return false;
    }

    if (config.type === 'none') {
        // User chose to skip encryption
        encryptionEnabled = false;
        encryptionKey = null;
        return true;
    }

    // Check for session key (survives page refresh within same tab)
    var sessionKey = await loadSessionKey();
    if (sessionKey && config.verificationToken) {
        try {
            await decryptData(config.verificationToken, sessionKey);
            // Session key is valid
            encryptionKey = sessionKey;
            encryptionEnabled = true;
            return true;
        } catch (e) {
            // Session key is stale or invalid
            clearSessionKey();
        }
    }

    // User has encryption set up - show unlock screen
    showUnlockScreen('prompt');
    return false;
}

// Only keep lightweight metadata in memory
var META_TABLES = {};
var META_FIELDS = {};
var META_VIEWS = {};

// Human-readable names for entity/event types
var ENTITY_TYPE_NAMES = {
    'data': 'Data',
    'INS': 'Insert',
    'ALT': 'Alter',
    'NUL': 'Nullify',
    'SYN': 'Sync',
    'table': 'Table',
    'field': 'Field',
    'view': 'View',
    'viewConfig': 'View Config',
    'tableSettings': 'Table Settings',
    'current': 'Current State'
};

var currentTable = null;
var currentView = null; // Current view ID or null for "All Fields" default
var currentPage = 0;
var currentRecordIds = [];
var totalRecords = 0;
var lastEventTimestamp = null; // ISO timestamp of last synced event
var pollInterval = null;
var navVersion = 0; // Navigation guard to prevent race conditions when rapidly switching views

// View field configuration cache (in-memory, persisted to IndexedDB)
// Structure: VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [...], fieldOrder: [...] }
// Note: Views default to showing ALL fields; hiddenFieldIds stores fields to hide
var VIEW_FIELD_CONFIG = {};

// View folders: Structure: VIEW_FOLDERS[tableId][folderId] = { folderId, folderName, parentFolderId, sortOrder, isExpanded }
var VIEW_FOLDERS = {};

// Workspaces: Structure: WORKSPACES[workspaceId] = { workspaceId, workspaceName, viewIds: [], sortOrder }
var WORKSPACES = {};
var currentWorkspace = null; // Current active workspace filter

// Table Settings: User-specific preferences for tables and views
// Structure: TABLE_SETTINGS = {
//   tables: {
//     [tableId]: {
//       visible: boolean,      // Whether table is visible in sidebar
//       sortOrder: number      // Custom sort order
//     }
//   },
//   tableOrder: string[],      // Array of tableIds in user's preferred order
//   views: {
//     [viewId]: {
//       isPublic: boolean,     // Whether view is public (shared) or private
//       sortOrder: number      // Custom sort order within table
//     }
//   }
// }
var TABLE_SETTINGS = {
    tables: {},
    tableOrder: [],
    views: {}
};

// ============ Sidebar Configuration ============
// Table type definitions with colors and icons
var TABLE_TYPE_CONFIG = {
    events: {
        color: '#f59e0b',
        label: 'Events',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>'
    },
    syncStatus: {
        color: '#10b981',
        label: 'Sync Status',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>'
    },
    operational: {
        color: '#3b82f6',
        label: 'Operational',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="3" x2="21" y1="9" y2="9"/><line x1="3" x2="21" y1="15" y2="15"/><line x1="9" x2="9" y1="9" y2="21"/><line x1="15" x2="15" y1="9" y2="21"/></svg>'
    },
    collection: {
        color: '#8b5cf6',
        label: 'Collections',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>'
    },
    reference: {
        color: '#10b981',
        label: 'Reference',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg>'
    },
    dev: {
        color: '#6b7280',
        label: 'Dev / Testing',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>'
    }
};

// Sidebar state (pinned tables, recent tables, expanded sections, search)
var SIDEBAR_STATE = {
    pinnedTables: [],
    recentTables: [],
    expandedSections: {
        pinned: true,
        recent: true,
        operational: true,
        collections: false,
        reference: false,
        dev: false
    },
    searchQuery: '',
    maxRecentTables: 5
};

// Determine table type based on name patterns
function getTableType(tableName) {
    var name = (tableName || '').toLowerCase();

    // Events
    if (name.includes('event') && name.includes('stream')) return 'events';
    if (name === 'events') return 'events';

    // Collections (date patterns)
    if (name.includes('collection')) return 'collection';
    if (/\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/.test(name)) return 'collection';
    if (/\d{1,2}(st|nd|rd|th)?\s*-\s*\d{1,2}(st|nd|rd|th)?/.test(name)) return 'collection';

    // Reference (small lookup tables)
    if (name.includes('dictionary') || name.includes('appendix') || name.includes('info')) return 'reference';
    if (name.includes('type') && !name.includes('activity')) return 'reference';

    // Dev
    if (name.includes('test') || name.includes('dev') || name.includes('data test')) return 'dev';

    // Default to operational
    return 'operational';
}

// Format record count (e.g., 73262 -> "73.3k")
function formatRecordCount(count) {
    if (count >= 1000) return (count / 1000).toFixed(1) + 'k';
    return count.toString();
}

// Get count bar width ratio (logarithmic scale)
function getCountBarWidth(count, maxCount) {
    if (count <= 0 || maxCount <= 0) return 0;
    var ratio = Math.log(count + 1) / Math.log(maxCount + 1);
    return Math.max(0.15, ratio);
}

// Add table to recent list
function addToRecentTables(tableId) {
    if (tableId === '_events') return;
    var recent = SIDEBAR_STATE.recentTables.filter(id => id !== tableId);
    recent.unshift(tableId);
    SIDEBAR_STATE.recentTables = recent.slice(0, SIDEBAR_STATE.maxRecentTables);
    saveSidebarState();
}

// Toggle table pin
function toggleTablePin(tableId, event) {
    if (event) event.stopPropagation();
    var idx = SIDEBAR_STATE.pinnedTables.indexOf(tableId);
    if (idx >= 0) {
        SIDEBAR_STATE.pinnedTables.splice(idx, 1);
    } else {
        SIDEBAR_STATE.pinnedTables.push(tableId);
    }
    saveSidebarState();
    renderSidebar();
}

// Toggle sidebar section
function toggleSidebarSection(sectionId) {
    SIDEBAR_STATE.expandedSections[sectionId] = !SIDEBAR_STATE.expandedSections[sectionId];
    saveSidebarState();
    renderSidebar();
}

// Save sidebar state to localStorage
function saveSidebarState() {
    try {
        localStorage.setItem('aminoSidebarState', JSON.stringify(SIDEBAR_STATE));
    } catch (e) { /* ignore */ }
}

// Load sidebar state from localStorage
function loadSidebarState() {
    try {
        var saved = localStorage.getItem('aminoSidebarState');
        if (saved) {
            var parsed = JSON.parse(saved);
            SIDEBAR_STATE.pinnedTables = parsed.pinnedTables || [];
            SIDEBAR_STATE.recentTables = parsed.recentTables || [];
            SIDEBAR_STATE.expandedSections = Object.assign({}, SIDEBAR_STATE.expandedSections, parsed.expandedSections || {});
        }
    } catch (e) { /* ignore */ }
}

// Initialize sidebar search functionality
function initSidebarSearch() {
    var searchInput = document.getElementById('sidebar-search-input');
    if (!searchInput) return;

    var debounceTimer = null;

    // Search input handler with debounce
    searchInput.addEventListener('input', function(e) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(function() {
            SIDEBAR_STATE.searchQuery = e.target.value;
            renderSidebar();
        }, 200);
    });

    // Clear search on Escape
    searchInput.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            searchInput.value = '';
            SIDEBAR_STATE.searchQuery = '';
            searchInput.blur();
            renderSidebar();
        }
    });

    // Keyboard shortcut: Cmd+K / Ctrl+K to focus search
    document.addEventListener('keydown', function(e) {
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            searchInput.focus();
            searchInput.select();
        }
    });
}

// SVG icons for sidebar
var SIDEBAR_ICONS = {
    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>',
    star: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    starFilled: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    clock: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>'
};

// Pending view action (when user tries to modify default view)
var pendingViewAction = null; // { action: 'filter'|'sort'|'fields'|'group', data: any }

// Snapshot sync toggle state (off by default)
var snapshotSyncEnabled = false;

// ============ Events View State ============
var eventsPageSize = 50;
var eventsTypeFilter = ''; // 'INS', 'ALT', 'NUL', 'SYN', 'table', 'field', 'view', 'viewConfig', or '' for all
var eventsSetFilter = ''; // Filter by set (table id)
var eventsSearchQuery = '';
var expandedPayloads = new Set(); // Set of event IDs with expanded payloads
var appOpenedEventId = 0; // Highest event ID when app was opened (events with higher IDs are "new")

// Infinite scroll state
var loadedEvents = []; // All currently loaded events
var eventsOffset = 0; // Current offset for loading more
var isLoadingMoreEvents = false; // Prevent multiple simultaneous loads
var hasMoreEvents = true; // Whether there are more events to load
var eventsScrollHandler = null; // Reference to scroll handler for cleanup

// In-memory event cache for fast startup from file import
// Events are loaded into memory first for instant UI, then saved to IndexedDB in background
var inMemoryEvents = null; // Array of events or null if not using memory cache
var inMemoryEventsByRecord = null; // Map of recordId -> array of events for fast lookup
var isBackgroundSaveInProgress = false; // Track background IndexedDB save status

// ============ View Auto-Save System ============
var XANO_POST_API = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:nrIL-Oi-/aminostreampost';
var XANO_SNAPSHOT_API = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:nrIL-Oi-/aminosnapshot';
var AUTO_SAVE_DELAY = 5 * 60 * 1000; // 5 minutes
var autoSaveTimer = null;

var viewDirtyState = {
    isDirty: false,
    lastEditTime: null,
    pendingChanges: {
        tableId: null,
        viewId: null,
        changes: {}
    }
};

// ============ AminoSync - Client-Side Snapshot Maintenance ============

var AminoSync = {
    // Post event to aminoStream and update snapshot
    async postEventWithSnapshot(event, snapshotData) {
        // Step 1: POST to aminoStream (append event, get event ID)
        var streamRes = await fetch(XANO_POST_API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(event)
        });

        if (!streamRes.ok) {
            throw new Error('Failed to post event: HTTP ' + streamRes.status);
        }

        var streamResult = await streamRes.json();
        var eventId = streamResult.id;

        // Step 2: PUT to aminoSnapshot (upsert state + event ID)
        if (snapshotData && event.recordId) {
            var snapshotRecord = {
                record_id: event.recordId,
                source_table: snapshotData.source_table || event.set,
                data: snapshotData.data,
                last_amino_event: eventId
            };

            try {
                await fetch(XANO_SNAPSHOT_API + '/record/' + encodeURIComponent(event.recordId), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(snapshotRecord)
                });

                // Step 3: Update local IndexedDB snapshot
                if (db && db.objectStoreNames.contains('snapshot')) {
                    var tx = db.transaction('snapshot', 'readwrite');
                    tx.objectStore('snapshot').put(snapshotRecord);
                }
            } catch (snapshotErr) {
                console.warn('Snapshot update failed (event still recorded):', snapshotErr);
            }
        }

        return { eventId, streamResult };
    },

    // Delete from snapshot (for NUL operations)
    async deleteSnapshot(recordId) {
        try {
            await fetch(XANO_SNAPSHOT_API + '/record/' + encodeURIComponent(recordId), {
                method: 'DELETE'
            });

            // Remove from local IndexedDB
            if (db && db.objectStoreNames.contains('snapshot')) {
                var tx = db.transaction('snapshot', 'readwrite');
                tx.objectStore('snapshot').delete(recordId);
            }
        } catch (err) {
            console.warn('Snapshot delete failed:', err);
        }
    },

    // Get snapshot record from local IndexedDB
    async getSnapshot(recordId) {
        if (!db || !db.objectStoreNames.contains('snapshot')) return null;

        return new Promise((resolve, reject) => {
            var tx = db.transaction('snapshot', 'readonly');
            var req = tx.objectStore('snapshot').get(recordId);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    },

    // Get all snapshots by source table
    async getSnapshotsByTable(sourceTable) {
        if (!db || !db.objectStoreNames.contains('snapshot')) return [];

        return new Promise((resolve, reject) => {
            var tx = db.transaction('snapshot', 'readonly');
            var index = tx.objectStore('snapshot').index('by_source_table');
            var req = index.getAll(sourceTable);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    },

    // Get last synced snapshot event ID
    async getLastSnapshotEventId() {
        var meta = await getSyncMeta('lastSnapshotEventId');
        return meta || 0;
    },

    // Set last synced snapshot event ID
    async setLastSnapshotEventId(eventId) {
        await setSyncMeta('lastSnapshotEventId', eventId);
    },

    // Incremental sync from snapshot endpoint
    async syncFromSnapshot() {
        if (!API_KEY) return { updated: 0 };
        var lastEventId = await this.getLastSnapshotEventId();

        try {
            var response = await fetch(
                XANO_SNAPSHOT_API + '?last_amino_event_gt=' + lastEventId +
                (API_KEY ? '&apiKey=' + encodeURIComponent(API_KEY) : '')
            );

            if (!response.ok) {
                throw new Error('Snapshot sync failed: HTTP ' + response.status);
            }

            var updates = await response.json();

            // Handle non-array responses (API might return object or null)
            if (!updates || !Array.isArray(updates)) {
                if (updates && typeof updates === 'object' && updates.message) {
                    // API returned an error object
                    return { updated: 0, error: updates.message };
                }
                return { updated: 0 };
            }

            if (updates.length === 0) {
                return { updated: 0 };
            }

            // Update local IndexedDB
            if (db && db.objectStoreNames.contains('snapshot')) {
                var tx = db.transaction('snapshot', 'readwrite');
                var store = tx.objectStore('snapshot');
                var maxEventId = lastEventId;

                for (var record of updates) {
                    store.put(record);
                    if (record.last_amino_event > maxEventId) {
                        maxEventId = record.last_amino_event;
                    }
                }

                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });

                await this.setLastSnapshotEventId(maxEventId);
            }

            return { updated: updates.length };
        } catch (err) {
            console.error('Snapshot sync error:', err);
            return { updated: 0, error: err.message };
        }
    },

    // Bootstrap from snapshot file (for new clients)
    // Supports .amo binary format, gzipped JSON, and plain JSON
    async bootstrapFromSnapshot(snapshotUrl) {
        try {
            var response = await fetch(snapshotUrl);
            if (!response.ok) {
                throw new Error('Bootstrap failed: HTTP ' + response.status);
            }

            var buffer = await response.arrayBuffer();
            var format = AmoFormat.detectFormat(buffer);
            var records;

            if (format === 'amo') {
                // Binary .amo format
                var amo = AmoFormat.read(buffer);
                records = AmoFormat.toSnapshotRecords(amo.tables, amo.cursor);
            } else if (format === 'json-gz') {
                // Gzipped JSON
                var decompressed = pako.ungzip(new Uint8Array(buffer), { to: 'string' });
                records = JSON.parse(decompressed);
            } else {
                // Plain JSON
                var text = new TextDecoder().decode(buffer);
                records = JSON.parse(text);
            }

            if (!records || records.length === 0) {
                return { records: 0, lastEvent: 0, format: format };
            }

            if (db && db.objectStoreNames.contains('snapshot')) {
                var tx = db.transaction('snapshot', 'readwrite');
                var store = tx.objectStore('snapshot');
                var maxEventId = 0;

                for (var record of records) {
                    store.put(record);
                    if (record.last_amino_event > maxEventId) {
                        maxEventId = record.last_amino_event;
                    }
                }

                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });

                await this.setLastSnapshotEventId(maxEventId);
                return { records: records.length, lastEvent: maxEventId, format: format };
            }

            return { records: 0, lastEvent: 0, format: format };
        } catch (err) {
            console.error('Bootstrap error:', err);
            throw err;
        }
    },

    // Compute current state from event (for snapshot data)
    computeSnapshotData(currentData, eventPayload, operator) {
        if (operator === 'INS') {
            // Insert: use the event data as initial state
            return eventPayload.context?.data || eventPayload.fields?.INS || eventPayload;
        } else if (operator === 'ALT') {
            // Alter: merge changes into current data
            var changes = eventPayload.context?.data || eventPayload.fields?.ALT || eventPayload;
            return { ...(currentData || {}), ...changes };
        } else if (operator === 'NUL') {
            // Nullify: record should be deleted
            return null;
        }
        return currentData;
    },

    // Export all local snapshots as a .amo binary file
    // Returns: { blob: Blob, filename: string, stats: { tables, records, bytes } }
    async exportSnapshotAsAmo() {
        var snapshots = await this.getAllLocalSnapshots();
        if (snapshots.length === 0) {
            return { blob: null, filename: null, stats: { tables: 0, records: 0, bytes: 0 } };
        }

        var binary = AmoFormat.produce(snapshots);
        var blob = new Blob([binary], { type: 'application/x-amino-snapshot' });

        // Count unique tables
        var tableSet = {};
        for (var i = 0; i < snapshots.length; i++) {
            tableSet[snapshots[i].source_table] = true;
        }

        var timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        var filename = 'amino-snapshot-' + timestamp + '.amo';

        return {
            blob: blob,
            filename: filename,
            stats: {
                tables: Object.keys(tableSet).length,
                records: snapshots.length,
                bytes: binary.length
            }
        };
    },

    // Download .amo snapshot file via browser
    async downloadSnapshotAsAmo() {
        var result = await this.exportSnapshotAsAmo();
        if (!result.blob) {
            console.warn('No snapshots to export');
            return result;
        }

        var url = URL.createObjectURL(result.blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = result.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        return result;
    },

    // Get all local snapshots from IndexedDB
    async getAllLocalSnapshots() {
        if (!db || !db.objectStoreNames.contains('snapshot')) return [];

        return new Promise((resolve, reject) => {
            var tx = db.transaction('snapshot', 'readonly');
            var req = tx.objectStore('snapshot').getAll();
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => reject(req.error);
        });
    },

    // Push a single snapshot to the server
    async pushSnapshot(snapshot) {
        try {
            var response = await fetch(XANO_SNAPSHOT_API + '/record/' + encodeURIComponent(snapshot.record_id), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(snapshot)
            });

            // 200 = updated, 201 = created, 409 = stale (remote is newer)
            if (response.ok) {
                return { success: true, status: response.status };
            } else if (response.status === 409) {
                // Remote has newer data - this is fine, not an error
                return { success: false, status: 409, stale: true };
            } else {
                return { success: false, status: response.status };
            }
        } catch (err) {
            return { success: false, error: err.message };
        }
    },

    // Push local snapshots to server (sync local state to cache)
    async pushLocalSnapshots(batchSize = 50) {
        var localSnapshots = await this.getAllLocalSnapshots();
        if (localSnapshots.length === 0) {
            return { pushed: 0, stale: 0, errors: 0 };
        }

        var pushed = 0;
        var stale = 0;
        var errors = 0;

        // Process in batches to avoid overwhelming the server
        for (var i = 0; i < localSnapshots.length; i += batchSize) {
            var batch = localSnapshots.slice(i, i + batchSize);

            // Push batch in parallel
            var results = await Promise.all(batch.map(s => this.pushSnapshot(s)));

            for (var result of results) {
                if (result.success) {
                    pushed++;
                } else if (result.stale) {
                    stale++;
                } else {
                    errors++;
                }
            }
        }

        return { pushed, stale, errors, total: localSnapshots.length };
    },

    // Verify and repair a single record by replaying events from the server
    async verifyRecord(recordId) {
        try {
            // 1. Fetch all events for this record from the server
            var response = await fetch(
                API + '?recordId=' + encodeURIComponent(recordId) +
                (API_KEY ? '&apiKey=' + encodeURIComponent(API_KEY) : '')
            );

            if (!response.ok) {
                return { status: 'error', recordId, error: 'HTTP ' + response.status };
            }

            var events = await response.json();

            if (!events || events.length === 0) {
                // No events = record shouldn't exist in snapshot
                var existing = await this.getSnapshot(recordId);
                if (existing) {
                    // Orphaned snapshot row, clean it up
                    await this.deleteSnapshot(recordId);
                    return { status: 'deleted_orphan', recordId };
                }
                return { status: 'not_found', recordId };
            }

            // 2. Sort by id ascending (chronological order)
            events.sort(function(a, b) { return (a.id || 0) - (b.id || 0); });

            // 3. Replay to compute current state
            var state = {};
            var lastOp = null;
            var lastEventId = 0;
            var sourceTable = null;

            for (var event of events) {
                var payload = parsePayload(event.payload);
                if (!payload || typeof payload !== 'object') continue;

                sourceTable = event.set;
                lastEventId = event.id;
                lastOp = event.operator;

                var pfields = payload.fields || {};

                // Default first ALT as INS: if state is empty and operator is ALT, treat as INS
                var effectiveOp = event.operator;
                if (effectiveOp === 'ALT' && state !== null && Object.keys(state).length === 0) {
                    effectiveOp = 'INS';
                    // Promote ALT fields to INS for consistent handling
                    if (!pfields.INS && pfields.ALT) {
                        pfields = { INS: pfields.ALT, NUL: pfields.NUL };
                    }
                }

                if (effectiveOp === 'INS') {
                    // Insert: initialize state
                    state = pfields.INS || payload.context?.data || {};
                } else if (effectiveOp === 'ALT') {
                    // Alter: merge changes
                    if (pfields.ALT) {
                        Object.assign(state, pfields.ALT);
                    }
                    if (payload.context?.data) {
                        Object.assign(state, payload.context.data);
                    }
                } else if (event.operator === 'NUL') {
                    // Nullify: handle field deletion or record deletion
                    if (pfields.NUL && Array.isArray(pfields.NUL)) {
                        pfields.NUL.forEach(function(fid) { delete state[fid]; });
                    } else {
                        state = null;
                    }
                }
            }

            // 4. Get current snapshot state from server
            var snapshotRes = await fetch(
                XANO_SNAPSHOT_API + '/record/' + encodeURIComponent(recordId)
            );
            var currentSnapshot = snapshotRes.ok ? await snapshotRes.json() : null;

            // 5. Compare and repair if needed
            if (lastOp === 'NUL' || state === null) {
                // Record was deleted
                if (currentSnapshot) {
                    await this.deleteSnapshot(recordId);
                    return { status: 'repaired_delete', recordId };
                }
                return { status: 'verified_deleted', recordId };
            }

            // Record should exist
            var replayedSnapshot = {
                record_id: recordId,
                source_table: sourceTable ? sourceTable.replace('airtable:', '') : null,
                data: state,
                last_amino_event: lastEventId
            };

            // Check if repair needed
            var needsRepair = !currentSnapshot ||
                currentSnapshot.last_amino_event !== lastEventId ||
                JSON.stringify(currentSnapshot.data) !== JSON.stringify(state);

            if (needsRepair) {
                await this.pushSnapshot(replayedSnapshot);

                // Also update local IndexedDB
                if (db && db.objectStoreNames.contains('snapshot')) {
                    var tx = db.transaction('snapshot', 'readwrite');
                    tx.objectStore('snapshot').put(replayedSnapshot);
                }

                return {
                    status: 'repaired',
                    recordId: recordId,
                    eventCount: events.length,
                    lastEventId: lastEventId,
                    diff: {
                        had: currentSnapshot ? currentSnapshot.last_amino_event : null,
                        expected: lastEventId
                    }
                };
            }

            return { status: 'verified_ok', recordId: recordId, eventCount: events.length };

        } catch (err) {
            return { status: 'error', recordId: recordId, error: err.message };
        }
    },

    // Verify a random record from local snapshot
    async verifyRandom() {
        var all = await this.getAllLocalSnapshots();
        if (all.length === 0) return { status: 'empty' };

        var random = all[Math.floor(Math.random() * all.length)];
        return this.verifyRecord(random.record_id);
    },

    // Background verification: check N random records
    async backgroundVerify(count) {
        count = count || 5;
        var results = [];

        for (var i = 0; i < count; i++) {
            var result = await this.verifyRandom();
            results.push(result);
            // Small delay to avoid hammering the API
            await new Promise(function(r) { setTimeout(r, 100); });
        }

        return {
            checked: results.length,
            repaired: results.filter(function(r) { return r.status === 'repaired'; }).length,
            results: results
        };
    },

    // Background verification interval handle
    verifyInterval: null,

    // Start background verification loop
    startBackgroundVerify(intervalMs, countPerInterval) {
        intervalMs = intervalMs || 60000;
        countPerInterval = countPerInterval || 3;

        var self = this;
        this.verifyInterval = setInterval(function() {
            self.backgroundVerify(countPerInterval);
        }, intervalMs);

        // Run initial verification
        return this.backgroundVerify(countPerInterval);
    },

    // Stop background verification
    stopBackgroundVerify() {
        if (this.verifyInterval) {
            clearInterval(this.verifyInterval);
            this.verifyInterval = null;
        }
    }
};

// ============ AmoFormat - Binary Snapshot Format (.amo) ============
// Compact binary representation using MessagePack + gzip with schema deduplication.
// Extension: .amo | MIME: application/x-amino-snapshot

var AmoFormat = {
    MAGIC: 'AMO1',
    VERSION: 1,
    HEADER_SIZE: 8,

    // Produce a .amo binary snapshot from snapshot records
    // snapshotRecords: array of { record_id, source_table, data: { field: value }, last_amino_event }
    // Returns: Uint8Array
    produce: function(snapshotRecords) {
        var schema = {};
        var records = {};
        var maxCursor = 0;

        // First pass: collect all column names per table
        for (var i = 0; i < snapshotRecords.length; i++) {
            var rec = snapshotRecords[i];
            var table = rec.source_table;
            if (rec.last_amino_event > maxCursor) maxCursor = rec.last_amino_event;

            if (!schema[table]) {
                schema[table] = [];
                records[table] = [];
            }
            var keys = Object.keys(rec.data || {});
            for (var k = 0; k < keys.length; k++) {
                if (schema[table].indexOf(keys[k]) === -1) {
                    schema[table].push(keys[k]);
                }
            }
        }

        // Second pass: convert records to positional arrays
        for (var j = 0; j < snapshotRecords.length; j++) {
            var r = snapshotRecords[j];
            var cols = schema[r.source_table];
            var row = [];
            for (var c = 0; c < cols.length; c++) {
                var val = r.data ? r.data[cols[c]] : null;
                row.push(val !== undefined ? val : null);
            }
            records[r.source_table].push(row);
        }

        // Encode payload with MessagePack
        var payload = { v: 1, ts: Math.floor(Date.now() / 1000), cursor: maxCursor, schema: schema, records: records };
        var encoded = MessagePack.encode(payload);

        // Compress with gzip
        var compressed = pako.gzipSync(encoded);

        // Prepend 8-byte header: "AMO1" + version(1) + flags(0) + reserved(0,0)
        var header = new Uint8Array([0x41, 0x4D, 0x4F, 0x31, 0x01, 0x00, 0x00, 0x00]);
        var out = new Uint8Array(8 + compressed.length);
        out.set(header);
        out.set(compressed, 8);
        return out;
    },

    // Read a .amo binary snapshot
    // arrayBuffer: ArrayBuffer or Uint8Array of the .amo file
    // Returns: { tables: { tableName: [{ field: value, ... }, ...] }, cursor, ts }
    read: function(arrayBuffer) {
        var bytes = new Uint8Array(arrayBuffer);

        // Validate header
        if (bytes.length < this.HEADER_SIZE) {
            throw new Error('File too small to be a .amo file');
        }
        var magic = String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]);
        if (magic !== this.MAGIC) {
            throw new Error('Not a .amo file (bad magic bytes)');
        }
        if (bytes[4] !== this.VERSION) {
            throw new Error('Unknown .amo version: ' + bytes[4]);
        }
        if (bytes[5] !== 0x00) {
            throw new Error('Unsupported .amo flags: 0x' + bytes[5].toString(16));
        }

        // Decompress + decode
        var compressed = bytes.slice(this.HEADER_SIZE);
        var decompressed = pako.ungzip(compressed);
        var payload = MessagePack.decode(decompressed);

        // Re-hydrate positional arrays back into objects
        var tables = {};
        var schemaEntries = Object.entries(payload.schema);
        for (var i = 0; i < schemaEntries.length; i++) {
            var tableName = schemaEntries[i][0];
            var columns = schemaEntries[i][1];
            var rows = payload.records[tableName] || [];
            tables[tableName] = [];
            for (var j = 0; j < rows.length; j++) {
                var obj = {};
                for (var k = 0; k < columns.length; k++) {
                    obj[columns[k]] = (k < rows[j].length) ? (rows[j][k] !== undefined ? rows[j][k] : null) : null;
                }
                tables[tableName].push(obj);
            }
        }

        return { tables: tables, cursor: payload.cursor, ts: payload.ts };
    },

    // Detect the format of a snapshot buffer
    // Returns: 'amo' | 'json-gz' | 'json'
    detectFormat: function(buffer) {
        var b = new Uint8Array(buffer.slice(0, 4));
        if (b[0] === 0x41 && b[1] === 0x4D && b[2] === 0x4F && b[3] === 0x31) return 'amo';
        if (b[0] === 0x1F && b[1] === 0x8B) return 'json-gz';
        if (b[0] === 0x7B || b[0] === 0x5B) return 'json';
        throw new Error('Unknown snapshot format');
    },

    // Convert re-hydrated tables back to flat snapshot records for IndexedDB
    // tables: { tableName: [{ field: value }, ...] }
    // cursor: the cursor value from the .amo file
    // Returns: array of { record_id, source_table, data, last_amino_event }
    toSnapshotRecords: function(tables, cursor) {
        var records = [];
        var tableNames = Object.keys(tables);
        for (var i = 0; i < tableNames.length; i++) {
            var tableName = tableNames[i];
            var rows = tables[tableName];
            for (var j = 0; j < rows.length; j++) {
                var row = rows[j];
                var recordId = row.record_id;
                if (!recordId) continue;
                // Build data object excluding record_id itself
                var data = {};
                var keys = Object.keys(row);
                for (var k = 0; k < keys.length; k++) {
                    if (keys[k] !== 'record_id') {
                        data[keys[k]] = row[keys[k]];
                    }
                }
                records.push({
                    record_id: recordId,
                    source_table: tableName,
                    data: data,
                    last_amino_event: cursor
                });
            }
        }
        return records;
    }
};

// ============ Sync Status Feed ============
// Terminal-style log for sync activity visibility

var SyncStatusFeed = {
    maxLines: 100,
    lines: [],
    isVisible: false,
    isActive: false,

    // Log a message to the feed
    log(message, type) {
        type = type || 'info';
        var timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        this.lines.push({ timestamp: timestamp, message: message, type: type });

        // Trim to max lines
        if (this.lines.length > this.maxLines) {
            this.lines = this.lines.slice(-this.maxLines);
        }

        this.render();
        this.updateButton();
    },

    info(message) { this.log(message, 'info'); },
    success(message) { this.log(message, 'success'); },
    error(message) { this.log(message, 'error'); },
    warn(message) { this.log(message, 'warn'); },

    // Set active state (sync in progress)
    setActive(active) {
        this.isActive = active;
        var dot = document.getElementById('sync-feed-status-dot');
        if (dot) {
            dot.className = 'sync-feed-status-dot' + (active ? ' active' : '');
        }
        this.updateStats();
    },

    // Set error state
    setError() {
        var dot = document.getElementById('sync-feed-status-dot');
        if (dot) {
            dot.className = 'sync-feed-status-dot error';
        }
    },

    // Update the [log] button to indicate activity
    updateButton() {
        var btn = document.getElementById('sync-feed-btn');
        if (btn && this.lines.length > 0) {
            btn.classList.add('has-activity');
        }
    },

    // Update stats display
    updateStats() {
        var statsEl = document.getElementById('sync-feed-stats');
        if (statsEl) {
            var stats = PassiveSnapshotSync.getStats();
            if (stats.isRunning) {
                statsEl.textContent = 'Running | Pulled: ' + stats.pulled + ' | Verified: ' + stats.verified;
            } else {
                statsEl.textContent = 'Idle';
            }
        }
    },

    // Render the feed content
    render() {
        var body = document.getElementById('sync-feed-body');
        if (!body) return;

        if (this.lines.length === 0) {
            body.innerHTML = '<div class="sync-feed-empty">No sync activity yet</div>';
            return;
        }

        var html = '';
        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];
            html += '<div class="sync-feed-line ' + line.type + '">';
            html += '<span class="timestamp">' + line.timestamp + '</span>';
            html += '<span class="message">' + esc(line.message) + '</span>';
            html += '</div>';
        }
        body.innerHTML = html;

        // Auto-scroll to bottom
        body.scrollTop = body.scrollHeight;
    },

    // Show the panel
    show() {
        var panel = document.getElementById('sync-feed-panel');
        if (panel) {
            panel.classList.add('visible');
            this.isVisible = true;
            this.updateStats();
        }
    },

    // Hide the panel
    hide() {
        var panel = document.getElementById('sync-feed-panel');
        if (panel) {
            panel.classList.remove('visible');
            this.isVisible = false;
        }
    },

    // Toggle visibility
    toggle() {
        if (this.isVisible) {
            this.hide();
        } else {
            this.show();
        }
    },

    // Clear all lines
    clear() {
        this.lines = [];
        this.render();
        var btn = document.getElementById('sync-feed-btn');
        if (btn) btn.classList.remove('has-activity');
    }
};

// ============ Sync History Tracker ============
// Tracks all sync operations for the Sync Status view

var SyncHistory = {
    maxEntries: 200,
    entries: [],
    pollInterval: null,
    POLL_INTERVAL: 15000, // 15 seconds - base poll interval
    MAX_POLL_INTERVAL: 300000, // 5 minutes - max backoff cap
    isPolling: false,
    consecutiveFailures: 0,
    currentPollInterval: 15000, // tracks the active interval (may be backed off)
    listeners: [],

    // Calculate next poll interval with exponential backoff + jitter
    getBackoffInterval() {
        if (this.consecutiveFailures === 0) return this.POLL_INTERVAL;
        // Exponential backoff: base * 2^failures, capped at MAX_POLL_INTERVAL
        var exponential = this.POLL_INTERVAL * Math.pow(2, this.consecutiveFailures);
        var capped = Math.min(exponential, this.MAX_POLL_INTERVAL);
        // Add jitter: +/- 20% to avoid thundering herd
        var jitter = capped * 0.2 * (Math.random() * 2 - 1);
        return Math.round(capped + jitter);
    },

    // Record a sync operation
    record(entry) {
        this.entries.unshift({
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 5),
            timestamp: new Date(),
            type: entry.type || 'incremental',    // 'incremental', 'full', 'snapshot', 'poll'
            result: entry.result || 'success',      // 'success', 'error', 'no-change'
            eventsFound: entry.eventsFound || 0,
            snapshotsUpdated: entry.snapshotsUpdated || 0,
            duration: entry.duration || 0,
            detail: entry.detail || '',
            error: entry.error || null
        });
        if (this.entries.length > this.maxEntries) {
            this.entries = this.entries.slice(0, this.maxEntries);
        }
        this.notify();
    },

    // Poll the API for new events since last known timestamp.
    // Uses a lightweight "last" query to check if any new events exist,
    // then triggers a full incremental sync only when new data is available.
    async pollForUpdates() {
        if (this.isPolling || !API_KEY) return;
        this.isPolling = true;
        var pollStart = Date.now();
        try {
            // Lightweight check: fetch only the single most recent event
            // If created_after is set, this tells us if anything new exists since our last sync
            var hasNewEvents = false;
            if (lastEventTimestamp) {
                var peek = await fetchPage(1, lastEventTimestamp, { last: true });
                hasNewEvents = peek.events && peek.events.length > 0;
            } else {
                // No lastEventTimestamp means we haven't synced yet - check for any events
                var peek = await fetchPage(1, null, { last: true });
                hasNewEvents = peek.events && peek.events.length > 0;
            }

            // Poll succeeded - reset backoff state
            if (this.consecutiveFailures > 0) {
                var wasBackedOff = this.consecutiveFailures;
                this.consecutiveFailures = 0;
                this.currentPollInterval = this.POLL_INTERVAL;
                this.record({
                    type: 'poll',
                    result: 'success',
                    duration: Date.now() - pollStart,
                    detail: 'Server recovered after ' + wasBackedOff + ' failure(s), resuming normal ' + (this.POLL_INTERVAL / 1000) + 's polling'
                });
            }

            if (hasNewEvents) {
                this.record({
                    type: 'poll',
                    result: 'success',
                    eventsFound: 1,
                    duration: Date.now() - pollStart,
                    detail: 'New events detected since ' + (lastEventTimestamp || 'start') + ', syncing...'
                });

                // Trigger full incremental sync to fetch all new events with pagination
                await incrementalSync();
            } else {
                this.record({
                    type: 'poll',
                    result: 'no-change',
                    eventsFound: 0,
                    duration: Date.now() - pollStart,
                    detail: 'No new events since last sync'
                });
            }
        } catch (err) {
            this.consecutiveFailures++;
            var nextInterval = this.getBackoffInterval();
            this.currentPollInterval = nextInterval;
            this.record({
                type: 'poll',
                result: 'error',
                duration: Date.now() - pollStart,
                error: err.message,
                detail: 'Poll failed: ' + err.message + ' (failure ' + this.consecutiveFailures + ', next retry in ' + Math.round(nextInterval / 1000) + 's)'
            });
        } finally {
            this.isPolling = false;
            // If auto-polling is active, reschedule the next poll with the current interval
            if (this.pollInterval) {
                this.scheduleNextPoll();
            }
        }
    },

    // Schedule the next poll using setTimeout (allows dynamic interval changes)
    scheduleNextPoll() {
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
        }
        var interval = this.consecutiveFailures > 0 ? this.currentPollInterval : this.POLL_INTERVAL;
        this.currentPollInterval = interval;
        this.pollInterval = setTimeout(() => this.pollForUpdates(), interval);
    },

    // Start background polling
    startPolling() {
        if (this.pollInterval) return;
        this.consecutiveFailures = 0;
        this.currentPollInterval = this.POLL_INTERVAL;
        this.scheduleNextPoll();
        this.record({ type: 'poll', result: 'no-change', detail: 'Background polling started (' + (this.POLL_INTERVAL / 1000) + 's interval)' });
    },

    // Stop background polling
    stopPolling() {
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
            this.pollInterval = null;
            this.consecutiveFailures = 0;
            this.currentPollInterval = this.POLL_INTERVAL;
            this.record({ type: 'poll', result: 'no-change', detail: 'Background polling stopped' });
        }
    },

    // Get summary stats
    getStats() {
        var now = Date.now();
        var last5min = this.entries.filter(e => (now - e.timestamp.getTime()) < 300000);
        var lastHour = this.entries.filter(e => (now - e.timestamp.getTime()) < 3600000);
        var errors = this.entries.filter(e => e.result === 'error');
        var totalEvents = this.entries.reduce((sum, e) => sum + (e.eventsFound || 0), 0);
        var totalSnapshots = this.entries.reduce((sum, e) => sum + (e.snapshotsUpdated || 0), 0);
        var lastSync = this.entries.find(e => e.type !== 'poll' && e.result === 'success');
        var lastPoll = this.entries.find(e => e.type === 'poll');

        return {
            totalSyncs: this.entries.filter(e => e.type !== 'poll').length,
            totalPolls: this.entries.filter(e => e.type === 'poll').length,
            last5minOps: last5min.length,
            lastHourOps: lastHour.length,
            totalEventsProcessed: totalEvents,
            totalSnapshotsUpdated: totalSnapshots,
            errorCount: errors.length,
            lastSyncTime: lastSync ? lastSync.timestamp : null,
            lastPollTime: lastPoll ? lastPoll.timestamp : null,
            isPolling: !!this.pollInterval
        };
    },

    // Subscribe to changes (for live UI updates)
    onChange(fn) {
        this.listeners.push(fn);
        return () => { this.listeners = this.listeners.filter(l => l !== fn); };
    },

    notify() {
        this.listeners.forEach(fn => { try { fn(); } catch(e) {} });
    }
};

// ============ Passive Snapshot Sync ============
// Wrapper that orchestrates background verification and snapshot pulling

var PassiveSnapshotSync = {
    // Configuration
    VERIFY_INTERVAL: 30000,  // 30 seconds between verification cycles
    VERIFY_COUNT: 3,         // Records to verify per cycle
    PULL_INTERVAL: 10000,    // 10 seconds between snapshot pulls

    // State
    isRunning: false,
    pullInterval: null,
    stats: {
        verified: 0,
        repaired: 0,
        pulled: 0
    },

    // Start passive sync (both verification and pulling)
    start() {
        if (this.isRunning) return;
        this.isRunning = true;

        console.log('[PassiveSync] Starting passive snapshot sync');
        SyncStatusFeed.info('Snapshot sync started');
        SyncStatusFeed.setActive(true);

        // Start background verification (self-healing)
        AminoSync.startBackgroundVerify(this.VERIFY_INTERVAL, this.VERIFY_COUNT);
        SyncStatusFeed.info('Background verification enabled (every ' + (this.VERIFY_INTERVAL / 1000) + 's)');

        // Start periodic snapshot pulls from server
        var self = this;
        SyncStatusFeed.info('Snapshot pull interval: ' + (this.PULL_INTERVAL / 1000) + 's');
        this.pullInterval = setInterval(async function() {
            try {
                SyncStatusFeed.info('Pulling snapshots from server...');
                var result = await AminoSync.syncFromSnapshot();
                if (result.updated > 0) {
                    self.stats.pulled += result.updated;
                    SyncStatusFeed.success('Pulled ' + result.updated + ' snapshot(s)');
                } else if (result.error) {
                    SyncStatusFeed.error('Pull failed: ' + result.error);
                } else {
                    SyncStatusFeed.info('No new snapshots');
                }
                SyncStatusFeed.updateStats();
            } catch (err) {
                SyncStatusFeed.error('Pull error: ' + err.message);
            }
        }, this.PULL_INTERVAL);
    },

    // Stop passive sync
    stop() {
        if (!this.isRunning) return;
        this.isRunning = false;

        AminoSync.stopBackgroundVerify();

        if (this.pullInterval) {
            clearInterval(this.pullInterval);
            this.pullInterval = null;
        }

        console.log('[PassiveSync] Stopped');
        SyncStatusFeed.warn('Snapshot sync stopped');
        SyncStatusFeed.setActive(false);
    },

    // Get current stats
    getStats() {
        return {
            isRunning: this.isRunning,
            ...this.stats
        };
    }
};

// Toggle snapshot sync on/off
function toggleSnapshotSync() {
    snapshotSyncEnabled = !snapshotSyncEnabled;
    var toggle = document.getElementById('sync-toggle');

    if (snapshotSyncEnabled) {
        toggle.classList.add('active');
        if (API_KEY) PassiveSnapshotSync.start();
        console.log('[SnapshotSync] Enabled');
    } else {
        toggle.classList.remove('active');
        PassiveSnapshotSync.stop();
        console.log('[SnapshotSync] Disabled');
    }
}

// Initialize sync toggle UI state
function initSyncToggle() {
    var toggle = document.getElementById('sync-toggle');
    if (toggle) {
        if (snapshotSyncEnabled) {
            toggle.classList.add('active');
        } else {
            toggle.classList.remove('active');
        }
    }
}

// ============ IndexedDB ============

function openDB() {
    return new Promise((resolve, reject) => {
        var req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve(req.result);
        req.onupgradeneeded = (e) => {
            var db = e.target.result;

            // Delete old stores if they exist
            if (db.objectStoreNames.contains('records')) {
                db.deleteObjectStore('records');
            }
            if (db.objectStoreNames.contains('meta')) {
                db.deleteObjectStore('meta');
            }

            // Data records: keyed by [tableId, recordId]
            if (!db.objectStoreNames.contains('data')) {
                var dataStore = db.createObjectStore('data', { keyPath: ['tableId', 'recordId'] });
                dataStore.createIndex('by_table', 'tableId');
            }

            // Table metadata
            if (!db.objectStoreNames.contains('tables')) {
                db.createObjectStore('tables', { keyPath: 'tableId' });
            }

            // Field metadata: keyed by [tableId, fieldId]
            if (!db.objectStoreNames.contains('fields')) {
                var fieldStore = db.createObjectStore('fields', { keyPath: ['tableId', 'fieldId'] });
                fieldStore.createIndex('by_table', 'tableId');
            }

            // View metadata: keyed by [tableId, viewId]
            if (!db.objectStoreNames.contains('views')) {
                var viewStore = db.createObjectStore('views', { keyPath: ['tableId', 'viewId'] });
                viewStore.createIndex('by_table', 'tableId');
            }

            // Field history: keyed by auto-increment, indexed by record and field
            if (!db.objectStoreNames.contains('fieldHistory')) {
                var historyStore = db.createObjectStore('fieldHistory', { keyPath: 'id', autoIncrement: true });
                historyStore.createIndex('by_record', ['tableId', 'recordId']);
                historyStore.createIndex('by_field', ['tableId', 'recordId', 'fieldId']);
                historyStore.createIndex('by_event', 'eventId');
            }

            // View folders: keyed by folderId
            if (!db.objectStoreNames.contains('viewFolders')) {
                var folderStore = db.createObjectStore('viewFolders', { keyPath: 'folderId' });
                folderStore.createIndex('by_table', 'tableId');
            }

            // Workspaces: keyed by workspaceId
            if (!db.objectStoreNames.contains('workspaces')) {
                db.createObjectStore('workspaces', { keyPath: 'workspaceId' });
            }

            // Sync state
            if (!db.objectStoreNames.contains('sync')) {
                db.createObjectStore('sync', { keyPath: 'key' });
            }

            // Raw events: keyed by event id, indexed by set and recordId
            if (!db.objectStoreNames.contains('events')) {
                var eventsStore = db.createObjectStore('events', { keyPath: 'id' });
                eventsStore.createIndex('by_set', 'set');
                eventsStore.createIndex('by_record', 'recordId');
                eventsStore.createIndex('by_timestamp', 'created_at');
            }

            // Snapshot: materialized current state, keyed by record_id
            if (!db.objectStoreNames.contains('snapshot')) {
                var snapshotStore = db.createObjectStore('snapshot', { keyPath: 'record_id' });
                snapshotStore.createIndex('by_source_table', 'source_table');
                snapshotStore.createIndex('by_last_amino_event', 'last_amino_event');
            }
        };
    });
}

function getSyncMeta(key) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readonly');
        var req = tx.objectStore('sync').get(key);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
        req.onerror = () => reject(req.error);
    });
}

function setSyncMeta(key, value) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('sync', 'readwrite');
        tx.objectStore('sync').put({ key, value });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// ============ Events Store Functions ============

// Encrypt event payloads for storage
async function encryptEventForStorage(event) {
    if (!encryptionEnabled || !encryptionKey || !event.payload) {
        return event;
    }
    var encrypted = { ...event };
    encrypted._encryptedPayload = await encryptData(event.payload, encryptionKey);
    delete encrypted.payload;
    return encrypted;
}

// Decrypt event payload after retrieval
async function decryptEventFromStorage(event) {
    if (!event || !event._encryptedPayload || !encryptionEnabled || !encryptionKey) {
        return event;
    }
    var decrypted = { ...event };
    decrypted.payload = await decryptData(event._encryptedPayload, encryptionKey);
    delete decrypted._encryptedPayload;
    return decrypted;
}

// Encrypt data record fields for storage
async function encryptRecordForStorage(record) {
    if (!encryptionEnabled || !encryptionKey || !record.fields) {
        return record;
    }
    var encrypted = { ...record };
    encrypted._encryptedFields = await encryptData(record.fields, encryptionKey);
    delete encrypted.fields;
    return encrypted;
}

// Decrypt data record fields after retrieval
async function decryptRecordFromStorage(record) {
    if (!record || !record._encryptedFields || !encryptionEnabled || !encryptionKey) {
        return record;
    }
    var decrypted = { ...record };
    decrypted.fields = await decryptData(record._encryptedFields, encryptionKey);
    delete decrypted._encryptedFields;
    return decrypted;
}

async function saveRawEvents(events) {
    if (!events || events.length === 0) return;

    // Encrypt events if encryption is enabled
    var eventsToStore = events;
    if (encryptionEnabled && encryptionKey) {
        eventsToStore = await Promise.all(events.map(e => encryptEventForStorage(e)));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readwrite');
        var store = tx.objectStore('events');
        eventsToStore.forEach(e => store.put(e));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function getAllRawEvents(limit, offset) {
    var maxLimit = limit || 100;
    var startOffset = offset || 0;

    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        // Events are sorted by ID ascending, we want newest first (descending)
        var reversed = [];
        for (var i = inMemoryEvents.length - 1; i >= 0; i--) {
            reversed.push(inMemoryEvents[i]);
        }
        return reversed.slice(startOffset, startOffset + maxLimit);
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;
        var collected = 0;

        // Use a cursor to iterate in reverse order (newest first)
        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor && collected < maxLimit) {
                if (skipped < startOffset) {
                    skipped++;
                    cursor.continue();
                } else {
                    results.push(cursor.value);
                    collected++;
                    cursor.continue();
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getRawEventsCount() {
    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        return Promise.resolve(inMemoryEvents.length);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var req = tx.objectStore('events').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

async function getRawEventsByRecordId(recordId, maxEventId) {
    // Check in-memory events first (from CSV import)
    if (inMemoryEventsByRecord && inMemoryEventsByRecord.has(recordId)) {
        var results = inMemoryEventsByRecord.get(recordId).slice();
        if (maxEventId) {
            results = results.filter(e => e.id <= maxEventId);
        }
        results.sort((a, b) => (a.id || 0) - (b.id || 0));
        return results;
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var index = tx.objectStore('events').index('by_record');
        var req = index.getAll(recordId);
        req.onsuccess = () => {
            var results = req.result || [];
            // Filter to events up to maxEventId and sort by id ascending
            if (maxEventId) {
                results = results.filter(e => e.id <= maxEventId);
            }
            results.sort((a, b) => (a.id || 0) - (b.id || 0));
            resolve(results);
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function getRawEventsBySet(setFilter) {
    // DEPRECATED: Use getRawEventsBySetPaginated instead
    return getRawEventsBySetPaginated(setFilter, 0, 500);
}

// Memory-efficient paginated events by set retrieval
async function getRawEventsBySetPaginated(setFilter, offset, limit) {
    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        var filtered = [];
        for (var i = inMemoryEvents.length - 1; i >= 0; i--) {
            if (inMemoryEvents[i].set === setFilter) {
                filtered.push(inMemoryEvents[i]);
            }
        }
        return filtered.slice(offset, offset + limit);
    }

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var index = tx.objectStore('events').index('by_set');

        // Get all matching, then sort and paginate
        // Note: IndexedDB index doesn't support ordering by different field, so we collect and sort
        var req = index.getAll(setFilter);
        req.onsuccess = () => {
            var all = req.result || [];
            all.sort((a, b) => (b.id || 0) - (a.id || 0)); // Newest first
            // Apply pagination
            resolve(all.slice(offset, offset + limit));
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

function searchRawEvents(query, limit, offset) {
    var maxLimit = limit || 100;
    var skipCount = offset || 0;
    var lowerQuery = query.toLowerCase();

    // Check in-memory events first (from CSV import)
    if (inMemoryEvents && inMemoryEvents.length > 0) {
        var results = [];
        var skipped = 0;
        for (var i = inMemoryEvents.length - 1; i >= 0 && results.length < maxLimit; i--) {
            var event = inMemoryEvents[i];
            var matchesRecord = event.recordId && event.recordId.toLowerCase().includes(lowerQuery);
            var matchesSet = event.set && event.set.toLowerCase().includes(lowerQuery);
            var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);
            var matchesPayload = payloadStr && payloadStr.toLowerCase().includes(lowerQuery);

            if (matchesRecord || matchesSet || matchesPayload) {
                if (skipped < skipCount) {
                    skipped++;
                } else {
                    results.push(event);
                }
            }
        }
        return Promise.resolve(results);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;

        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                var event = cursor.value;
                // Search in recordId, set, and payload
                var matchesRecord = event.recordId && event.recordId.toLowerCase().includes(lowerQuery);
                var matchesSet = event.set && event.set.toLowerCase().includes(lowerQuery);
                var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);
                var matchesPayload = payloadStr && payloadStr.toLowerCase().includes(lowerQuery);

                if (matchesRecord || matchesSet || matchesPayload) {
                    if (skipped < skipCount) {
                        skipped++;
                        cursor.continue();
                    } else if (results.length < maxLimit) {
                        results.push(event);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                } else {
                    cursor.continue();
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

function getMaxEventId() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var req = store.openCursor(null, 'prev'); // Open cursor in reverse to get highest ID first
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                resolve(cursor.value.id || 0);
            } else {
                resolve(0); // No events
            }
        };
        req.onerror = () => reject(req.error);
    });
}

function getAllRawEventsNoPagination() {
    // DEPRECATED: Use getRawEventsPaginated instead to avoid memory issues
    return getRawEventsPaginated(0, 500); // Return max 500 events
}

// Memory-efficient paginated events retrieval using IndexedDB cursor
async function getRawEventsPaginated(offset, limit) {
    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var results = [];
        var skipped = 0;

        // Use cursor in reverse order (newest first, highest ID first)
        var req = store.openCursor(null, 'prev');
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                if (skipped < offset) {
                    skipped++;
                    cursor.continue();
                } else if (results.length < limit) {
                    results.push(cursor.value);
                    cursor.continue();
                } else {
                    resolve(results);
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });

    // Decrypt events if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(e => decryptEventFromStorage(e)));
    }
    return results;
}

// Get total count of raw events
function getRawEventsTotalCount() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('events', 'readonly');
        var req = tx.objectStore('events').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

// Get all current records from all tables as synthetic event-like objects
// DEPRECATED: Use getCurrentRecordsPaginated instead to avoid memory issues
function getAllCurrentRecords() {
    return getCurrentRecordsPaginated(0, 500); // Return max 500 records
}

// Memory-efficient paginated current records retrieval
function getCurrentRecordsPaginated(offset, limit, tableFilter, searchQuery) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var results = [];
        var skipped = 0;
        var setFilter = tableFilter || null;
        var query = searchQuery ? searchQuery.toLowerCase() : null;

        var req = store.openCursor();
        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor) {
                var rec = cursor.value;
                var setVal = 'airtable:' + rec.tableId;

                // Apply table filter if set
                if (setFilter && setVal !== setFilter) {
                    cursor.continue();
                    return;
                }

                // Apply search filter if set
                if (query) {
                    var matchesSearch = (rec.recordId && rec.recordId.toLowerCase().includes(query)) ||
                                       (setVal.toLowerCase().includes(query)) ||
                                       (JSON.stringify(rec.fields || {}).toLowerCase().includes(query));
                    if (!matchesSearch) {
                        cursor.continue();
                        return;
                    }
                }

                if (skipped < offset) {
                    skipped++;
                    cursor.continue();
                } else if (results.length < limit) {
                    // Convert to synthetic event format
                    results.push({
                        id: 0,
                        recordId: rec.recordId,
                        set: setVal,
                        payload: JSON.stringify({
                            _set: 'current',
                            fields: { INS: rec.fields }
                        }),
                        created_at: null,
                        _isCurrentState: true
                    });
                    cursor.continue();
                } else {
                    resolve(results);
                }
            } else {
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

// Get count of all current records
function getCurrentRecordsCount() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var req = tx.objectStore('data').count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

function getAllTables() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readonly');
        var req = tx.objectStore('tables').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getFieldsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var index = tx.objectStore('fields').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getViewsForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var index = tx.objectStore('views').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllViews() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readonly');
        var req = tx.objectStore('views').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function getAllFields() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readonly');
        var req = tx.objectStore('fields').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Query schema elements by recordId prefix
function getSchemaByPrefix(prefix) {
    // Returns tables (tbl*), fields (fld*), or views (viw*) based on prefix
    return new Promise(async (resolve) => {
        var results = [];
        if (prefix === 'tbl') {
            var tables = await getAllTables();
            results = tables.filter(t => t.tableId && t.tableId.startsWith('tbl'));
        } else if (prefix === 'fld') {
            var fields = await getAllFields();
            results = fields.filter(f => f.fieldId && f.fieldId.startsWith('fld'));
        } else if (prefix === 'viw') {
            var views = await getAllViews();
            results = views.filter(v => v.viewId && v.viewId.startsWith('viw'));
        }
        resolve(results);
    });
}

function getRecordIdsForTable(tableId) {
    // Check in-memory data first (from CSV import)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        return Promise.resolve(Object.keys(window.IN_MEMORY_DATA[tableId]));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var index = tx.objectStore('data').index('by_table');
        var req = index.getAllKeys(tableId);
        req.onsuccess = () => {
            // Keys are [tableId, recordId], extract recordIds
            var recordIds = (req.result || []).map(k => k[1]);
            resolve(recordIds);
        };
        req.onerror = () => reject(req.error);
    });
}

async function getRecord(tableId, recordId) {
    // Check in-memory data first (from CSV import)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId] && window.IN_MEMORY_DATA[tableId][recordId]) {
        return {
            tableId: tableId,
            recordId: recordId,
            fields: window.IN_MEMORY_DATA[tableId][recordId]
        };
    }

    var result = await new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var req = tx.objectStore('data').get([tableId, recordId]);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
    });

    // Decrypt record if needed
    if (result && encryptionEnabled && encryptionKey) {
        return decryptRecordFromStorage(result);
    }
    return result;
}

async function getRecordsByIds(tableId, recordIds) {
    if (!recordIds.length) return [];

    // Check in-memory data first (from CSV import)
    if (window.IN_MEMORY_DATA && window.IN_MEMORY_DATA[tableId]) {
        var memResults = [];
        var missingIds = [];
        for (var i = 0; i < recordIds.length; i++) {
            var rid = recordIds[i];
            if (window.IN_MEMORY_DATA[tableId][rid]) {
                memResults.push({
                    tableId: tableId,
                    recordId: rid,
                    fields: window.IN_MEMORY_DATA[tableId][rid]
                });
            } else {
                missingIds.push(rid);
            }
        }
        // If all records found in memory, return immediately
        if (missingIds.length === 0) {
            return memResults;
        }
        // Otherwise, also check IndexedDB for missing ones
        var dbResults = await getRecordsByIdsFromDB(tableId, missingIds);
        return memResults.concat(dbResults);
    }

    return getRecordsByIdsFromDB(tableId, recordIds);
}

// Internal: Get records from IndexedDB only
async function getRecordsByIdsFromDB(tableId, recordIds) {
    if (!recordIds.length) return [];

    var results = await new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readonly');
        var store = tx.objectStore('data');
        var results = [];
        var pending = recordIds.length;

        recordIds.forEach(rid => {
            var req = store.get([tableId, rid]);
            req.onsuccess = () => {
                if (req.result) results.push(req.result);
                if (--pending === 0) resolve(results);
            };
            req.onerror = () => {
                if (--pending === 0) resolve(results);
            };
        });
    });

    // Decrypt records if needed
    if (encryptionEnabled && encryptionKey) {
        return Promise.all(results.map(r => decryptRecordFromStorage(r)));
    }
    return results;
}

function saveTable(table) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('tables', 'readwrite');
        tx.objectStore('tables').put(table);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveField(field) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fields', 'readwrite');
        tx.objectStore('fields').put(field);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveView(view) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readwrite');
        tx.objectStore('views').put(view);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function saveDataRecord(record) {
    // Encrypt record if needed
    var recordToStore = record;
    if (encryptionEnabled && encryptionKey) {
        recordToStore = await encryptRecordForStorage(record);
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction('data', 'readwrite');
        tx.objectStore('data').put(recordToStore);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

async function saveBatch(tables, fields, views, dataRecords) {
    var stores = [];
    if (tables.length) stores.push('tables');
    if (fields.length) stores.push('fields');
    if (views.length) stores.push('views');
    if (dataRecords.length) stores.push('data');
    if (!stores.length) return;

    // Encrypt data records if needed
    var recordsToStore = dataRecords;
    if (encryptionEnabled && encryptionKey && dataRecords.length) {
        recordsToStore = await Promise.all(dataRecords.map(r => encryptRecordForStorage(r)));
    }

    return new Promise((resolve, reject) => {
        var tx = db.transaction(stores, 'readwrite');

        tables.forEach(t => tx.objectStore('tables').put(t));
        fields.forEach(f => tx.objectStore('fields').put(f));
        views.forEach(v => tx.objectStore('views').put(v));
        recordsToStore.forEach(d => tx.objectStore('data').put(d));

        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function clearAllData() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction(['data', 'tables', 'fields', 'views', 'sync', 'fieldHistory', 'events'], 'readwrite');
        tx.objectStore('data').clear();
        tx.objectStore('tables').clear();
        tx.objectStore('fields').clear();
        tx.objectStore('views').clear();
        tx.objectStore('sync').clear();
        tx.objectStore('fieldHistory').clear();
        tx.objectStore('events').clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function saveFieldHistory(historyEntries) {
    return new Promise((resolve, reject) => {
        if (!historyEntries.length) return resolve();
        var tx = db.transaction('fieldHistory', 'readwrite');
        var store = tx.objectStore('fieldHistory');
        historyEntries.forEach(entry => store.add(entry));
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Field history limit to prevent excessive memory usage
var FIELD_HISTORY_LIMIT = 1000;

function getFieldHistoryForRecord(tableId, recordId, limit) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('fieldHistory', 'readonly');
        var index = tx.objectStore('fieldHistory').index('by_record');
        var maxLimit = limit || FIELD_HISTORY_LIMIT;

        // Use cursor for memory-efficient retrieval with limit
        var results = [];
        var req = index.openCursor(IDBKeyRange.only([tableId, recordId]));

        req.onsuccess = (e) => {
            var cursor = e.target.result;
            if (cursor && results.length < maxLimit) {
                results.push(cursor.value);
                cursor.continue();
            } else {
                // Sort by eventId descending (most recent first)
                results.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
                resolve(results);
            }
        };
        req.onerror = () => reject(req.error);
    });
}

// Fetch and process any new history events for a specific record from API
async function fetchAndProcessHistoryForRecord(tableId, recordId) {
    if (!API_KEY) return;

    // Get the highest eventId we have for this record to fetch only newer events
    var existingHistory = await getFieldHistoryForRecord(tableId, recordId);
    var maxEventId = existingHistory.reduce((max, h) => Math.max(max, h.eventId || 0), 0);

    // Build API URL with recordId filter and id > maxEventId
    var url = API + '?page=1&per_page=500';
    url += '&apiKey=' + encodeURIComponent(API_KEY);
    url += '&recordId=' + encodeURIComponent(recordId);
    if (maxEventId > 0) {
        url += '&id=' + maxEventId;
    }

    try {
        var res = await fetch(url);
        if (!res.ok) return;

        var data = await res.json();
        var events = Array.isArray(data) ? data : (data.items || data.data || []);

        if (!events || events.length === 0) return;

        // Sort events by id ascending (oldest first for proper state tracking)
        events.sort((a, b) => (a.id || 0) - (b.id || 0));

        // Get existing record state to calculate oldValue correctly
        var existingRecord = await getRecord(tableId, recordId);
        var state = existingRecord ? { ...existingRecord.fields } : {};

        var fieldHistoryEntries = [];

        for (var e of events) {
            if (!e || !e.recordId || e.recordId !== recordId) continue;

            var payload = parsePayload(e.payload);
            if (!payload || typeof payload !== 'object') continue;

            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            var eventId = e.id;
            var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

            // Process INS (insert/create)
            if (pfields.INS) {
                for (var fieldId in pfields.INS) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'created',
                        oldValue: null,
                        newValue: pfields.INS[fieldId]
                    });
                }
                Object.assign(state, pfields.INS);
            }

            // Process ALT (alter/update)
            if (pfields.ALT) {
                for (var fieldId in pfields.ALT) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'updated',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.ALT[fieldId]
                    });
                }
                Object.assign(state, pfields.ALT);
            }

            // Process NUL (nullify/delete)
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'deleted',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: null
                    });
                    delete state[fieldId];
                });
            }
        }

        // Save new history entries
        if (fieldHistoryEntries.length > 0) {
            await saveFieldHistory(fieldHistoryEntries);
        }
    } catch (err) {
        console.error('Error fetching history for record:', err);
    }
}

// ============ View Folders ============

function getFoldersForTable(tableId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readonly');
        var index = tx.objectStore('viewFolders').index('by_table');
        var req = index.getAll(tableId);
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

function saveFolder(folder) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readwrite');
        tx.objectStore('viewFolders').put(folder);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function deleteFolder(folderId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readwrite');
        tx.objectStore('viewFolders').delete(folderId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

function getAllFolders() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('viewFolders', 'readonly');
        var req = tx.objectStore('viewFolders').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// ============ View Auto-Save System ============

// Mark view as dirty (edited)
function markViewDirty(changeType, data) {
    if (!currentTable || !currentView) return;

    viewDirtyState.isDirty = true;
    viewDirtyState.lastEditTime = Date.now();
    viewDirtyState.pendingChanges.tableId = currentTable;
    viewDirtyState.pendingChanges.viewId = currentView;
    viewDirtyState.pendingChanges.changes[changeType] = data;

    // Reset auto-save timer (debounce)
    clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(saveViewToBackend, AUTO_SAVE_DELAY);

    // Update UI indicator
    updateSaveIndicator('dirty');
}

// Update save indicator UI
function updateSaveIndicator(state) {
    var indicator = document.getElementById('view-save-indicator');
    var text = document.getElementById('save-indicator-text');
    var saveBtn = document.getElementById('manual-save-btn');

    if (!indicator || !text || !saveBtn) return;

    indicator.style.display = 'flex';
    indicator.className = 'view-save-indicator ' + state;

    switch(state) {
        case 'dirty':
            var remaining = Math.ceil((AUTO_SAVE_DELAY - (Date.now() - viewDirtyState.lastEditTime)) / 60000);
            text.textContent = 'Auto-save in ~' + Math.max(1, remaining) + 'm';
            saveBtn.style.display = 'inline-block';
            saveBtn.disabled = false;
            break;
        case 'saving':
            text.textContent = 'Saving...';
            saveBtn.style.display = 'inline-block';
            saveBtn.disabled = true;
            break;
        case 'saved':
            text.textContent = 'Saved';
            saveBtn.style.display = 'none';
            // Hide after 3 seconds
            setTimeout(() => {
                if (!viewDirtyState.isDirty) {
                    indicator.style.display = 'none';
                }
            }, 3000);
            break;
        default:
            indicator.style.display = 'none';
    }
}

// Save view changes to backend
async function saveViewToBackend() {
    if (!viewDirtyState.isDirty || !API_KEY) return;

    var { tableId, viewId, changes } = viewDirtyState.pendingChanges;
    if (!tableId || !viewId) return;

    updateSaveIndicator('saving');

    // Get the full view data
    var view = META_VIEWS[tableId]?.[viewId] || {};
    var config = VIEW_FIELD_CONFIG[tableId]?.[viewId] || {};

    // Build the complete view config data for snapshot
    var viewConfigData = {
        _set: 'viewConfig',
        tableId: tableId,
        viewId: viewId,
        viewName: view.viewName || viewId,
        hiddenFieldIds: config.hiddenFieldIds || [],
        fieldOrder: config.fieldOrder || [],
        filters: view.filters || [],
        sorts: view.sorts || [],
        folderId: view.folderId || null,
        ...changes
    };

    var payload = {
        uuid: crypto.randomUUID(),
        recordId: viewId,
        set: 'airtable:' + tableId,
        operator: 'ALT',
        created_at: new Date().toISOString(),
        apiKey: API_KEY,
        payload: JSON.stringify(viewConfigData)
    };

    try {
        // Use AminoSync to post event and update snapshot
        await AminoSync.postEventWithSnapshot(payload, {
            source_table: 'viewConfig:' + tableId,
            data: viewConfigData
        });

        // Clear dirty state
        viewDirtyState.isDirty = false;
        viewDirtyState.pendingChanges = { tableId: null, viewId: null, changes: {} };
        clearTimeout(autoSaveTimer);

        updateSaveIndicator('saved');
        console.log('View saved to backend:', viewId);
    } catch (error) {
        console.error('Failed to save view to backend:', error);
        // Keep dirty state, will retry on next trigger
        updateSaveIndicator('dirty');
    }
}

// Manual save button handler
async function saveViewToBackendNow() {
    clearTimeout(autoSaveTimer);
    await saveViewToBackend();
}

// Auto-save before navigation
async function autoSaveBeforeNavigation() {
    if (viewDirtyState.isDirty) {
        clearTimeout(autoSaveTimer);
        await saveViewToBackend();
    }
}

// Browser beforeunload - auto-save
window.addEventListener('beforeunload', function(e) {
    if (viewDirtyState.isDirty) {
        // Attempt to save (may not complete if user leaves too quickly)
        saveViewToBackend();
    }
    if (tableSettingsDirty) {
        // Attempt to save table settings
        saveTableSettings();
    }
});

// ============ Table Settings (User-Specific Table/View Preferences) ============

// Table settings dirty state tracking
var tableSettingsDirty = false;
var tableSettingsAutoSaveTimer = null;

// Get current table settings
function getTableSettings() {
    return TABLE_SETTINGS;
}

// Update table visibility
function setTableVisible(tableId, visible) {
    if (!TABLE_SETTINGS.tables[tableId]) {
        TABLE_SETTINGS.tables[tableId] = {};
    }
    TABLE_SETTINGS.tables[tableId].visible = visible;
    markTableSettingsDirty();
}

// Update table sort order
function setTableSortOrder(tableId, sortOrder) {
    if (!TABLE_SETTINGS.tables[tableId]) {
        TABLE_SETTINGS.tables[tableId] = {};
    }
    TABLE_SETTINGS.tables[tableId].sortOrder = sortOrder;
    markTableSettingsDirty();
}

// Update the table order array (reorder tables)
function setTableOrder(tableOrder) {
    TABLE_SETTINGS.tableOrder = tableOrder;
    markTableSettingsDirty();
}

// Update view public/private setting
function setViewPublic(viewId, isPublic) {
    if (!TABLE_SETTINGS.views[viewId]) {
        TABLE_SETTINGS.views[viewId] = {};
    }
    TABLE_SETTINGS.views[viewId].isPublic = isPublic;
    markTableSettingsDirty();
}

// Update view sort order
function setViewSortOrder(viewId, sortOrder) {
    if (!TABLE_SETTINGS.views[viewId]) {
        TABLE_SETTINGS.views[viewId] = {};
    }
    TABLE_SETTINGS.views[viewId].sortOrder = sortOrder;
    markTableSettingsDirty();
}

// Check if a table is visible (defaults to true if not set)
function isTableVisible(tableId) {
    var settings = TABLE_SETTINGS.tables[tableId];
    return settings ? settings.visible !== false : true;
}

// Check if a view is public (defaults to false - private by default)
function isViewPublic(viewId) {
    var settings = TABLE_SETTINGS.views[viewId];
    return settings ? settings.isPublic === true : false;
}

// Get table sort order (returns null if not set)
function getTableSortOrder(tableId) {
    var settings = TABLE_SETTINGS.tables[tableId];
    return settings ? settings.sortOrder : null;
}

// Get view sort order (returns null if not set)
function getViewSortOrder(viewId) {
    var settings = TABLE_SETTINGS.views[viewId];
    return settings ? settings.sortOrder : null;
}

// Mark table settings as dirty and schedule auto-save
function markTableSettingsDirty() {
    tableSettingsDirty = true;

    // Clear existing timer
    if (tableSettingsAutoSaveTimer) {
        clearTimeout(tableSettingsAutoSaveTimer);
    }

    // Schedule auto-save after 2 seconds of inactivity
    tableSettingsAutoSaveTimer = setTimeout(function() {
        saveTableSettings();
    }, 2000);
}

// Save table settings to backend
async function saveTableSettings() {
    if (!tableSettingsDirty || !API_KEY) return;

    var tableSettingsData = {
        _set: 'tableSettings',
        tables: TABLE_SETTINGS.tables,
        tableOrder: TABLE_SETTINGS.tableOrder,
        views: TABLE_SETTINGS.views
    };

    var payload = {
        uuid: crypto.randomUUID(),
        recordId: 'tableSettings:' + (API_KEY || 'default'),
        set: 'userSettings',
        operator: 'ALT',
        created_at: new Date().toISOString(),
        apiKey: API_KEY,
        payload: JSON.stringify(tableSettingsData)
    };

    try {
        // Use AminoSync to post event and update snapshot
        await AminoSync.postEventWithSnapshot(payload, {
            source_table: 'tableSettings',
            data: tableSettingsData
        });

        // Clear dirty state
        tableSettingsDirty = false;
        clearTimeout(tableSettingsAutoSaveTimer);

        console.log('Table settings saved to backend');
    } catch (error) {
        console.error('Failed to save table settings to backend:', error);
        // Keep dirty state, will retry on next trigger
    }
}

// Load table settings from snapshots
async function loadTableSettings() {
    try {
        var recordId = 'tableSettings:' + (API_KEY || 'default');
        var snapshot = await AminoSync.getSnapshot(recordId);

        if (snapshot && snapshot.data) {
            if (snapshot.data.tables) TABLE_SETTINGS.tables = snapshot.data.tables;
            if (snapshot.data.tableOrder) TABLE_SETTINGS.tableOrder = snapshot.data.tableOrder;
            if (snapshot.data.views) TABLE_SETTINGS.views = snapshot.data.views;
            console.log('Table settings loaded from snapshot');
        }
    } catch (error) {
        console.error('Failed to load table settings:', error);
    }
}

// ============ View Field Configuration ============

// Get the field configuration for a view (from cache or initialize default)
function getViewFieldConfig(tableId, viewId) {
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};

    // Return cached config if exists
    if (VIEW_FIELD_CONFIG[tableId][viewId]) {
        return VIEW_FIELD_CONFIG[tableId][viewId];
    }

    // Check if view has stored config in META_VIEWS
    var view = META_VIEWS[tableId]?.[viewId];
    if (view && (view.hiddenFieldIds || view.fieldOrder)) {
        VIEW_FIELD_CONFIG[tableId][viewId] = {
            hiddenFieldIds: view.hiddenFieldIds || [],
            fieldOrder: view.fieldOrder || []
        };
        return VIEW_FIELD_CONFIG[tableId][viewId];
    }

    // Initialize default config - show all fields in their natural order
    return initViewFieldConfig(tableId, viewId);
}

// Initialize default view field config (all fields visible)
function initViewFieldConfig(tableId, viewId) {
    var fields = META_FIELDS[tableId] || {};
    var fieldIds = Object.keys(fields);

    // Sort fields by name for consistent initial order
    fieldIds.sort((a, b) => {
        var nameA = (fields[a].fieldName || a).toLowerCase();
        var nameB = (fields[b].fieldName || b).toLowerCase();
        return nameA.localeCompare(nameB);
    });

    var config = {
        hiddenFieldIds: [],          // No fields hidden initially (all visible)
        fieldOrder: fieldIds.slice() // Order for display
    };

    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    VIEW_FIELD_CONFIG[tableId][viewId] = config;

    return config;
}

// Save view field configuration to memory and IndexedDB
async function saveViewFieldConfig(tableId, viewId, config) {
    // Update cache
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    VIEW_FIELD_CONFIG[tableId][viewId] = config;

    // Update META_VIEWS and persist to IndexedDB
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        // Create a synthetic view if it doesn't exist
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId,
            viewType: 'grid'
        };
    }

    // Merge config into view
    META_VIEWS[tableId][viewId].hiddenFieldIds = config.hiddenFieldIds;
    META_VIEWS[tableId][viewId].fieldOrder = config.fieldOrder;

    // Persist to IndexedDB
    await saveView(META_VIEWS[tableId][viewId]);
}

// Save view filters, sorts, and groupBy to IndexedDB
async function saveViewFiltersAndSorts(tableId, viewId, filters, sorts, groupBy) {
    if (!tableId || !viewId) return;

    // Update META_VIEWS
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        // Create a synthetic view if it doesn't exist
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId,
            viewType: 'grid'
        };
    }

    // Store filters, sorts, and groupBy
    META_VIEWS[tableId][viewId].filters = filters || [];
    META_VIEWS[tableId][viewId].sorts = sorts || [];
    META_VIEWS[tableId][viewId].groupBy = groupBy || null;

    // Persist to IndexedDB
    await saveView(META_VIEWS[tableId][viewId]);
}

// Get view filters, sorts, and groupBy
function getViewFiltersAndSorts(tableId, viewId) {
    if (!tableId || !viewId) return { filters: [], sorts: [], groupBy: null };

    var view = META_VIEWS[tableId]?.[viewId];
    return {
        filters: (view && view.filters) ? view.filters.slice() : [],
        sorts: (view && view.sorts) ? view.sorts.slice() : [],
        groupBy: (view && view.groupBy) ? view.groupBy : null
    };
}

// Get visible fields for current view in correct order
function getVisibleFieldsForView(tableId, viewId) {
    var config = getViewFieldConfig(tableId, viewId || '_default');
    var fields = META_FIELDS[tableId] || {};
    var allFieldIds = Object.keys(fields);

    // Hidden fields are in hiddenFieldIds; all others are visible
    var hiddenSet = new Set(config.hiddenFieldIds || []);
    var result = [];
    var addedSet = new Set();

    // First add fields from fieldOrder that are not hidden
    for (var fid of (config.fieldOrder || [])) {
        if (fields[fid] && !hiddenSet.has(fid) && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    // Add any remaining visible fields not in fieldOrder (newly added fields)
    for (var fid of allFieldIds) {
        if (!hiddenSet.has(fid) && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    return result;
}

// Get all fields in order (both visible and hidden) for the fields dropdown
function getAllFieldsInOrder(tableId, viewId) {
    var config = getViewFieldConfig(tableId, viewId || '_default');
    var fields = META_FIELDS[tableId] || {};
    var allFieldIds = Object.keys(fields);
    var result = [];
    var addedSet = new Set();

    // First add fields in fieldOrder
    for (var fid of (config.fieldOrder || [])) {
        if (fields[fid] && !addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    // Then add any remaining fields (newly added ones)
    for (var fid of allFieldIds) {
        if (!addedSet.has(fid)) {
            result.push(fid);
            addedSet.add(fid);
        }
    }

    return result;
}

// Toggle field visibility for current view
async function toggleFieldVisibility(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    if (!config.hiddenFieldIds) config.hiddenFieldIds = [];

    var idx = config.hiddenFieldIds.indexOf(fieldId);
    if (idx >= 0) {
        // Field is hidden, make it visible
        config.hiddenFieldIds.splice(idx, 1);
    } else {
        // Field is visible, hide it
        config.hiddenFieldIds.push(fieldId);
    }

    // Ensure field is in fieldOrder
    if (!config.fieldOrder.includes(fieldId)) {
        config.fieldOrder.push(fieldId);
    }

    await saveViewFieldConfig(currentTable, viewId, config);
    markViewDirty('hiddenFieldIds', config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    await renderTable();
}

// Move field up in order (optimized with DOM manipulation)
function moveFieldUp(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var idx = config.fieldOrder.indexOf(fieldId);
    if (idx > 0) {
        // Move column in DOM immediately (no full re-render)
        moveColumnInDOM(idx, idx - 1);

        // Swap with previous in array
        var temp = config.fieldOrder[idx - 1];
        config.fieldOrder[idx - 1] = config.fieldOrder[idx];
        config.fieldOrder[idx] = temp;

        // Fast update: in-memory + debounced save
        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();
    }
}

// Move field down in order (optimized with DOM manipulation)
function moveFieldDown(fieldId) {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var idx = config.fieldOrder.indexOf(fieldId);
    if (idx >= 0 && idx < config.fieldOrder.length - 1) {
        // Move column in DOM immediately (no full re-render)
        moveColumnInDOM(idx, idx + 1);

        // Swap with next in array
        var temp = config.fieldOrder[idx + 1];
        config.fieldOrder[idx + 1] = config.fieldOrder[idx];
        config.fieldOrder[idx] = temp;

        // Fast update: in-memory + debounced save
        updateFieldOrderFast(currentTable, viewId, config.fieldOrder);
        renderFieldsDropdown();
    }
}

// Show all fields
async function showAllFields() {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var fields = META_FIELDS[currentTable] || {};
    var allFieldIds = Object.keys(fields);

    var config = getViewFieldConfig(currentTable, viewId);
    config.hiddenFieldIds = []; // Clear all hidden fields

    // Ensure all fields are in fieldOrder
    for (var fid of allFieldIds) {
        if (!config.fieldOrder.includes(fid)) {
            config.fieldOrder.push(fid);
        }
    }

    await saveViewFieldConfig(currentTable, viewId, config);
    markViewDirty('hiddenFieldIds', config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    await renderTable();
}

// Hide all fields (except keep at least one visible)
async function hideAllFields() {
    if (!currentTable) return;
    var viewId = currentView || '_default';
    var fields = META_FIELDS[currentTable] || {};
    var allFieldIds = Object.keys(fields);

    var config = getViewFieldConfig(currentTable, viewId);

    // Get all fields in order, keep the first one visible
    var orderedFields = getAllFieldsInOrder(currentTable, viewId);
    var firstField = orderedFields[0] || allFieldIds[0];

    // Hide all fields except the first one
    config.hiddenFieldIds = allFieldIds.filter(fid => fid !== firstField);

    await saveViewFieldConfig(currentTable, viewId, config);
    markViewDirty('hiddenFieldIds', config.hiddenFieldIds);
    renderFieldsDropdown();
    updateFieldsCount();
    await renderTable();
}

function getLocalStats() {
    return new Promise(async (resolve) => {
        try {
            var tempDb = await openDB();
            var count = await new Promise((res, rej) => {
                var tx = tempDb.transaction('data', 'readonly');
                var req = tx.objectStore('data').count();
                req.onsuccess = () => res(req.result);
                req.onerror = () => res(0);
            });
            var lastTimestamp = await new Promise((res, rej) => {
                var tx = tempDb.transaction('sync', 'readonly');
                var req = tx.objectStore('sync').get('lastEventTimestamp');
                req.onsuccess = () => res(req.result ? req.result.value : null);
                req.onerror = () => res(null);
            });
            tempDb.close();
            resolve({ count, lastTimestamp });
        } catch (e) {
            resolve({ count: 0, lastTimestamp: null });
        }
    });
}

// ============ Auth ============

document.getElementById('auth-submit').onclick = tryAuth;
document.getElementById('api-key-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('set-filter-input').onkeydown = (e) => { if (e.key === 'Enter') tryAuth(); };
document.getElementById('auth-clear').onclick = clearLocalAndReset;
document.getElementById('connect-api-key-input').onkeydown = (e) => { if (e.key === 'Enter') submitConnectApi(); };
document.getElementById('connect-api-set-filter').onkeydown = (e) => { if (e.key === 'Enter') submitConnectApi(); };

async function initAuthScreen() {
    var stats = await getLocalStats();
    var infoEl = document.getElementById('auth-info');
    var clearBtn = document.getElementById('auth-clear');

    if (stats.count > 0) {
        infoEl.textContent = 'Local cache: ' + stats.count.toLocaleString() + ' records';
        clearBtn.classList.remove('hidden');
    } else {
        infoEl.textContent = 'No local data';
        clearBtn.classList.add('hidden');
    }

    // Check for saved credentials and auto-authenticate (encrypted or plaintext)
    var savedCredentials = await loadEncryptedCredentials();

    // Pre-fill input fields with saved credentials
    if (savedCredentials && savedCredentials.apiKey) {
        document.getElementById('api-key-input').value = savedCredentials.apiKey;
    }
    if (savedCredentials && savedCredentials.setFilter) {
        document.getElementById('set-filter-input').value = savedCredentials.setFilter;
    }

    if (savedCredentials && savedCredentials.apiKey) {
        // Auto-login without showing auth screen
        API_KEY = savedCredentials.apiKey;
        SET_FILTER = savedCredentials.setFilter || null;

        try {
            await init();
            return; // Success - auth screen stays hidden
        } catch (err) {
            console.error('Auto-login failed:', err);
            API_KEY = null;
            SET_FILTER = null;
            // Show auth screen with error so user can retry
            showAuthError('Connection failed. Click Connect to retry.');
            if (stats.count > 0) {
                infoEl.textContent = 'Local cache: ' + stats.count.toLocaleString() + ' records';
            } else {
                infoEl.textContent = 'No local data';
            }
        }
    }

    // No saved credentials or auto-login failed - show auth screen
    var authEl = document.getElementById('auth-screen');
    authEl.classList.remove('hidden', 'fading-out');
}

async function clearLocalAndReset() {
    if (!confirm('Clear all local data?')) return;
    try {
        db = await openDB();
        await clearAllData();
        db.close();
        db = null;
    } catch (e) {
        console.error('Clear error:', e);
    }
    initAuthScreen();
}

async function tryAuth() {
    var key = document.getElementById('api-key-input').value.trim();
    if (!key) {
        showAuthError('Please enter an API key');
        return;
    }

    var btn = document.getElementById('auth-submit');
    btn.textContent = 'Connecting...';
    btn.disabled = true;
    document.getElementById('auth-error').style.display = 'none';

    API_KEY = key;
    SET_FILTER = document.getElementById('set-filter-input').value.trim() || null;

    try {
        await init();
    } catch (err) {
        console.error('Init error:', err);
        showAuthError('Connection failed: ' + err.message);
        btn.textContent = 'Connect';
        btn.disabled = false;
        API_KEY = null;
        SET_FILTER = null;
        return;
    }

    // Save credentials (encrypted if encryption is enabled)
    await saveEncryptedCredentials(API_KEY, SET_FILTER);

    btn.textContent = 'Connect';
    btn.disabled = false;
}

function showAuthError(msg) {
    var el = document.getElementById('auth-error');
    el.textContent = msg;
    el.style.display = 'block';
}

function hideAuthScreen() {
    var el = document.getElementById('auth-screen');
    el.classList.add('fading-out');
    el.addEventListener('transitionend', function handler() {
        el.removeEventListener('transitionend', handler);
        el.classList.add('hidden');
        el.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    setTimeout(function() { el.classList.add('hidden'); el.classList.remove('fading-out'); }, 400);
}

function showAuthScreen() {
    var el = document.getElementById('auth-screen');
    el.classList.remove('hidden', 'fading-out');
    if (pollInterval) clearInterval(pollInterval);
    SyncHistory.stopPolling();
    initAuthScreen();
}

function logout() {
    if (pollInterval) clearInterval(pollInterval);
    SyncHistory.stopPolling();
    API_KEY = null;
    SET_FILTER = null;
    // Clear saved credentials (both encrypted and plaintext)
    clearEncryptedCredentials();
    clearSessionKey();
    showAuthScreen();
}

async function manualSync() {
    if (!API_KEY) {
        showConnectApiModal();
        return;
    }
    await incrementalSync();
}

// Skip auth and go directly to CSV upload
async function skipAuthAndUploadCSV() {
    // Hide auth screen and show the app without an API key
    hideAuthScreen();

    // Initialize the database and app state
    META_TABLES = {};
    META_FIELDS = {};
    META_VIEWS = {};
    TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
    currentTable = null;
    currentPage = 0;
    currentRecordIds = [];
    originalRecordIds = [];
    totalRecords = 0;
    lastEventTimestamp = null;

    loadSidebarState();
    initSidebarSearch();

    db = await openDB();
    appOpenedEventId = await getMaxEventId();

    // Load any existing local data
    var tables = await getAllTables();
    var fields = await getAllFields();
    var views = await getAllViews();

    tables.forEach(t => META_TABLES[t.tableId] = t);
    fields.forEach(f => {
        if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
        META_FIELDS[f.tableId][f.fieldId] = f;
    });
    views.forEach(v => {
        if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
        META_VIEWS[v.tableId][v.viewId] = v;
    });

    await loadTableSettings();
    updateConnectApiButton();

    // Trigger the CSV file upload
    skipSetupAndUploadFile();
}

// Show/hide the Connect API button based on API_KEY state
function updateConnectApiButton() {
    var btn = document.getElementById('connect-api-btn');
    if (btn) {
        btn.style.display = API_KEY ? 'none' : '';
    }
}

// Connect API modal functions
function showConnectApiModal() {
    var modal = document.getElementById('connect-api-modal');
    modal.style.display = 'flex';
    document.getElementById('connect-api-key-input').value = '';
    document.getElementById('connect-api-set-filter').value = '';
    document.getElementById('connect-api-error').style.display = 'none';
    document.getElementById('connect-api-key-input').focus();
}

function hideConnectApiModal() {
    document.getElementById('connect-api-modal').style.display = 'none';
}

async function submitConnectApi() {
    var key = document.getElementById('connect-api-key-input').value.trim();
    if (!key) {
        var errEl = document.getElementById('connect-api-error');
        errEl.textContent = 'Please enter an API key';
        errEl.style.display = 'block';
        return;
    }

    var btn = document.getElementById('connect-api-submit');
    btn.textContent = 'Connecting...';
    btn.disabled = true;
    document.getElementById('connect-api-error').style.display = 'none';

    API_KEY = key;
    SET_FILTER = document.getElementById('connect-api-set-filter').value.trim() || null;

    try {
        // Test the connection with a lightweight check
        var testResult = await fetchPage(1, null, { last: true });

        // Save credentials
        await saveEncryptedCredentials(API_KEY, SET_FILTER);

        // Hide modal and update UI
        hideConnectApiModal();
        updateConnectApiButton();

        // Start syncing
        updateStatus('Connected! Syncing...', false, null, null);
        await incrementalSync();

        if (pollInterval) clearInterval(pollInterval);
        pollInterval = setInterval(incrementalSync, 60000);
        SyncHistory.startPolling();

        updateStatus('Up to date', true, null, null);
    } catch (err) {
        console.error('Connect API failed:', err);
        var errEl = document.getElementById('connect-api-error');
        errEl.textContent = 'Connection failed: ' + err.message;
        errEl.style.display = 'block';
        API_KEY = null;
        SET_FILTER = null;
    }

    btn.textContent = 'Connect';
    btn.disabled = false;
}

// ============ Data Processing ============

function parsePayload(payload) {
    if (typeof payload === 'string') {
        try { return JSON.parse(payload); } catch { return null; }
    }
    return payload;
}

// Infer field type from a sample value (used for auto-discovered fields)
function inferFieldType(value) {
    if (value === null || value === undefined) return 'unknown';
    if (Array.isArray(value)) {
        // Check if it's an attachment array (objects with url property)
        if (value.length > 0 && typeof value[0] === 'object' && value[0].url) {
            return 'multipleAttachments';
        }
        // Check if it's a linked record array (strings starting with 'rec')
        if (value.length > 0 && typeof value[0] === 'string' && value[0].startsWith('rec')) {
            return 'multipleRecordLinks';
        }
        return 'multipleSelects';
    }
    if (typeof value === 'object') {
        // Could be a single attachment or other complex type
        if (value.url) return 'multipleAttachments';
        return 'object';
    }
    if (typeof value === 'number') {
        return Number.isInteger(value) ? 'number' : 'number';
    }
    if (typeof value === 'boolean') return 'checkbox';
    if (typeof value === 'string') {
        // Try to detect dates
        if (/^\d{4}-\d{2}-\d{2}/.test(value)) return 'date';
        // Try to detect emails
        if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) return 'email';
        // Try to detect URLs
        if (/^https?:\/\//.test(value)) return 'url';
        return 'singleLineText';
    }
    return 'unknown';
}

// Fast in-memory event processing for CSV import - skips IndexedDB entirely
// Calls onProgress periodically for UI updates
async function processEventsMemoryOnly(events, onProgress) {
    if (!events || !Array.isArray(events)) return;

    var tableDataMap = {}; // tableId -> { recordId -> fields }
    var total = events.length;

    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;

        if (recordType === 'table') {
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else if (recordType === 'viewConfig') {
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) {
                META_VIEWS[tableId][viewId] = { tableId, viewId };
            }
            var viewData = META_VIEWS[tableId][viewId];
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.hiddenFieldIds) viewData.hiddenFieldIds = payload.hiddenFieldIds;
            if (payload.fieldOrder) viewData.fieldOrder = payload.fieldOrder;
            if (payload.filters) viewData.filters = payload.filters;
            if (payload.sorts) viewData.sorts = payload.sorts;
            if (payload.folderId !== undefined) viewData.folderId = payload.folderId;

        } else if (recordType === 'tableSettings') {
            // User-specific table and view settings
            if (payload.tables) TABLE_SETTINGS.tables = payload.tables;
            if (payload.tableOrder) TABLE_SETTINGS.tableOrder = payload.tableOrder;
            if (payload.views) TABLE_SETTINGS.views = payload.views;

        } else {
            // Data record
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            // Auto-create placeholder table
            if (!META_TABLES[tableId]) {
                META_TABLES[tableId] = {
                    tableId: tableId,
                    tableName: tableId,
                    _placeholder: true
                };
            }

            // Auto-create placeholder fields
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            var allFieldIds = [
                ...Object.keys(pfields.INS || {}),
                ...Object.keys(pfields.ALT || {}),
                ...(Array.isArray(pfields.NUL) ? pfields.NUL : [])
            ];
            for (var fid of allFieldIds) {
                if (!META_FIELDS[tableId][fid]) {
                    var sampleValue = (pfields.INS && pfields.INS[fid]) || (pfields.ALT && pfields.ALT[fid]);
                    META_FIELDS[tableId][fid] = {
                        tableId: tableId,
                        fieldId: fid,
                        fieldName: fid,
                        fieldType: inferFieldType(sampleValue),
                        _placeholder: true
                    };
                }
            }

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) tableDataMap[tableId][recordId] = {};

            var state = tableDataMap[tableId][recordId];
            if (pfields.INS) Object.assign(state, pfields.INS);
            if (pfields.ALT) Object.assign(state, pfields.ALT);
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => delete state[fieldId]);
            }
        }

        // Report progress and yield to UI every 5000 events
        if (i > 0 && i % 5000 === 0) {
            if (onProgress) onProgress(i, total, Object.keys(META_TABLES).length);
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Store data records in a memory-only snapshot (for showing table data)
    // Structure: IN_MEMORY_DATA[tableId][recordId] = { fields }
    window.IN_MEMORY_DATA = tableDataMap;

    if (onProgress) onProgress(total, total, Object.keys(META_TABLES).length);
}

async function processEvents(events) {
    if (!events || !Array.isArray(events)) return;

    var tables = [];
    var fields = [];
    var views = [];
    var dataRecords = [];
    var fieldHistoryEntries = [];
    var tableDataMap = {}; // tableId -> { recordId -> fields }

    // Pre-load existing record states from IndexedDB for accurate history oldValue tracking
    // First pass: collect all unique [tableId, recordId] pairs for data records
    var recordsToLoad = {}; // tableId -> Set of recordIds
    for (var e of events) {
        if (!e || !e.set || !e.recordId) continue;
        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;
        var recordType = payload._set;
        // Only load state for data records (not table/field/view metadata)
        if (recordType !== 'table' && recordType !== 'field' && recordType !== 'view') {
            var tableId = e.set.replace('airtable:', '');
            if (!recordsToLoad[tableId]) recordsToLoad[tableId] = new Set();
            recordsToLoad[tableId].add(e.recordId);
        }
    }

    // Load existing records from IndexedDB
    for (var tableId in recordsToLoad) {
        var recordIds = Array.from(recordsToLoad[tableId]);
        if (recordIds.length > 0) {
            var existingRecords = await getRecordsByIds(tableId, recordIds);
            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            for (var rec of existingRecords) {
                // Pre-populate with existing field values
                tableDataMap[tableId][rec.recordId] = { ...rec.fields };
            }
        }
    }

    for (var e of events) {
        if (!e || !e.set || !e.recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var recordType = payload._set;
        var setName = e.set;
        var recordId = e.recordId;
        var eventId = e.id;
        var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

        if (recordType === 'table') {
            // Tables: recordId starts with "tbl", set points to base
            var tableId = recordId;
            var tableData = { tableId };
            applyPayloadFields(tableData, payload);
            if (payload.tableName) tableData.tableName = payload.tableName;
            if (payload.primaryFieldId) tableData.primaryFieldId = payload.primaryFieldId;
            if (payload.tableId) tableData.tableId = payload.tableId;
            tables.push(tableData);
            META_TABLES[tableId] = tableData;

        } else if (recordType === 'field') {
            // Fields: recordId starts with "fld", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var fieldId = recordId;
            var fieldData = { tableId, fieldId };
            applyPayloadFields(fieldData, payload);
            if (payload.fieldName) fieldData.fieldName = payload.fieldName;
            if (payload.fieldType) fieldData.fieldType = payload.fieldType;
            if (payload.fieldId) fieldData.fieldId = payload.fieldId;
            if (payload.options) fieldData.options = payload.options;
            fields.push(fieldData);
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            META_FIELDS[tableId][fieldId] = fieldData;

        } else if (recordType === 'view') {
            // Views: recordId starts with "viw", set points to table
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;
            var viewData = { tableId, viewId };
            applyPayloadFields(viewData, payload);
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.viewType) viewData.viewType = payload.viewType;
            if (payload.viewId) viewData.viewId = payload.viewId;
            views.push(viewData);
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            META_VIEWS[tableId][viewId] = viewData;

        } else if (recordType === 'viewConfig') {
            // View configuration updates: hiddenFieldIds, fieldOrder, filters, sorts
            var tableId = payload.tableId || setName.replace('airtable:', '');
            var viewId = recordId;

            // Initialize META_VIEWS if needed
            if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
            if (!META_VIEWS[tableId][viewId]) {
                META_VIEWS[tableId][viewId] = { tableId, viewId };
            }

            // Update the view with config data
            var viewData = META_VIEWS[tableId][viewId];
            if (payload.viewName) viewData.viewName = payload.viewName;
            if (payload.hiddenFieldIds) viewData.hiddenFieldIds = payload.hiddenFieldIds;
            if (payload.fieldOrder) viewData.fieldOrder = payload.fieldOrder;
            if (payload.filters) viewData.filters = payload.filters;
            if (payload.sorts) viewData.sorts = payload.sorts;
            if (payload.folderId !== undefined) viewData.folderId = payload.folderId;

            views.push(viewData);

        } else if (recordType === 'tableSettings') {
            // User-specific table and view settings
            if (payload.tables) TABLE_SETTINGS.tables = payload.tables;
            if (payload.tableOrder) TABLE_SETTINGS.tableOrder = payload.tableOrder;
            if (payload.views) TABLE_SETTINGS.views = payload.views;

        } else {
            // Data record: recordId starts with "rec"
            var tableId = setName.replace('airtable:', '');
            var pfields = payload.fields;
            if (!pfields || typeof pfields !== 'object') continue;

            // Auto-create placeholder table if not seen yet (will be updated when real metadata arrives)
            if (!META_TABLES[tableId]) {
                var placeholderTable = {
                    tableId: tableId,
                    tableName: tableId,  // Use ID as placeholder name
                    _placeholder: true   // Mark as placeholder for later update
                };
                META_TABLES[tableId] = placeholderTable;
                tables.push(placeholderTable);
            }

            // Auto-create placeholder fields from INS/ALT/NUL keys
            if (!META_FIELDS[tableId]) META_FIELDS[tableId] = {};
            var allFieldIds = [
                ...Object.keys(pfields.INS || {}),
                ...Object.keys(pfields.ALT || {}),
                ...(Array.isArray(pfields.NUL) ? pfields.NUL : [])
            ];
            for (var fid of allFieldIds) {
                if (!META_FIELDS[tableId][fid]) {
                    // Get a sample value to infer type
                    var sampleValue = (pfields.INS && pfields.INS[fid]) || (pfields.ALT && pfields.ALT[fid]);
                    var placeholderField = {
                        tableId: tableId,
                        fieldId: fid,
                        fieldName: fid,  // Use ID as placeholder name
                        fieldType: inferFieldType(sampleValue),
                        _placeholder: true  // Mark as placeholder for later update
                    };
                    META_FIELDS[tableId][fid] = placeholderField;
                    fields.push(placeholderField);
                }
            }

            if (!tableDataMap[tableId]) tableDataMap[tableId] = {};
            if (!tableDataMap[tableId][recordId]) {
                // Initialize new record (existing records pre-loaded above)
                tableDataMap[tableId][recordId] = {};
            }

            var state = tableDataMap[tableId][recordId];

            // Default first ALT as INS: if record state is empty (new record) and
            // there's no INS but there IS ALT, promote ALT to INS
            if (Object.keys(state).length === 0 && !pfields.INS && pfields.ALT) {
                pfields = { INS: pfields.ALT, NUL: pfields.NUL };
            }

            // Capture field history for INS (insert/create)
            if (pfields.INS) {
                for (var fieldId in pfields.INS) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'created',
                        oldValue: null,
                        newValue: pfields.INS[fieldId]
                    });
                }
                Object.assign(state, pfields.INS);
            }

            // Capture field history for ALT (alter/update)
            if (pfields.ALT) {
                for (var fieldId in pfields.ALT) {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'updated',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: pfields.ALT[fieldId]
                    });
                }
                Object.assign(state, pfields.ALT);
            }

            // Capture field history for NUL (nullify/delete)
            if (pfields.NUL && Array.isArray(pfields.NUL)) {
                pfields.NUL.forEach(fieldId => {
                    fieldHistoryEntries.push({
                        tableId: tableId,
                        recordId: recordId,
                        fieldId: fieldId,
                        eventId: eventId,
                        timestamp: timestamp,
                        changeType: 'deleted',
                        oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                        newValue: null
                    });
                    delete state[fieldId];
                });
            }
        }

        // Track the latest event timestamp for incremental sync
        if (e.created_at && (!lastEventTimestamp || e.created_at > lastEventTimestamp)) {
            lastEventTimestamp = e.created_at;
        }
    }

    // Convert tableDataMap to dataRecords array
    for (var tableId in tableDataMap) {
        for (var recordId in tableDataMap[tableId]) {
            dataRecords.push({
                tableId,
                recordId,
                fields: tableDataMap[tableId][recordId]
            });
        }
    }

    // Save batch
    if (tables.length || fields.length || views.length || dataRecords.length) {
        await saveBatch(tables, fields, views, dataRecords);
    }

    // Save field history
    if (fieldHistoryEntries.length) {
        await saveFieldHistory(fieldHistoryEntries);
    }

    // Save raw events for Events view
    await saveRawEvents(events);
}

function applyPayloadFields(target, payload) {
    if (!payload.fields) return;
    var fields = payload.fields;
    if (fields.INS) Object.assign(target, fields.INS);
    if (fields.ALT) Object.assign(target, fields.ALT);
    if (fields.NUL && Array.isArray(fields.NUL)) {
        fields.NUL.forEach(k => delete target[k]);
    }
}

// ============ UI ============

async function renderSidebar() {
    var tableList = document.getElementById('table-list');
    tableList.innerHTML = '';

    // Get all tables
    var tables = await getAllTables();

    // Also get tables from META_TABLES (in-memory from current session)
    for (var tid in META_TABLES) {
        if (!tables.find(t => t.tableId === tid)) {
            tables.push(META_TABLES[tid]);
        }
    }

    // Get record counts for all tables (for count bar visualization)
    var tableCounts = {};
    var maxCount = 0;
    for (var table of tables) {
        var ids = await getRecordIdsForTable(table.tableId);
        tableCounts[table.tableId] = ids.length;
        if (ids.length > maxCount) maxCount = ids.length;
    }

    // Get events count
    var eventsCount = await getRawEventsCount();
    if (eventsCount > maxCount) maxCount = eventsCount;

    // Filter tables by search query
    var searchQuery = SIDEBAR_STATE.searchQuery.toLowerCase().trim();
    var filteredTables = tables;
    if (searchQuery) {
        filteredTables = tables.filter(t => {
            var name = (t.tableName || t.tableId || '').toLowerCase();
            return name.includes(searchQuery);
        });
    }

    // Group tables by type
    var groupedTables = {
        operational: [],
        collection: [],
        reference: [],
        dev: []
    };

    filteredTables.forEach(table => {
        var tableName = table.tableName || table.tableId;
        var type = getTableType(tableName);
        // Map 'events' type to operational
        if (type === 'events') type = 'operational';
        if (groupedTables[type]) {
            groupedTables[type].push(table);
        } else {
            groupedTables.operational.push(table);
        }
    });

    // Sort each group alphabetically
    Object.keys(groupedTables).forEach(type => {
        groupedTables[type].sort((a, b) => (a.tableName || a.tableId).localeCompare(b.tableName || b.tableId));
    });

    // Helper to render a table item
    function renderTableItem(table, showExpandArrow = true) {
        var tableId = table.tableId;
        var tableName = table.tableName || tableId;
        var type = getTableType(tableName);
        var config = TABLE_TYPE_CONFIG[type] || TABLE_TYPE_CONFIG.operational;
        var count = tableCounts[tableId] || 0;
        var isPinned = SIDEBAR_STATE.pinnedTables.includes(tableId);
        var isActive = tableId === currentTable;
        var barWidth = Math.round(getCountBarWidth(count, maxCount) * 20);

        var wrapper = document.createElement('div');
        wrapper.className = 'table-wrapper';
        wrapper.setAttribute('data-table-id', tableId);

        var div = document.createElement('div');
        div.className = 'table-item' + (isActive ? ' active expanded' : '');
        div.style.cssText = isActive ? '--active-color: ' + config.color + ';' : '';

        // Set the ::before background color for active state
        if (isActive) {
            div.style.setProperty('--type-color', config.color);
        }

        div.innerHTML =
            '<span class="table-icon type-' + type + '">' + config.icon + '</span>' +
            '<span class="table-name">' + esc(tableName) + '</span>' +
            '<button class="pin-btn' + (isPinned ? ' pinned' : '') + '" onclick="toggleTablePin(\'' + esc(tableId) + '\', event)" title="' + (isPinned ? 'Unpin' : 'Pin') + '">' +
                (isPinned ? SIDEBAR_ICONS.starFilled : SIDEBAR_ICONS.star) +
            '</button>' +
            '<span class="count-bar-wrapper">' +
                '<span class="count-bar" style="width: ' + barWidth + 'px; background: ' + config.color + ';"></span>' +
                '<span class="count-value" style="color: ' + config.color + ';">' + formatRecordCount(count) + '</span>' +
            '</span>' +
            (showExpandArrow ? '<span class="expand-arrow">&#9654;</span>' : '');

        div.oncontextmenu = ((t) => (e) => {
            showTableContextMenu(e, t);
        })(tableId);

        div.onclick = ((t) => (e) => {
            // Don't toggle if clicking pin button
            if (e.target.closest('.pin-btn')) return;
            toggleTableViews(t, e);
        })(tableId);

        wrapper.appendChild(div);

        // Create views list container
        var viewsList = document.createElement('div');
        viewsList.className = 'table-views-list' + (isActive ? ' expanded' : '');
        viewsList.id = 'views-list-' + tableId;
        viewsList.innerHTML = '<div class="table-view-item loading" style="color: #6b7280; font-style: italic;">Loading views...</div>';
        wrapper.appendChild(viewsList);

        return wrapper;
    }

    // Helper to render a section header
    function renderSectionHeader(sectionId, title, icon, color, count) {
        var isExpanded = SIDEBAR_STATE.expandedSections[sectionId];
        var header = document.createElement('div');
        header.className = 'sidebar-section-header' + (isExpanded ? '' : ' collapsed');
        header.innerHTML =
            SIDEBAR_ICONS.chevronDown +
            '<span class="section-icon" style="color: ' + color + ';">' + icon + '</span>' +
            '<span>' + title + '</span>' +
            '<span class="section-count">' + count + '</span>';
        header.onclick = () => toggleSidebarSection(sectionId);
        return header;
    }

    // If not searching, show pinned and recent sections
    if (!searchQuery) {
        // Events Stream (always at top)
        var eventsWrapper = document.createElement('div');
        eventsWrapper.className = 'table-wrapper';
        eventsWrapper.setAttribute('data-table-id', '_events');

        var eventsDiv = document.createElement('div');
        eventsDiv.className = 'table-item events-item' + (currentTable === '_events' ? ' active' : '');
        var eventsBarWidth = Math.round(getCountBarWidth(eventsCount, maxCount) * 20);
        eventsDiv.innerHTML =
            '<span class="table-icon type-events">' + TABLE_TYPE_CONFIG.events.icon + '</span>' +
            '<span class="table-name">Events Stream</span>' +
            '<span class="count-bar-wrapper">' +
                '<span class="count-bar" style="width: ' + eventsBarWidth + 'px; background: ' + TABLE_TYPE_CONFIG.events.color + ';"></span>' +
                '<span class="count-value" style="color: ' + TABLE_TYPE_CONFIG.events.color + ';">' + formatRecordCount(eventsCount) + '</span>' +
            '</span>';
        eventsDiv.onclick = () => showEventsView();
        eventsWrapper.appendChild(eventsDiv);
        tableList.appendChild(eventsWrapper);

        // Sync Status (below Events Stream)
        var syncStatusWrapper = document.createElement('div');
        syncStatusWrapper.className = 'table-wrapper';
        syncStatusWrapper.setAttribute('data-table-id', '_sync_status');

        var syncStatusDiv = document.createElement('div');
        syncStatusDiv.className = 'table-item sync-status-item' + (currentTable === '_sync_status' ? ' active' : '');
        syncStatusDiv.innerHTML =
            '<span class="table-icon type-sync-status">' + TABLE_TYPE_CONFIG.syncStatus.icon + '</span>' +
            '<span class="table-name">Sync Status</span>';
        syncStatusDiv.onclick = () => showSyncStatusView();
        syncStatusWrapper.appendChild(syncStatusDiv);
        tableList.appendChild(syncStatusWrapper);

        // Pinned Section
        var pinnedTables = tables.filter(t => SIDEBAR_STATE.pinnedTables.includes(t.tableId));
        if (pinnedTables.length > 0) {
            tableList.appendChild(renderSectionHeader('pinned', 'Pinned', SIDEBAR_ICONS.starFilled, '#fbbf24', pinnedTables.length));
            if (SIDEBAR_STATE.expandedSections.pinned) {
                pinnedTables.forEach(table => {
                    tableList.appendChild(renderTableItem(table));
                    loadTableViewsAsync(table.tableId);
                });
            }
        }

        // Recent Section
        var recentTables = SIDEBAR_STATE.recentTables
            .filter(id => !SIDEBAR_STATE.pinnedTables.includes(id))
            .map(id => tables.find(t => t.tableId === id))
            .filter(t => t);
        if (recentTables.length > 0) {
            tableList.appendChild(renderSectionHeader('recent', 'Recent', SIDEBAR_ICONS.clock, '#9ca3af', recentTables.length));
            if (SIDEBAR_STATE.expandedSections.recent) {
                recentTables.forEach(table => {
                    tableList.appendChild(renderTableItem(table));
                    loadTableViewsAsync(table.tableId);
                });
            }
        }

        // Divider
        if (pinnedTables.length > 0 || recentTables.length > 0) {
            var divider = document.createElement('div');
            divider.className = 'sidebar-divider';
            tableList.appendChild(divider);
        }
    }

    // Grouped Sections
    var sectionConfig = [
        { id: 'operational', key: 'operational', label: 'Operational', color: '#3b82f6' },
        { id: 'collections', key: 'collection', label: 'Collections', color: '#8b5cf6' },
        { id: 'reference', key: 'reference', label: 'Reference', color: '#10b981' },
        { id: 'dev', key: 'dev', label: 'Dev / Testing', color: '#6b7280' }
    ];

    sectionConfig.forEach(section => {
        var sectionTables = groupedTables[section.key] || [];
        // When searching, show all matching tables; otherwise filter out pinned from main sections
        if (!searchQuery) {
            sectionTables = sectionTables.filter(t => !SIDEBAR_STATE.pinnedTables.includes(t.tableId));
        }
        if (sectionTables.length === 0 && searchQuery) return;
        if (sectionTables.length === 0 && !SIDEBAR_STATE.expandedSections[section.id]) return;

        var config = TABLE_TYPE_CONFIG[section.key] || TABLE_TYPE_CONFIG.operational;
        tableList.appendChild(renderSectionHeader(section.id, section.label, config.icon, section.color, sectionTables.length));

        if (SIDEBAR_STATE.expandedSections[section.id] || searchQuery) {
            sectionTables.forEach(table => {
                tableList.appendChild(renderTableItem(table));
                loadTableViewsAsync(table.tableId);
            });
        }
    });

    // Update active indicator color via CSS variable
    document.querySelectorAll('.sidebar .table-item.active').forEach(el => {
        var tableId = el.closest('.table-wrapper')?.getAttribute('data-table-id');
        if (tableId && tableId !== '_events') {
            var table = tables.find(t => t.tableId === tableId);
            if (table) {
                var type = getTableType(table.tableName || table.tableId);
                var config = TABLE_TYPE_CONFIG[type] || TABLE_TYPE_CONFIG.operational;
                el.style.setProperty('--before-bg', config.color);
                // Also update the ::before pseudo element
                var styleId = 'active-indicator-' + tableId.replace(/[^a-z0-9]/gi, '');
                var existingStyle = document.getElementById(styleId);
                if (existingStyle) existingStyle.remove();
                var style = document.createElement('style');
                style.id = styleId;
                style.textContent = '.table-wrapper[data-table-id="' + tableId + '"] .table-item.active::before { background: ' + config.color + ' !important; }';
                document.head.appendChild(style);
            }
        }
    });
}

// Load views for a table and populate the views list
async function loadTableViewsAsync(tableId) {
    var viewsList = document.getElementById('views-list-' + tableId);
    if (!viewsList) return;

    var views = await getViewsForTable(tableId);
    var folders = await getFoldersForTable(tableId);

    // Cache views in META_VIEWS
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

    // Cache folders in VIEW_FOLDERS
    if (!VIEW_FOLDERS[tableId]) VIEW_FOLDERS[tableId] = {};
    folders.forEach(f => VIEW_FOLDERS[tableId][f.folderId] = f);

    var html = '';

    // Add "All Fields" default option first
    var isDefaultActive = currentTable === tableId && (!currentView || currentView === '_default');
    html += '<div class="table-view-item' + (isDefaultActive ? ' active' : '') + '" onclick="selectTableView(\'' + esc(tableId) + '\', \'_default\')">' +
            '<span class="view-icon">&#9638;</span>' +
            '<span class="view-name table-view-default">All Fields</span>' +
            '</div>';

    // Group views by folder
    var viewsByFolder = { '_root': [] };
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    for (var vid of viewIds) {
        if (vid === '_default') continue;
        var view = META_VIEWS[tableId][vid];
        var folderId = view.folderId || '_root';
        if (!viewsByFolder[folderId]) viewsByFolder[folderId] = [];
        viewsByFolder[folderId].push(view);
    }

    // Render root-level views first
    for (var view of viewsByFolder['_root'] || []) {
        html += renderViewItem(tableId, view);
    }

    // Render folders and their views
    var folderIds = Object.keys(VIEW_FOLDERS[tableId] || {});
    folderIds.sort((a, b) => {
        var fa = VIEW_FOLDERS[tableId][a];
        var fb = VIEW_FOLDERS[tableId][b];
        return (fa.sortOrder || 0) - (fb.sortOrder || 0);
    });

    for (var fid of folderIds) {
        var folder = VIEW_FOLDERS[tableId][fid];
        var isExpanded = folder.isExpanded !== false;

        html += '<div class="table-view-folder' + (isExpanded ? ' expanded' : '') + '" data-folder-id="' + esc(fid) + '" onclick="toggleViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)">';
        html += '<span class="folder-icon">&#9654;</span>';
        html += '<span class="folder-name">&#128193; ' + esc(folder.folderName || 'Folder') + '</span>';
        html += '<span class="folder-actions">';
        html += '<button class="folder-action-btn" onclick="renameViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)" title="Rename">&#9998;</button>';
        html += '<button class="folder-action-btn" onclick="deleteViewFolder(\'' + esc(tableId) + '\', \'' + esc(fid) + '\', event)" title="Delete">&#128465;</button>';
        html += '</span>';
        html += '</div>';

        html += '<div class="folder-views-list' + (isExpanded ? ' expanded' : '') + '" id="folder-views-' + esc(fid) + '">';
        for (var view of viewsByFolder[fid] || []) {
            html += renderViewItem(tableId, view, true);
        }
        html += '</div>';
    }

    // Add "New view" button
    html += '<div class="table-view-add-btn" onclick="openCreateViewModal(\'' + esc(tableId) + '\')">';
    html += '<span class="add-icon">+</span>';
    html += '<span>New view</span>';
    html += '</div>';


    viewsList.innerHTML = html;
}

// Render a single view item
function renderViewItem(tableId, view, inFolder) {
    var isActive = currentTable === tableId && currentView === view.viewId;
    var viewName = view.viewName || view.viewId;
    var viewIcon = getViewTypeIcon(view.viewType);
    var paddingClass = inFolder ? ' style="padding-left: 52px;"' : '';

    return '<div class="table-view-item' + (isActive ? ' active' : '') + '"' + paddingClass + ' ' +
           'data-table-id="' + esc(tableId) + '" data-view-id="' + esc(view.viewId) + '" ' +
           'onclick="selectTableView(\'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'ondblclick="startViewRename(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'oncontextmenu="showViewContextMenu(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')">' +
           '<span class="view-icon">' + viewIcon + '</span>' +
           '<span class="view-name">' + esc(viewName) + '</span>' +
           '</div>';
}

// Toggle view folder expanded state
async function toggleViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var folder = VIEW_FOLDERS[tableId]?.[folderId];
    if (!folder) return;

    folder.isExpanded = !folder.isExpanded;
    await saveFolder(folder);

    // Update UI
    var folderEl = document.querySelector('.table-view-folder[data-folder-id="' + folderId + '"]');
    var viewsListEl = document.getElementById('folder-views-' + folderId);

    if (folderEl && viewsListEl) {
        if (folder.isExpanded) {
            folderEl.classList.add('expanded');
            viewsListEl.classList.add('expanded');
        } else {
            folderEl.classList.remove('expanded');
            viewsListEl.classList.remove('expanded');
        }
    }
}

// Create a new view folder
async function createViewFolder(tableId) {
    var folderName = prompt('Enter folder name:');
    if (!folderName) return;

    var folderId = 'vfld' + Date.now();
    var folder = {
        folderId: folderId,
        tableId: tableId,
        folderName: folderName,
        parentFolderId: null,
        sortOrder: Object.keys(VIEW_FOLDERS[tableId] || {}).length,
        isExpanded: true
    };

    await saveFolder(folder);
    if (!VIEW_FOLDERS[tableId]) VIEW_FOLDERS[tableId] = {};
    VIEW_FOLDERS[tableId][folderId] = folder;

    // Also sync to backend
    await saveFolderToBackend(folder, 'create');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Rename a view folder
async function renameViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    var folder = VIEW_FOLDERS[tableId]?.[folderId];
    if (!folder) return;

    var newName = prompt('Enter new folder name:', folder.folderName);
    if (!newName || newName === folder.folderName) return;

    folder.folderName = newName;
    await saveFolder(folder);

    // Sync to backend
    await saveFolderToBackend(folder, 'update');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Delete a view folder
async function deleteViewFolder(tableId, folderId, event) {
    event.stopPropagation();

    if (!confirm('Delete this folder? Views will be moved to the root level.')) return;

    // Move all views in this folder to root
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    for (var vid of viewIds) {
        var view = META_VIEWS[tableId][vid];
        if (view.folderId === folderId) {
            view.folderId = null;
            await saveView(view);
        }
    }

    // Delete the folder
    await deleteFolder(folderId);
    delete VIEW_FOLDERS[tableId][folderId];

    // Sync to backend
    await saveFolderToBackend({ folderId: folderId, tableId: tableId }, 'delete');

    // Refresh the views list
    await loadTableViewsAsync(tableId);
}

// Save folder to backend
async function saveFolderToBackend(folder, operator) {
    if (!API_KEY) return;
    var payload = {
        uuid: crypto.randomUUID(),
        recordId: folder.folderId,
        set: 'viewFolders',
        operator: operator,
        created_at: new Date().toISOString(),
        apiKey: API_KEY,
        payload: JSON.stringify(folder)
    };

    try {
        if (operator === 'NUL') {
            // For delete operations, post event and delete from snapshot
            await AminoSync.postEventWithSnapshot(payload, null);
            await AminoSync.deleteSnapshot(folder.folderId);
        } else {
            // For INS/ALT operations, post event and update snapshot
            await AminoSync.postEventWithSnapshot(payload, {
                source_table: 'viewFolders',
                data: folder
            });
        }
    } catch (error) {
        console.error('Failed to save folder to backend:', error);
    }
}

// View context menu state
var contextMenuViewId = null;
var contextMenuTableId = null;

// Show view context menu
function showViewContextMenu(event, tableId, viewId) {
    event.preventDefault();
    event.stopPropagation();

    contextMenuTableId = tableId;
    contextMenuViewId = viewId;

    var menu = document.getElementById('view-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close view context menu
function closeViewContextMenu() {
    var menu = document.getElementById('view-context-menu');
    menu.classList.remove('open');
    contextMenuViewId = null;
    contextMenuTableId = null;
}

// Table context menu state
var tableContextMenuTableId = null;

// Show table context menu
function showTableContextMenu(event, tableId) {
    event.preventDefault();
    event.stopPropagation();

    tableContextMenuTableId = tableId;

    var menu = document.getElementById('table-context-menu');
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    menu.classList.add('open');
}

// Close table context menu
function closeTableContextMenu() {
    var menu = document.getElementById('table-context-menu');
    menu.classList.remove('open');
    tableContextMenuTableId = null;
}

// Create view folder from table context menu
async function createViewFolderFromContextMenu() {
    if (!tableContextMenuTableId) return;
    var tableId = tableContextMenuTableId;
    closeTableContextMenu();
    await createViewFolder(tableId);

    // Ensure the table's views list is expanded so the user can see the new folder
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItem = wrapper.querySelector('.table-item');
        var viewsList = wrapper.querySelector('.table-views-list');
        if (tableItem && !tableItem.classList.contains('expanded')) {
            tableItem.classList.add('expanded');
        }
        if (viewsList && !viewsList.classList.contains('expanded')) {
            viewsList.classList.add('expanded');
        }
    }
}

// Move view to folder
async function moveViewToFolder() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var folders = VIEW_FOLDERS[contextMenuTableId] || {};
    var folderNames = Object.values(folders).map(f => f.folderName);

    var options = ['(Root level)', ...folderNames];
    var choice = prompt('Move to folder:\n' + options.map((n, i) => i + ': ' + n).join('\n') + '\n\nEnter number:');

    if (choice === null) {
        closeViewContextMenu();
        return;
    }

    var choiceIdx = parseInt(choice);
    if (isNaN(choiceIdx) || choiceIdx < 0 || choiceIdx >= options.length) {
        closeViewContextMenu();
        return;
    }

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    if (choiceIdx === 0) {
        view.folderId = null;
    } else {
        var folderIds = Object.keys(folders);
        view.folderId = folderIds[choiceIdx - 1];
    }

    await saveView(view);
    markViewDirty('folderId', view.folderId);

    closeViewContextMenu();
    await loadTableViewsAsync(contextMenuTableId);
}

// Start inline view rename (double-click)
function startViewRename(event, tableId, viewId) {
    event.preventDefault();
    event.stopPropagation();

    var view = META_VIEWS[tableId]?.[viewId];
    if (!view) return;

    var viewItem = event.currentTarget;
    var nameSpan = viewItem.querySelector('.view-name');
    if (!nameSpan) return;

    // Create input element
    var input = document.createElement('input');
    input.type = 'text';
    input.className = 'view-name-input';
    input.value = view.viewName || '';
    input.setAttribute('data-table-id', tableId);
    input.setAttribute('data-view-id', viewId);

    // Replace span with input
    nameSpan.style.display = 'none';
    nameSpan.parentNode.insertBefore(input, nameSpan.nextSibling);
    input.focus();
    input.select();

    // Handle blur and enter key
    input.addEventListener('blur', finishViewRename);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            input.value = view.viewName || '';
            input.blur();
        }
    });
    input.addEventListener('click', function(e) {
        e.stopPropagation();
    });
}

// Finish inline view rename
async function finishViewRename(event) {
    var input = event.target;
    var tableId = input.getAttribute('data-table-id');
    var viewId = input.getAttribute('data-view-id');
    var newName = input.value.trim();

    var view = META_VIEWS[tableId]?.[viewId];
    var nameSpan = input.previousElementSibling;

    // Restore the span
    if (nameSpan) {
        nameSpan.style.display = '';
    }
    input.remove();

    if (!view || !newName || newName === view.viewName) {
        return;
    }

    // Update the view name
    view.viewName = newName;
    await saveView(view);
    markViewDirty('viewName', newName);

    // Refresh the UI
    await loadTableViewsAsync(tableId);
    renderViewSelector();
}

// Rename view (from context menu)
async function renameView() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    closeViewContextMenu();

    // Find the view item and trigger inline rename
    var viewItem = document.querySelector('.table-view-item[data-view-id="' + contextMenuViewId + '"]');
    if (viewItem) {
        var fakeEvent = {
            preventDefault: function() {},
            stopPropagation: function() {},
            currentTarget: viewItem
        };
        startViewRename(fakeEvent, contextMenuTableId, contextMenuViewId);
    } else {
        // Fallback to prompt if element not found
        var newName = prompt('Enter new view name:', view.viewName);
        if (!newName || newName === view.viewName) {
            return;
        }
        view.viewName = newName;
        await saveView(view);
        markViewDirty('viewName', newName);
        await loadTableViewsAsync(contextMenuTableId);
        renderViewSelector();
    }
}

// Delete view
async function deleteView() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    if (!confirm('Delete this view?')) {
        closeViewContextMenu();
        return;
    }

    // Remove from META_VIEWS
    delete META_VIEWS[contextMenuTableId][contextMenuViewId];

    // Remove from IndexedDB
    await new Promise((resolve, reject) => {
        var tx = db.transaction('views', 'readwrite');
        tx.objectStore('views').delete([contextMenuTableId, contextMenuViewId]);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });

    // If current view was deleted, switch to default
    if (currentView === contextMenuViewId) {
        currentView = '_default';
        renderViewSelector();
        renderFieldsDropdown();
        updateFieldsCount();
        await renderTable();
    }

    closeViewContextMenu();
    await loadTableViewsAsync(contextMenuTableId);
}

// Manage view tags from context menu
async function manageViewTags() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    var currentTags = (view.tags || []).join(', ');
    var newTags = prompt('Enter tags (comma-separated):', currentTags);

    if (newTags !== null) {
        view.tags = newTags.split(',').map(t => t.trim()).filter(t => t);
        await saveView(view);
        markViewDirty('tags', view.tags);
        await loadTableViewsAsync(contextMenuTableId);
    }

    closeViewContextMenu();
}

// Add view to workspace from context menu
async function addViewToWorkspaceMenu() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var wsIds = Object.keys(WORKSPACES);

    if (wsIds.length === 0) {
        var name = prompt('No workspaces exist. Enter a name to create one:');
        if (name) {
            var wsId = await createWorkspace(name);
            await addViewToWorkspace(contextMenuViewId, wsId);
            renderWorkspaceTabs();
            await loadTableViewsAsync(contextMenuTableId);
        }
        closeViewContextMenu();
        return;
    }

    var options = wsIds.map((wid, i) => {
        var ws = WORKSPACES[wid];
        var inWs = ws.viewIds.includes(contextMenuViewId) ? ' [already added]' : '';
        return i + ': ' + ws.workspaceName + inWs;
    });
    options.push(wsIds.length + ': Create new workspace...');

    var choice = prompt('Add to workspace:\n' + options.join('\n') + '\n\nEnter number:');

    if (choice !== null) {
        var idx = parseInt(choice);
        if (idx >= 0 && idx < wsIds.length) {
            await addViewToWorkspace(contextMenuViewId, wsIds[idx]);
            renderWorkspaceTabs();
        } else if (idx === wsIds.length) {
            var name = prompt('Enter workspace name:');
            if (name) {
                var wsId = await createWorkspace(name);
                await addViewToWorkspace(contextMenuViewId, wsId);
                renderWorkspaceTabs();
            }
        }
    }

    closeViewContextMenu();
}

// Set parent view from context menu
async function setViewParent() {
    if (!contextMenuTableId || !contextMenuViewId) return;

    var view = META_VIEWS[contextMenuTableId]?.[contextMenuViewId];
    if (!view) {
        closeViewContextMenu();
        return;
    }

    var views = META_VIEWS[contextMenuTableId] || {};
    var options = ['0: (No parent - root level)'];
    var viewIds = [''];

    var idx = 1;
    for (var vid in views) {
        if (vid === '_default' || vid === contextMenuViewId) continue;
        var v = views[vid];
        options.push(idx + ': ' + (v.viewName || vid));
        viewIds.push(vid);
        idx++;
    }

    var choice = prompt('Set parent view (for nesting):\n' + options.join('\n') + '\n\nEnter number:');

    if (choice !== null) {
        var choiceIdx = parseInt(choice);
        if (choiceIdx >= 0 && choiceIdx < viewIds.length) {
            view.parentViewId = viewIds[choiceIdx] || null;
            await saveView(view);
            markViewDirty('parentViewId', view.parentViewId);
            await loadTableViewsAsync(contextMenuTableId);
        }
    }

    closeViewContextMenu();
}

// Open create view modal directly (not from default view protection)
function openCreateViewModal(tableId) {
    if (tableId) {
        // Temporarily switch context to the target table
        currentTable = tableId;
    }

    pendingViewAction = null;

    // Set the reason text
    var reasonEl = document.getElementById('create-view-reason');
    if (reasonEl) {
        reasonEl.textContent = 'Create a custom view with your own filters, sorting, and field configuration.';
    }

    // Set default view name
    var nameInput = document.getElementById('create-view-name');
    if (nameInput) {
        nameInput.value = generateDefaultViewName();
    }

    // Reset other fields
    document.getElementById('create-view-type').value = 'grid';
    document.getElementById('create-view-tags').value = '';

    // Populate parent view options
    populateParentViewOptions();

    // Populate workspace options
    populateWorkspaceOptions();

    // Show modal
    document.getElementById('create-view-modal').classList.add('open');

    // Focus name input
    setTimeout(() => nameInput?.focus(), 100);
}

// Close context menu on click outside
document.addEventListener('click', function() {
    closeViewContextMenu();
    closeTableContextMenu();
});

// Clean up state from special views (Events, Sync Status) before switching
function cleanupSpecialViewState() {
    // Clean up events view state
    expandedPayloads.clear();
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;
    if (eventsScrollHandler) {
        var container = document.querySelector('.table-container');
        if (container) container.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }

    // Clean up sync status listener
    if (syncStatusUnsubscribe) { syncStatusUnsubscribe(); syncStatusUnsubscribe = null; }

    // Restore view controls bar visibility
    var viewControlsBar = document.getElementById('view-controls-bar');
    if (viewControlsBar) viewControlsBar.style.display = '';
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = '';
}

// Toggle the expanded views list for a table
function toggleTableViews(tableId, event) {
    event.stopPropagation();

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (!wrapper) return;

    var tableItem = wrapper.querySelector('.table-item');
    var viewsList = wrapper.querySelector('.table-views-list');

    if (tableItem.classList.contains('expanded')) {
        // Collapse
        tableItem.classList.remove('expanded');
        viewsList.classList.remove('expanded');
    } else {
        // Expand
        tableItem.classList.add('expanded');
        viewsList.classList.add('expanded');

        // If clicking a different table, also load it with its default view
        if (currentTable !== tableId) {
            showTable(tableId);
        }
    }
}

// Select a view from the sidebar and show the table
async function selectTableView(tableId, viewId) {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Auto-save any pending changes before navigating
    await autoSaveBeforeNavigation();
    if (navVersion !== myNav) return; // Another navigation started, abort

    // Clean up any special view state (Events, Sync Status)
    cleanupSpecialViewState();

    // Update sidebar active states
    document.querySelectorAll('.table-item').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.table-view-item').forEach(el => el.classList.remove('active'));

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        wrapper.querySelector('.table-item').classList.add('active');
        // Find and mark the selected view as active
        var viewItems = wrapper.querySelectorAll('.table-view-item');
        viewItems.forEach(item => {
            var onclickAttr = item.getAttribute('onclick') || '';
            if (onclickAttr.includes("'" + viewId + "'")) {
                item.classList.add('active');
            }
        });
    }

    // If switching to a different table, load it first
    if (currentTable !== tableId) {
        currentTable = tableId;
        currentPage = 0;

        var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
        if (navVersion !== myNav) return;
        var tableName = table.tableName || tableId;
        document.getElementById('title').textContent = tableName;

        // Show loading state immediately
        showTableLoading('Loading table structure...');

        // Load fields first (table structure)
        var fields = await getFieldsForTable(tableId);
        if (navVersion !== myNav) return;
        META_FIELDS[tableId] = {};
        fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

        // Load views for this table
        var views = await getViewsForTable(tableId);
        if (navVersion !== myNav) return;
        META_VIEWS[tableId] = {};
        views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

        // Load record IDs
        originalRecordIds = await getRecordIdsForTable(tableId);
        if (navVersion !== myNav) return;
        currentRecordIds = originalRecordIds.slice();
        totalRecords = currentRecordIds.length;
    }

    // Set the current view
    currentView = viewId;

    // Load and apply view filters, sorts, and groupBy
    var viewConfig = getViewFiltersAndSorts(tableId, viewId);
    currentFilters = viewConfig.filters;
    currentSorts = viewConfig.sorts;
    currentGroupBy = viewConfig.groupBy;
    currentSearchQuery = ''; // Reset search when switching views

    // Update filter/sort/group button states
    updateFilterCount();
    updateSortCount();
    updateGroupButtonState();
    var searchInput = document.getElementById('view-search-input');
    if (searchInput) searchInput.value = '';

    // Render view selector and fields dropdown
    renderViewSelector();
    renderFieldsDropdown();
    updateFieldsCount();

    // Render the table
    await renderTable();
}

function updateStatus(msg, isSynced, progress, detail) {
    var dot = document.getElementById('status-dot');
    var text = document.getElementById('status-text');
    var progressBar = document.getElementById('progress-bar');
    var progressFill = document.getElementById('progress-fill');
    var statusDetail = document.getElementById('status-detail');

    dot.className = 'status-dot ' + (isSynced ? 'synced' : 'loading');
    text.textContent = msg;

    if (typeof progress === 'number' && progress >= 0) {
        progressBar.style.display = 'block';
        progressFill.style.width = Math.min(100, progress) + '%';
    } else {
        progressBar.style.display = 'none';
    }

    statusDetail.textContent = detail || '';
}

// ============ Loading Overlay ============

var refreshCountdownInterval = null;
var lastSyncTime = null;

function showLoadingOverlay() {
    var overlay = document.getElementById('loading-overlay');
    overlay.classList.remove('hidden', 'fading-out');
}

function hideLoadingOverlay() {
    var overlay = document.getElementById('loading-overlay');
    overlay.classList.add('fading-out');
    overlay.addEventListener('transitionend', function handler() {
        overlay.removeEventListener('transitionend', handler);
        overlay.classList.add('hidden');
        overlay.classList.remove('fading-out');
    }, { once: true });
    // Fallback in case transitionend doesn't fire
    setTimeout(function() { overlay.classList.add('hidden'); overlay.classList.remove('fading-out'); }, 500);
}

function updateLoadingOverlay(status, detail, progress, tables, fields, records, timeEstimate) {
    var statusEl = document.getElementById('loading-status');
    var detailEl = document.getElementById('loading-detail');
    var progressEl = document.getElementById('loading-progress-fill');
    var tablesEl = document.getElementById('loading-tables');
    var fieldsEl = document.getElementById('loading-fields');
    var recordsEl = document.getElementById('loading-records');
    var timeEl = document.getElementById('loading-time-estimate');

    if (statusEl) statusEl.textContent = status || 'Loading...';
    if (detailEl) detailEl.textContent = detail || '';
    if (progressEl) progressEl.style.width = Math.min(100, progress || 0) + '%';
    if (tablesEl) tablesEl.textContent = (tables || 0).toLocaleString();
    if (fieldsEl) fieldsEl.textContent = (fields || 0).toLocaleString();
    if (recordsEl) recordsEl.textContent = (records || 0).toLocaleString();
    if (timeEl) timeEl.textContent = timeEstimate || '';
}

function setRefreshIndicatorSyncing(isSyncing) {
    var indicator = document.getElementById('refresh-indicator');
    var textEl = document.getElementById('last-refresh-text');
    if (!indicator) return;

    if (isSyncing) {
        indicator.classList.add('syncing');
        textEl.textContent = 'Checking for updates...';
    } else {
        indicator.classList.remove('syncing');
        lastSyncTime = Date.now();
        startRefreshCountdown();
    }
}

function startRefreshCountdown() {
    if (refreshCountdownInterval) clearInterval(refreshCountdownInterval);

    var textEl = document.getElementById('last-refresh-text');
    if (!textEl) return;

    function updateCountdown() {
        var elapsed = Math.floor((Date.now() - lastSyncTime) / 1000);
        var remaining = Math.max(0, 60 - elapsed);

        if (remaining > 0) {
            textEl.textContent = 'Auto-refresh in ' + remaining + 's';
        } else {
            textEl.textContent = 'Refreshing soon...';
        }
    }

    updateCountdown();
    refreshCountdownInterval = setInterval(updateCountdown, 1000);
}

async function showTable(tableId) {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Auto-save any pending changes before switching tables
    await autoSaveBeforeNavigation();
    if (navVersion !== myNav) return;

    // Clean up special view state (Events, Sync Status)
    cleanupSpecialViewState();

    currentTable = tableId;
    currentView = null; // Reset view when switching tables
    currentPage = 0;

    // Track as recently accessed table
    addToRecentTables(tableId);

    // Reset search and other controls (filters/sorts will be loaded from view)
    if (typeof currentGroupBy !== 'undefined') currentGroupBy = null;
    if (typeof currentColorBy !== 'undefined') currentColorBy = null;
    if (typeof currentSearchQuery !== 'undefined') currentSearchQuery = '';

    // Reset non-filter/sort button states and search input
    var groupBtn = document.getElementById('group-btn');
    var colorBtn = document.getElementById('color-btn');
    var searchInput = document.getElementById('view-search-input');
    if (groupBtn) groupBtn.classList.remove('active');
    if (colorBtn) colorBtn.classList.remove('active');
    if (searchInput) searchInput.value = '';

    var table = META_TABLES[tableId] || (await getAllTables()).find(t => t.tableId === tableId) || {};
    if (navVersion !== myNav) return;
    var tableName = table.tableName || tableId;

    document.getElementById('title').textContent = tableName;

    // Update sidebar - expand the selected table and highlight it
    document.querySelectorAll('.table-item').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.table-view-item').forEach(el => el.classList.remove('active'));

    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (wrapper) {
        var tableItem = wrapper.querySelector('.table-item');
        var viewsList = wrapper.querySelector('.table-views-list');
        if (tableItem) {
            tableItem.classList.add('active', 'expanded');
        }
        if (viewsList) {
            viewsList.classList.add('expanded');
        }
    }

    // Show loading state immediately
    showTableLoading('Loading table structure...');

    // Load fields first (table structure)
    var fields = await getFieldsForTable(tableId);
    if (navVersion !== myNav) return;
    META_FIELDS[tableId] = {};
    fields.forEach(f => META_FIELDS[tableId][f.fieldId] = f);

    // Load views for this table
    var views = await getViewsForTable(tableId);
    if (navVersion !== myNav) return;
    META_VIEWS[tableId] = {};
    views.forEach(v => META_VIEWS[tableId][v.viewId] = v);

    // Set current view to the first available view or default
    var viewIds = Object.keys(META_VIEWS[tableId] || {});
    if (viewIds.length > 0 && !currentView) {
        // Check if there's a saved preference or use first view
        currentView = viewIds[0];
    } else if (!currentView) {
        currentView = '_default';
    }

    // Load and apply view filters, sorts, and groupBy
    var viewConfig = getViewFiltersAndSorts(tableId, currentView);
    currentFilters = viewConfig.filters;
    currentSorts = viewConfig.sorts;
    currentGroupBy = viewConfig.groupBy;

    // Update filter/sort/group button states
    updateFilterCount();
    updateSortCount();
    updateGroupButtonState();

    // Update the view list to highlight the active view
    updateSidebarViewActive(tableId, currentView);

    // Render view selector and fields dropdown
    renderViewSelector();
    renderFieldsDropdown();
    updateFieldsCount();

    // Show table headers immediately with skeleton rows (even before data loads)
    renderTableHeaders();

    // Update status (don't overwrite table headers with loading spinner)
    updateStatus('Loading records...', false, null, null);

    // Load record IDs
    originalRecordIds = await getRecordIdsForTable(tableId);
    if (navVersion !== myNav) return;
    currentRecordIds = originalRecordIds.slice();
    totalRecords = currentRecordIds.length;

    // Now render full table with data
    await renderTable();
}

// Update the sidebar to highlight the active view
function updateSidebarViewActive(tableId, viewId) {
    var wrapper = document.querySelector('.table-wrapper[data-table-id="' + tableId + '"]');
    if (!wrapper) return;

    var viewItems = wrapper.querySelectorAll('.table-view-item');
    viewItems.forEach(item => {
        item.classList.remove('active');
        var onclickAttr = item.getAttribute('onclick') || '';
        if (onclickAttr.includes("'" + viewId + "'")) {
            item.classList.add('active');
        }
    });
}

function showTableLoading(message) {
    var container = document.getElementById('table-container');
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>' + esc(message) + '</h3></div>';
    document.getElementById('pagination').style.display = 'none';
}

function renderTableHeaders() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');
    var fields = META_FIELDS[currentTable] || {};

    // Use view field configuration for visible fields
    var viewId = currentView || '_default';
    var colList = getVisibleFieldsForView(currentTable, viewId);

    if (colList.length === 0) {
        // No visible fields, show empty state
        container.innerHTML = '<div class="empty-state"><h3>No visible fields</h3><p>Click the Fields button to show columns</p></div>';
        return;
    }

    var colNames = {};
    colList.forEach(fid => {
        colNames[fid] = fields[fid]?.fieldName || fid;
    });

    // Build table with headers and skeleton rows
    var html = '<table id="table"><thead><tr><th style="width: 70px;">Actions</th><th>ID</th>';
    colList.forEach(col => {
        html += '<th title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    // Add skeleton loading rows
    for (var i = 0; i < 5; i++) {
        html += '<tr class="skeleton-row"><td><div class="skeleton-cell" style="width: 50px;"></div></td><td><div class="skeleton-cell" style="width: 60px;"></div></td>';
        colList.forEach(() => {
            html += '<td><div class="skeleton-cell" style="width: ' + (60 + Math.random() * 80) + 'px;"></div></td>';
        });
        html += '</tr>';
    }

    html += '</tbody></table>';
    container.innerHTML = html;
}

async function renderTable() {
    if (!currentTable) return;
    // Skip rendering if we're in a special view (Events or Sync Status)
    if (currentTable === '_events' || currentTable === '_sync_status') return;

    var renderNav = navVersion; // Capture current nav version for stale check

    // Check if table container exists - may not exist during early loading
    var tableContainer = document.getElementById('table-container');
    if (!tableContainer) {
        console.log('renderTable: table-container not ready yet');
        return;
    }

    // Apply filters, search, and sorts
    var needsFiltering = currentFilters.length > 0 || currentSearchQuery || currentSorts.length > 0;
    if (needsFiltering) {
        currentRecordIds = await getFilteredSortedRecords();
        if (navVersion !== renderNav) return; // Navigation changed, abort stale render
    } else {
        currentRecordIds = originalRecordIds.slice();
    }
    totalRecords = currentRecordIds.length;

    var tableEl = document.getElementById('table');

    // Determine which records to display
    var displayRecordIds;
    var isGrouped = !!currentGroupBy;

    if (isGrouped) {
        // When grouping, show all records (no pagination) - up to a reasonable limit
        var maxGroupedRecords = 1000;
        displayRecordIds = currentRecordIds.slice(0, maxGroupedRecords);
    } else {
        // Standard pagination
        displayRecordIds = currentRecordIds.slice(currentPage * PAGE_SIZE, (currentPage + 1) * PAGE_SIZE);

        // Check if we're on a page beyond available data (can happen after filtering)
        if (displayRecordIds.length === 0 && currentPage > 0) {
            currentPage = 0;
            displayRecordIds = currentRecordIds.slice(0, PAGE_SIZE);
        }
    }

    if (displayRecordIds.length === 0) {
        if (tableEl) tableEl.innerHTML = '';
        var emptyMsg = (currentFilters.length > 0 || currentSearchQuery)
            ? '<div class="empty-state"><h3>No matching records</h3><p>Try adjusting your filters or search</p></div>'
            : '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        tableContainer.innerHTML = emptyMsg;
        document.getElementById('pagination').style.display = 'none';
        return;
    }

    // Fetch records before clearing the container to avoid a white flash
    var records = await getRecordsByIds(currentTable, displayRecordIds);
    if (navVersion !== renderNav) return; // Navigation changed, abort stale render
    var recordMap = {};
    records.forEach(r => recordMap[r.recordId] = r.fields || {});

    // Get columns from view configuration
    var fields = META_FIELDS[currentTable] || {};
    var viewId = currentView || '_default';
    var colList = getVisibleFieldsForView(currentTable, viewId);

    // If no visible fields but we have data, initialize with all fields
    if (colList.length === 0 && Object.keys(fields).length === 0) {
        // Discover from data
        var colSet = {};
        records.forEach(r => {
            if (r.fields) Object.keys(r.fields).forEach(k => colSet[k] = true);
        });
        colList = Object.keys(colSet).sort();
    }

    var colNames = {};
    colList.forEach(fid => {
        colNames[fid] = fields[fid]?.fieldName || fid;
    });

    // Get group field name for header display
    var groupFieldName = currentGroupBy ? (fields[currentGroupBy]?.fieldName || currentGroupBy) : null;

    // Build table with draggable headers
    var html = '<thead><tr><th style="width: 70px; cursor: default;">Actions</th>';
    colList.forEach((col, idx) => {
        html += '<th draggable="true" data-field-id="' + esc(col) + '" data-field-index="' + idx + '" ' +
                'ondragstart="handleColumnDragStart(event)" ondragover="handleColumnDragOver(event)" ' +
                'ondrop="handleColumnDrop(event)" ondragend="handleColumnDragEnd(event)" ' +
                'title="' + esc(col) + '">' + esc(colNames[col]) + '</th>';
    });
    html += '</tr></thead><tbody>';

    if (isGrouped) {
        // Group records by field value
        var groups = groupRecordsByField(displayRecordIds, recordMap, currentGroupBy, colNames);

        // Render grouped rows
        var groupIndex = 0;
        for (var groupKey in groups) {
            var groupRecords = groups[groupKey];
            var groupId = 'group-' + groupIndex;

            // Group header row
            html += '<tr class="group-header-row" data-group-id="' + groupId + '" onclick="toggleGroup(\'' + groupId + '\')">';
            html += '<td colspan="' + (colList.length + 1) + '">';
            html += '<span class="group-toggle">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg>';
            html += '<span class="group-name">' + esc(groupFieldName) + ': ' + esc(groupKey) + '</span>';
            html += '<span class="group-count">(' + groupRecords.length + ')</span>';
            html += '</span>';
            html += '</td></tr>';

            // Group data rows
            groupRecords.forEach(rid => {
                var row = recordMap[rid] || {};
                html += '<tr class="group-row" data-group-id="' + groupId + '" data-record-id="' + esc(rid) + '" onclick="handleRowClick(event, \'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" style="cursor: pointer;">';
                html += '<td><button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="View field history">';
                html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
                html += 'History</button></td>';
                colList.forEach(col => {
                    var value = row[col];
                    if (value === undefined) value = row[colNames[col]];
                    html += '<td>' + formatCell(value) + '</td>';
                });
                html += '</tr>';
            });

            groupIndex++;
        }
    } else {
        // Standard flat rendering
        displayRecordIds.forEach(rid => {
            var row = recordMap[rid] || {};
            html += '<tr data-record-id="' + esc(rid) + '" onclick="handleRowClick(event, \'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" style="cursor: pointer;">';
            html += '<td><button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(rid) + '\')" title="View field history">';
            html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
            html += 'History</button></td>';
            colList.forEach(col => {
                var value = row[col];
                if (value === undefined) value = row[colNames[col]];
                html += '<td>' + formatCell(value) + '</td>';
            });
            html += '</tr>';
        });
    }

    html += '</tbody>';

    // Replace container content in one shot after data is ready (no intermediate blank state)
    tableContainer.innerHTML = '<table id="table"></table>';
    tableEl = document.getElementById('table');
    tableEl.innerHTML = html;

    // Update pagination (hide when grouped)
    if (isGrouped) {
        document.getElementById('pagination').style.display = 'none';
    } else {
        document.getElementById('pagination').style.display = '';
        updatePagination();
    }
}

// Group records by a field value
function groupRecordsByField(recordIds, recordMap, fieldId, colNames) {
    var groups = {};
    var emptyGroupKey = '(Empty)';

    recordIds.forEach(rid => {
        var row = recordMap[rid] || {};
        var value = row[fieldId];
        if (value === undefined) value = row[colNames[fieldId]];

        // Convert value to display string for grouping
        var groupKey = getGroupKeyFromValue(value);

        if (!groups[groupKey]) {
            groups[groupKey] = [];
        }
        groups[groupKey].push(rid);
    });

    // Sort groups: put (Empty) last, then sort alphabetically
    var sortedGroups = {};
    var keys = Object.keys(groups).sort((a, b) => {
        if (a === emptyGroupKey) return 1;
        if (b === emptyGroupKey) return -1;
        return a.localeCompare(b);
    });
    keys.forEach(k => sortedGroups[k] = groups[k]);

    return sortedGroups;
}

// Get a display string for grouping from a cell value
function getGroupKeyFromValue(value) {
    if (value == null || value === '') return '(Empty)';

    if (Array.isArray(value)) {
        if (value.length === 0) return '(Empty)';
        // For arrays, join values for display
        return value.map(v => {
            if (typeof v === 'object' && v !== null) {
                return v.name || v.filename || v.email || v.id || JSON.stringify(v);
            }
            return String(v);
        }).join(', ');
    }

    if (typeof value === 'object') {
        return value.name || value.filename || value.email || value.url || JSON.stringify(value);
    }

    return String(value);
}

// Toggle group visibility
function toggleGroup(groupId) {
    var headerRow = document.querySelector('.group-header-row[data-group-id="' + groupId + '"]');
    var dataRows = document.querySelectorAll('.group-row[data-group-id="' + groupId + '"]');

    if (headerRow.classList.contains('collapsed')) {
        headerRow.classList.remove('collapsed');
        dataRows.forEach(row => row.classList.remove('hidden'));
    } else {
        headerRow.classList.add('collapsed');
        dataRows.forEach(row => row.classList.add('hidden'));
    }
}

function formatCell(v) {
    if (v == null || v === '') {
        return '<span class="cell-empty"></span>';
    }

    if (Array.isArray(v)) {
        if (v.length === 0) return '<span class="cell-empty"></span>';

        // Check if it's an array of objects (linked records, attachments, etc.)
        if (typeof v[0] === 'object' && v[0] !== null) {
            var items = v.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return '<span class="cell-array">' + items.map(i => '<span class="tag">' + esc(i) + '</span>').join('') + '</span>';
        }

        // Simple array - join with commas
        return '<span class="cell-array">' + v.map(i => '<span class="tag">' + esc(String(i)) + '</span>').join('') + '</span>';
    }

    if (typeof v === 'object') {
        // Single object
        if (v.name) return esc(v.name);
        if (v.filename) return esc(v.filename);
        if (v.email) return esc(v.email);
        if (v.url) return '<a class="cell-link" href="' + esc(v.url) + '" target="_blank">' + esc(v.url.slice(0, 40)) + '</a>';
        return esc(JSON.stringify(v).slice(0, 50));
    }

    if (typeof v === 'boolean') {
        return '<span class="cell-bool ' + v + '">' + (v ? 'Yes' : 'No') + '</span>';
    }

    if (typeof v === 'number') {
        return '<span class="cell-number">' + v.toLocaleString() + '</span>';
    }

    // String - check for URLs
    var str = String(v);
    if (str.startsWith('http://') || str.startsWith('https://')) {
        return '<a class="cell-link" href="' + esc(str) + '" target="_blank">' + esc(str.slice(0, 50)) + '</a>';
    }

    return esc(str);
}

function updatePagination() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    var start = currentPage * PAGE_SIZE + 1;
    var end = Math.min((currentPage + 1) * PAGE_SIZE, totalRecords);

    document.getElementById('page-info').textContent = start + '-' + end + ' of ' + totalRecords.toLocaleString();
    document.getElementById('prev-btn').disabled = currentPage === 0;
    document.getElementById('next-btn').disabled = currentPage >= totalPages - 1;
    document.getElementById('pagination').style.display = totalRecords > PAGE_SIZE ? 'flex' : 'none';
}

function prevPage() {
    if (currentPage > 0) {
        currentPage--;
        renderTable();
    }
}

function nextPage() {
    var totalPages = Math.ceil(totalRecords / PAGE_SIZE);
    if (currentPage < totalPages - 1) {
        currentPage++;
        renderTable();
    }
}

// ============ API ============

// Fetch all records of a specific set type (table, field, view)
// Fetch all pages and filter events client-side by set type
async function fetchAllBySet(setType, onProgress) {
    var allEvents = [];
    var page = 1;
    var iterations = 0;
    while (true) {
        // Fetch using page-based pagination
        var result = await fetchPage(page);
        if (!result.events || result.events.length === 0) break;

        // Filter events client-side by payload._set
        var matchingEvents = result.events.filter(function(e) {
            if (!e || !e.payload) return false;
            var payload = parsePayload(e.payload);
            return payload && payload._set === setType;
        });

        allEvents = allEvents.concat(matchingEvents);
        if (onProgress) onProgress(allEvents.length);
        if (!result.hasMore) break;
        page = result.nextPage;
        iterations++;
        if (iterations > 100) break; // Safety limit for schema
    }
    return allEvents;
}

// Fetch events using page-based pagination
// API returns 2500 records per page with nextPage indicator
// Supports aminoStream query parameters:
//   page (int, min:1, default 1), per_page (int, min:1, max:10000, default 2500),
//   created_after (timestamp), created_before (timestamp), last (bool - single most recent record)
async function fetchPage(page, createdAfter, options) {
    options = options || {};
    var params = [];
    if (API_KEY) params.push('apiKey=' + encodeURIComponent(API_KEY));
    if (page && page > 1) params.push('page=' + page);
    if (createdAfter) params.push('created_after=' + encodeURIComponent(createdAfter));
    if (options.createdBefore) params.push('created_before=' + encodeURIComponent(options.createdBefore));
    if (options.perPage) params.push('per_page=' + encodeURIComponent(options.perPage));
    if (options.last) params.push('last=true');

    var url = API + (params.length > 0 ? '?' + params.join('&') : '');

    var res = await fetch(url);

    if (res.status === 401 || res.status === 403) {
        throw new Error('Invalid API key');
    }

    var data = await res.json();

    if (!res.ok) {
        throw new Error(data.message || data.error || 'HTTP ' + res.status);
    }

    // If 'last' was requested, API returns a single record instead of a paginated list
    if (options.last) {
        var singleEvent = Array.isArray(data) ? data[0] : (data.items ? data.items[0] : data);
        return { events: singleEvent ? [singleEvent] : [], hasMore: false, nextPage: null };
    }

    // Handle paginated response format: { itemsReceived, curPage, nextPage, prevPage, offset, perPage, items }
    var events = Array.isArray(data) ? data : (data.items || data.data || []);
    // API returns nextPage as number if more pages exist, null otherwise
    var hasMore = data.nextPage != null;
    var nextPage = data.nextPage || null;

    // Normalize event fields: API may return payload under alternative field names
    for (var i = 0; i < events.length; i++) {
        var ev = events[i];
        if (ev && ev.payload === undefined) {
            // Check for alternative payload field names from Xano/API
            if (ev._payload !== undefined) { ev.payload = ev._payload; delete ev._payload; }
            else if (ev.event_payload !== undefined) { ev.payload = ev.event_payload; delete ev.event_payload; }
        }
    }

    return { events, hasMore, nextPage };
}

async function fullSync() {
    if (!API_KEY) return;
    var eventsLoaded = 0;
    var tablesFound = 0;
    var fieldsFound = 0;
    var viewsFound = 0;
    var recordsFound = 0;
    var schemaLoaded = false;
    var syncStartTime = Date.now();
    var lastBatchTime = syncStartTime;
    var recordsPerSecond = 0;

    // Helper to format time remaining
    function formatTimeRemaining(seconds) {
        if (seconds < 0 || !isFinite(seconds)) return 'Calculating...';
        if (seconds < 5) return 'Almost done...';
        if (seconds < 60) return 'About ' + Math.ceil(seconds) + ' seconds remaining';
        var minutes = Math.ceil(seconds / 60);
        return 'About ' + minutes + ' minute' + (minutes > 1 ? 's' : '') + ' remaining';
    }

    // Show the loading overlay for initial sync
    showLoadingOverlay();

    // Background function to load schema metadata (proper names for tables/fields/views)
    // Fetches all events once and filters by type client-side
    async function loadSchemaInBackground() {
        try {
            var tableEvents = [];
            var fieldEvents = [];
            var viewEvents = [];
            var page = 1; // Page-based pagination
            var iterations = 0;

            // Fetch all events once and categorize by payload._set
            while (true) {
                var result = await fetchPage(page);
                if (!result.events || result.events.length === 0) break;

                for (var e of result.events) {
                    if (!e || !e.payload) continue;
                    var payload = parsePayload(e.payload);
                    if (!payload) continue;

                    if (payload._set === 'table') {
                        tableEvents.push(e);
                    } else if (payload._set === 'field') {
                        fieldEvents.push(e);
                    } else if (payload._set === 'view') {
                        viewEvents.push(e);
                    }
                }

                if (!result.hasMore) break;
                page = result.nextPage;
                iterations++;
                if (iterations > 100) break; // Safety limit for schema
            }

            // Process tables
            if (tableEvents.length > 0) {
                tableEvents.sort((a, b) => (a.id || 0) - (b.id || 0));
                await processEvents(tableEvents);
                eventsLoaded += tableEvents.length;
                tablesFound = tableEvents.length;
            }

            // Process fields
            if (fieldEvents.length > 0) {
                fieldEvents.sort((a, b) => (a.id || 0) - (b.id || 0));
                await processEvents(fieldEvents);
                eventsLoaded += fieldEvents.length;
                fieldsFound = fieldEvents.length;
            }

            // Process views
            if (viewEvents.length > 0) {
                viewEvents.sort((a, b) => (a.id || 0) - (b.id || 0));
                await processEvents(viewEvents);
                eventsLoaded += viewEvents.length;
                viewsFound = viewEvents.length;
            }

            schemaLoaded = true;

            // Re-render UI with proper names
            await renderSidebar();
            if (currentTable && currentTable !== '_events') {
                await renderTable();
            }
        } catch (err) {
            console.error('Background schema load error:', err);
        }
    }

    // PHASE 1: Start streaming data immediately (schema will be auto-discovered from records)
    // This shows tables/fields right away with ID placeholders
    updateStatus('Loading recent data...', false, 5, 'Streaming records...');
    updateLoadingOverlay('Loading data...', 'Starting...', 5, 0, 0, 0, 'Connecting to server...');

    // Start schema loading in background (will update placeholders with proper names)
    var schemaPromise = loadSchemaInBackground();

    var page = 1; // Page-based pagination
    var iterations = 0;
    var smoothProgress = 5; // For smooth animation between batches
    var targetProgress = 5;

    // Smooth progress animation - updates every 100ms between batches
    var progressAnimationInterval = setInterval(function() {
        if (smoothProgress < targetProgress) {
            smoothProgress = Math.min(targetProgress, smoothProgress + 0.5);
            var progressEl = document.getElementById('loading-progress-fill');
            if (progressEl) progressEl.style.width = smoothProgress + '%';
        }
    }, 100);

    while (true) {
        // Calculate time-based estimates
        var elapsed = (Date.now() - syncStartTime) / 1000;
        var timeEstimate = '';

        if (iterations > 0 && recordsFound > 0) {
            // Calculate records per second based on overall progress
            recordsPerSecond = recordsFound / elapsed;

            // Estimate remaining time - we use hasMore to determine if there's more data
            // Rough estimate: assume linear progress based on batch count
            var estimatedTotalBatches = Math.max(iterations + 1, iterations * 1.2);
            var remainingBatches = estimatedTotalBatches - iterations;
            var avgBatchTime = elapsed / iterations;
            var remainingSeconds = remainingBatches * avgBatchTime;

            if (remainingSeconds > 0) {
                timeEstimate = formatTimeRemaining(remainingSeconds) + '  ' + Math.round(recordsPerSecond).toLocaleString() + ' records/sec';
            }
        } else {
            timeEstimate = 'Calculating speed...';
        }

        // Show progress with estimates - smoother progress calculation
        targetProgress = Math.min(95, 5 + (iterations / 50) * 85);
        var tableCount = Object.keys(META_TABLES).length;
        var fieldCount = Object.values(META_FIELDS).reduce((sum, t) => sum + Object.keys(t).length, 0);
        var detail = tableCount + ' tables, ' + fieldCount + ' fields, ' + recordsFound.toLocaleString() + ' records';
        updateStatus('Loading page ' + page + '...', false, targetProgress, detail);

        // Update the loading overlay with progress and time estimate
        updateLoadingOverlay('Downloading data...', 'Page ' + page + '  ' + Math.round(elapsed) + 's elapsed', targetProgress, tableCount, fieldCount, recordsFound, timeEstimate);

        // Fetch all events using page-based pagination
        var result = await fetchPage(page);
        if (!result.events || result.events.length === 0) {
            clearInterval(progressAnimationInterval);
            break;
        }

        // Process all events (data records will auto-create placeholder schema,
        // schema events will update with proper names)
        var allEvents = result.events;
        if (allEvents.length > 0) {
            eventsLoaded += allEvents.length;
            // Count data records (non-schema events)
            var dataCount = allEvents.filter(function(e) {
                var payload = parsePayload(e.payload);
                var set = payload && payload._set;
                return set !== 'table' && set !== 'field' && set !== 'view';
            }).length;
            recordsFound += dataCount;

            // Sort events by ID ascending for correct state processing
            allEvents.sort((a, b) => (a.id || 0) - (b.id || 0));
            await processEvents(allEvents);

            // Stream data to UI - render after every page for immediate feedback
            await renderSidebar();

            // Auto-select first table after first batch of data
            if (!currentTable && Object.keys(META_TABLES).length > 0) {
                var firstTable = Object.keys(META_TABLES)[0];
                await showTable(firstTable);
            }

            // Refresh current table view to show new data
            if (currentTable && currentTable !== '_events') {
                originalRecordIds = await getRecordIdsForTable(currentTable);
                currentRecordIds = originalRecordIds.slice();
                totalRecords = currentRecordIds.length;
                await renderTable();
            }
        }

        // Keep overlay visible during initial sync - only hide when complete
        if (!result.hasMore) {
            clearInterval(progressAnimationInterval);
            break;
        }
        page = result.nextPage;
        iterations++;
        if (iterations > 500) {
            clearInterval(progressAnimationInterval);
            break;
        }
    }

    // Wait for schema to finish loading (ensures proper names are applied)
    var totalElapsed = Math.round((Date.now() - syncStartTime) / 1000);
    updateLoadingOverlay('Finalizing schema...', 'Processing metadata', 95, Object.keys(META_TABLES).length, Object.values(META_FIELDS).reduce((sum, t) => sum + Object.keys(t).length, 0), recordsFound, 'Almost done...');
    await schemaPromise;

    // Final render after sync completes
    await renderSidebar();
    if (currentTable && currentTable !== '_events') {
        originalRecordIds = await getRecordIdsForTable(currentTable);
        currentRecordIds = originalRecordIds.slice();
        totalRecords = currentRecordIds.length;
        await renderTable();
    }

    await setSyncMeta('lastEventTimestamp', lastEventTimestamp);
    var finalTableCount = Object.keys(META_TABLES).length;
    var finalFieldCount = Object.values(META_FIELDS).reduce((sum, t) => sum + Object.keys(t).length, 0);
    var finalDetail = finalTableCount + ' tables, ' + finalFieldCount + ' fields, ' + viewsFound + ' views, ' + recordsFound.toLocaleString() + ' records';

    // Show completion on overlay before hiding
    var completionTime = Math.round((Date.now() - syncStartTime) / 1000);
    var completionMsg = 'Completed in ' + completionTime + ' seconds';
    updateLoadingOverlay('Setup complete!', 'Ready to explore your data', 100, finalTableCount, finalFieldCount, recordsFound, completionMsg);

    // Brief delay to show completion, then hide overlay
    await new Promise(resolve => setTimeout(resolve, 500));
    hideLoadingOverlay();

    updateStatus('Synced ' + eventsLoaded.toLocaleString() + ' events', true, null, finalDetail);
}

async function incrementalSync() {
    if (!API_KEY) return;
    var syncStartTime = Date.now();
    try {
        // Show syncing indicator
        setRefreshIndicatorSyncing(true);
        updateStatus('Checking for updates...', false, null, null);

        // Sync snapshot table in parallel with event stream
        var snapshotSyncPromise = AminoSync.syncFromSnapshot().catch(err => {
            console.warn('Snapshot sync failed:', err);
            return { updated: 0 };
        });

        // Fetch all events created after the last synced timestamp (with pagination)
        var allEvents = [];
        var page = 1;
        var iterations = 0;
        while (true) {
            var result = await fetchPage(page, lastEventTimestamp);
            if (!result.events || result.events.length === 0) break;
            allEvents = allEvents.concat(result.events);
            if (!result.hasMore) break;
            page = result.nextPage;
            iterations++;
            if (iterations > 100) break; // Safety limit
        }

        // Wait for snapshot sync to complete
        var snapshotResult = await snapshotSyncPromise;

        if (allEvents.length > 0) {
            updateStatus('Processing ' + allEvents.length + ' new events...', false, null, null);
            // Sort by timestamp for correct processing order (handle both string and numeric timestamps)
            allEvents.sort((a, b) => {
                var aTime = a.created_at ? (typeof a.created_at === 'number' ? a.created_at : new Date(a.created_at).getTime()) : 0;
                var bTime = b.created_at ? (typeof b.created_at === 'number' ? b.created_at : new Date(b.created_at).getTime()) : 0;
                return aTime - bTime;
            });
            await processEvents(allEvents);
            await setSyncMeta('lastEventTimestamp', lastEventTimestamp);

            updateStatus('Updating views...', false, null, null);
            await renderSidebar();

            // Update data view if table is selected
            if (currentTable && currentTable !== '_sync_status') {
                originalRecordIds = await getRecordIdsForTable(currentTable);
                currentRecordIds = originalRecordIds.slice();
                totalRecords = currentRecordIds.length;
                await renderTable();
            }

            var syncDetail = allEvents.length + ' events synced';
            if (snapshotResult.updated > 0) {
                syncDetail += ', ' + snapshotResult.updated + ' snapshots updated';
            }
            updateStatus('Up to date', true, null, syncDetail);

            // Record to sync history
            SyncHistory.record({
                type: 'incremental',
                result: 'success',
                eventsFound: allEvents.length,
                snapshotsUpdated: snapshotResult.updated || 0,
                duration: Date.now() - syncStartTime,
                detail: syncDetail
            });
        } else {
            var statusDetail = snapshotResult.updated > 0 ? snapshotResult.updated + ' snapshots updated' : null;
            updateStatus('Up to date', true, null, statusDetail);

            // Record no-change sync
            SyncHistory.record({
                type: 'incremental',
                result: snapshotResult.updated > 0 ? 'success' : 'no-change',
                eventsFound: 0,
                snapshotsUpdated: snapshotResult.updated || 0,
                duration: Date.now() - syncStartTime,
                detail: statusDetail || 'No new events'
            });
        }

        // Reset indicator and start countdown
        setRefreshIndicatorSyncing(false);
    } catch (err) {
        console.error('Sync error:', err);
        updateStatus('Sync error: ' + err.message, false, null, null);
        setRefreshIndicatorSyncing(false);

        // Record error to sync history
        SyncHistory.record({
            type: 'incremental',
            result: 'error',
            duration: Date.now() - syncStartTime,
            error: err.message,
            detail: 'Sync error: ' + err.message
        });
    }
}

// ============ Sync Status View ============

var syncStatusUnsubscribe = null;

async function showSyncStatusView() {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Clean up events view state
    expandedPayloads.clear();
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;
    if (eventsScrollHandler) {
        var evContainer = document.querySelector('.table-container');
        if (evContainer) evContainer.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }

    currentTable = '_sync_status';
    currentView = null;

    // Update sidebar selection
    document.querySelectorAll('.sidebar .table-item').forEach(el => el.classList.remove('active', 'expanded'));
    document.querySelectorAll('.sidebar .table-view-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.sidebar .table-item.sync-status-item')?.classList.add('active');

    // Hide view controls and show sync status view
    document.getElementById('view-controls-bar').style.display = 'none';
    document.getElementById('title').textContent = 'Sync Status';
    document.getElementById('pagination').style.display = 'none';

    // Hide toolbar views section
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = 'none';

    // Show loading state immediately
    var container = document.querySelector('.table-container');
    if (container) container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading sync status...</h3></div>';

    await renderSyncStatusView();
    if (navVersion !== myNav) return;

    // Subscribe to live updates
    if (syncStatusUnsubscribe) syncStatusUnsubscribe();
    syncStatusUnsubscribe = SyncHistory.onChange(() => {
        if (currentTable === '_sync_status') renderSyncStatusView();
    });
}

async function handleSnapshotExport() {
    var btn = document.getElementById('snapshot-export-btn');
    var resultEl = document.getElementById('snapshot-export-result');
    if (!btn || !resultEl) return;

    btn.disabled = true;
    btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>Exporting...';
    resultEl.textContent = '';

    try {
        var result = await AminoSync.downloadSnapshotAsAmo();
        if (!result.blob) {
            resultEl.textContent = 'No snapshots available to export.';
            resultEl.style.color = '#f59e0b';
        } else {
            var sizeStr = result.stats.bytes < 1024
                ? result.stats.bytes + ' B'
                : result.stats.bytes < 1048576
                    ? (result.stats.bytes / 1024).toFixed(1) + ' KB'
                    : (result.stats.bytes / 1048576).toFixed(1) + ' MB';
            resultEl.innerHTML = '<span style="color: #10b981;">&#10003;</span> ' +
                result.stats.records.toLocaleString() + ' records across ' +
                result.stats.tables + ' table' + (result.stats.tables !== 1 ? 's' : '') +
                ' &middot; ' + sizeStr;
            resultEl.style.color = '#d1d5db';
        }
    } catch (err) {
        resultEl.textContent = 'Export failed: ' + (err.message || err);
        resultEl.style.color = '#ef4444';
    }

    btn.disabled = false;
    btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>Export .amo Snapshot';
}

async function renderSyncStatusView() {
    var container = document.querySelector('.table-container');
    var stats = SyncHistory.getStats();
    var passiveStats = PassiveSnapshotSync.getStats();
    var totalEventsCount = await getRawEventsCount();

    // Determine overall sync state
    var syncState = 'synced';
    var syncLabel = 'Up to Date';
    if (SyncHistory.isPolling) {
        syncState = 'syncing';
        syncLabel = 'Checking...';
    } else if (stats.errorCount > 0 && stats.errorCount === stats.totalSyncs + stats.totalPolls) {
        syncState = 'error';
        syncLabel = 'Errors Detected';
    }

    var html = '<div class="sync-status-view">';

    // Header
    html += '<div class="sync-status-header">';
    html += '<h2>Sync Status</h2>';
    html += '<span class="sync-status-badge ' + syncState + '">' + syncLabel + '</span>';
    html += '</div>';

    // Summary cards
    html += '<div class="sync-status-cards">';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Total Events in DB</div>';
    html += '<div class="card-value">' + totalEventsCount.toLocaleString() + '</div>';
    html += '<div class="card-sub">Last event timestamp: ' + (lastEventTimestamp ? formatTimestamp(lastEventTimestamp) : 'N/A') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Events Synced (Session)</div>';
    html += '<div class="card-value">' + stats.totalEventsProcessed.toLocaleString() + '</div>';
    html += '<div class="card-sub">' + stats.totalSyncs + ' sync operation' + (stats.totalSyncs !== 1 ? 's' : '') + '</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Snapshots Updated</div>';
    html += '<div class="card-value">' + stats.totalSnapshotsUpdated.toLocaleString() + '</div>';
    html += '<div class="card-sub">Passive: ' + passiveStats.pulled + ' pulled, ' + passiveStats.verified + ' verified</div>';
    html += '</div>';

    html += '<div class="sync-status-card">';
    html += '<div class="card-label">Last Sync</div>';
    html += '<div class="card-value" style="font-size: 16px;">' + (stats.lastSyncTime ? formatSyncTimestamp(stats.lastSyncTime) : 'Never') + '</div>';
    html += '<div class="card-sub">Last poll: ' + (stats.lastPollTime ? formatSyncTimestamp(stats.lastPollTime) : 'Never') + '</div>';
    html += '</div>';

    html += '</div>';

    // Polling controls
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (SyncHistory.pollInterval ? (SyncHistory.consecutiveFailures > 0 ? 'red' : 'green') : 'amber') + '"></span>Database Polling</h3>';
    html += '<div class="sync-poll-controls">';
    html += '<button class="btn-poll primary" onclick="SyncHistory.pollForUpdates()" ' + (SyncHistory.isPolling ? 'disabled' : '') + '>';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>';
    html += 'Poll Now</button>';
    if (SyncHistory.pollInterval) {
        html += '<button class="btn-poll" onclick="SyncHistory.stopPolling(); renderSyncStatusView();">Stop Auto-Poll</button>';
        if (SyncHistory.consecutiveFailures > 0) {
            html += '<span style="font-size: 12px; color: #ef4444;">Backing off: ' + Math.round(SyncHistory.currentPollInterval / 1000) + 's interval (' + SyncHistory.consecutiveFailures + ' consecutive failure' + (SyncHistory.consecutiveFailures > 1 ? 's' : '') + ')</span>';
        } else {
            html += '<span style="font-size: 12px; color: #6b7280;">Polling every ' + (SyncHistory.POLL_INTERVAL / 1000) + 's</span>';
        }
    } else {
        html += '<button class="btn-poll" onclick="SyncHistory.startPolling(); renderSyncStatusView();">Start Auto-Poll</button>';
        html += '<span style="font-size: 12px; color: #6b7280;">Auto-poll is off</span>';
    }
    html += '</div>';
    html += '</div>';

    // Snapshot Export
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot green"></span>Snapshot Export</h3>';
    html += '<div class="snapshot-export-controls">';
    html += '<button class="btn-poll primary snapshot-export-btn" id="snapshot-export-btn" onclick="handleSnapshotExport()">';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
    html += 'Export .amo Snapshot</button>';
    html += '<span id="snapshot-export-result" style="font-size: 12px; color: #6b7280;"></span>';
    html += '</div>';
    html += '</div>';

    // Sync history table
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (stats.errorCount > 0 ? 'red' : 'green') + '"></span>Sync History</h3>';

    if (SyncHistory.entries.length === 0) {
        html += '<div style="text-align: center; padding: 32px; color: #9ca3af; font-size: 13px;">No sync operations recorded yet. Syncs will appear here as they occur.</div>';
    } else {
        html += '<table class="sync-history-table">';
        html += '<thead><tr>';
        html += '<th>Time</th>';
        html += '<th>Type</th>';
        html += '<th>Result</th>';
        html += '<th>Events</th>';
        html += '<th>Snapshots</th>';
        html += '<th>Duration</th>';
        html += '<th>Detail</th>';
        html += '</tr></thead>';
        html += '<tbody>';

        var displayEntries = SyncHistory.entries.slice(0, 50);
        for (var i = 0; i < displayEntries.length; i++) {
            var entry = displayEntries[i];
            html += '<tr>';
            html += '<td style="white-space: nowrap; font-size: 12px; color: #6b7280;">' + formatSyncTimestamp(entry.timestamp) + '</td>';
            html += '<td><span class="sync-type-badge ' + entry.type + '">' + entry.type + '</span></td>';
            html += '<td><span class="sync-result-badge ' + entry.result + '">' + entry.result.replace('-', ' ') + '</span></td>';
            html += '<td>' + (entry.eventsFound || 0) + '</td>';
            html += '<td>' + (entry.snapshotsUpdated || 0) + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280;">' + (entry.duration > 0 ? entry.duration + 'ms' : '-') + '</td>';
            html += '<td style="font-size: 12px; color: #6b7280; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + esc(entry.detail || '') + '</td>';
            html += '</tr>';
        }

        html += '</tbody></table>';
        if (SyncHistory.entries.length > 50) {
            html += '<div style="text-align: center; padding: 8px; color: #9ca3af; font-size: 12px;">Showing 50 of ' + SyncHistory.entries.length + ' entries</div>';
        }
    }
    html += '</div>';

    // Activity log (mirrors SyncStatusFeed)
    html += '<div class="sync-status-section">';
    html += '<h3><span class="section-dot ' + (SyncStatusFeed.isActive ? 'green' : 'amber') + '"></span>Activity Log</h3>';
    html += '<div class="sync-activity-log">';
    if (SyncStatusFeed.lines.length === 0) {
        html += '<div class="log-empty">No sync activity logged yet</div>';
    } else {
        var logLines = SyncStatusFeed.lines.slice(-50);
        for (var j = 0; j < logLines.length; j++) {
            var line = logLines[j];
            html += '<div class="log-line ' + line.type + '">';
            html += '<span class="timestamp">' + line.timestamp + '</span>';
            html += '<span class="message">' + esc(line.message) + '</span>';
            html += '</div>';
        }
    }
    html += '</div>';
    html += '</div>';

    html += '</div>';
    container.innerHTML = html;

    // Scroll activity log to bottom
    var logEl = container.querySelector('.sync-activity-log');
    if (logEl) logEl.scrollTop = logEl.scrollHeight;
}

function formatSyncTimestamp(ts) {
    var d;
    if (ts instanceof Date) {
        d = ts;
    } else if (typeof ts === 'number') {
        d = new Date(ts);
    } else {
        d = new Date(ts);
    }
    if (isNaN(d.getTime())) return String(ts);
    var now = new Date();
    var isToday = d.toDateString() === now.toDateString();
    var time = d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });
    if (isToday) return time;
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' + time;
}

// ============ Init ============

async function init() {
    META_TABLES = {};
    META_FIELDS = {};
    META_VIEWS = {};
    TABLE_SETTINGS = { tables: {}, tableOrder: [], views: {} };
    currentTable = null;
    currentPage = 0;
    currentRecordIds = [];
    originalRecordIds = [];
    totalRecords = 0;
    lastEventTimestamp = null;

    // Load sidebar state (pinned, recent, expanded sections)
    loadSidebarState();
    initSidebarSearch();

    db = await openDB();

    // Capture the highest event ID at app open time for "new" event indicators
    appOpenedEventId = await getMaxEventId();

    updateStatus('Loading local data...', false, null, null);

    var storedLastTimestamp = await getSyncMeta('lastEventTimestamp');
    var tables = await getAllTables();
    var fields = await getAllFields();
    var views = await getAllViews();

    // Load metadata into memory
    tables.forEach(t => META_TABLES[t.tableId] = t);
    fields.forEach(f => {
        if (!META_FIELDS[f.tableId]) META_FIELDS[f.tableId] = {};
        META_FIELDS[f.tableId][f.fieldId] = f;
    });
    views.forEach(v => {
        if (!META_VIEWS[v.tableId]) META_VIEWS[v.tableId] = {};
        META_VIEWS[v.tableId][v.viewId] = v;
    });

    // Load user-specific table settings
    await loadTableSettings();

    hideAuthScreen();

    if (tables.length > 0) {
        updateStatus('Found ' + tables.length + ' tables', false, null, 'Loading data...');
        await renderSidebar();

        // Auto-select first table
        var firstTable = Object.keys(META_TABLES)[0];
        if (firstTable) {
            await showTable(firstTable);
        }

        lastEventTimestamp = storedLastTimestamp || null;
        if (API_KEY) await incrementalSync();
    } else if (API_KEY) {
        updateStatus('Starting initial sync...', false, 0, 'Fetching data from server...');
        await renderSidebar();
        await fullSync();
        await renderSidebar();
    } else {
        // No API key and no local data - just show empty state
        updateStatus('Offline mode - upload CSV or add API key', true, null, null);
        await renderSidebar();
    }

    updateStatus(API_KEY ? 'Up to date' : 'Offline mode', true, null, null);
    updateConnectApiButton();

    // Start the refresh indicator countdown
    lastSyncTime = Date.now();
    startRefreshCountdown();

    if (API_KEY) {
        if (pollInterval) clearInterval(pollInterval);
        pollInterval = setInterval(incrementalSync, 60000);

        // Start background polling for new events (lightweight 15s checks)
        // This uses the 'last' query parameter to efficiently detect new events
        // and triggers incremental sync only when new data is available
        SyncHistory.startPolling();
    }

    // Initialize sync toggle UI and only start if enabled
    initSyncToggle();
    if (snapshotSyncEnabled && API_KEY) {
        PassiveSnapshotSync.start();
    }
}

// ============ Field History Modal ============

var currentHistoryData = [];
var currentHistoryRecordId = null;
var currentHistoryTableId = null;

async function openHistoryModal(tableId, recordId) {
    currentHistoryTableId = tableId;
    currentHistoryRecordId = recordId;

    // Set modal title
    var tableName = META_TABLES[tableId]?.tableName || tableId;
    document.getElementById('history-modal-title').textContent = 'Field History - ' + tableName;

    // Show modal with loading state
    var overlay = document.getElementById('history-modal-overlay');
    var body = document.getElementById('history-modal-body');
    body.innerHTML = '<div class="modal-empty"><div class="loading-spinner"></div><h3>Loading history...</h3></div>';
    overlay.classList.add('open');

    // Fetch history data
    try {
        // First fetch any new events from API for this specific record (incremental)
        await fetchAndProcessHistoryForRecord(tableId, recordId);

        // Then get all history from IndexedDB (includes newly fetched entries)
        currentHistoryData = await getFieldHistoryForRecord(tableId, recordId);
        renderHistoryModal();
    } catch (err) {
        console.error('Error loading history:', err);
        body.innerHTML = '<div class="modal-empty"><h3>Error loading history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closeHistoryModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('history-modal-overlay').classList.remove('open');
    currentHistoryData = [];
    currentHistoryRecordId = null;
    currentHistoryTableId = null;
}

function renderHistoryModal() {
    var body = document.getElementById('history-modal-body');
    var filterSelect = document.getElementById('history-field-filter');
    var countEl = document.getElementById('history-count');

    if (!currentHistoryData || currentHistoryData.length === 0) {
        body.innerHTML = '<div class="modal-empty"><h3>No history available</h3><p>Field changes will appear here after the next sync</p></div>';
        filterSelect.innerHTML = '<option value="">All Fields</option>';
        countEl.textContent = '0 changes';
        return;
    }

    // Build field filter options
    var fieldIds = [...new Set(currentHistoryData.map(h => h.fieldId))];
    var fields = META_FIELDS[currentHistoryTableId] || {};

    var filterHtml = '<option value="">All Fields</option>';
    fieldIds.forEach(fid => {
        var fieldName = fields[fid]?.fieldName || fid;
        filterHtml += '<option value="' + esc(fid) + '">' + esc(fieldName) + '</option>';
    });
    filterSelect.innerHTML = filterHtml;

    // Get selected filter
    var selectedField = filterSelect.value;
    var filteredData = selectedField
        ? currentHistoryData.filter(h => h.fieldId === selectedField)
        : currentHistoryData;

    countEl.textContent = filteredData.length + ' change' + (filteredData.length !== 1 ? 's' : '');

    // Render history items
    var html = '<div class="history-timeline">';

    for (var item of filteredData) {
        var fieldName = fields[item.fieldId]?.fieldName || item.fieldId;
        var changeTypeClass = item.changeType || 'updated';
        var timestamp = item.timestamp ? formatTimestamp(item.timestamp) : 'Unknown time';

        html += '<div class="history-item">';
        html += '<div class="history-item-header">';
        html += '<span class="history-field-name">' + esc(fieldName) + '</span>';
        html += '<span class="history-change-type ' + changeTypeClass + '">' + changeTypeClass + '</span>';
        html += '<span class="history-timestamp">' + esc(timestamp) + '</span>';
        html += '<span class="history-event-id">Event #' + (item.eventId || '?') + '</span>';
        html += '</div>';

        html += '<div class="history-values">';

        // Old value
        if (item.changeType !== 'created') {
            html += '<div class="history-value-box ' + (item.oldValue === null ? 'null' : 'old') + '">';
            html += '<div class="history-value-label">Previous</div>';
            html += '<div class="history-value-content">' + formatHistoryValue(item.oldValue) + '</div>';
            html += '</div>';
            html += '<span class="history-arrow">&#8594;</span>';
        }

        // New value
        html += '<div class="history-value-box ' + (item.newValue === null ? 'null' : 'new') + '">';
        html += '<div class="history-value-label">' + (item.changeType === 'created' ? 'Initial Value' : 'New Value') + '</div>';
        html += '<div class="history-value-content">' + formatHistoryValue(item.newValue) + '</div>';
        html += '</div>';

        html += '</div>'; // .history-values
        html += '</div>'; // .history-item
    }

    html += '</div>';
    body.innerHTML = html;
}

function filterHistoryByField() {
    renderHistoryModal();
}

function formatTimestamp(ts) {
    if (!ts) return 'Unknown';
    var date = new Date(ts);
    var now = new Date();
    var diff = now - date;

    // If less than 24 hours, show relative time
    if (diff < 86400000) {
        if (diff < 60000) return 'Just now';
        if (diff < 3600000) return Math.floor(diff / 60000) + ' min ago';
        return Math.floor(diff / 3600000) + ' hour' + (Math.floor(diff / 3600000) !== 1 ? 's' : '') + ' ago';
    }

    // Otherwise show date and time
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatHistoryValue(value) {
    if (value === null || value === undefined) {
        return '<span style="color: #999; font-style: italic;">empty</span>';
    }

    if (Array.isArray(value)) {
        if (value.length === 0) return '<span style="color: #999; font-style: italic;">empty array</span>';

        // Check if it's an array of objects
        if (typeof value[0] === 'object' && value[0] !== null) {
            var items = value.map(item => {
                if (item.name) return item.name;
                if (item.filename) return item.filename;
                if (item.email) return item.email;
                if (item.id) return item.id;
                return JSON.stringify(item).slice(0, 30);
            });
            return items.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(i) + '</span>').join('');
        }

        return value.map(i => '<span class="tag" style="background: #e8f0fe; color: #2d6cdf; padding: 2px 8px; border-radius: 12px; margin: 1px 2px 1px 0; display: inline-block;">' + esc(String(i)) + '</span>').join('');
    }

    if (typeof value === 'object') {
        if (value.name) return esc(value.name);
        if (value.filename) return esc(value.filename);
        if (value.email) return esc(value.email);
        return esc(JSON.stringify(value).slice(0, 100));
    }

    if (typeof value === 'boolean') {
        return '<span style="padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; ' +
            (value ? 'background: #d4edda; color: #155724;' : 'background: #f8d7da; color: #721c24;') + '">' +
            (value ? 'Yes' : 'No') + '</span>';
    }

    if (typeof value === 'number') {
        return '<span style="font-family: monospace;">' + value.toLocaleString() + '</span>';
    }

    return esc(String(value));
}

// Keyboard handler for modal
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        var overlay = document.getElementById('history-modal-overlay');
        if (overlay && overlay.classList.contains('open')) {
            closeHistoryModal();
        }
        // Also close PIT modal
        var pitOverlay = document.getElementById('pit-modal-overlay');
        if (pitOverlay && pitOverlay.classList.contains('open')) {
            closePitModal();
        }
        // Also close view selector and fields dropdown
        closeAllDropdowns();
    }
});

// ============ Events View ============

async function showEventsView() {
    // Navigation guard: increment version and capture it
    var myNav = ++navVersion;

    // Clean up sync status listener
    if (syncStatusUnsubscribe) { syncStatusUnsubscribe(); syncStatusUnsubscribe = null; }

    currentTable = '_events';
    currentView = null;

    // Update sidebar selection
    document.querySelectorAll('.sidebar .table-item').forEach(el => el.classList.remove('active', 'expanded'));
    document.querySelectorAll('.sidebar .table-view-item').forEach(el => el.classList.remove('active'));
    document.querySelector('.sidebar .table-item.events-item')?.classList.add('active');

    // Hide view controls and show events view
    document.getElementById('view-controls-bar').style.display = 'none';
    document.getElementById('title').textContent = 'Events Stream';
    document.getElementById('pagination').style.display = 'none';

    // Hide toolbar views section for events view
    var toolbarViews = document.querySelector('.toolbar-views');
    if (toolbarViews) toolbarViews.style.display = 'none';

    await renderEventsView();
    // Navigation guard check after async work (renderEventsView handles its own loading state)
}

async function renderEventsView() {
    var container = document.querySelector('.table-container');
    container.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><h3>Loading events...</h3></div>';

    // Clean up previous scroll handler
    if (eventsScrollHandler) {
        container.removeEventListener('scroll', eventsScrollHandler);
        eventsScrollHandler = null;
    }

    // Reset infinite scroll state
    loadedEvents = [];
    eventsOffset = 0;
    isLoadingMoreEvents = false;
    hasMoreEvents = true;

    try {
        var totalEventsCount = await getRawEventsCount();
        var totalRecordsCount = await getCurrentRecordsCount();

        // Load initial batch of events
        var events = await fetchEventsForInfiniteScroll(eventsOffset, eventsPageSize);
        loadedEvents = events;
        eventsOffset = events.length;
        hasMoreEvents = events.length === eventsPageSize;

        // Count new events (events with ID > appOpenedEventId)
        var newEventsCount = events.filter(e => e.id > appOpenedEventId).length;

        var html = '';

        // Events controls bar
        html += '<div class="events-controls">';
        html += '<div class="events-filter-group">';
        html += '<label>Type:</label>';
        html += '<select onchange="setEventsTypeFilter(this.value)">';
        html += '<option value=""' + (!eventsTypeFilter ? ' selected' : '') + '>All Events</option>';
        html += '<option value="current"' + (eventsTypeFilter === 'current' ? ' selected' : '') + '>All Records (' + ENTITY_TYPE_NAMES['current'] + ')</option>';
        ['INS', 'ALT', 'NUL', 'SYN', 'table', 'field', 'view', 'viewConfig'].forEach(function(t) {
            html += '<option value="' + t + '"' + (eventsTypeFilter === t ? ' selected' : '') + '>' + ENTITY_TYPE_NAMES[t] + '</option>';
        });
        html += '</select>';
        html += '</div>';

        html += '<div class="events-filter-group">';
        html += '<label>Table:</label>';
        html += '<select onchange="setEventsSetFilter(this.value)">';
        html += '<option value="">All Tables</option>';
        for (var tid in META_TABLES) {
            var tableName = META_TABLES[tid].tableName || tid;
            var setVal = 'airtable:' + tid;
            html += '<option value="' + esc(setVal) + '"' + (eventsSetFilter === setVal ? ' selected' : '') + '>' + esc(tableName) + '</option>';
        }
        html += '</select>';
        html += '</div>';

        html += '<div class="events-filter-group">';
        html += '<label>Search:</label>';
        html += '<input type="text" placeholder="Search events..." value="' + esc(eventsSearchQuery) + '" onkeydown="if(event.key===\'Enter\')setEventsSearch(this.value)">';
        html += '</div>';

        // Show loaded count and total
        html += '<div class="events-stats" id="events-stats">';
        if (eventsTypeFilter === 'current') {
            html += 'Loaded ' + loadedEvents.length.toLocaleString();
            html += ' <span style="color: #666;">(' + totalRecordsCount.toLocaleString() + ' total records)</span>';
        } else {
            html += 'Loaded ' + loadedEvents.length.toLocaleString();
            html += ' <span style="color: #666;">(' + totalEventsCount.toLocaleString() + ' total events)</span>';
            if (newEventsCount > 0) {
                html += ' <span class="new-event-badge">' + newEventsCount + ' new</span>';
            }
        }
        html += '</div>';

        // Import/Export buttons
        html += '<div class="events-actions">';
        html += '<button class="btn" onclick="exportEventsToCSV()" title="Export events to CSV">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>';
        html += ' Export CSV';
        html += '</button>';
        html += '<button class="btn" onclick="importEventsFromCSV()" title="Import events from CSV (deduplicates by ID)">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>';
        html += ' Import CSV';
        html += '</button>';
        html += '</div>';

        html += '</div>';

        // Events table
        html += '<table class="events-table">';
        html += '<thead><tr>';
        html += '<th style="width: 80px;">ID</th>';
        html += '<th style="width: 140px;">Timestamp</th>';
        html += '<th style="width: 90px;">Type</th>';
        html += '<th style="width: 140px;">Set</th>';
        html += '<th style="width: 130px;">Record ID</th>';
        html += '<th style="width: 140px;">Details</th>';
        html += '<th>Payload</th>';
        html += '<th style="width: 120px;">Actions</th>';
        html += '</tr></thead>';
        html += '<tbody id="events-tbody">';

        if (events.length === 0) {
            html += '<tr><td colspan="8" style="text-align: center; padding: 40px; color: #666;">No events found</td></tr>';
        } else {
            html += renderEventRows(events, newEventsCount);
        }

        html += '</tbody></table>';

        // Infinite scroll loading indicator
        html += '<div id="events-load-more" class="events-load-more" style="display: ' + (hasMoreEvents ? 'flex' : 'none') + ';">';
        html += '<div class="loading-spinner-small"></div>';
        html += '<span>Loading more events...</span>';
        html += '</div>';

        // End of events message
        html += '<div id="events-end-message" class="events-end-message" style="display: ' + (hasMoreEvents ? 'none' : 'block') + ';">';
        html += 'All events loaded';
        html += '</div>';

        container.innerHTML = html;

        // Set up infinite scroll
        setupEventsInfiniteScroll(container, totalEventsCount, totalRecordsCount);

    } catch (err) {
        console.error('Error loading events:', err);
        container.innerHTML = '<div class="empty-state"><h3>Error loading events</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Helper function to fetch events based on current filters
async function fetchEventsForInfiniteScroll(offset, limit) {
    var events = [];

    if (eventsTypeFilter === 'current') {
        events = await getCurrentRecordsPaginated(offset, limit, eventsSetFilter, eventsSearchQuery);
    } else {
        if (eventsSearchQuery) {
            events = await searchRawEvents(eventsSearchQuery, limit, offset);
        } else if (eventsSetFilter) {
            events = await getRawEventsBySetPaginated(eventsSetFilter, offset, limit);
        } else {
            events = await getRawEventsPaginated(offset, limit);
        }

        // Apply type filter if set (post-filter since we need to parse payload)
        if (eventsTypeFilter) {
            events = events.filter(e => {
                var payload = parsePayload(e.payload);
                var baseType = payload?._set || 'data';
                // For data events, resolve to operator type (INS/ALT/NUL)
                var type = baseType;
                if (baseType === 'data') {
                    if (e.operator) {
                        type = e.operator;
                    } else if (payload && payload.fields) {
                        if (payload.fields.INS) type = 'INS';
                        else if (payload.fields.ALT) type = 'ALT';
                        else if (payload.fields.NUL) type = 'NUL';
                        else if (payload.fields.SYN) type = 'SYN';
                    }
                }
                return type === eventsTypeFilter;
            });
        }
    }

    return events;
}

// Render multiple event rows and track new events divider
function renderEventRows(events, newEventsCount) {
    var html = '';
    var addedDivider = loadedEvents.length > events.length; // Divider already added if we've loaded more than initial batch

    for (var i = 0; i < events.length; i++) {
        var event = events[i];
        var isNew = event.id > appOpenedEventId;

        // Add divider between new and old events (only once)
        if (!addedDivider && !isNew && newEventsCount > 0) {
            html += '<tr class="new-events-divider"><td colspan="7"><span class="new-events-divider-text">Events when app opened</span></td></tr>';
            addedDivider = true;
        }

        html += renderEventRow(event, isNew);
    }

    return html;
}

// Set up infinite scroll for events
function setupEventsInfiniteScroll(container, totalEventsCount, totalRecordsCount) {
    eventsScrollHandler = function() {
        // Check if we're near the bottom (within 200px)
        var scrollTop = container.scrollTop;
        var scrollHeight = container.scrollHeight;
        var clientHeight = container.clientHeight;

        if (scrollHeight - scrollTop - clientHeight < 200) {
            loadMoreEvents(totalEventsCount, totalRecordsCount);
        }
    };

    container.addEventListener('scroll', eventsScrollHandler);
}

// Load more events for infinite scroll
async function loadMoreEvents(totalEventsCount, totalRecordsCount) {
    if (isLoadingMoreEvents || !hasMoreEvents) return;

    isLoadingMoreEvents = true;
    var loadMoreDiv = document.getElementById('events-load-more');
    if (loadMoreDiv) loadMoreDiv.style.display = 'flex';

    try {
        var newEvents = await fetchEventsForInfiniteScroll(eventsOffset, eventsPageSize);

        if (newEvents.length === 0) {
            hasMoreEvents = false;
        } else {
            // Add new events to loaded array
            loadedEvents = loadedEvents.concat(newEvents);
            eventsOffset += newEvents.length;
            hasMoreEvents = newEvents.length === eventsPageSize;

            // Count new events in this batch
            var newEventsCount = newEvents.filter(e => e.id > appOpenedEventId).length;

            // Append rows to tbody
            var tbody = document.getElementById('events-tbody');
            if (tbody) {
                var rowsHtml = renderEventRows(newEvents, newEventsCount);
                tbody.insertAdjacentHTML('beforeend', rowsHtml);
            }

            // Update stats
            updateEventsStats(totalEventsCount, totalRecordsCount);
        }
    } catch (err) {
        console.error('Error loading more events:', err);
    } finally {
        isLoadingMoreEvents = false;

        // Update loading indicator visibility
        var loadMoreDiv = document.getElementById('events-load-more');
        var endMessage = document.getElementById('events-end-message');

        if (loadMoreDiv) loadMoreDiv.style.display = hasMoreEvents ? 'none' : 'none';
        if (endMessage) endMessage.style.display = hasMoreEvents ? 'none' : 'block';
    }
}

// Update the events stats display
function updateEventsStats(totalEventsCount, totalRecordsCount) {
    var statsDiv = document.getElementById('events-stats');
    if (!statsDiv) return;

    var newEventsCount = loadedEvents.filter(e => e.id > appOpenedEventId).length;

    var html = '';
    if (eventsTypeFilter === 'current') {
        html += 'Loaded ' + loadedEvents.length.toLocaleString();
        html += ' <span style="color: #666;">(' + totalRecordsCount.toLocaleString() + ' total records)</span>';
    } else {
        html += 'Loaded ' + loadedEvents.length.toLocaleString();
        html += ' <span style="color: #666;">(' + totalEventsCount.toLocaleString() + ' total events)</span>';
        if (newEventsCount > 0) {
            html += ' <span class="new-event-badge">' + newEventsCount + ' new</span>';
        }
    }

    statsDiv.innerHTML = html;
}

function renderEventRow(event, isNew) {
    var payload = parsePayload(event.payload);
    var baseType = payload?._set || 'data';
    // For data events, show the operator (INS/ALT/NUL) instead of generic "data"
    var eventType = baseType;
    if (baseType === 'data') {
        if (event.operator) {
            eventType = event.operator;
        } else if (payload && payload.fields) {
            // Infer from payload fields
            if (payload.fields.INS) eventType = 'INS';
            else if (payload.fields.ALT) eventType = 'ALT';
            else if (payload.fields.NUL) eventType = 'NUL';
            else if (payload.fields.SYN) eventType = 'SYN';
        }
    }
    var isCurrentState = event._isCurrentState || eventType === 'current';
    var timestamp = event.created_at ? formatTimestamp(new Date(event.created_at).getTime()) : (isCurrentState ? 'Current' : 'Unknown');
    var isExpanded = expandedPayloads.has(event.id || event.recordId);

    var rowClass = isNew ? 'new-event' : (isCurrentState ? 'current-state-row' : '');
    var html = '<tr data-event-id="' + (event.id || event.recordId) + '"' + (rowClass ? ' class="' + rowClass + '"' : '') + '>';

    // ID column - show "" for current state
    if (isCurrentState) {
        html += '<td><span class="event-id current-state"></span></td>';
    } else {
        html += '<td><span class="event-id">' + event.id + (isNew ? '<span class="new-event-badge">NEW</span>' : '') + '</span></td>';
    }

    html += '<td><span class="event-timestamp">' + esc(timestamp) + '</span></td>';
    html += '<td><span class="event-type-badge ' + eventType + '">' + esc(ENTITY_TYPE_NAMES[eventType] || eventType) + '</span></td>';
    var setTableId = (event.set || '').replace('airtable:', '');
    var setDisplayName = (META_TABLES[setTableId] && META_TABLES[setTableId].tableName) || event.set || '';
    html += '<td><span class="event-set" title="' + esc(event.set || '') + '">' + esc(setDisplayName) + '</span></td>';
    html += '<td><span class="event-record-id">' + esc(event.recordId || '') + '</span></td>';

    // Details column - show field operation types and counts
    html += '<td class="event-details">';
    var fieldOps = getFieldOperationDetails(payload);
    if (fieldOps) {
        fieldOps.forEach(function(op) {
            html += '<span class="field-op-badge ' + op.type + '">' + op.type + ' <span class="field-count">' + op.label + '</span></span>';
        });
    } else if (eventType !== 'data') {
        html += '<span style="color: #9ca3af; font-size: 11px;"></span>';
    } else {
        html += '<span style="color: #9ca3af; font-size: 11px;"></span>';
    }
    html += '</td>';

    // Payload preview
    html += '<td class="payload-preview-container">';
    html += '<div class="payload-preview' + (isExpanded ? ' expanded' : '') + '" onclick="togglePayloadExpand(\'' + (event.id || event.recordId) + '\')">';
    html += formatPayloadPreview(payload, isExpanded);
    if (!isExpanded) {
        html += '<span class="payload-expand-btn">Expand</span>';
    } else {
        html += '<span class="payload-expand-btn">Collapse</span>';
    }
    html += '</div>';
    html += '</td>';

    // Actions
    html += '<td class="event-actions">';
    if (event.recordId && event.recordId.startsWith('rec')) {
        if (isCurrentState) {
            // For current state, show "View Record" button that opens profile
            var tableId = (event.set || '').replace('airtable:', '');
            html += '<button class="event-action-btn primary" onclick="openRecordProfile(\'' + esc(tableId) + '\', \'' + esc(event.recordId) + '\')" title="View full record details">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M2 4h12M2 8h12M2 12h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';
            html += 'View Record';
            html += '</button>';
        } else {
            html += '<button class="event-action-btn primary" onclick="viewRecordAtPointInTime(' + event.id + ', \'' + esc(event.recordId) + '\', \'' + esc(event.set || '') + '\')" title="View record state at this point in time">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M8 3v5l3 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="1.5"/></svg>';
            html += 'View State';
            html += '</button>';
        }
    }
    html += '</td>';

    html += '</tr>';
    return html;
}

function getFieldOperationDetails(payload) {
    if (!payload || !payload.fields) return null;

    var fields = payload.fields;
    var details = [];

    if (fields.INS && typeof fields.INS === 'object') {
        var count = Object.keys(fields.INS).length;
        details.push({ type: 'INS', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    if (fields.ALT && typeof fields.ALT === 'object') {
        var count = Object.keys(fields.ALT).length;
        details.push({ type: 'ALT', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    if (fields.NUL && Array.isArray(fields.NUL)) {
        var count = fields.NUL.length;
        if (count > 0) {
            details.push({ type: 'NUL', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
        }
    }

    if (fields.SYN && typeof fields.SYN === 'object') {
        var count = Object.keys(fields.SYN).length;
        details.push({ type: 'SYN', count: count, label: count + ' field' + (count !== 1 ? 's' : '') });
    }

    return details.length > 0 ? details : null;
}

function formatPayloadPreview(payload, expanded) {
    if (!payload) return '<span class="json-null">null</span>';

    // Try to extract INS/ALT/NUL field data for nice display
    var fields = payload.fields;
    var hasFieldData = fields && (fields.INS || fields.ALT || fields.NUL || fields.SYN);

    if (hasFieldData) {
        return formatPayloadFields(fields, expanded);
    }

    // Check if payload has context.data (alternative structure)
    if (payload.context && payload.context.data) {
        return formatPayloadFields({ INS: payload.context.data }, expanded);
    }

    // Fallback to raw JSON display
    try {
        var str = typeof payload === 'string' ? payload : JSON.stringify(payload, null, expanded ? 2 : 0);

        // Apply syntax highlighting
        str = esc(str)
            .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span>:')
            .replace(/: "([^"]*)"([,\n\}])/g, ': <span class="json-string">"$1"</span>$2')
            .replace(/: (-?\d+\.?\d*)([,\n\}])/g, ': <span class="json-number">$1</span>$2')
            .replace(/: (true|false)([,\n\}])/g, ': <span class="json-boolean">$1</span>$2')
            .replace(/: (null)([,\n\}])/g, ': <span class="json-null">$1</span>$2');

        return str;
    } catch (e) {
        return esc(String(payload));
    }
}

function formatPayloadFields(fields, expanded) {
    var html = '<div class="payload-fields">';
    var ops = ['INS', 'ALT', 'NUL'];
    var hasAnyFields = false;

    for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        var data = fields[op];
        if (!data) continue;

        // NUL is an array of field names, INS/ALT are objects
        if (op === 'NUL' && Array.isArray(data) && data.length > 0) {
            hasAnyFields = true;
            html += '<div class="payload-op-group">';
            html += '<span class="payload-op-label ' + op + '">' + op + '</span>';
            html += '<div class="payload-field-row">';
            html += '<span class="payload-field-value null">' + esc(data.join(', ')) + '</span>';
            html += '</div></div>';
        } else if (typeof data === 'object' && !Array.isArray(data)) {
            var keys = Object.keys(data);
            if (keys.length === 0) continue;

            hasAnyFields = true;
            html += '<div class="payload-op-group">';
            html += '<span class="payload-op-label ' + op + '">' + op + '</span>';

            // In collapsed mode, show limited fields
            var displayKeys = expanded ? keys : keys.slice(0, 3);

            for (var j = 0; j < displayKeys.length; j++) {
                var key = displayKeys[j];
                var value = data[key];
                html += '<div class="payload-field-row">';
                html += '<span class="payload-field-name">' + esc(getFieldDisplayName(key)) + '</span>';
                html += '<span class="payload-field-value ' + getValueClass(value) + '">' + formatFieldValue(value, expanded) + '</span>';
                html += '</div>';
            }

            if (!expanded && keys.length > 3) {
                html += '<div class="payload-field-row" style="color: #9ca3af; font-style: italic;">+' + (keys.length - 3) + ' more fields</div>';
            }

            html += '</div>';
        }
    }

    html += '</div>';
    return hasAnyFields ? html : '<span class="json-null">no field data</span>';
}

function getFieldDisplayName(fieldId) {
    // Try to get human-readable field name from schema
    if (window.fields && window.fields[fieldId]) {
        return window.fields[fieldId].name || fieldId;
    }
    // Truncate long field IDs
    if (fieldId.length > 20) {
        return fieldId.substring(0, 17) + '...';
    }
    return fieldId;
}

function getValueClass(value) {
    if (value === null || value === undefined) return 'null';
    if (Array.isArray(value)) return 'array';
    if (typeof value === 'object') return 'object';
    if (typeof value === 'number') return 'number';
    if (typeof value === 'boolean') return 'boolean';
    return 'string';
}

function formatFieldValue(value, expanded) {
    if (value === null || value === undefined) return 'null';

    if (Array.isArray(value)) {
        if (value.length === 0) return '[]';
        if (!expanded && value.length > 2) {
            return '[' + esc(String(value[0])) + ', ... +' + (value.length - 1) + ']';
        }
        return '[' + value.map(function(v) { return esc(String(v)); }).join(', ') + ']';
    }

    if (typeof value === 'object') {
        var keys = Object.keys(value);
        if (keys.length === 0) return '{}';
        if (!expanded) return '{' + keys.length + ' keys}';
        return esc(JSON.stringify(value));
    }

    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'number') return String(value);

    // String value - truncate if too long
    var str = String(value);
    if (!expanded && str.length > 50) {
        return esc(str.substring(0, 47)) + '...';
    }
    return esc(str);
}

function togglePayloadExpand(eventId) {
    if (expandedPayloads.has(eventId)) {
        expandedPayloads.delete(eventId);
    } else {
        expandedPayloads.add(eventId);
    }

    // Find the row and update just the payload cell instead of re-rendering everything
    var row = document.querySelector('tr[data-event-id="' + eventId + '"]');
    if (row) {
        var event = loadedEvents.find(e => (e.id || e.recordId) == eventId);
        if (event) {
            var payload = parsePayload(event.payload);
            var isExpanded = expandedPayloads.has(eventId);
            var payloadCell = row.querySelector('.payload-preview-container');
            if (payloadCell) {
                var html = '<div class="payload-preview' + (isExpanded ? ' expanded' : '') + '" onclick="togglePayloadExpand(\'' + eventId + '\')">';
                html += formatPayloadPreview(payload, isExpanded);
                if (!isExpanded) {
                    html += '<span class="payload-expand-btn">Expand</span>';
                } else {
                    html += '<span class="payload-expand-btn">Collapse</span>';
                }
                html += '</div>';
                payloadCell.innerHTML = html;
            }
        }
    }
}

function setEventsTypeFilter(type) {
    eventsTypeFilter = type;
    renderEventsView();
}

function setEventsSetFilter(set) {
    eventsSetFilter = set;
    renderEventsView();
}

function setEventsSearch(query) {
    eventsSearchQuery = query;
    renderEventsView();
}

// ============ Events CSV Export/Import ============

async function exportEventsToCSV() {
    try {
        // Show progress
        showImportStatus('Exporting...', 'Collecting events from database...', 'progress', 0);

        // Get all events from IndexedDB
        var allEvents = [];
        var batchSize = 1000;
        var offset = 0;
        var totalCount = await getRawEventsCount();

        while (true) {
            var batch = await getRawEventsPaginated(offset, batchSize);
            if (batch.length === 0) break;
            allEvents = allEvents.concat(batch);
            offset += batch.length;

            var progress = Math.round((allEvents.length / totalCount) * 50);
            showImportStatus('Exporting...', 'Collected ' + allEvents.length.toLocaleString() + ' of ' + totalCount.toLocaleString() + ' events', 'progress', progress);
        }

        if (allEvents.length === 0) {
            showImportStatus('No Events', 'No events to export.', 'error');
            return;
        }

        showImportStatus('Exporting...', 'Building CSV file...', 'progress', 60);

        // CSV header
        var csvLines = ['id,set,recordId,created_at,payload'];

        // Convert events to CSV rows
        for (var i = 0; i < allEvents.length; i++) {
            var event = allEvents[i];
            var payloadStr = typeof event.payload === 'string' ? event.payload : JSON.stringify(event.payload);

            // Escape CSV fields
            var row = [
                event.id,
                escapeCSVField(event.set || ''),
                escapeCSVField(event.recordId || ''),
                escapeCSVField(event.created_at || ''),
                escapeCSVField(payloadStr)
            ];
            csvLines.push(row.join(','));

            if (i % 1000 === 0) {
                var progress = 60 + Math.round((i / allEvents.length) * 30);
                showImportStatus('Exporting...', 'Processing event ' + i.toLocaleString() + ' of ' + allEvents.length.toLocaleString(), 'progress', progress);
            }
        }

        showImportStatus('Exporting...', 'Creating download...', 'progress', 95);

        // Create and download file
        var csvContent = csvLines.join('\n');
        var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        var url = URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = url;
        link.download = 'events_export_' + new Date().toISOString().slice(0, 10) + '.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        showImportStatus('Export Complete', 'Exported ' + allEvents.length.toLocaleString() + ' events to CSV.', 'success');

    } catch (err) {
        console.error('Error exporting events:', err);
        showImportStatus('Export Failed', err.message, 'error');
    }
}

function escapeCSVField(value) {
    if (value === null || value === undefined) return '';
    var str = String(value);
    // If contains comma, newline, or quote, wrap in quotes and escape inner quotes
    if (str.includes(',') || str.includes('\n') || str.includes('"') || str.includes('\r')) {
        return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
}

function parseCSVLine(line) {
    var result = [];
    var current = '';
    var inQuotes = false;
    var i = 0;

    while (i < line.length) {
        var char = line[i];

        if (inQuotes) {
            if (char === '"') {
                // Check for escaped quote
                if (i + 1 < line.length && line[i + 1] === '"') {
                    current += '"';
                    i += 2;
                    continue;
                } else {
                    inQuotes = false;
                    i++;
                    continue;
                }
            }
            current += char;
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === ',') {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        i++;
    }
    result.push(current);
    return result;
}

async function importEventsFromCSV() {
    // Create file input
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;

        try {
            showImportStatus('Importing...', 'Reading file...', 'progress', 0);

            var text = await file.text();
            var lines = text.split(/\r?\n/);

            if (lines.length < 2) {
                showImportStatus('Import Failed', 'CSV file is empty or has no data rows.', 'error');
                return;
            }

            // Parse header
            var header = parseCSVLine(lines[0]);
            var idIndex = header.indexOf('id');
            var setIndex = header.indexOf('set');
            var recordIdIndex = header.indexOf('recordId');
            var createdAtIndex = header.indexOf('created_at');
            var payloadIndex = header.indexOf('payload');

            if (idIndex === -1) {
                showImportStatus('Import Failed', 'CSV must have an "id" column.', 'error');
                return;
            }

            showImportStatus('Importing...', 'Parsing CSV data...', 'progress', 10);

            // Parse all event rows
            var events = [];
            for (var i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                var fields = parseCSVLine(lines[i]);
                var event = {
                    id: parseInt(fields[idIndex], 10)
                };

                if (isNaN(event.id)) continue; // Skip invalid IDs

                if (setIndex !== -1) event.set = fields[setIndex] || '';
                if (recordIdIndex !== -1) event.recordId = fields[recordIdIndex] || '';
                if (createdAtIndex !== -1) event.created_at = fields[createdAtIndex] || '';
                if (payloadIndex !== -1) {
                    var payloadStr = fields[payloadIndex] || '{}';
                    try {
                        event.payload = JSON.parse(payloadStr);
                    } catch (e) {
                        event.payload = payloadStr;
                    }
                }

                events.push(event);

                if (i % 1000 === 0) {
                    showImportStatus('Importing...', 'Parsed ' + events.length.toLocaleString() + ' events...', 'progress', 10 + Math.round((i / lines.length) * 20));
                }
            }

            if (events.length === 0) {
                showImportStatus('Import Failed', 'No valid events found in CSV.', 'error');
                return;
            }

            showImportStatus('Importing...', 'Checking for duplicates...', 'progress', 35);

            // Get existing event IDs from IndexedDB for deduplication
            var existingIds = await getExistingEventIds();

            showImportStatus('Importing...', 'Found ' + existingIds.size.toLocaleString() + ' existing events. Filtering duplicates...', 'progress', 50);

            // Filter out duplicates
            var newEvents = events.filter(function(e) {
                return !existingIds.has(e.id);
            });

            var duplicateCount = events.length - newEvents.length;

            if (newEvents.length === 0) {
                showImportStatus('Import Complete', 'All ' + events.length.toLocaleString() + ' events already exist (no new events to import).', 'success');
                return;
            }

            showImportStatus('Importing...', 'Importing ' + newEvents.length.toLocaleString() + ' new events (skipping ' + duplicateCount.toLocaleString() + ' duplicates)...', 'progress', 60);

            // Import events in batches
            var batchSize = 500;
            var imported = 0;

            for (var j = 0; j < newEvents.length; j += batchSize) {
                var batch = newEvents.slice(j, j + batchSize);
                await saveRawEvents(batch);
                imported += batch.length;

                var progress = 60 + Math.round((imported / newEvents.length) * 35);
                showImportStatus('Importing...', 'Imported ' + imported.toLocaleString() + ' of ' + newEvents.length.toLocaleString() + ' events...', 'progress', progress);
            }

            showImportStatus('Import Complete',
                'Imported ' + newEvents.length.toLocaleString() + ' new events' +
                (duplicateCount > 0 ? ' (skipped ' + duplicateCount.toLocaleString() + ' duplicates)' : '') + '.',
                'success');

            // Refresh the events view
            if (currentTable === '_events') {
                renderEventsView();
            }

        } catch (err) {
            console.error('Error importing events:', err);
            showImportStatus('Import Failed', err.message, 'error');
        }
    };

    input.click();
}

async function getExistingEventIds() {
    return new Promise(function(resolve, reject) {
        var tx = db.transaction('events', 'readonly');
        var store = tx.objectStore('events');
        var ids = new Set();

        var req = store.openKeyCursor();
        req.onsuccess = function(e) {
            var cursor = e.target.result;
            if (cursor) {
                ids.add(cursor.key);
                cursor.continue();
            } else {
                resolve(ids);
            }
        };
        req.onerror = function() {
            reject(req.error);
        };
    });
}

function showImportStatus(title, details, type, progress) {
    var existing = document.querySelector('.import-status');
    if (existing) existing.remove();

    var div = document.createElement('div');
    div.className = 'import-status' + (type === 'success' ? ' success' : type === 'error' ? ' error' : '');

    var icon = type === 'success' ? '' : type === 'error' ? '' : '';
    var titleClass = type === 'success' ? ' success' : type === 'error' ? ' error' : '';

    div.innerHTML = '<div class="import-status-title' + titleClass + '">' + icon + ' ' + esc(title) + '</div>' +
                    '<div class="import-status-details">' + esc(details) + '</div>' +
                    (type === 'progress' ? '<div class="import-progress"><div class="import-progress-bar" style="width: ' + (progress || 0) + '%"></div></div>' : '');

    document.body.appendChild(div);

    // Auto-remove success/error messages after 5 seconds
    if (type === 'success' || type === 'error') {
        setTimeout(function() {
            if (div.parentNode) div.remove();
        }, 5000);
    }
}

// Skip setup and upload CSV file directly
var skipSyncAbortController = null;

// Build in-memory lookup map for events by recordId
function buildInMemoryEventsByRecord(events) {
    var map = new Map();
    for (var i = 0; i < events.length; i++) {
        var e = events[i];
        if (e.recordId) {
            if (!map.has(e.recordId)) {
                map.set(e.recordId, []);
            }
            map.get(e.recordId).push(e);
        }
    }
    return map;
}

// Background save events to IndexedDB (non-blocking)
async function backgroundSaveToIndexedDB(events, onProgress) {
    isBackgroundSaveInProgress = true;
    var batchSize = 500;
    var saved = 0;
    var total = events.length;

    try {
        // Phase 1: Save raw events
        for (var j = 0; j < events.length; j += batchSize) {
            var batch = events.slice(j, j + batchSize);
            await saveRawEvents(batch);
            saved += batch.length;

            if (onProgress) {
                onProgress(saved, total);
            }

            // Yield to main thread periodically to keep UI responsive
            if (j % 2000 === 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Phase 2: Save metadata (tables, fields, views)
        var tables = Object.values(META_TABLES);
        var fields = [];
        for (var tid in META_FIELDS) {
            for (var fid in META_FIELDS[tid]) {
                fields.push(META_FIELDS[tid][fid]);
            }
        }
        var views = [];
        for (var tid in META_VIEWS) {
            for (var vid in META_VIEWS[tid]) {
                views.push(META_VIEWS[tid][vid]);
            }
        }

        // Phase 3: Save data records from IN_MEMORY_DATA
        var dataRecords = [];
        if (window.IN_MEMORY_DATA) {
            for (var tableId in window.IN_MEMORY_DATA) {
                for (var recordId in window.IN_MEMORY_DATA[tableId]) {
                    dataRecords.push({
                        tableId: tableId,
                        recordId: recordId,
                        fields: window.IN_MEMORY_DATA[tableId][recordId]
                    });
                }
            }
        }

        // Save metadata and records in batch
        if (tables.length || fields.length || views.length || dataRecords.length) {
            await saveBatch(tables, fields, views, dataRecords);
        }

        // Phase 4: Build and save field history from raw events
        // Group events by tableId and recordId, then build history for each record
        // Only process data events (set starts with 'airtable:')
        var eventsByTableAndRecord = {};
        for (var i = 0; i < events.length; i++) {
            var evt = events[i];
            if (evt.recordId && evt.set && evt.set.startsWith('airtable:')) {
                var tableId = evt.set.replace('airtable:', '');
                var key = tableId + '|' + evt.recordId;
                if (!eventsByTableAndRecord[key]) {
                    eventsByTableAndRecord[key] = { tableId: tableId, recordId: evt.recordId, events: [] };
                }
                eventsByTableAndRecord[key].events.push(evt);
            }
        }

        var allFieldHistoryEntries = [];
        var recordKeys = Object.keys(eventsByTableAndRecord);
        for (var k = 0; k < recordKeys.length; k++) {
            var group = eventsByTableAndRecord[recordKeys[k]];
            var historyEntries = buildFieldHistoryFromRawEvents(group.tableId, group.recordId, group.events);
            allFieldHistoryEntries = allFieldHistoryEntries.concat(historyEntries);

            // Yield periodically to keep UI responsive
            if (k % 500 === 0 && k > 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Save field history in batches
        if (allFieldHistoryEntries.length > 0) {
            for (var h = 0; h < allFieldHistoryEntries.length; h += batchSize) {
                var historyBatch = allFieldHistoryEntries.slice(h, h + batchSize);
                await saveFieldHistory(historyBatch);
            }
            console.log('Saved ' + allFieldHistoryEntries.length + ' field history entries');
        }

        // Update the last event timestamp in IndexedDB
        var maxId = events.reduce(function(max, e) { return Math.max(max, e.id); }, 0);
        var lastEvent = events.find(function(e) { return e.id === maxId; });
        if (lastEvent && lastEvent.created_at) {
            await setSyncMeta('lastEventTimestamp', lastEvent.created_at);
        }

        console.log('Background IndexedDB save complete: ' + saved + ' events, ' + dataRecords.length + ' records');

        // Clear in-memory cache after successful IndexedDB save to free memory
        // (functions will now read from IndexedDB)
        inMemoryEvents = null;
        inMemoryEventsByRecord = null;
        window.IN_MEMORY_DATA = null;

    } catch (err) {
        console.error('Background IndexedDB save failed:', err);
        // Keep in-memory cache if save failed
    } finally {
        isBackgroundSaveInProgress = false;
    }
}

async function skipSetupAndUploadFile() {
    // Create file input
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';

    input.onchange = async function(e) {
        var file = e.target.files[0];
        if (!file) return;

        try {
            // Update the loading overlay to show import progress
            updateLoadingOverlay('Importing from file...', 'Reading CSV...', 5, 0, 0, 0, 'Starting import...');

            var text = await file.text();
            var lines = text.split(/\r?\n/);

            if (lines.length < 2) {
                alert('CSV file is empty or has no data rows.');
                return;
            }

            // Parse header
            var header = parseCSVLine(lines[0]);
            var idIndex = header.indexOf('id');
            var setIndex = header.indexOf('set');
            var recordIdIndex = header.indexOf('recordId');
            var createdAtIndex = header.indexOf('created_at');
            var payloadIndex = header.indexOf('payload');

            if (idIndex === -1) {
                alert('CSV must have an "id" column.');
                return;
            }

            updateLoadingOverlay('Importing from file...', 'Parsing CSV data...', 10, 0, 0, 0, '');

            // Parse all event rows
            var events = [];
            var tablesCount = 0;
            var fieldsCount = 0;
            var recordsCount = 0;

            for (var i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                var fields = parseCSVLine(lines[i]);
                var event = {
                    id: parseInt(fields[idIndex], 10)
                };

                if (isNaN(event.id)) continue;

                if (setIndex !== -1) event.set = fields[setIndex] || '';
                if (recordIdIndex !== -1) event.recordId = fields[recordIdIndex] || '';
                if (createdAtIndex !== -1) event.created_at = fields[createdAtIndex] || '';
                if (payloadIndex !== -1) {
                    var payloadStr = fields[payloadIndex] || '{}';
                    try {
                        event.payload = JSON.parse(payloadStr);
                    } catch (err) {
                        event.payload = payloadStr;
                    }
                }

                events.push(event);

                // Count types for progress display
                if (event.payload && event.payload._set) {
                    if (event.payload._set === 'table') tablesCount++;
                    else if (event.payload._set === 'field') fieldsCount++;
                    else recordsCount++;
                } else {
                    recordsCount++;
                }

                if (i % 5000 === 0) {
                    var progress = 10 + Math.round((i / lines.length) * 40);
                    updateLoadingOverlay('Importing from file...', 'Parsed ' + events.length.toLocaleString() + ' events...', progress, tablesCount, fieldsCount, recordsCount, '');
                }
            }

            if (events.length === 0) {
                alert('No valid events found in CSV.');
                return;
            }

            // Sort events by ID to ensure proper order
            events.sort(function(a, b) { return a.id - b.id; });

            updateLoadingOverlay('Importing from file...', 'Processing ' + events.length.toLocaleString() + ' events...', 55, tablesCount, fieldsCount, recordsCount, '');

            // Store events in memory for instant access (before IndexedDB save)
            inMemoryEvents = events;
            inMemoryEventsByRecord = buildInMemoryEventsByRecord(events);

            // Process events using fast memory-only approach (no IndexedDB)
            await processEventsMemoryOnly(events, function(processed, total, tableCount) {
                var pct = 55 + Math.round((processed / total) * 30);
                updateLoadingOverlay('Importing from file...', 'Processing events: ' + processed.toLocaleString() + ' / ' + total.toLocaleString(), pct, tableCount, fieldsCount, recordsCount, '');
            });

            // Update the last event timestamp in memory
            var maxId = events.reduce(function(max, e) { return Math.max(max, e.id); }, 0);
            var lastEvent = events.find(function(e) { return e.id === maxId; });
            if (lastEvent && lastEvent.created_at) {
                lastEventTimestamp = lastEvent.created_at;
            }

            updateLoadingOverlay('Import complete!', 'Rendering interface...', 90, tablesCount, fieldsCount, recordsCount, '');

            // Render the UI immediately - data is in memory
            await renderSidebar();

            // Auto-select first table
            var firstTable = Object.keys(META_TABLES)[0];
            if (firstTable) {
                await showTable(firstTable);
            }

            // Hide overlay - app is ready to use!
            updateLoadingOverlay('Import complete!', events.length.toLocaleString() + ' events loaded', 100, tablesCount, fieldsCount, recordsCount, '');
            setTimeout(hideLoadingOverlay, 300);

            updateStatus(API_KEY ? 'Up to date' : 'Offline mode', true, null, null);

            // Start the refresh indicator countdown
            lastSyncTime = Date.now();
            startRefreshCountdown();

            // Start incremental sync polling (but don't block on it)
            if (API_KEY) {
                if (pollInterval) clearInterval(pollInterval);
                pollInterval = setInterval(incrementalSync, 60000);

                // Start background polling for new events (lightweight 15s checks)
                SyncHistory.startPolling();
            }

            updateConnectApiButton();

            // Background: Save to IndexedDB for next visit (non-blocking)
            // This happens after the UI is ready, so user can start working immediately
            updateStatus('Caching locally...', true, null, null);
            backgroundSaveToIndexedDB(events, function(saved, total) {
                var pct = Math.round((saved / total) * 100);
                updateStatus('Caching: ' + pct + '%', true, null, null);
            }).then(function() {
                updateStatus('Up to date', true, null, null);
            });

        } catch (err) {
            console.error('Error importing file:', err);
            alert('Error importing file: ' + err.message);
        }
    };

    input.click();
}

// ============ Point in Time View ============

async function viewRecordAtPointInTime(eventId, recordId, set) {
    var overlay = document.getElementById('pit-modal-overlay');
    var body = document.getElementById('pit-modal-body');

    // Show loading state
    body.innerHTML = '<div class="pit-empty-state"><div class="loading-spinner"></div><h3>Replaying events...</h3><p>Building record state at event #' + eventId + '</p></div>';
    overlay.classList.add('open');

    try {
        // Get all events for this record up to the specified event ID
        var events = await getRawEventsByRecordId(recordId, eventId);

        if (events.length === 0) {
            body.innerHTML = '<div class="pit-empty-state"><h3>No events found</h3><p>Could not find any events for this record.</p></div>';
            return;
        }

        // Determine the table ID from the set
        var tableId = set ? set.replace('airtable:', '') : null;

        // Replay events to build the record state
        var recordState = {};
        var lastTimestamp = null;

        for (var e of events) {
            var payload = parsePayload(e.payload);
            if (!payload || !payload.fields) continue;

            var fields = payload.fields;

            // Default first ALT as INS if record state is empty and no INS exists
            if (Object.keys(recordState).length === 0 && !fields.INS && fields.ALT) {
                fields = { INS: fields.ALT, NUL: fields.NUL };
            }

            // Apply INS (insert)
            if (fields.INS) {
                Object.assign(recordState, fields.INS);
            }

            // Apply ALT (alter)
            if (fields.ALT) {
                Object.assign(recordState, fields.ALT);
            }

            // Apply NUL (nullify)
            if (fields.NUL && Array.isArray(fields.NUL)) {
                fields.NUL.forEach(k => delete recordState[k]);
            }

            if (e.created_at) {
                lastTimestamp = e.created_at;
            }
        }

        // Update modal header
        var tableName = META_TABLES[tableId]?.tableName || tableId || 'Unknown Table';
        document.getElementById('pit-modal-title').textContent = tableName;
        document.getElementById('pit-modal-event-badge').textContent = 'Event #' + eventId;
        document.getElementById('pit-modal-timestamp').textContent = lastTimestamp ? formatTimestamp(new Date(lastTimestamp).getTime()) : '';

        // Render the record state
        var html = '<div class="pit-record-card">';
        html += '<div class="pit-record-header">';
        html += '<span class="pit-table-name">' + esc(tableName) + '</span>';
        html += '<span class="pit-record-id">' + esc(recordId) + '</span>';
        if (tableId && META_TABLES[tableId]) {
            html += '<button class="event-action-btn pit-go-to-table" onclick="goToRecordInTable(\'' + esc(tableId) + '\', \'' + esc(recordId) + '\')">';
            html += '<svg width="12" height="12" viewBox="0 0 16 16" fill="none"><path d="M6 3L11 8L6 13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
            html += 'View Current Record';
            html += '</button>';
        }
        html += '</div>';

        html += '<div class="pit-record-fields">';

        var fieldIds = Object.keys(recordState);
        if (fieldIds.length === 0) {
            html += '<div class="pit-empty-state">No fields recorded at this point in time</div>';
        } else {
            // Sort fields by name
            var fieldsInfo = META_FIELDS[tableId] || {};
            fieldIds.sort((a, b) => {
                var nameA = (fieldsInfo[a]?.fieldName || a).toLowerCase();
                var nameB = (fieldsInfo[b]?.fieldName || b).toLowerCase();
                return nameA.localeCompare(nameB);
            });

            for (var fieldId of fieldIds) {
                var fieldName = fieldsInfo[fieldId]?.fieldName || fieldId;
                var value = recordState[fieldId];

                html += '<div class="pit-field-row">';
                html += '<div class="pit-field-name">' + esc(fieldName) + '</div>';
                html += '<div class="pit-field-value">' + formatHistoryValue(value) + '</div>';
                html += '</div>';
            }
        }

        html += '</div>'; // .pit-record-fields
        html += '</div>'; // .pit-record-card

        body.innerHTML = html;

    } catch (err) {
        console.error('Error viewing record at point in time:', err);
        body.innerHTML = '<div class="pit-empty-state"><h3>Error</h3><p>' + esc(err.message) + '</p></div>';
    }
}

function closePitModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('pit-modal-overlay').classList.remove('open');
}

function goToRecordInTable(tableId, recordId) {
    closePitModal();
    showTable(tableId);
    // Open the record profile after navigating
    setTimeout(function() {
        openRecordProfile(tableId, recordId);
    }, 100);
}

// ============ Record Profile Panel ============

var profileCurrentTableId = null;
var profileCurrentRecordId = null;
var profileConfigureMode = false;
var profileFieldPicker = null;

// Default profile configuration - one block with all visible fields in 2 columns
function getDefaultProfileConfig(tableId, viewId) {
    var visibleFields = getVisibleFieldsForView(tableId, viewId || '_default');
    return {
        blocks: [
            {
                id: 'block-1',
                columns: 2,
                fieldIds: visibleFields.slice()
            }
        ]
    };
}

// Get profile configuration for a view
// Returns { config: {...}, isDefault: boolean }
function getProfileConfig(tableId, viewId) {
    var view = META_VIEWS[tableId]?.[viewId || '_default'];
    if (view && view.profileConfig && view.profileConfig.blocks && view.profileConfig.blocks.length > 0) {
        return { config: view.profileConfig, isDefault: false };
    }
    return { config: getDefaultProfileConfig(tableId, viewId), isDefault: true };
}

// Save profile configuration for a view
async function saveProfileConfig(tableId, viewId, config) {
    viewId = viewId || '_default';
    if (!META_VIEWS[tableId]) META_VIEWS[tableId] = {};
    if (!META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId] = {
            tableId: tableId,
            viewId: viewId,
            viewName: viewId === '_default' ? 'All Fields' : viewId
        };
    }
    META_VIEWS[tableId][viewId].profileConfig = config;
    await saveView(META_VIEWS[tableId][viewId]);
}

// Open record profile panel
async function openRecordProfile(tableId, recordId, viewId) {
    profileCurrentTableId = tableId;
    profileCurrentRecordId = recordId;

    // Use current view if not specified
    if (!viewId && tableId === currentTable) {
        viewId = currentView;
    }

    var overlay = document.getElementById('record-profile-overlay');
    overlay.classList.add('open');

    // Update header
    var tableName = META_TABLES[tableId]?.tableName || tableId;
    document.getElementById('profile-title').textContent = tableName;

    // Show view name
    var actualViewId = viewId || currentView || '_default';
    var viewData = META_VIEWS[tableId]?.[actualViewId];
    var viewName = viewData?.viewName || (actualViewId === '_default' ? 'All Fields' : actualViewId);
    document.getElementById('profile-view-name').textContent = viewName;

    document.getElementById('profile-record-id').textContent = recordId;

    // Reset configure mode
    profileConfigureMode = false;
    document.getElementById('profile-body').classList.remove('configure-mode');
    document.getElementById('profile-add-block-btn').style.display = 'none';
    document.getElementById('profile-configure-btn').innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg> Configure';

    // Reset to details tab
    profileCurrentTab = 'details';
    document.querySelectorAll('.profile-tab').forEach(function(tab) {
        tab.classList.toggle('active', tab.dataset.tab === 'details');
    });
    document.getElementById('profile-tab-details').classList.add('active');
    document.getElementById('profile-tab-sync-history').classList.remove('active');

    // Render profile content
    await renderRecordProfile();

    // Update navigation
    updateProfileNavigation();
}

// Close record profile panel
function closeRecordProfile(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('record-profile-overlay').classList.remove('open');
    closeFieldPicker();
    profileCurrentTableId = null;
    profileCurrentRecordId = null;
}

// Render the record profile content
async function renderRecordProfile() {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var body = document.getElementById('profile-body');
    var viewId = currentView || '_default';

    // Get record data
    var records = await getRecordsByIds(profileCurrentTableId, [profileCurrentRecordId]);
    if (records.length === 0) {
        body.innerHTML = '<div class="profile-empty-state">Record not found</div>';
        return;
    }

    var record = records[0];
    var recordFields = record.fields || {};
    var fields = META_FIELDS[profileCurrentTableId] || {};

    // Get profile configuration
    var profileResult = getProfileConfig(profileCurrentTableId, viewId);
    var config = profileResult.config;
    var isDefaultConfig = profileResult.isDefault;

    var html = '';

    config.blocks.forEach(function(block, blockIndex) {
        html += '<div class="profile-block" data-block-index="' + blockIndex + '">';

        // Block header (visible in configure mode)
        html += '<div class="profile-block-header">';
        html += '<span class="block-drag-handle" draggable="true" ondragstart="handleBlockDragStart(event, ' + blockIndex + ')" ondragover="handleBlockDragOver(event)" ondrop="handleBlockDrop(event, ' + blockIndex + ')">&#8942;&#8942;</span>';
        html += '<span class="block-title">Block ' + (blockIndex + 1) + '</span>';
        html += '<select class="block-cols-select" onchange="setBlockColumns(' + blockIndex + ', this.value)">';
        html += '<option value="1"' + (block.columns === 1 ? ' selected' : '') + '>1 column</option>';
        html += '<option value="2"' + (block.columns === 2 ? ' selected' : '') + '>2 columns</option>';
        html += '<option value="3"' + (block.columns === 3 ? ' selected' : '') + '>3 columns</option>';
        html += '</select>';
        html += '<button class="block-remove-btn" onclick="removeProfileBlock(' + blockIndex + ')" title="Remove block">&times;</button>';
        html += '</div>';

        // Block content
        html += '<div class="profile-block-content">';
        html += '<div class="profile-field-grid cols-' + block.columns + '">';

        block.fieldIds.forEach(function(fieldId, fieldIndex) {
            var field = fields[fieldId];
            var fieldName = field?.fieldName || fieldId;
            var value = recordFields[fieldId];
            if (value === undefined) value = recordFields[fieldName];

            // Skip fields with no data when using default config and not in configure mode
            var isEmpty = value == null || value === '' || (Array.isArray(value) && value.length === 0);
            if (isEmpty && isDefaultConfig && !profileConfigureMode) {
                return; // Skip this field
            }

            html += '<div class="profile-field-card" data-field-id="' + esc(fieldId) + '" data-block-index="' + blockIndex + '" data-field-index="' + fieldIndex + '" draggable="true" ondragstart="handleFieldDragStart(event)" ondragover="handleFieldDragOver(event)" ondragleave="handleFieldDragLeave(event)" ondrop="handleFieldDrop(event)">';
            html += '<div class="profile-field-name">';
            html += '<span class="field-drag-handle">&#8942;&#8942;</span>';
            html += esc(fieldName);
            if (profileConfigureMode) {
                html += '<button style="margin-left: auto; background: none; border: none; color: #ccc; cursor: pointer; font-size: 12px;" onclick="removeFieldFromBlock(' + blockIndex + ', ' + fieldIndex + ')">&times;</button>';
            }
            html += '</div>';
            if (isEmpty) {
                html += '<div class="profile-field-value empty"></div>';
            } else {
                html += '<div class="profile-field-value">' + formatCell(value) + '</div>';
            }
            html += '</div>';
        });

        html += '</div>'; // .profile-field-grid

        // Add field button (visible in configure mode)
        html += '<button class="profile-add-field-btn" onclick="showFieldPicker(event, ' + blockIndex + ')">+ Add Field</button>';

        html += '</div>'; // .profile-block-content
        html += '</div>'; // .profile-block
    });

    body.innerHTML = html;

    // Maintain configure mode if active
    if (profileConfigureMode) {
        body.classList.add('configure-mode');
    }
}

// Toggle configure mode
function toggleProfileConfigureMode() {
    profileConfigureMode = !profileConfigureMode;
    var body = document.getElementById('profile-body');
    var addBlockBtn = document.getElementById('profile-add-block-btn');
    var configureBtn = document.getElementById('profile-configure-btn');

    if (profileConfigureMode) {
        body.classList.add('configure-mode');
        addBlockBtn.style.display = '';
        configureBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"/></svg> Done';
    } else {
        body.classList.remove('configure-mode');
        addBlockBtn.style.display = 'none';
        configureBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg> Configure';
        closeFieldPicker();
    }

    renderRecordProfile();
}

// Set block columns
async function setBlockColumns(blockIndex, columns) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].columns = parseInt(columns);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Add a new block
async function addProfileBlock() {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    config.blocks.push({
        id: 'block-' + (config.blocks.length + 1) + '-' + Date.now(),
        columns: 2,
        fieldIds: []
    });

    await saveProfileConfig(profileCurrentTableId, viewId, config);
    renderRecordProfile();
}

// Remove a block
async function removeProfileBlock(blockIndex) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks.length > 1) {
        config.blocks.splice(blockIndex, 1);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Show field picker dropdown
function showFieldPicker(event, blockIndex) {
    event.stopPropagation();
    closeFieldPicker();

    var fields = META_FIELDS[profileCurrentTableId] || {};
    var fieldIds = Object.keys(fields);

    var picker = document.createElement('div');
    picker.className = 'profile-field-picker';
    picker.innerHTML = '<div class="profile-field-picker-header">Add Field</div>';

    fieldIds.sort(function(a, b) {
        var nameA = (fields[a]?.fieldName || a).toLowerCase();
        var nameB = (fields[b]?.fieldName || b).toLowerCase();
        return nameA.localeCompare(nameB);
    });

    fieldIds.forEach(function(fieldId) {
        var field = fields[fieldId];
        var fieldName = field?.fieldName || fieldId;
        var fieldType = field?.fieldType || 'text';

        var item = document.createElement('div');
        item.className = 'profile-field-picker-item';
        item.innerHTML = '<span>' + esc(fieldName) + '</span><span class="field-type-badge">' + esc(fieldType) + '</span>';
        item.onclick = function() {
            addFieldToBlock(blockIndex, fieldId);
            closeFieldPicker();
        };
        picker.appendChild(item);
    });

    // Position the picker
    var rect = event.target.getBoundingClientRect();
    picker.style.left = rect.left + 'px';
    picker.style.top = (rect.bottom + 4) + 'px';

    document.body.appendChild(picker);
    profileFieldPicker = picker;

    // Close on outside click
    setTimeout(function() {
        document.addEventListener('click', closeFieldPickerOnOutsideClick);
    }, 0);
}

function closeFieldPickerOnOutsideClick(event) {
    if (profileFieldPicker && !profileFieldPicker.contains(event.target)) {
        closeFieldPicker();
    }
}

function closeFieldPicker() {
    if (profileFieldPicker) {
        profileFieldPicker.remove();
        profileFieldPicker = null;
        document.removeEventListener('click', closeFieldPickerOnOutsideClick);
    }
}

// Add field to a block
async function addFieldToBlock(blockIndex, fieldId) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].fieldIds.push(fieldId);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Remove field from a block
async function removeFieldFromBlock(blockIndex, fieldIndex) {
    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    if (config.blocks[blockIndex]) {
        config.blocks[blockIndex].fieldIds.splice(fieldIndex, 1);
        await saveProfileConfig(profileCurrentTableId, viewId, config);
        renderRecordProfile();
    }
}

// Field drag and drop
var profileDragData = null;

function handleFieldDragStart(event) {
    if (!profileConfigureMode) {
        event.preventDefault();
        return;
    }
    var card = event.target.closest('.profile-field-card');
    profileDragData = {
        type: 'field',
        blockIndex: parseInt(card.dataset.blockIndex),
        fieldIndex: parseInt(card.dataset.fieldIndex),
        fieldId: card.dataset.fieldId
    };
    card.classList.add('dragging');
    event.dataTransfer.effectAllowed = 'move';
}

function handleFieldDragOver(event) {
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'field') return;
    event.preventDefault();
    var card = event.target.closest('.profile-field-card');
    if (card) {
        card.classList.add('drag-over');
    }
}

function handleFieldDragLeave(event) {
    var card = event.target.closest('.profile-field-card');
    if (card) {
        card.classList.remove('drag-over');
    }
}

async function handleFieldDrop(event) {
    event.preventDefault();
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'field') return;

    var targetCard = event.target.closest('.profile-field-card');
    if (!targetCard) return;

    var targetBlockIndex = parseInt(targetCard.dataset.blockIndex);
    var targetFieldIndex = parseInt(targetCard.dataset.fieldIndex);

    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    // Remove from source
    var fieldId = config.blocks[profileDragData.blockIndex].fieldIds.splice(profileDragData.fieldIndex, 1)[0];

    // Adjust target index if in same block and after source
    if (targetBlockIndex === profileDragData.blockIndex && targetFieldIndex > profileDragData.fieldIndex) {
        targetFieldIndex--;
    }

    // Insert at target
    config.blocks[targetBlockIndex].fieldIds.splice(targetFieldIndex, 0, fieldId);

    await saveProfileConfig(profileCurrentTableId, viewId, config);

    profileDragData = null;
    renderRecordProfile();
}

// Block drag and drop
function handleBlockDragStart(event, blockIndex) {
    if (!profileConfigureMode) {
        event.preventDefault();
        return;
    }
    profileDragData = {
        type: 'block',
        blockIndex: blockIndex
    };
    event.dataTransfer.effectAllowed = 'move';
}

function handleBlockDragOver(event) {
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'block') return;
    event.preventDefault();
}

async function handleBlockDrop(event, targetBlockIndex) {
    event.preventDefault();
    if (!profileConfigureMode || !profileDragData || profileDragData.type !== 'block') return;

    if (targetBlockIndex === profileDragData.blockIndex) return;

    var viewId = currentView || '_default';
    var config = getProfileConfig(profileCurrentTableId, viewId).config;

    // Remove from source
    var block = config.blocks.splice(profileDragData.blockIndex, 1)[0];

    // Adjust target index if after source
    if (targetBlockIndex > profileDragData.blockIndex) {
        targetBlockIndex--;
    }

    // Insert at target
    config.blocks.splice(targetBlockIndex, 0, block);

    await saveProfileConfig(profileCurrentTableId, viewId, config);

    profileDragData = null;
    renderRecordProfile();
}

// Navigation between records
function updateProfileNavigation() {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var recordIndex = currentRecordIds.indexOf(profileCurrentRecordId);
    var total = currentRecordIds.length;

    document.getElementById('profile-nav-info').textContent = (recordIndex + 1) + ' of ' + total;
    document.getElementById('profile-prev-btn').disabled = recordIndex <= 0;
    document.getElementById('profile-next-btn').disabled = recordIndex >= total - 1;
}

async function navigateProfile(direction) {
    if (!profileCurrentTableId || !profileCurrentRecordId) return;

    var recordIndex = currentRecordIds.indexOf(profileCurrentRecordId);
    var newIndex = recordIndex + direction;

    if (newIndex >= 0 && newIndex < currentRecordIds.length) {
        profileCurrentRecordId = currentRecordIds[newIndex];
        document.getElementById('profile-record-id').textContent = profileCurrentRecordId;
        await renderRecordProfile();
        updateProfileNavigation();

        // Refresh sync history if that tab is active
        if (profileCurrentTab === 'sync-history') {
            renderProfileSyncHistory();
        }
    }
}

// Open history from profile
function openHistoryFromProfile() {
    if (profileCurrentTableId && profileCurrentRecordId) {
        openHistoryModal(profileCurrentTableId, profileCurrentRecordId);
    }
}

// Profile tab state
var profileCurrentTab = 'details';

// Switch profile tab
function switchProfileTab(tabName) {
    profileCurrentTab = tabName;

    // Update tab buttons
    document.querySelectorAll('.profile-tab').forEach(function(tab) {
        if (tab.dataset.tab === tabName) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // Update tab content
    document.querySelectorAll('.profile-tab-content').forEach(function(content) {
        content.classList.remove('active');
    });

    if (tabName === 'details') {
        document.getElementById('profile-tab-details').classList.add('active');
    } else if (tabName === 'sync-history') {
        document.getElementById('profile-tab-sync-history').classList.add('active');
        renderProfileSyncHistory();
    }
}

// Build field history entries from raw events (used for in-memory events from CSV)
function buildFieldHistoryFromRawEvents(tableId, recordId, events) {
    // Sort events by id ascending (oldest first for proper state tracking)
    var sorted = events.slice().sort((a, b) => (a.id || 0) - (b.id || 0));

    var state = {};
    var fieldHistoryEntries = [];

    for (var e of sorted) {
        if (!e || !e.recordId || e.recordId !== recordId) continue;

        var payload = parsePayload(e.payload);
        if (!payload || typeof payload !== 'object') continue;

        var pfields = payload.fields;
        if (!pfields || typeof pfields !== 'object') continue;

        var eventId = e.id;
        var timestamp = e.created_at ? new Date(e.created_at).getTime() : Date.now();

        // Process INS (insert/create)
        if (pfields.INS) {
            for (var fieldId in pfields.INS) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'created',
                    oldValue: null,
                    newValue: pfields.INS[fieldId]
                });
            }
            Object.assign(state, pfields.INS);
        }

        // Process ALT (alter/update)
        if (pfields.ALT) {
            for (var fieldId in pfields.ALT) {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'updated',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: pfields.ALT[fieldId]
                });
            }
            Object.assign(state, pfields.ALT);
        }

        // Process NUL (nullify/delete)
        if (pfields.NUL && Array.isArray(pfields.NUL)) {
            pfields.NUL.forEach(fieldId => {
                fieldHistoryEntries.push({
                    tableId: tableId,
                    recordId: recordId,
                    fieldId: fieldId,
                    eventId: eventId,
                    timestamp: timestamp,
                    changeType: 'deleted',
                    oldValue: state[fieldId] !== undefined ? state[fieldId] : null,
                    newValue: null
                });
                delete state[fieldId];
            });
        }
    }

    // Return sorted by eventId descending (most recent first) for display
    return fieldHistoryEntries.sort((a, b) => (b.eventId || 0) - (a.eventId || 0));
}

// Render sync history in the profile tab
async function renderProfileSyncHistory() {
    var container = document.getElementById('profile-tab-sync-history');
    if (!profileCurrentTableId || !profileCurrentRecordId) {
        container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No record selected</h3><p>Select a record to view its sync history</p></div>';
        return;
    }

    // Show loading state
    container.innerHTML = '<div class="profile-sync-history-empty"><div class="loading-spinner"></div><h3>Loading sync history...</h3></div>';

    try {
        var history;

        // Check if we have in-memory events (from CSV import) - use them for instant display
        if (inMemoryEventsByRecord && inMemoryEventsByRecord.has(profileCurrentRecordId)) {
            var rawEvents = inMemoryEventsByRecord.get(profileCurrentRecordId);
            history = buildFieldHistoryFromRawEvents(profileCurrentTableId, profileCurrentRecordId, rawEvents);
            // Limit to 100 most recent entries
            if (history.length > 100) {
                history = history.slice(0, 100);
            }
        } else {
            // Fall back to API + IndexedDB when no in-memory events
            await fetchAndProcessHistoryForRecord(profileCurrentTableId, profileCurrentRecordId);
            // Get history from IndexedDB
            history = await getFieldHistoryForRecord(profileCurrentTableId, profileCurrentRecordId, 100);
        }

        if (!history || history.length === 0) {
            container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>No sync history available for this record</h3><p>Field changes will appear here after syncing</p></div>';
            return;
        }

        // Get field metadata
        var fields = META_FIELDS[profileCurrentTableId] || {};

        // Render history items
        var html = '<div class="profile-sync-history-list">';

        history.forEach(function(item) {
            var fieldName = fields[item.fieldId]?.fieldName || item.fieldId;
            var changeType = item.changeType || 'updated';
            var timestamp = item.timestamp ? new Date(item.timestamp).toLocaleString() : 'Unknown';

            html += '<div class="profile-sync-history-item">';
            html += '<div class="profile-sync-history-item-header">';
            html += '<span class="profile-sync-history-field">' + esc(fieldName) + '</span>';
            html += '<span class="profile-sync-history-type ' + changeType + '">' + changeType.charAt(0).toUpperCase() + changeType.slice(1) + '</span>';
            html += '<span class="profile-sync-history-time">' + esc(timestamp) + '</span>';
            html += '</div>';

            if (changeType !== 'created' || item.oldValue != null) {
                html += '<div class="profile-sync-history-values">';
                if (item.oldValue != null) {
                    html += '<div class="profile-sync-history-value old">';
                    html += '<div class="profile-sync-history-value-label">Old</div>';
                    html += formatHistoryValue(item.oldValue);
                    html += '</div>';
                }
                if (item.newValue != null) {
                    html += '<div class="profile-sync-history-value new">';
                    html += '<div class="profile-sync-history-value-label">New</div>';
                    html += formatHistoryValue(item.newValue);
                    html += '</div>';
                }
                html += '</div>';
            } else if (item.newValue != null) {
                html += '<div class="profile-sync-history-values">';
                html += '<div class="profile-sync-history-value new">';
                html += '<div class="profile-sync-history-value-label">Value</div>';
                html += formatHistoryValue(item.newValue);
                html += '</div>';
                html += '</div>';
            }

            html += '</div>';
        });

        html += '</div>';
        container.innerHTML = html;

    } catch (err) {
        console.error('Error loading sync history:', err);
        container.innerHTML = '<div class="profile-sync-history-empty"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg><h3>Error loading sync history</h3><p>' + esc(err.message) + '</p></div>';
    }
}

// Format history value for display
function formatHistoryValue(value) {
    if (value == null) return '<em>empty</em>';
    if (typeof value === 'object') {
        return esc(JSON.stringify(value));
    }
    return esc(String(value));
}

// Handle row click to open profile
function handleRowClick(event, tableId, recordId) {
    // Don't open profile if clicking on a button, link, or interactive element
    if (event.target.closest('button, a, input, select, textarea')) {
        return;
    }
    openRecordProfile(tableId, recordId);
}

// Keyboard navigation for profile
document.addEventListener('keydown', function(e) {
    var overlay = document.getElementById('record-profile-overlay');
    if (!overlay.classList.contains('open')) return;

    if (e.key === 'Escape') {
        closeRecordProfile();
    } else if (e.key === 'ArrowLeft' && !e.target.matches('input, textarea, select')) {
        navigateProfile(-1);
    } else if (e.key === 'ArrowRight' && !e.target.matches('input, textarea, select')) {
        navigateProfile(1);
    }
});

// ============ View Selector & Fields Dropdown UI ============

// Toggle view selector dropdown
function toggleViewSelector() {
    var dropdown = document.getElementById('view-selector-dropdown');
    var fieldsDropdown = document.getElementById('fields-dropdown');

    // Close fields dropdown if open
    fieldsDropdown.classList.remove('open');

    dropdown.classList.toggle('open');
}

// Toggle fields dropdown
function toggleFieldsDropdown() {
    var dropdown = document.getElementById('fields-dropdown');
    var viewDropdown = document.getElementById('view-selector-dropdown');

    // Close view dropdown if open
    viewDropdown.classList.remove('open');

    dropdown.classList.toggle('open');
}

// Close all dropdowns
function closeAllDropdowns() {
    document.getElementById('view-selector-dropdown')?.classList.remove('open');
    document.getElementById('fields-dropdown')?.classList.remove('open');
}

// Click outside handler to close dropdowns
document.addEventListener('click', function(e) {
    var viewSelector = document.getElementById('view-selector-container');
    var fieldsBtn = document.getElementById('fields-btn');
    var fieldsDropdown = document.getElementById('fields-dropdown');

    // Close view selector if clicked outside
    if (viewSelector && !viewSelector.contains(e.target)) {
        document.getElementById('view-selector-dropdown')?.classList.remove('open');
    }

    // Close fields dropdown if clicked outside
    if (fieldsBtn && fieldsDropdown && !fieldsBtn.contains(e.target) && !fieldsDropdown.contains(e.target)) {
        fieldsDropdown.classList.remove('open');
    }
});

// Get view type icon
function getViewTypeIcon(viewType) {
    switch ((viewType || '').toLowerCase()) {
        case 'grid': return '&#9638;';
        case 'gallery': return '&#128444;';
        case 'kanban': return '&#9636;';
        case 'calendar': return '&#128197;';
        case 'timeline': return '&#8594;';
        case 'form': return '&#128196;';
        default: return '&#9638;';
    }
}

// Render view selector dropdown
function renderViewSelector() {
    if (!currentTable) return;

    var dropdown = document.getElementById('view-selector-dropdown');
    var currentViewIcon = document.getElementById('current-view-icon');
    var currentViewName = document.getElementById('current-view-name');

    var views = META_VIEWS[currentTable] || {};
    var viewIds = Object.keys(views);

    // Update current view display
    var viewId = currentView || '_default';
    var currentViewObj = views[viewId];
    if (currentViewObj) {
        currentViewIcon.innerHTML = getViewTypeIcon(currentViewObj.viewType);
        currentViewName.textContent = currentViewObj.viewName || viewId;
    } else {
        currentViewIcon.innerHTML = '&#9638;';
        currentViewName.textContent = 'All Fields';
    }

    // Build dropdown
    var html = '<div class="view-selector-dropdown-header">Views</div>';

    // Add "All Fields" default option
    var isDefaultActive = !currentView || currentView === '_default';
    html += '<div class="view-selector-option' + (isDefaultActive ? ' active' : '') + '" onclick="selectView(\'_default\')">';
    html += '<span class="view-type-icon">&#9638;</span>';
    html += '<span class="view-option-name">All Fields</span>';
    if (isDefaultActive) html += '<span class="view-check">&#10003;</span>';
    html += '</div>';

    // Add existing views
    for (var vid of viewIds) {
        if (vid === '_default') continue;
        var view = views[vid];
        var isActive = currentView === vid;
        html += '<div class="view-selector-option' + (isActive ? ' active' : '') + '" onclick="selectView(\'' + esc(vid) + '\')">';
        html += '<span class="view-type-icon">' + getViewTypeIcon(view.viewType) + '</span>';
        html += '<span class="view-option-name">' + esc(view.viewName || vid) + '</span>';
        if (isActive) html += '<span class="view-check">&#10003;</span>';
        html += '</div>';
    }

    // Add "Create New View" option at bottom
    html += '<div style="border-top: 1px solid #eee; margin-top: 4px; padding-top: 4px;"></div>';
    html += '<div class="view-selector-option" onclick="openCreateViewModal()" style="color: #2d6cdf;">';
    html += '<span class="view-type-icon">+</span>';
    html += '<span class="view-option-name">Create New View</span>';
    html += '</div>';

    dropdown.innerHTML = html;
}

// Select a view
async function selectView(viewId) {
    // Auto-save any pending changes before switching views
    await autoSaveBeforeNavigation();

    currentView = viewId;
    closeAllDropdowns();

    // Load and apply view filters, sorts, and groupBy for the new view
    if (currentTable) {
        var viewConfig = getViewFiltersAndSorts(currentTable, viewId);
        currentFilters = viewConfig.filters;
        currentSorts = viewConfig.sorts;
        currentGroupBy = viewConfig.groupBy;
        updateFilterCount();
        updateSortCount();
        updateGroupButtonState();
    }

    // Update sidebar to reflect the new active view
    if (currentTable) {
        updateSidebarViewActive(currentTable, viewId);
    }

    // Render view selector to update current view display
    renderViewSelector();

    // Render fields dropdown for new view
    renderFieldsDropdown();
    updateFieldsCount();

    // Re-render table with new view's field configuration
    await renderTable();
}

// Render fields dropdown
function renderFieldsDropdown() {
    if (!currentTable) return;

    var list = document.getElementById('fields-dropdown-list');
    var fields = META_FIELDS[currentTable] || {};
    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);
    var hiddenSet = new Set(config.hiddenFieldIds || []);

    // Get all fields in order
    var allFieldIds = getAllFieldsInOrder(currentTable, viewId);

    var html = '';
    for (var i = 0; i < allFieldIds.length; i++) {
        var fid = allFieldIds[i];
        var field = fields[fid];
        if (!field) continue;

        var isVisible = !hiddenSet.has(fid);
        var fieldName = field.fieldName || fid;
        var fieldType = field.fieldType || 'unknown';

        html += '<div class="fields-dropdown-item" data-field-id="' + esc(fid) + '">';

        // Drag handle
        html += '<span class="field-drag-handle" title="Drag to reorder">&#9776;</span>';

        // Checkbox
        html += '<div class="field-checkbox' + (isVisible ? ' checked' : '') + '" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<span class="check-icon">&#10003;</span>';
        html += '</div>';

        // Field info
        html += '<div class="field-info" onclick="toggleFieldVisibility(\'' + esc(fid) + '\')">';
        html += '<div class="field-name">' + esc(fieldName) + '</div>';
        html += '<div class="field-type">' + esc(fieldType) + '</div>';
        html += '</div>';

        // Move buttons
        html += '<div class="field-move-btns">';
        if (i > 0) {
            html += '<button class="field-move-btn" onclick="moveFieldUp(\'' + esc(fid) + '\')" title="Move up">&#9650;</button>';
        } else {
            html += '<button class="field-move-btn" disabled style="opacity: 0.3;">&#9650;</button>';
        }
        if (i < allFieldIds.length - 1) {
            html += '<button class="field-move-btn" onclick="moveFieldDown(\'' + esc(fid) + '\')" title="Move down">&#9660;</button>';
        } else {
            html += '<button class="field-move-btn" disabled style="opacity: 0.3;">&#9660;</button>';
        }
        html += '</div>';

        html += '</div>';
    }

    list.innerHTML = html;
}

// Update visible fields count badge
function updateFieldsCount() {
    if (!currentTable) return;

    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);
    var fields = META_FIELDS[currentTable] || {};
    var totalFields = Object.keys(fields).length;
    var hiddenCount = (config.hiddenFieldIds || []).length;
    var visibleCount = totalFields - hiddenCount;

    var countEl = document.getElementById('fields-visible-count');
    if (countEl) {
        countEl.textContent = visibleCount + '/' + totalFields;
    }
}

function esc(s) {
    if (s == null) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ============ View Controls (Filter, Sort, Group, etc.) ============

var currentFilters = [];
var currentSorts = [];
var currentGroupBy = null;
var currentColorBy = null;
var currentRowHeight = 'medium';
var currentSearchQuery = '';

// Original unfiltered/unsorted record IDs
var originalRecordIds = [];

// Get cell value from a record for filtering/sorting
function getCellValue(record, fieldId) {
    if (!record || !record.fields) return null;
    var value = record.fields[fieldId];
    if (value === undefined) {
        // Try field name lookup
        var fields = META_FIELDS[currentTable] || {};
        var fieldName = fields[fieldId]?.fieldName;
        if (fieldName) value = record.fields[fieldName];
    }
    return value;
}

// Convert value to string for comparison
function valueToString(value) {
    if (value == null) return '';
    if (Array.isArray(value)) {
        return value.map(v => {
            if (typeof v === 'object' && v !== null) {
                return v.name || v.filename || v.email || v.id || JSON.stringify(v);
            }
            return String(v);
        }).join(' ');
    }
    if (typeof value === 'object') {
        return value.name || value.filename || value.email || value.url || JSON.stringify(value);
    }
    return String(value);
}

// Check if a record matches a single filter
function matchesFilter(record, filter) {
    var value = getCellValue(record, filter.fieldId);
    var strValue = valueToString(value).toLowerCase();
    var filterValue = (filter.value || '').toLowerCase();

    switch (filter.operator) {
        case 'contains':
            return strValue.includes(filterValue);
        case 'equals':
            return strValue === filterValue;
        case 'not_equals':
            return strValue !== filterValue;
        case 'is_empty':
            return value == null || value === '' || (Array.isArray(value) && value.length === 0);
        case 'is_not_empty':
            return value != null && value !== '' && !(Array.isArray(value) && value.length === 0);
        default:
            return true;
    }
}

// Check if a record matches search query
function matchesSearch(record, query) {
    if (!query) return true;
    var fields = record.fields || {};
    for (var key in fields) {
        var strValue = valueToString(fields[key]).toLowerCase();
        if (strValue.includes(query)) return true;
    }
    return false;
}

// Compare two values for sorting
function compareValues(a, b, direction) {
    // Handle nulls
    if (a == null && b == null) return 0;
    if (a == null) return direction === 'asc' ? -1 : 1;
    if (b == null) return direction === 'asc' ? 1 : -1;

    // Convert to strings for comparison
    var strA = valueToString(a).toLowerCase();
    var strB = valueToString(b).toLowerCase();

    // Try numeric comparison
    var numA = parseFloat(strA);
    var numB = parseFloat(strB);
    if (!isNaN(numA) && !isNaN(numB)) {
        var result = numA - numB;
        return direction === 'asc' ? result : -result;
    }

    // String comparison
    var result = strA.localeCompare(strB);
    return direction === 'asc' ? result : -result;
}

// Apply all filters, search, and sorts to get filtered record IDs
async function getFilteredSortedRecords() {
    if (!currentTable) return [];

    // Fetch all records for the table
    var allRecords = await getRecordsByIds(currentTable, originalRecordIds);

    // Build record map
    var recordsById = {};
    allRecords.forEach(r => {
        recordsById[r.recordId] = r;
    });

    // Start with original order
    var filteredIds = originalRecordIds.slice();

    // Apply search filter
    if (currentSearchQuery) {
        filteredIds = filteredIds.filter(id => {
            var record = recordsById[id];
            return record && matchesSearch(record, currentSearchQuery);
        });
    }

    // Apply custom filters
    if (currentFilters.length > 0) {
        filteredIds = filteredIds.filter(id => {
            var record = recordsById[id];
            if (!record) return false;
            return currentFilters.every(filter => matchesFilter(record, filter));
        });
    }

    // Apply sorts
    if (currentSorts.length > 0) {
        filteredIds.sort((idA, idB) => {
            var recordA = recordsById[idA];
            var recordB = recordsById[idB];

            for (var i = 0; i < currentSorts.length; i++) {
                var sort = currentSorts[i];
                var valueA = getCellValue(recordA, sort.fieldId);
                var valueB = getCellValue(recordB, sort.fieldId);
                var cmp = compareValues(valueA, valueB, sort.direction);
                if (cmp !== 0) return cmp;
            }
            return 0;
        });
    }

    return filteredIds;
}

// Close all view control dropdowns
function closeViewControlDropdowns() {
    document.querySelectorAll('.view-control-dropdown').forEach(d => d.classList.remove('open'));
}

// Toggle filter dropdown
function toggleFilterDropdown() {
    var dropdown = document.getElementById('filter-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        filterDropdownSearch = '';
        var searchInput = document.getElementById('filter-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderFilterDropdown();
    }
}

// Toggle sort dropdown
function toggleSortDropdown() {
    var dropdown = document.getElementById('sort-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        sortDropdownSearch = '';
        var searchInput = document.getElementById('sort-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderSortDropdown();
    }
}

// Toggle group dropdown
function toggleGroupDropdown() {
    var dropdown = document.getElementById('group-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        groupDropdownSearch = '';
        var searchInput = document.getElementById('group-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderGroupDropdown();
    }
}

// Toggle color dropdown
function toggleColorDropdown() {
    var dropdown = document.getElementById('color-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        var searchInput = document.getElementById('color-search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        renderColorDropdown();
    }
}

// Toggle row height dropdown
function toggleRowHeightDropdown() {
    var dropdown = document.getElementById('row-height-dropdown');
    var wasOpen = dropdown.classList.contains('open');
    closeViewControlDropdowns();
    if (!wasOpen) {
        dropdown.classList.add('open');
        updateRowHeightDropdown();
    }
}

// Get sorted fields for dropdown: alphabetical, with selected/used fields at top
function getSortedFieldsForDropdown(fields, usedFieldIds, filterText) {
    var filter = (filterText || '').toLowerCase().trim();
    var fieldArray = [];

    for (var fid in fields) {
        var field = fields[fid];
        var fieldName = field.fieldName || fid;

        // Filter by search text
        if (filter && !fieldName.toLowerCase().includes(filter)) {
            continue;
        }

        fieldArray.push({
            fieldId: fid,
            fieldName: fieldName,
            isUsed: usedFieldIds.indexOf(fid) !== -1
        });
    }

    // Sort: used fields first, then alphabetically
    fieldArray.sort(function(a, b) {
        if (a.isUsed !== b.isUsed) {
            return a.isUsed ? -1 : 1;
        }
        return a.fieldName.localeCompare(b.fieldName);
    });

    return fieldArray;
}

// Current search state for dropdowns
var filterDropdownSearch = '';
var sortDropdownSearch = '';
var groupDropdownSearch = '';

// Render filter dropdown
function renderFilterDropdown(filterText) {
    if (!currentTable) return;
    var list = document.getElementById('filter-list');

    if (filterText !== undefined) {
        filterDropdownSearch = filterText;
    }

    if (currentFilters.length === 0) {
        list.innerHTML = '<div class="empty-filters">No filters applied</div>';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};

    // Get used field IDs from current filters
    var usedFieldIds = currentFilters.map(function(f) { return f.fieldId; });
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filterDropdownSearch);

    var html = '';

    for (var i = 0; i < currentFilters.length; i++) {
        var filter = currentFilters[i];
        html += '<div class="filter-row">';
        html += '<select onchange="updateFilter(' + i + ', \'field\', this.value)">';

        // Add sorted fields to dropdown, ensuring selected field is always included
        var selectedInList = false;
        for (var j = 0; j < sortedFields.length; j++) {
            var sf = sortedFields[j];
            var sel = filter.fieldId === sf.fieldId ? ' selected' : '';
            if (sel) selectedInList = true;
            html += '<option value="' + esc(sf.fieldId) + '"' + sel + '>' + esc(sf.fieldName) + '</option>';
        }
        // If selected field was filtered out, still include it
        if (!selectedInList && fields[filter.fieldId]) {
            var selField = fields[filter.fieldId];
            html += '<option value="' + esc(filter.fieldId) + '" selected>' + esc(selField.fieldName || filter.fieldId) + '</option>';
        }

        html += '</select>';
        html += '<select onchange="updateFilter(' + i + ', \'operator\', this.value)">';
        html += '<option value="contains"' + (filter.operator === 'contains' ? ' selected' : '') + '>contains</option>';
        html += '<option value="equals"' + (filter.operator === 'equals' ? ' selected' : '') + '>equals</option>';
        html += '<option value="not_equals"' + (filter.operator === 'not_equals' ? ' selected' : '') + '>does not equal</option>';
        html += '<option value="is_empty"' + (filter.operator === 'is_empty' ? ' selected' : '') + '>is empty</option>';
        html += '<option value="is_not_empty"' + (filter.operator === 'is_not_empty' ? ' selected' : '') + '>is not empty</option>';
        html += '</select>';
        if (filter.operator !== 'is_empty' && filter.operator !== 'is_not_empty') {
            html += '<input type="text" value="' + esc(filter.value || '') + '" onchange="updateFilter(' + i + ', \'value\', this.value)" placeholder="Value">';
        }
        html += '<button class="filter-remove-btn" onclick="removeFilter(' + i + ')" title="Remove">&times;</button>';
        html += '</div>';
    }

    list.innerHTML = html;
    updateFilterCount();
}

// Filter filter dropdown based on search input
function filterFilterDropdown(filterText) {
    renderFilterDropdown(filterText);
}

// Add filter
function addFilter() {
    if (!currentTable) return;
    var fields = META_FIELDS[currentTable] || {};
    // Get sorted fields (alphabetically)
    var sortedFields = getSortedFieldsForDropdown(fields, [], '');
    var firstFieldId = sortedFields.length > 0 ? sortedFields[0].fieldId : null;
    if (!firstFieldId) return;

    currentFilters.push({
        fieldId: firstFieldId,
        operator: 'contains',
        value: ''
    });
    renderFilterDropdown();
    applyFilters();
}

// Update filter
function updateFilter(index, prop, value) {
    if (currentFilters[index]) {
        currentFilters[index][prop] = value;
        renderFilterDropdown();
        applyFilters();
    }
}

// Remove filter
function removeFilter(index) {
    currentFilters.splice(index, 1);
    renderFilterDropdown();
    applyFilters();
}

// Update filter count badge
function updateFilterCount() {
    var countEl = document.getElementById('filter-count');
    var btn = document.getElementById('filter-btn');
    if (currentFilters.length > 0) {
        countEl.textContent = currentFilters.length;
        countEl.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        countEl.style.display = 'none';
        btn.classList.remove('active');
    }
}

// Apply filters (re-render table)
async function applyFilters() {
    updateFilterCount();
    await renderTable();
    // Save filters to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('filters', currentFilters);
    }
}

// Render sort dropdown
function renderSortDropdown(filterText) {
    if (!currentTable) return;
    var list = document.getElementById('sort-list');

    if (filterText !== undefined) {
        sortDropdownSearch = filterText;
    }

    if (currentSorts.length === 0) {
        list.innerHTML = '<div class="empty-sorts">No sorts applied</div>';
        return;
    }

    var fields = META_FIELDS[currentTable] || {};

    // Get used field IDs from current sorts
    var usedFieldIds = currentSorts.map(function(s) { return s.fieldId; });
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, sortDropdownSearch);

    var html = '';

    for (var i = 0; i < currentSorts.length; i++) {
        var sort = currentSorts[i];
        html += '<div class="sort-row">';
        html += '<select onchange="updateSort(' + i + ', \'field\', this.value)">';

        // Add sorted fields to dropdown, ensuring selected field is always included
        var selectedInList = false;
        for (var j = 0; j < sortedFields.length; j++) {
            var sf = sortedFields[j];
            var sel = sort.fieldId === sf.fieldId ? ' selected' : '';
            if (sel) selectedInList = true;
            html += '<option value="' + esc(sf.fieldId) + '"' + sel + '>' + esc(sf.fieldName) + '</option>';
        }
        // If selected field was filtered out, still include it
        if (!selectedInList && fields[sort.fieldId]) {
            var selField = fields[sort.fieldId];
            html += '<option value="' + esc(sort.fieldId) + '" selected>' + esc(selField.fieldName || sort.fieldId) + '</option>';
        }

        html += '</select>';
        html += '<div class="sort-direction-btns">';
        html += '<button class="sort-direction-btn' + (sort.direction === 'asc' ? ' active' : '') + '" onclick="updateSort(' + i + ', \'direction\', \'asc\')">AZ</button>';
        html += '<button class="sort-direction-btn' + (sort.direction === 'desc' ? ' active' : '') + '" onclick="updateSort(' + i + ', \'direction\', \'desc\')">ZA</button>';
        html += '</div>';
        html += '<button class="sort-remove-btn" onclick="removeSort(' + i + ')" title="Remove">&times;</button>';
        html += '</div>';
    }

    list.innerHTML = html;
    updateSortCount();
}

// Filter sort dropdown based on search input
function filterSortDropdown(filterText) {
    renderSortDropdown(filterText);
}

// Add sort
function addSort() {
    if (!currentTable) return;
    var fields = META_FIELDS[currentTable] || {};
    // Get sorted fields (alphabetically)
    var sortedFields = getSortedFieldsForDropdown(fields, [], '');
    var firstFieldId = sortedFields.length > 0 ? sortedFields[0].fieldId : null;
    if (!firstFieldId) return;

    currentSorts.push({
        fieldId: firstFieldId,
        direction: 'asc'
    });
    renderSortDropdown();
    applySorts();
}

// Update sort
function updateSort(index, prop, value) {
    if (currentSorts[index]) {
        currentSorts[index][prop] = value;
        renderSortDropdown();
        applySorts();
    }
}

// Remove sort
function removeSort(index) {
    currentSorts.splice(index, 1);
    renderSortDropdown();
    applySorts();
}

// Update sort count badge
function updateSortCount() {
    var countEl = document.getElementById('sort-count');
    var btn = document.getElementById('sort-btn');
    if (currentSorts.length > 0) {
        countEl.textContent = currentSorts.length;
        countEl.style.display = 'inline-block';
        btn.classList.add('active');
    } else {
        countEl.style.display = 'none';
        btn.classList.remove('active');
    }
}

// Apply sorts (re-render table)
async function applySorts() {
    updateSortCount();
    await renderTable();
    // Save sorts to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('sorts', currentSorts);
    }
}

// Render group dropdown
function renderGroupDropdown(filterText) {
    if (!currentTable) return;
    var container = document.getElementById('group-options');
    var fields = META_FIELDS[currentTable] || {};

    if (filterText !== undefined) {
        groupDropdownSearch = filterText;
    }

    var filter = (groupDropdownSearch || '').toLowerCase().trim();

    var html = '';

    // Show "None" option only if it matches filter or no filter
    if (!filter || 'none'.includes(filter)) {
        html += '<div class="group-option' + (!currentGroupBy ? ' none-selected' : '') + '" onclick="setGroupBy(null)">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>None</span>';
        html += '</div>';
    }

    // Get sorted fields with selected at top
    var usedFieldIds = currentGroupBy ? [currentGroupBy] : [];
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filter);

    for (var i = 0; i < sortedFields.length; i++) {
        var sf = sortedFields[i];
        var isSelected = currentGroupBy === sf.fieldId;
        html += '<div class="group-option' + (isSelected ? ' selected' : '') + '" onclick="setGroupBy(\'' + esc(sf.fieldId) + '\')">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>' + esc(sf.fieldName) + '</span>';
        html += '</div>';
    }

    if (!html) {
        html = '<div class="group-option" style="color: #999; cursor: default;">No matching fields</div>';
    }

    container.innerHTML = html;
}

// Filter group dropdown based on search input
function filterGroupDropdown(filterText) {
    renderGroupDropdown(filterText);
}

// Update group button state
function updateGroupButtonState() {
    var btn = document.getElementById('group-btn');
    if (currentGroupBy) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
}

// Set group by field
async function setGroupBy(fieldId) {
    currentGroupBy = fieldId;
    closeViewControlDropdowns();
    updateGroupButtonState();
    await renderTable();
    // Save groupBy to current view
    if (currentTable && currentView) {
        await saveViewFiltersAndSorts(currentTable, currentView, currentFilters, currentSorts, currentGroupBy);
        markViewDirty('groupBy', currentGroupBy);
    }
}

// Render color dropdown
function renderColorDropdown(filterText) {
    if (!currentTable) return;
    var container = document.getElementById('color-options');
    var fields = META_FIELDS[currentTable] || {};
    var filter = (filterText || '').toLowerCase().trim();

    var html = '';

    // Show "None" option only if it matches filter or no filter
    if (!filter || 'none'.includes(filter)) {
        html += '<div class="color-option' + (!currentColorBy ? ' none-selected' : '') + '" onclick="setColorBy(null)">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>None</span>';
        html += '</div>';
    }

    // Get sorted fields with selected at top
    var usedFieldIds = currentColorBy ? [currentColorBy] : [];
    var sortedFields = getSortedFieldsForDropdown(fields, usedFieldIds, filter);

    for (var i = 0; i < sortedFields.length; i++) {
        var sf = sortedFields[i];
        var isSelected = currentColorBy === sf.fieldId;
        html += '<div class="color-option' + (isSelected ? ' selected' : '') + '" onclick="setColorBy(\'' + esc(sf.fieldId) + '\')">';
        html += '<span class="check-mark">&#10003;</span>';
        html += '<span>' + esc(sf.fieldName) + '</span>';
        html += '</div>';
    }

    if (!html) {
        html = '<div class="color-option" style="color: #999; cursor: default;">No matching fields</div>';
    }

    container.innerHTML = html;
}

// Filter color dropdown based on search input
function filterColorDropdown(filterText) {
    renderColorDropdown(filterText);
}

// Set color by field
async function setColorBy(fieldId) {
    currentColorBy = fieldId;
    closeViewControlDropdowns();
    var btn = document.getElementById('color-btn');
    if (fieldId) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
    await renderTable();
}

// Update row height dropdown selection
function updateRowHeightDropdown() {
    document.querySelectorAll('.row-height-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    var options = document.querySelectorAll('.row-height-option');
    options.forEach(opt => {
        if (opt.textContent.trim().toLowerCase().replace(' ', '-') === currentRowHeight ||
            (opt.textContent.trim() === 'Short' && currentRowHeight === 'short') ||
            (opt.textContent.trim() === 'Medium' && currentRowHeight === 'medium') ||
            (opt.textContent.trim() === 'Tall' && currentRowHeight === 'tall') ||
            (opt.textContent.trim() === 'Extra tall' && currentRowHeight === 'extra-tall')) {
            opt.classList.add('selected');
        }
    });
}

// Set row height
function setRowHeight(height) {
    currentRowHeight = height;
    closeViewControlDropdowns();

    var table = document.getElementById('table');
    if (table) {
        table.className = 'row-height-' + height;
    }
}

// Handle view search
function handleViewSearch(query) {
    currentSearchQuery = query.toLowerCase();
    renderTable();
}

// Update closeAllDropdowns to also close view control dropdowns
var originalCloseAllDropdowns = closeAllDropdowns;
closeAllDropdowns = function() {
    originalCloseAllDropdowns();
    closeViewControlDropdowns();
};

// Add click handler for view control dropdowns
document.addEventListener('click', function(e) {
    var wrapper = e.target.closest('.view-control-wrapper');
    if (!wrapper) {
        closeViewControlDropdowns();
    }
});

// ============ Column Drag & Drop Reordering ============

var draggedColumnFieldId = null;

// Optimized DOM-based column movement (no full table re-render)
function moveColumnInDOM(fromIndex, toIndex) {
    var table = document.getElementById('table');
    if (!table) return false;

    // Account for the Actions column at index 0
    var domFromIndex = fromIndex + 1;
    var domToIndex = toIndex + 1;

    // Move header
    var headerRow = table.querySelector('thead tr');
    if (!headerRow) return false;

    var headers = headerRow.children;
    if (domFromIndex >= headers.length || domToIndex >= headers.length) return false;

    var headerToMove = headers[domFromIndex];
    var targetHeader = headers[domToIndex];

    if (domFromIndex < domToIndex) {
        // Moving right: insert after target
        targetHeader.after(headerToMove);
    } else {
        // Moving left: insert before target
        targetHeader.before(headerToMove);
    }

    // Update data-field-index attributes on all headers
    Array.from(headers).forEach((th, idx) => {
        if (idx > 0 && th.dataset.fieldIndex !== undefined) {
            th.dataset.fieldIndex = idx - 1;
        }
    });

    // Move cells in all body rows
    var bodyRows = table.querySelectorAll('tbody tr:not(.group-header-row)');
    bodyRows.forEach(row => {
        var cells = row.children;
        if (domFromIndex >= cells.length || domToIndex >= cells.length) return;

        var cellToMove = cells[domFromIndex];
        var targetCell = cells[domToIndex];

        if (domFromIndex < domToIndex) {
            targetCell.after(cellToMove);
        } else {
            targetCell.before(cellToMove);
        }
    });

    return true;
}

// Update field order in memory and trigger debounced save
function updateFieldOrderFast(tableId, viewId, newFieldOrder) {
    // Update in-memory config
    if (!VIEW_FIELD_CONFIG[tableId]) VIEW_FIELD_CONFIG[tableId] = {};
    if (!VIEW_FIELD_CONFIG[tableId][viewId]) {
        VIEW_FIELD_CONFIG[tableId][viewId] = { hiddenFieldIds: [], fieldOrder: [] };
    }
    VIEW_FIELD_CONFIG[tableId][viewId].fieldOrder = newFieldOrder;

    // Update META_VIEWS as well for consistency
    if (META_VIEWS[tableId] && META_VIEWS[tableId][viewId]) {
        META_VIEWS[tableId][viewId].fieldOrder = newFieldOrder;
    }

    // Mark dirty for debounced auto-save (uses existing system)
    markViewDirty('fieldOrder', newFieldOrder);
}

function handleColumnDragStart(event) {
    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId) return;

    draggedColumnFieldId = th.dataset.fieldId;
    th.classList.add('dragging');

    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', draggedColumnFieldId);
}

function handleColumnDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';

    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId) return;

    // Remove drag-over class from all headers
    document.querySelectorAll('th.drag-over').forEach(el => el.classList.remove('drag-over'));

    // Add drag-over class to current target
    if (th.dataset.fieldId !== draggedColumnFieldId) {
        th.classList.add('drag-over');
    }
}

function handleColumnDragEnd(event) {
    // Remove all drag classes
    document.querySelectorAll('th.dragging').forEach(el => el.classList.remove('dragging'));
    document.querySelectorAll('th.drag-over').forEach(el => el.classList.remove('drag-over'));
    draggedColumnFieldId = null;
}

function handleColumnDrop(event) {
    event.preventDefault();

    var th = event.target.closest('th');
    if (!th || !th.dataset.fieldId || !draggedColumnFieldId) {
        handleColumnDragEnd(event);
        return;
    }

    var targetFieldId = th.dataset.fieldId;
    if (targetFieldId === draggedColumnFieldId) {
        handleColumnDragEnd(event);
        return;
    }

    // Reorder the fields (synchronous DOM update)
    reorderColumn(draggedColumnFieldId, targetFieldId);

    handleColumnDragEnd(event);
}

function reorderColumn(draggedFieldId, targetFieldId) {
    if (!currentTable) return;

    var viewId = currentView || '_default';
    var config = getViewFieldConfig(currentTable, viewId);

    var fromIdx = config.fieldOrder.indexOf(draggedFieldId);
    var toIdx = config.fieldOrder.indexOf(targetFieldId);

    if (fromIdx < 0 || toIdx < 0) return;

    // Optimized: Move columns in DOM immediately (no full re-render)
    var domMoved = moveColumnInDOM(fromIdx, toIdx);

    // Update the field order array
    config.fieldOrder.splice(fromIdx, 1);
    var insertIdx = fromIdx < toIdx ? toIdx - 1 : toIdx;
    config.fieldOrder.splice(insertIdx, 0, draggedFieldId);

    // Fast update: in-memory + debounced save (no blocking await)
    updateFieldOrderFast(currentTable, viewId, config.fieldOrder);

    // Update fields dropdown to reflect new order
    renderFieldsDropdown();
}

// ============ Default View Protection & View Creation ============

// Check if current view is the default view (cannot be modified directly)
function isDefaultView() {
    return !currentView || currentView === '_default';
}

// Generate default view name: "{Table Name} {DateTime}"
function generateDefaultViewName() {
    var tableName = 'View';
    if (currentTable && META_TABLES[currentTable]) {
        tableName = META_TABLES[currentTable].tableName || currentTable;
    }
    var now = new Date();
    var dateStr = now.toLocaleDateString() + ' ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    return tableName + ' ' + dateStr;
}

// Show create view modal when user tries to modify default view
function promptCreateViewFromDefault(action, data, reason) {
    pendingViewAction = { action: action, data: data };

    // Set the reason text
    var reasonEl = document.getElementById('create-view-reason');
    if (reasonEl) {
        reasonEl.textContent = reason || 'The default view cannot be modified. Create a new view to customize.';
    }

    // Set default view name
    var nameInput = document.getElementById('create-view-name');
    if (nameInput) {
        nameInput.value = generateDefaultViewName();
    }

    // Reset other fields
    document.getElementById('create-view-type').value = 'grid';
    document.getElementById('create-view-tags').value = '';

    // Populate parent view options
    populateParentViewOptions();

    // Populate workspace options
    populateWorkspaceOptions();

    // Show modal
    document.getElementById('create-view-modal').classList.add('open');

    // Focus name input
    setTimeout(() => nameInput?.focus(), 100);
}

// Populate parent view dropdown for nesting
function populateParentViewOptions() {
    var select = document.getElementById('create-view-parent');
    if (!select || !currentTable) return;

    var html = '<option value="">(No parent - root level)</option>';
    var views = META_VIEWS[currentTable] || {};

    for (var vid in views) {
        if (vid === '_default') continue;
        var view = views[vid];
        html += '<option value="' + esc(vid) + '">' + esc(view.viewName || vid) + '</option>';
    }

    select.innerHTML = html;
}

// Populate workspace dropdown
function populateWorkspaceOptions() {
    var select = document.getElementById('create-view-workspace');
    if (!select) return;

    var html = '<option value="">(None)</option>';

    for (var wid in WORKSPACES) {
        var ws = WORKSPACES[wid];
        html += '<option value="' + esc(wid) + '">' + esc(ws.workspaceName) + '</option>';
    }

    // Add option to create new workspace
    html += '<option value="_new">+ Create new workspace...</option>';

    select.innerHTML = html;
}

// Close create view modal
function closeCreateViewModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('create-view-modal').classList.remove('open');
    pendingViewAction = null;
}

// Submit create view
async function submitCreateView() {
    var nameInput = document.getElementById('create-view-name');
    var typeSelect = document.getElementById('create-view-type');
    var parentSelect = document.getElementById('create-view-parent');
    var tagsInput = document.getElementById('create-view-tags');
    var workspaceSelect = document.getElementById('create-view-workspace');

    var viewName = nameInput.value.trim();
    if (!viewName) {
        alert('Please enter a view name');
        nameInput.focus();
        return;
    }

    var viewType = typeSelect.value;
    var parentViewId = parentSelect.value || null;
    var tags = tagsInput.value.split(',').map(t => t.trim()).filter(t => t);
    var workspaceId = workspaceSelect.value;

    // Handle "create new workspace" option
    if (workspaceId === '_new') {
        var wsName = prompt('Enter workspace name:');
        if (wsName) {
            workspaceId = await createWorkspace(wsName);
        } else {
            workspaceId = null;
        }
    }

    // Create the new view
    var newViewId = 'viw_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    var newView = {
        tableId: currentTable,
        viewId: newViewId,
        viewName: viewName,
        viewType: viewType,
        parentViewId: parentViewId,
        tags: tags,
        hiddenFieldIds: [],
        fieldOrder: [],
        filters: [],
        sorts: [],
        groupBy: null,
        folderId: null
    };

    // If there was a pending action (filter, sort, etc.), apply it to the new view
    if (pendingViewAction) {
        switch (pendingViewAction.action) {
            case 'filter':
                newView.filters = [pendingViewAction.data];
                break;
            case 'sort':
                newView.sorts = [pendingViewAction.data];
                break;
            case 'group':
                newView.groupBy = pendingViewAction.data;
                break;
            case 'hideField':
                newView.hiddenFieldIds = [pendingViewAction.data];
                break;
        }
    }

    // Add to workspace if selected
    if (workspaceId && WORKSPACES[workspaceId]) {
        WORKSPACES[workspaceId].viewIds.push(newViewId);
        await saveWorkspace(WORKSPACES[workspaceId]);
    }

    // Save the view
    if (!META_VIEWS[currentTable]) META_VIEWS[currentTable] = {};
    META_VIEWS[currentTable][newViewId] = newView;
    await saveView(newView);

    // Close modal
    closeCreateViewModal();

    // Refresh sidebar
    await loadTableViewsAsync(currentTable);

    // Switch to the new view
    await selectTableView(currentTable, newViewId);
}

// ============ Workspace Management ============

// Get all workspaces from IndexedDB
function getAllWorkspaces() {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readonly');
        var req = tx.objectStore('workspaces').getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
    });
}

// Save a workspace to IndexedDB
function saveWorkspace(workspace) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readwrite');
        tx.objectStore('workspaces').put(workspace);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Delete a workspace from IndexedDB
function deleteWorkspaceFromDB(workspaceId) {
    return new Promise((resolve, reject) => {
        var tx = db.transaction('workspaces', 'readwrite');
        tx.objectStore('workspaces').delete(workspaceId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
    });
}

// Create a new workspace
async function createWorkspace(name) {
    var workspaceId = 'ws_' + Date.now();
    var workspace = {
        workspaceId: workspaceId,
        workspaceName: name,
        viewIds: [],
        sortOrder: Object.keys(WORKSPACES).length
    };

    WORKSPACES[workspaceId] = workspace;
    await saveWorkspace(workspace);

    // Sync to backend
    await saveWorkspaceToBackend(workspace, 'create');

    return workspaceId;
}

// Add a view to a workspace
async function addViewToWorkspace(viewId, workspaceId) {
    if (!WORKSPACES[workspaceId]) return;

    if (!WORKSPACES[workspaceId].viewIds.includes(viewId)) {
        WORKSPACES[workspaceId].viewIds.push(viewId);
        await saveWorkspace(WORKSPACES[workspaceId]);
        await saveWorkspaceToBackend(WORKSPACES[workspaceId], 'update');
    }
}

// Remove a view from a workspace
async function removeViewFromWorkspace(viewId, workspaceId) {
    if (!WORKSPACES[workspaceId]) return;

    var idx = WORKSPACES[workspaceId].viewIds.indexOf(viewId);
    if (idx >= 0) {
        WORKSPACES[workspaceId].viewIds.splice(idx, 1);
        await saveWorkspace(WORKSPACES[workspaceId]);
        await saveWorkspaceToBackend(WORKSPACES[workspaceId], 'update');
    }
}

// Delete a workspace
async function deleteWorkspace(workspaceId) {
    if (!confirm('Delete this workspace?')) return;

    delete WORKSPACES[workspaceId];
    await deleteWorkspaceFromDB(workspaceId);
    await saveWorkspaceToBackend({ workspaceId: workspaceId }, 'delete');

    if (currentWorkspace === workspaceId) {
        currentWorkspace = null;
    }

    renderSidebar();
}

// Save workspace to backend
async function saveWorkspaceToBackend(workspace, operator) {
    if (!API_KEY) return;
    var payload = {
        uuid: crypto.randomUUID(),
        recordId: workspace.workspaceId,
        set: 'workspaces',
        operator: operator,
        created_at: new Date().toISOString(),
        apiKey: API_KEY,
        payload: JSON.stringify(workspace)
    };

    try {
        if (operator === 'NUL') {
            // For delete operations, post event and delete from snapshot
            await AminoSync.postEventWithSnapshot(payload, null);
            await AminoSync.deleteSnapshot(workspace.workspaceId);
        } else {
            // For INS/ALT operations, post event and update snapshot
            await AminoSync.postEventWithSnapshot(payload, {
                source_table: 'workspaces',
                data: workspace
            });
        }
    } catch (error) {
        console.error('Failed to save workspace to backend:', error);
    }
}

// Load workspaces into memory
async function loadWorkspaces() {
    try {
        var workspaces = await getAllWorkspaces();
        WORKSPACES = {};
        workspaces.forEach(ws => WORKSPACES[ws.workspaceId] = ws);
    } catch (err) {
        console.error('Error loading workspaces:', err);
    }
}

// ============ Schema View Rendering ============

// Render schema view (card-based vertical layout)
async function renderSchemaView() {
    if (!currentTable) return;

    var container = document.getElementById('table-container');

    // Get records (limited for performance)
    var displayRecordIds = currentRecordIds.slice(0, 50); // Show up to 50 cards

    if (displayRecordIds.length === 0) {
        container.innerHTML = '<div class="empty-state"><h3>No records</h3><p>This table is empty</p></div>';
        document.getElementById('pagination').style.display = 'none';
        return;
    }

    var records = await getRecordsByIds(currentTable, displayRecordIds);
    var fields = META_FIELDS[currentTable] || {};
    var fieldIds = Object.keys(fields);

    var html = '<div class="schema-view-container">';

    for (var record of records) {
        var recordId = record.recordId;
        var recordFields = record.fields || {};

        html += '<div class="schema-card" data-record-id="' + esc(recordId) + '" onclick="handleRowClick(event, \'' + esc(currentTable) + '\', \'' + esc(recordId) + '\')" style="cursor: pointer;">';

        // Card header
        html += '<div class="schema-card-header">';
        html += '<span class="schema-card-id">' + esc(recordId) + '</span>';
        html += '<div class="schema-card-actions">';
        html += '<button class="history-btn" onclick="event.stopPropagation(); openHistoryModal(\'' + esc(currentTable) + '\', \'' + esc(recordId) + '\')" title="View field history">';
        html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
        html += '</button>';
        html += '</div>';
        html += '</div>';

        // Card body - all fields vertically
        html += '<div class="schema-card-body">';

        for (var fid of fieldIds) {
            var field = fields[fid];
            var fieldName = field.fieldName || fid;
            var value = recordFields[fid];
            if (value === undefined) value = recordFields[fieldName];

            html += '<div class="schema-field-row">';
            html += '<div class="schema-field-name">' + esc(fieldName) + '</div>';

            if (value == null || value === '') {
                html += '<div class="schema-field-value empty"></div>';
            } else {
                html += '<div class="schema-field-value">' + formatCell(value) + '</div>';
            }

            html += '</div>';
        }

        html += '</div>'; // .schema-card-body
        html += '</div>'; // .schema-card
    }

    html += '</div>'; // .schema-view-container

    container.innerHTML = html;

    // Update pagination info (schema view shows limited records)
    document.getElementById('pagination').style.display = 'none';
    updateStatus('Showing ' + displayRecordIds.length + ' of ' + totalRecords + ' records', true, null, 'Schema view');
}

// ============ View Type Detection & Rendering ============

// Get the current view's type
function getCurrentViewType() {
    if (!currentTable || !currentView || currentView === '_default') {
        return 'grid'; // Default view is always grid
    }

    var view = META_VIEWS[currentTable]?.[currentView];
    return view?.viewType || 'grid';
}

// Override renderTable to handle different view types
var originalRenderTable = renderTable;
renderTable = async function() {
    var viewType = getCurrentViewType();

    if (viewType === 'schema') {
        await renderSchemaView();
    } else {
        await originalRenderTable();
    }
};

// ============ Override Filter/Sort/Field Functions for Default View Protection ============

// Store original functions
var originalAddFilter = addFilter;
var originalAddSort = addSort;
var originalSetGroupBy = setGroupBy;
var originalToggleFieldVisibility = toggleFieldVisibility;

// Override addFilter to protect default view
addFilter = function() {
    if (isDefaultView()) {
        var fields = META_FIELDS[currentTable] || {};
        var firstFieldId = Object.keys(fields)[0];
        promptCreateViewFromDefault('filter', {
            fieldId: firstFieldId,
            operator: 'contains',
            value: ''
        }, 'To add filters, please create a new view. The default view shows all records without filters.');
        return;
    }
    originalAddFilter();
};

// Override addSort to protect default view
addSort = function() {
    if (isDefaultView()) {
        var fields = META_FIELDS[currentTable] || {};
        var firstFieldId = Object.keys(fields)[0];
        promptCreateViewFromDefault('sort', {
            fieldId: firstFieldId,
            direction: 'asc'
        }, 'To add sorting, please create a new view. The default view maintains the original record order.');
        return;
    }
    originalAddSort();
};

// Override setGroupBy to protect default view
setGroupBy = async function(fieldId) {
    if (isDefaultView() && fieldId) {
        promptCreateViewFromDefault('group', fieldId, 'To group records, please create a new view. The default view shows records ungrouped.');
        return;
    }
    await originalSetGroupBy(fieldId);
};

// Override toggleFieldVisibility to protect default view
toggleFieldVisibility = async function(fieldId) {
    if (isDefaultView()) {
        promptCreateViewFromDefault('hideField', fieldId, 'To customize visible fields, please create a new view. The default view shows all fields.');
        return;
    }
    await originalToggleFieldVisibility(fieldId);
};

// ============ View Tags UI ============

// Get tags for a view
function getViewTags(tableId, viewId) {
    var view = META_VIEWS[tableId]?.[viewId];
    return view?.tags || [];
}

// Add tag to a view
async function addTagToView(tableId, viewId, tag) {
    var view = META_VIEWS[tableId]?.[viewId];
    if (!view) return;

    if (!view.tags) view.tags = [];
    if (!view.tags.includes(tag)) {
        view.tags.push(tag);
        await saveView(view);
        markViewDirty('tags', view.tags);
    }
}

// Remove tag from a view
async function removeTagFromView(tableId, viewId, tag) {
    var view = META_VIEWS[tableId]?.[viewId];
    if (!view || !view.tags) return;

    var idx = view.tags.indexOf(tag);
    if (idx >= 0) {
        view.tags.splice(idx, 1);
        await saveView(view);
        markViewDirty('tags', view.tags);
    }
}

// Render tags for a view in sidebar
function renderViewTags(tags) {
    if (!tags || tags.length === 0) return '';

    var html = '<div class="view-tags">';
    tags.slice(0, 3).forEach(tag => {
        html += '<span class="view-tag">' + esc(tag) + '</span>';
    });
    if (tags.length > 3) {
        html += '<span class="view-tag">+' + (tags.length - 3) + '</span>';
    }
    html += '</div>';
    return html;
}

// ============ Enhanced Sidebar View Rendering ============

// Update renderViewItem to show tags, type badges, and nesting
var originalRenderViewItem = renderViewItem;
renderViewItem = function(tableId, view, inFolder) {
    var isActive = currentTable === tableId && currentView === view.viewId;
    var viewName = view.viewName || view.viewId;
    var viewIcon = getViewTypeIcon(view.viewType);
    var paddingClass = inFolder ? ' style="padding-left: 52px;"' : '';

    // Calculate nesting level
    var nestLevel = 0;
    var parentId = view.parentViewId;
    while (parentId && nestLevel < 3) {
        nestLevel++;
        var parentView = META_VIEWS[tableId]?.[parentId];
        parentId = parentView?.parentViewId;
    }

    var nestClass = nestLevel > 0 ? ' nested-level-' + nestLevel : '';

    var html = '<div class="table-view-item' + (isActive ? ' active' : '') + nestClass + '"' + paddingClass + ' ' +
           'onclick="selectTableView(\'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')" ' +
           'oncontextmenu="showViewContextMenu(event, \'' + esc(tableId) + '\', \'' + esc(view.viewId) + '\')">';

    // Nesting indicator
    if (nestLevel > 0) {
        html += '<span class="view-nest-indicator"></span>';
    }

    html += '<span class="view-icon">' + viewIcon + '</span>' +
           '<span class="view-name">' + esc(viewName) + '</span>';

    // View type badge
    if (view.viewType && view.viewType !== 'grid') {
        var badgeLabel = view.viewType === 'schema' ? 'cards' : view.viewType;
        html += '<span class="view-type-badge ' + esc(view.viewType) + '">' + esc(badgeLabel) + '</span>';
    }

    html += '</div>';

    // Tags row (if present)
    var tags = view.tags || [];
    if (tags.length > 0) {
        html += renderViewTags(tags);
    }

    return html;
};

// ============ Workspace UI in Sidebar ============

// Render workspace tabs at top of sidebar
function renderWorkspaceTabs() {
    var sidebarHeader = document.querySelector('.sidebar-header');
    if (!sidebarHeader) return;

    // Remove existing workspace tabs
    var existingTabs = document.querySelector('.workspace-tabs');
    if (existingTabs) existingTabs.remove();

    var wsIds = Object.keys(WORKSPACES);
    if (wsIds.length === 0) return;

    var html = '<div class="workspace-tabs">';

    // "All" tab
    html += '<div class="workspace-tab' + (!currentWorkspace ? ' active' : '') + '" onclick="filterByWorkspace(null)">All</div>';

    // Workspace tabs
    wsIds.forEach(wid => {
        var ws = WORKSPACES[wid];
        var isActive = currentWorkspace === wid;
        html += '<div class="workspace-tab' + (isActive ? ' active' : '') + '" onclick="filterByWorkspace(\'' + esc(wid) + '\')">';
        html += esc(ws.workspaceName);
        html += '<span class="workspace-count">' + ws.viewIds.length + '</span>';
        html += '</div>';
    });

    // Add workspace button
    html += '<div class="workspace-add-btn" onclick="promptCreateWorkspace()" title="Create workspace">+</div>';

    html += '</div>';

    sidebarHeader.insertAdjacentHTML('afterend', html);
}

// Filter sidebar views by workspace
function filterByWorkspace(workspaceId) {
    currentWorkspace = workspaceId;
    renderSidebar();
}

// Prompt to create a new workspace
async function promptCreateWorkspace() {
    var name = prompt('Enter workspace name:');
    if (name) {
        await createWorkspace(name);
        renderWorkspaceTabs();
    }
}

// ============ Initialize Workspaces on Load ============

// Extend init to load workspaces
var originalInit = init;
init = async function() {
    await originalInit();
    await loadWorkspaces();
    renderWorkspaceTabs();
};

// Keyboard handler for create view modal
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        var modal = document.getElementById('create-view-modal');
        if (modal && modal.classList.contains('open')) {
            closeCreateViewModal();
        }
    }
});

// Keyboard handler for unlock screen
document.getElementById('unlock-password').onkeydown = (e) => { if (e.key === 'Enter') unlockWithPassword(); };
document.getElementById('setup-password').onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('setup-password-confirm').focus(); };
document.getElementById('setup-password-confirm').onkeydown = (e) => { if (e.key === 'Enter') setupEncryptionWithPassword(); };

// Initialize: check encryption first, then auth
(async function() {
    var encryptionReady = await initEncryption();
    if (encryptionReady) {
        initAuthScreen();
    }
    // If encryption is not ready, the unlock screen handlers will call initAuthScreen after unlock
})();
    </script>
</body>
</html>
